# Comparing `tmp/fw_storage-2.1.3-py3-none-any.whl.zip` & `tmp/fw_storage-2.1.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 37751 bytes, number of entries: 24
--rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 fw_storage/__init__.py
--rw-r--r--  2.0 unx    17634 b- defN 80-Jan-01 00:00 fw_storage/config.py
--rw-r--r--  2.0 unx      179 b- defN 80-Jan-01 00:00 fw_storage/errors.py
+Zip file size: 37647 bytes, number of entries: 24
+-rw-r--r--  2.0 unx      511 b- defN 80-Jan-01 00:00 fw_storage/__init__.py
+-rw-r--r--  2.0 unx    18067 b- defN 80-Jan-01 00:00 fw_storage/config.py
+-rw-r--r--  2.0 unx      113 b- defN 80-Jan-01 00:00 fw_storage/errors.py
 -rw-r--r--  2.0 unx      963 b- defN 80-Jan-01 00:00 fw_storage/fileinfo.py
 -rw-r--r--  2.0 unx     1016 b- defN 80-Jan-01 00:00 fw_storage/filters.py
 -rw-r--r--  2.0 unx     1013 b- defN 80-Jan-01 00:00 fw_storage/future/__init__.py
--rw-r--r--  2.0 unx    11513 b- defN 80-Jan-01 00:00 fw_storage/future/base.py
--rw-r--r--  2.0 unx     4758 b- defN 80-Jan-01 00:00 fw_storage/future/errors.py
+-rw-r--r--  2.0 unx    11541 b- defN 80-Jan-01 00:00 fw_storage/future/base.py
+-rw-r--r--  2.0 unx     4652 b- defN 80-Jan-01 00:00 fw_storage/future/errors.py
 -rw-r--r--  2.0 unx       36 b- defN 80-Jan-01 00:00 fw_storage/future/types/__init__.py
--rw-r--r--  2.0 unx    12698 b- defN 80-Jan-01 00:00 fw_storage/future/types/fs.py
--rw-r--r--  2.0 unx     3962 b- defN 80-Jan-01 00:00 fw_storage/future/utils.py
+-rw-r--r--  2.0 unx    12557 b- defN 80-Jan-01 00:00 fw_storage/future/types/fs.py
+-rw-r--r--  2.0 unx     3934 b- defN 80-Jan-01 00:00 fw_storage/future/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 fw_storage/py.typed
--rw-r--r--  2.0 unx     7727 b- defN 80-Jan-01 00:00 fw_storage/storage.py
+-rw-r--r--  2.0 unx     7677 b- defN 80-Jan-01 00:00 fw_storage/storage.py
 -rw-r--r--  2.0 unx       28 b- defN 80-Jan-01 00:00 fw_storage/types/__init__.py
--rw-r--r--  2.0 unx     6864 b- defN 80-Jan-01 00:00 fw_storage/types/az.py
--rw-r--r--  2.0 unx    13496 b- defN 80-Jan-01 00:00 fw_storage/types/dicom.py
--rw-r--r--  2.0 unx     7967 b- defN 80-Jan-01 00:00 fw_storage/types/dicomweb.py
--rw-r--r--  2.0 unx      165 b- defN 80-Jan-01 00:00 fw_storage/types/fs.py
--rw-r--r--  2.0 unx     4847 b- defN 80-Jan-01 00:00 fw_storage/types/gs.py
--rw-r--r--  2.0 unx     6287 b- defN 80-Jan-01 00:00 fw_storage/types/s3.py
--rw-r--r--  2.0 unx     4013 b- defN 80-Jan-01 00:00 fw_storage-2.1.3.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 fw_storage-2.1.3.dist-info/WHEEL
--rw-r--r--  2.0 unx     1078 b- defN 80-Jan-01 00:00 fw_storage-2.1.3.dist-info/LICENSE
-?rw-r--r--  2.0 unx     1924 b- defN 16-Jan-01 00:00 fw_storage-2.1.3.dist-info/RECORD
-24 files, 108732 bytes uncompressed, 34667 bytes compressed:  68.1%
+-rw-r--r--  2.0 unx     6844 b- defN 80-Jan-01 00:00 fw_storage/types/az.py
+-rw-r--r--  2.0 unx    13338 b- defN 80-Jan-01 00:00 fw_storage/types/dicom.py
+-rw-r--r--  2.0 unx     7996 b- defN 80-Jan-01 00:00 fw_storage/types/dicomweb.py
+-rw-r--r--  2.0 unx      140 b- defN 80-Jan-01 00:00 fw_storage/types/fs.py
+-rw-r--r--  2.0 unx     4861 b- defN 80-Jan-01 00:00 fw_storage/types/gs.py
+-rw-r--r--  2.0 unx     6374 b- defN 80-Jan-01 00:00 fw_storage/types/s3.py
+-rw-r--r--  2.0 unx     1078 b- defN 80-Jan-01 00:00 fw_storage-2.1.4.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4013 b- defN 80-Jan-01 00:00 fw_storage-2.1.4.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 fw_storage-2.1.4.dist-info/WHEEL
+?rw-r--r--  2.0 unx     1924 b- defN 16-Jan-01 00:00 fw_storage-2.1.4.dist-info/RECORD
+24 files, 108764 bytes uncompressed, 34563 bytes compressed:  68.2%
```

## zipnote {}

```diff
@@ -54,20 +54,20 @@
 
 Filename: fw_storage/types/gs.py
 Comment: 
 
 Filename: fw_storage/types/s3.py
 Comment: 
 
-Filename: fw_storage-2.1.3.dist-info/METADATA
+Filename: fw_storage-2.1.4.dist-info/LICENSE
 Comment: 
 
-Filename: fw_storage-2.1.3.dist-info/WHEEL
+Filename: fw_storage-2.1.4.dist-info/METADATA
 Comment: 
 
-Filename: fw_storage-2.1.3.dist-info/LICENSE
+Filename: fw_storage-2.1.4.dist-info/WHEEL
 Comment: 
 
-Filename: fw_storage-2.1.3.dist-info/RECORD
+Filename: fw_storage-2.1.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fw_storage/__init__.py

```diff
@@ -1,20 +1,25 @@
 """Flywheel storage library."""
 from importlib.metadata import version
 
-from .errors import *  # pylint: disable=redefined-builtin
-from .storage import Storage, create_storage_client, create_storage_config
-
 __version__ = version(__name__)
-
-# pylint: disable=duplicate-code
 __all__ = [
     "FileExists",
     "FileNotFound",
     "IsADirectory",
     "NotADirectory",
     "PermError",
     "Storage",
     "StorageError",
     "create_storage_client",
     "create_storage_config",
 ]
+
+from .errors import (
+    FileExists,
+    FileNotFound,
+    IsADirectory,
+    NotADirectory,
+    PermError,
+    StorageError,
+)
+from .storage import Storage, create_storage_client, create_storage_config
```

## fw_storage/config.py

```diff
@@ -42,17 +42,17 @@
         """Return full storage URL including credentials and options."""
 
     def dict(self, secret: t.Literal[None, "str", "val"] = None, **kwargs) -> dict:
         """Return model as dictionary with optional secret serialization."""
         data = super().dict(**kwargs)
         for key, value in data.items():
             if isinstance(value, SecretStr):
-                if secret == "str":  # serialize as ***
+                if secret == "str":  # noqa, serialize as **
                     data[key] = str(value)  # pragma: no cover
-                if secret == "val":  # serialize as val
+                if secret == "val":  # noqa, serialize as val, noqa
                     data[key] = value.get_secret_value()
         return data
 
     def apply_override(self, override: "StorageConfigOverride"):
         """Apply property overrides."""
         expected_class = f"{type(self).__name__}Override"
         actual_class = type(override).__name__
@@ -78,15 +78,17 @@
         title="AWS S3 bucket name",
         example="s3-bucket",
         min_length=3,
         max_length=63,
         regex=r"^[a-z0-9-.]+$",
     )
     prefix: str = Field("", title="Common object key prefix", example="prefix")
-
+    connector_creds: bool = Field(
+        False, title="Use connector's pre-configured credentials"
+    )
     access_key_id: t.Optional[str] = Field(
         title="AWS Access Key ID",
         example="AKIAIOSFODNN7EXAMPLE",
         min_length=16,
         max_length=128,
     )
     secret_access_key: t.Optional[SecretStr] = Field(
@@ -101,36 +103,42 @@
         parsed = parse_url(url)
         params = {
             "type": parsed.pop("scheme"),
             "bucket": parsed.pop("host"),
             "prefix": parsed.pop("path", "").strip("/"),
             "access_key_id": parsed.pop("access_key_id", None),
             "secret_access_key": parsed.pop("secret_access_key", None),
+            "connector_creds": parsed.pop("connector_creds", False),
         }
         assert not parsed, f"unexpected {','.join(parsed)} in url {url!r}"
         return cls(**params)
 
     @property
     def safe_url(self) -> str:
         """Return safe storage URL without credentials."""
         return format_url(scheme=self.type, host=self.bucket, path=self.prefix)
 
     @property
     def full_url(self) -> str:
         """Return full storage URL with credentials."""
-        data = self.dict(secret="val")
+        data = self.dict(secret="val")  # noqa: S106
         return self.safe_url + qs(
             access_key_id=data["access_key_id"],
             secret_access_key=data["secret_access_key"],
         )
 
     @root_validator(pre=True)
     @classmethod
     def load_creds(cls, values: dict) -> dict:
         """Load creds from the env if enabled."""
+        if values.get("connector_creds"):
+            # drop creds if passed
+            values.pop("access_key_id", None)
+            values.pop("secret_access_key", None)
+            return values
         if LOAD_ENV:
             if not values.get("access_key_id"):
                 values["access_key_id"] = os.getenv("AWS_ACCESS_KEY_ID")
             if not values.get("secret_access_key"):
                 values["secret_access_key"] = os.getenv("AWS_SECRET_ACCESS_KEY")
         if REQUIRE_CREDS:
             assert values.get("access_key_id"), "access_key_id required"
@@ -209,15 +217,15 @@
     def safe_url(self) -> str:
         """Return safe storage URL without credentials."""
         return format_url(scheme=self.type, host=self.bucket, path=self.prefix)
 
     @property
     def full_url(self) -> str:
         """Return full storage URL with credentials."""
-        creds = self.dict(secret="val")["application_credentials"]
+        creds = self.dict(secret="val")["application_credentials"]  # noqa: S106
         return self.safe_url + qs(application_credentials=creds)
 
     @validator("application_credentials", always=True)
     @classmethod
     def load_creds(
         cls, application_credentials: t.Optional[SecretStr]
     ) -> t.Optional[SecretStr]:
@@ -324,15 +332,15 @@
         """Return safe storage URL without credentials."""
         path = f"{self.container}/{self.prefix}" if self.prefix else self.container
         return format_url(scheme=self.type, host=self.account, path=path)
 
     @property
     def full_url(self) -> str:
         """Return full storage URL with credentials."""
-        data = self.dict(secret="val")
+        data = self.dict(secret="val")  # noqa: S106
         return self.safe_url + qs(
             access_key=data["access_key"],
             tenant_id=data["tenant_id"],
             client_id=data["client_id"],
             client_secret=data["client_secret"],
         )
```

## fw_storage/errors.py

```diff
@@ -1,4 +1,4 @@
 """Storage errors."""
 # TODO replace when .future is promoted to top level
-# pylint: disable=wildcard-import,redefined-builtin,unused-wildcard-import
-from .future.errors import *
+
+from .future.errors import *  # noqa
```

## fw_storage/future/base.py

```diff
@@ -43,15 +43,15 @@
             **kw: Keyword arguments passed to pydantic.BaseModel.dict().
         """
         kw.setdefault("exclude_none", True)
         kw.setdefault("exclude_unset", True)
         kw.setdefault("exclude_defaults", True)
         if reveal is None:
             secret = kw.pop("secret", None)
-            reveal = secret == "val" if secret else None
+            reveal = secret == "val" if secret else None  # noqa: S105
         data = super().dict(**kw)
         for key, val in data.items():
             if reveal is not None and isinstance(val, SecretStr):  # pragma: no cover
                 data[key] = val.get_secret_value() if reveal else str(val)
         return data
 
     @classmethod
@@ -145,15 +145,15 @@
         urlpath = self.config.to_url()
         relpath = self.relpath(path)
         if relpath and not urlpath.endswith("/"):
             urlpath += "/"
         return f"{urlpath}{relpath}"
 
     @abstractmethod
-    def ls(
+    def ls(  # noqa: D417
         self,
         path: t.Optional[AnyPath] = None,
         filt: t.Optional[t.Callable[[ItemT], bool]] = None,
         **kw,
     ) -> t.Iterator[ItemT]:
         """Yield sorted storage items, optionally filtered.
```

## fw_storage/future/errors.py

```diff
@@ -31,15 +31,15 @@
             msg += f"\n  errors (showing first {limit} of {err_cnt}):"
             msg += "\n    - ".join([""] + [str(e) for e in self.errors[:limit]])
             if err_cnt > limit:
                 msg += f"\n    - and {err_cnt - limit} more...')"
         return msg
 
 
-class PermissionError(StorageError):  # pylint: disable=redefined-builtin
+class PermissionError(StorageError):
     """Permission error. Raised when roles/permissions are insufficient."""
 
 
 # TODO deprecation warning (when most of future is implemented)
 PermError = PermissionError
 
 
@@ -75,15 +75,14 @@
     ):
         """Init the decorator with the errors to catch and the conversion func."""
         self.errors = errors
         self.mapper = mapper
 
     def __call__(self, func: t.Callable) -> t.Callable:
         """Return decorated function that maps errors to StorageErrors."""
-        # pylint: disable=bad-exception-cause,catching-non-exception
         # TODO use decorator.decorator to retain signature
         if inspect.isgeneratorfunction(func):
 
             def wrapper(*args, **kwargs):
                 try:
                     yield from func(*args, **kwargs)
                 except tuple(self.errors) as exc:
```

## fw_storage/future/types/fs.py

```diff
@@ -177,15 +177,15 @@
         return "" if str(relpath) == "." else str(relpath)
 
     def abspath(self, path: t.Optional[AnyPath] = None) -> str:
         """Return absolute file path, including the storage path."""
         return str(Path(self.config.path) / self.relpath(path))
 
     @errmap
-    def ls(  # pylint: disable=too-many-arguments,too-many-locals
+    def ls(  # noqa: D417, PLR0913
         self,
         path: t.Optional[AnyPath] = None,
         filt: t.Optional[t.Callable[[File], bool]] = None,
         filt_dir: t.Optional[t.Callable[[str], bool]] = None,
         filt_file: t.Optional[t.Callable[[str], bool]] = None,
         follow_links: t.Optional[bool] = None,
         **kw,
@@ -204,16 +204,18 @@
         # TODO before 1st usage in prod, consider adding to super() interface
         filt_dir = filt_dir or utils.true
         filt_file = filt_file or utils.true
         links = follow_links if follow_links is not None else self.config.follow_links
         rel_dirs: t.List[str] = []
         rel_files: t.List[str] = []
         for root, dirs, files in os.walk(top, followlinks=links, onerror=onerr):
-            # pylint: disable=cell-var-from-loop,unnecessary-lambda-assignment
-            rel = lambda name: self.relpath(f"{root}/{name}")
+
+            def rel(name):
+                return self.relpath(f"{root}/{name}")
+
             # pop first dir from the buffer (should be the root)
             assert not rel_dirs or rel_dirs.pop(0) == rel("")
             # apply the dir filters to prune the walk tree for efficiency
             # also sort dirs to enforce deterministic walk order
             dirs[:] = [d for d in sorted(dirs) if filt_dir(d)]
             rel_dirs.extend([rel(d) for d in dirs])
             rel_dirs.sort()
@@ -260,15 +262,15 @@
                 if self.config.chown:
                     shutil.chown(parent, *self.config.owner)
             path.touch()
             if self.config.chmod:
                 path.chmod(self.config.file_perms)
             if self.config.chown:
                 shutil.chown(path, *self.config.owner)
-        # pylint: disable=consider-using-with,unspecified-encoding
+
         file = path.open(mode=f"{mode}b")
         return t.cast(t.BinaryIO, file)
 
     @errmap
     def rm(self, path: AnyPath, recurse: bool = False) -> None:
         """Remove a file at the given path."""
         path = Path(self.abspath(path))
@@ -309,12 +311,12 @@
 def onerr(exc: OSError):
     """Walk error callback to raise exceptions instead of swallowing them."""
     raise exc  # pragma: no cover
 
 
 def md5sum(path: AnyPath, block_size: int = 2**20) -> str:
     """Return file content-hash for the given path."""
-    md5 = hashlib.md5()
+    md5 = hashlib.md5()  # noqa: S324
     with open(str(path), mode="rb") as file:
         while data := file.read(block_size):
             md5.update(data)
     return md5.hexdigest()
```

## fw_storage/future/utils.py

```diff
@@ -34,26 +34,26 @@
     port: t.Optional[int] = None
     path: t.Optional[str] = None
     query: t.Dict[str, str] = {}
     fragment: t.Optional[str] = None
 
     @root_validator(pre=True)
     @classmethod
-    def flex_load(cls, values: dict) -> dict:  # pylint: disable=used-before-assignment
+    def flex_load(cls, values: dict) -> dict:
         """Return dict without null values and unknown keys as query params."""
         props = cls.schema()["properties"]
         query = values.pop("query", {})
         extra = [key for key in values if key not in props]
         for key in extra:
             query[key] = values.pop(key)
         values["query"] = filter_none(query)
         values = filter_none(values)
         return values
 
-    def dict(self, merge: bool = True, **kw) -> dict:
+    def dict(self, merge: bool = True, **kw) -> dict:  # noqa: D417
         """Return model as a dict, w/ the query merged into it by default.
 
         Args:
             merge: Set to False to retain query as a top-level dict key.
         """
         kw.setdefault("exclude_none", True)
         data = super().dict(**kw)
```

## fw_storage/storage.py

```diff
@@ -132,17 +132,15 @@
     def upload_file(self, path: str, file: AnyFile) -> None:
         """Upload file to the given path."""
 
     @abc.abstractmethod
     def flush_delete(self):
         """Flush pending remove operations."""
 
-    def get(  # pylint: disable=arguments-differ
-        self, path: AnyPath, **_kwargs
-    ) -> BinFile:
+    def get(self, path: AnyPath, **_kwargs) -> BinFile:
         """Return a file opened for reading in binary mode."""
         abspath = self.abspath(path)
         file = TempFile()
         self.download_file(abspath, file)
         file.seek(0)
         return BinFile(t.cast(t.BinaryIO, file), metapath=self.relpath(path))
```

## fw_storage/types/az.py

```diff
@@ -57,24 +57,27 @@
     return from_creds(credential=DefaultAzureCredential(), retry_policy=retry_policy)
 
 
 class RetryConfig(BaseSettings):
     """Retry config."""
 
     class Config:
+        """Model config."""
+
         env_prefix = "AZURE_RETRY_"
 
     total: int = 3
     backoff_factor: float = 0.5
 
 
 class AzureRetryPolicy(StorageRetryPolicy):
     """Custom Azure retry policy."""
 
     def __init__(self, config: RetryConfig):
+        """Init retry policy."""
         self.backoff_factor = config.backoff_factor
         super().__init__(retry_total=config.total, retry_to_secondary=False)
 
     def get_backoff_time(self, settings):  # pragma: no cover
         """Calculates how long to sleep before retrying."""
         # TODO re-add cover
         return self.backoff_factor * (2 ** settings["count"] - 1)
@@ -88,19 +91,18 @@
 }
 errmap = errors.ErrorMapper(ERRMAP)
 
 
 class AZStorage(CloudStorage):
     """Azure Blob Storage class."""
 
-    # NOTE Azure only supports up to 256 subrequests in a single batch
+    # NOTE Azure only supports up to 256 requests in a single batch
     delete_batch_size: t.ClassVar[int] = 256
 
     def __init__(
-        # pylint: disable=too-many-arguments
         self,
         config: AZConfig,
         **kwargs,
     ) -> None:
         """Construct Azure storage."""
         self.config = config
 
@@ -137,15 +139,15 @@
         path = self.abspath(path)
         filt = StorageFilter(include=include, exclude=exclude)
         for blob in self.client.list_blobs(name_starts_with=path):
             relpath = re.sub(rf"^{self.config.prefix}", "", blob.name).lstrip("/")
             info = FileInfo(
                 path=relpath,
                 size=blob.size,
-                hash=blob.etag,  # pylint: disable=duplicate-code
+                hash=blob.etag,
                 created=blob.creation_time.timestamp(),
                 modified=blob.last_modified.timestamp(),
             )
             # skip az "folders" - path is empty if the prefix itself is a "folder"
             if not relpath or relpath.endswith("/") and info.size == 0:
                 continue  # pragma: no cover
             if filt.match(info):
```

## fw_storage/types/dicom.py

```diff
@@ -17,15 +17,15 @@
 from ..storage import AnyPath, Storage
 
 __all__ = ["DICOMStorage"]
 
 PENDING = {0xFF00, 0xFF01}
 SUCCESS = 0x0000
 
-# pylint: disable=no-member
+
 STUDY_FIND = sop_class.StudyRootQueryRetrieveInformationModelFind
 STUDY_GET = sop_class.StudyRootQueryRetrieveInformationModelGet
 STUDY_MOVE = sop_class.StudyRootQueryRetrieveInformationModelMove
 # pylint: enable=no-member
 
 
 class DICOMBase(Storage):
@@ -38,20 +38,18 @@
     @abc.abstractmethod
     def stat(self, path: AnyPath) -> FileInfo:
         """Return FileInfo for a single file."""
 
     @abc.abstractmethod
     def get(self, path: AnyPath, **kwargs) -> AnyPath:  # type: ignore
         """Return path to downloaded series."""
-        # pylint: disable=arguments-differ
 
     @abc.abstractmethod
     def set(self, file: AnyPath) -> None:  # type: ignore
         """Write a file at the given path in storage."""
-        # pylint: disable=arguments-differ
 
     @abc.abstractmethod
     def rm(self, path: AnyPath, recurse: bool = False) -> None:
         """Remove file from storage."""
 
     def result_to_fileinfo(self, ds: Dataset) -> FileInfo:
         """Fills the FileInfo from a dict."""
@@ -169,15 +167,14 @@
 
     def __init__(self, config: DICOMConfig) -> None:
         """Construct DICOM storage.
 
         Args:
             config: DICOMConfig
         """
-        # pylint: disable=too-many-arguments
         self.config = config
         self.ae = AE(ae_title=self.config.aet.encode())
         # Add required contexts for operations
         contexts = [STUDY_FIND, STUDY_GET, STUDY_MOVE]
         for cx in contexts:
             self.ae.add_requested_context(cx)
```

## fw_storage/types/dicomweb.py

```diff
@@ -145,14 +145,16 @@
     def get_image_count(self, study_uid: str, series_uid: str) -> int:
         """Get image count of series."""
         result = self.client.qido(f"/studies/{study_uid}/series/{series_uid}/instances")
         return len(result)
 
 
 class DICOMwebClient(HttpClient):
+    """DICOM web client."""
+
     def qido(self, url, params=None):
         """Handle QIDO requests."""
         headers = {"Accept": "application/json"}
         response = super().get(url, raw=True, params=params, headers=headers)
         content_type = response.headers.get("Content-Type")
         datasets = []
         if content_type in ["application/json", "application/dicom+json"]:
```

## fw_storage/types/fs.py

```diff
@@ -1,3 +1,3 @@
 """Local storage module."""
 # TODO deprecation warning (when most of future is implemented)
-from ..future.types.fs import FSStorage  # pylint: disable=unused-import
+from ..future.types.fs import FSStorage  # noqa
```

## fw_storage/types/gs.py

```diff
@@ -25,15 +25,15 @@
 }
 errmap = errors.ErrorMapper(ERRMAP)
 
 
 class GSStorage(CloudStorage):
     """Google Cloud Storage class."""
 
-    def __init__(
+    def __init__(  # noqa: D417
         self,
         config: GSConfig,
         **kwargs,
     ):
         """Google Cloud Storage class for working with blobs in GCS buckets.
 
         Args:
```

## fw_storage/types/s3.py

```diff
@@ -43,15 +43,15 @@
 
 errmap = errors.ErrorMapper(ERRMAP, convert_s3_error)  # type: ignore
 
 
 class S3Storage(CloudStorage):
     """AWS S3 Storage class."""
 
-    def __init__(
+    def __init__(  # noqa: D417
         self,
         config: S3Config,
         **kwargs,
     ):
         """AWS S3 Storage class for working with blobs in S3 buckets.
 
         Args:
@@ -60,21 +60,21 @@
         self.config = config
 
         # https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html
         client_config = botocore.config.Config(
             signature_version="s3v4",
             retries={"max_attempts": 3},
         )
-        secret = None
+        session_kw = {}
+        if self.config.access_key_id:
+            session_kw["aws_access_key_id"] = self.config.access_key_id
         if self.config.secret_access_key:
             secret = self.config.secret_access_key.get_secret_value()
-        session = boto3.session.Session(
-            aws_access_key_id=self.config.access_key_id,
-            aws_secret_access_key=secret,
-        )
+            session_kw["aws_secret_access_key"] = secret
+        session = boto3.session.Session(**session_kw)
         self.client = session.client("s3", config=client_config)
 
         super().__init__(**kwargs)
 
     def abspath(self, path: AnyPath) -> str:
         """Return path string relative to the storage URL, including the perfix."""
         return f"{self.config.prefix}/{self.relpath(path)}".lstrip("/")
```

## Comparing `fw_storage-2.1.3.dist-info/METADATA` & `fw_storage-2.1.4.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fw-storage
-Version: 2.1.3
+Version: 2.1.4
 Summary: Unified storage interface.
 Home-page: https://gitlab.com/flywheel-io/tools/lib/fw-storage
 License: MIT
 Keywords: Flywheel,file,object,storage
 Author: Flywheel
 Author-email: support@flywheel.io
 Requires-Python: >=3.8,<4.0
```

## Comparing `fw_storage-2.1.3.dist-info/LICENSE` & `fw_storage-2.1.4.dist-info/LICENSE`

 * *Files identical despite different names*

