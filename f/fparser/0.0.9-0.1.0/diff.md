# Comparing `tmp/fparser-0.0.9.tar.gz` & `tmp/fparser-0.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/fparser-0.0.9.tar", last modified: Mon Nov  4 16:58:30 2019, max compression
+gzip compressed data, was "fparser-0.1.0.tar", last modified: Tue Apr 18 07:31:30 2023, max compression
```

## Comparing `fparser-0.0.9.tar` & `fparser-0.1.0.tar`

### file list

```diff
@@ -1,92 +1,241 @@
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3280 2019-03-06 14:59:58.000000 fparser-0.0.9/LICENSE
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3540 2019-03-06 14:59:58.000000 fparser-0.0.9/MANIFEST.in
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     1055 2019-11-04 16:58:30.000000 fparser-0.0.9/PKG-INFO
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     1685 2019-11-04 16:57:11.000000 fparser-0.0.9/README.md
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/doc/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    10148 2019-03-06 14:59:58.000000 fparser-0.0.9/doc/Makefile
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/doc/_build/
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/doc/_build/latex/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     1648 2019-07-15 15:52:32.000000 fparser-0.0.9/doc/_build/latex/Makefile
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    11984 2019-11-04 16:57:11.000000 fparser-0.0.9/doc/conf.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    30767 2019-07-15 17:58:20.000000 fparser-0.0.9/doc/developers_guide.rst
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    19112 2019-03-06 14:59:58.000000 fparser-0.0.9/doc/fparser.rst
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    14112 2019-07-15 17:58:20.000000 fparser-0.0.9/doc/fparser2.rst
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3880 2019-03-06 14:59:58.000000 fparser-0.0.9/doc/index.rst
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3565 2019-07-15 17:58:20.000000 fparser-0.0.9/doc/introduction.rst
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3446 2019-03-06 14:59:58.000000 fparser-0.0.9/doc/license.rst
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)       38 2019-11-04 16:58:30.000000 fparser-0.0.9/setup.cfg
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     5284 2019-11-04 16:57:11.000000 fparser-0.0.9/setup.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3530 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/__init__.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    10761 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/api.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/common/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        0 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/common/__init__.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    35829 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/common/base_classes.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    60456 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/common/readfortran.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    11635 2019-06-04 15:52:08.000000 fparser-0.0.9/src/fparser/common/sourceinfo.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    10761 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/common/splitline.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/common/tests/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)      168 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/common/tests/__init__.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     1996 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/common/tests/conftest.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3585 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/common/tests/logging_utils.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     6402 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/common/tests/test_base_classes.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    32904 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/common/tests/test_readfortran.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    13744 2019-06-04 15:52:08.000000 fparser-0.0.9/src/fparser/common/tests/test_sourceinfo.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     6509 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/common/tests/test_splitline.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     9570 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/common/tests/test_utils.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    15250 2019-06-04 15:52:08.000000 fparser-0.0.9/src/fparser/common/utils.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     2578 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/conftest.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/one/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        0 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/__init__.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    51766 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/block_statements.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     6183 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/parsefortran.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    78227 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/one/statements.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/one/tests/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)      169 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/tests/__init__.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     5190 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/one/tests/test_block_stmts.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     6604 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/tests/test_do_block_r814.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     9025 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/tests/test_parsefortran.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    38485 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/one/tests/test_parser.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3704 2019-04-05 11:49:34.000000 fparser-0.0.9/src/fparser/one/tests/test_scripts.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    17267 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/one/tests/test_select.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    23550 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/one/typedecl_statements.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/scripts/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        0 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/scripts/__init__.py
--rwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)     5790 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/scripts/fparser2.py
--rwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)     4698 2019-04-05 11:49:34.000000 fparser-0.0.9/src/fparser/scripts/parse.py
--rwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)     4958 2019-04-05 11:49:34.000000 fparser-0.0.9/src/fparser/scripts/read.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     5613 2019-07-08 09:48:18.000000 fparser-0.0.9/src/fparser/scripts/script_options.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/tests/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     8044 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_api.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4261 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_blank_lines.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     5617 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_comment.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3844 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_f90comment_f77source.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     2751 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_functional.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3883 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue10.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3875 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue11.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4112 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue23.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4104 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue25.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4141 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue26.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     3960 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue33.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     5558 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue4.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4387 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue5.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     7166 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue7.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     6540 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue8.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4023 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_issue9.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     4265 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/tests/test_mod_private.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser/two/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)   323639 2019-11-04 16:57:11.000000 fparser-0.0.9/src/fparser/two/Fortran2003.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    16823 2019-07-08 09:48:18.000000 fparser-0.0.9/src/fparser/two/Fortran2008.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        0 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/two/__init__.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    12413 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/two/parser.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    20452 2019-03-06 14:59:58.000000 fparser-0.0.9/src/fparser/two/pattern_tools.py
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)    54570 2019-11-04 16:57:12.000000 fparser-0.0.9/src/fparser/two/utils.py
-drwxrwxrwx   0 kbc59144  (1000) kbc59144  (1000)        0 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser.egg-info/
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     1055 2019-11-04 16:58:29.000000 fparser-0.0.9/src/fparser.egg-info/PKG-INFO
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)     2369 2019-11-04 16:58:30.000000 fparser-0.0.9/src/fparser.egg-info/SOURCES.txt
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        1 2019-11-04 16:58:29.000000 fparser-0.0.9/src/fparser.egg-info/dependency_links.txt
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)       60 2019-11-04 16:58:29.000000 fparser-0.0.9/src/fparser.egg-info/entry_points.txt
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        4 2019-11-04 16:58:29.000000 fparser-0.0.9/src/fparser.egg-info/requires.txt
--rw-rw-rw-   0 kbc59144  (1000) kbc59144  (1000)        8 2019-11-04 16:58:29.000000 fparser-0.0.9/src/fparser.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.915221 fparser-0.1.0/
+-rw-r--r--   0 runner    (1001) docker     (123)       41 2023-04-18 07:31:15.000000 fparser-0.1.0/.git-blame-ignore-revs
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.863220 fparser-0.1.0/.github/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.871220 fparser-0.1.0/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (123)      645 2023-04-18 07:31:15.000000 fparser-0.1.0/.github/workflows/python_publish.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     3454 2023-04-18 07:31:15.000000 fparser-0.1.0/.github/workflows/unit-tests.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1833 2023-04-18 07:31:15.000000 fparser-0.1.0/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)    17006 2023-04-18 07:31:15.000000 fparser-0.1.0/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (123)     3286 2023-04-18 07:31:15.000000 fparser-0.1.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     3540 2023-04-18 07:31:15.000000 fparser-0.1.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     3317 2023-04-18 07:31:30.915221 fparser-0.1.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2256 2023-04-18 07:31:15.000000 fparser-0.1.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.871220 fparser-0.1.0/doc/
+-rw-r--r--   0 runner    (1001) docker     (123)      800 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/Makefile
+-rw-r--r--   0 runner    (1001) docker     (123)   114630 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/doxygen.config
+-rw-r--r--   0 runner    (1001) docker     (123)     1948 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/pip_requirements.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.871220 fparser-0.1.0/doc/source/
+-rw-r--r--   0 runner    (1001) docker     (123)     1833 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/conf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42926 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/developers_guide.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    19397 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/fparser.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    20973 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/fparser2.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3932 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3660 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/introduction.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3490 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/license.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     2706 2023-04-18 07:31:15.000000 fparser-0.1.0/doc/source/reference_guide.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.871220 fparser-0.1.0/example/
+-rw-r--r--   0 runner    (1001) docker     (123)     2006 2023-04-18 07:31:15.000000 fparser-0.1.0/example/Makefile
+-rw-r--r--   0 runner    (1001) docker     (123)     2583 2023-04-18 07:31:15.000000 fparser-0.1.0/example/README.md
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6102 2023-04-18 07:31:15.000000 fparser-0.1.0/example/create_dependencies.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2127 2023-04-18 07:31:15.000000 fparser-0.1.0/example/fparser2_f2008.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.875220 fparser-0.1.0/example/test_files/
+-rw-r--r--   0 runner    (1001) docker     (123)       30 2023-04-18 07:31:15.000000 fparser-0.1.0/example/test_files/a.f90
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-04-18 07:31:15.000000 fparser-0.1.0/example/test_files/b.f90
+-rw-r--r--   0 runner    (1001) docker     (123)       48 2023-04-18 07:31:15.000000 fparser-0.1.0/example/test_files/c.f90
+-rw-r--r--   0 runner    (1001) docker     (123)      246 2023-04-18 07:31:15.000000 fparser-0.1.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)     1339 2023-04-18 07:31:30.915221 fparser-0.1.0/setup.cfg
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3618 2023-04-18 07:31:15.000000 fparser-0.1.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.863220 fparser-0.1.0/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.875220 fparser-0.1.0/src/fparser/
+-rw-r--r--   0 runner    (1001) docker     (123)      614 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/.pylintrc
+-rw-r--r--   0 runner    (1001) docker     (123)     4833 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      160 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser/_version.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10705 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/api.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.879220 fparser-0.1.0/src/fparser/common/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35934 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/base_classes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    62920 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/readfortran.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12263 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/sourceinfo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15228 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/splitline.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.879220 fparser-0.1.0/src/fparser/common/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)      168 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1993 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3557 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/logging_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3485 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/modfile.f95
+-rw-r--r--   0 runner    (1001) docker     (123)     6903 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/test_base_classes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48185 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/test_readfortran.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12954 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/test_sourceinfo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10699 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/test_splitline.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5081 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/test_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1832 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/utf.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     1865 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/tests/utf_in_code.f90
+-rw-r--r--   0 runner    (1001) docker     (123)    12533 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/common/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2578 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.879220 fparser-0.1.0/src/fparser/one/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    51336 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/block_statements.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6169 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/parsefortran.py
+-rw-r--r--   0 runner    (1001) docker     (123)    78902 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/statements.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.883220 fparser-0.1.0/src/fparser/one/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)      169 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1838 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/bad_char.f90
+-rw-r--r--   0 runner    (1001) docker     (123)     5131 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/test_block_stmts.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7017 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/test_do_block_r814.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8656 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/test_parsefortran.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38497 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/test_parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3647 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/test_scripts.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17066 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/tests/test_select.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24502 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/one/typedecl_statements.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.883220 fparser-0.1.0/src/fparser/scripts/
+-rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5268 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/fparser2.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3985 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/fparser2_bench.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     4640 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/parse.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     4934 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/read.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5319 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/script_options.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.883220 fparser-0.1.0/src/fparser/scripts/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     2869 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/tests/test_fparser2_bench.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21396 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/scripts/tests/test_scripts.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.887220 fparser-0.1.0/src/fparser/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     3480 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/funcfile.f95
+-rw-r--r--   0 runner    (1001) docker     (123)     3485 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/modfile.f95
+-rw-r--r--   0 runner    (1001) docker     (123)     7978 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4263 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_blank_lines.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5670 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_comment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3863 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_f90comment_f77source.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3700 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_fparser_module.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2729 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_functional.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3895 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue10.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3878 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue11.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4130 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue23.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4117 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue25.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4169 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue26.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3988 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue33.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5584 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue4.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4408 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue5.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7198 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue7.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6569 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue8.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4035 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_issue9.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4267 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/tests/test_mod_private.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.891220 fparser-0.1.0/src/fparser/two/
+-rw-r--r--   0 runner    (1001) docker     (123)    24469 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/C99Preprocessor.py
+-rw-r--r--   0 runner    (1001) docker     (123)   379425 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/Fortran2003.py
+-rw-r--r--   0 runner    (1001) docker     (123)    53562 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/Fortran2008.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12517 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19850 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/pattern_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26435 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/symbol_table.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.895221 fparser-0.1.0/src/fparser/two/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     1791 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/.pylintrc
+-rw-r--r--   0 runner    (1001) docker     (123)     2749 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.907221 fparser-0.1.0/src/fparser/two/tests/fortran2003/
+-rw-r--r--   0 runner    (1001) docker     (123)     2245 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3965 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_add_operand_r705.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4038 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_allocate_stmt_r623.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3477 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_array_constructor_implied_do_ctl_r471.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2818 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_array_constructor_implied_do_r470.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3164 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_array_constructor_r465.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3497 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_array_constructor_spec_r466.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5951 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_associate_construct_r816.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8630 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_block_do_construct_r826.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5895 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_case_construct_r808.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3462 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_char_expr_r725.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5994 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_char_literal_constant_r427.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4262 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_component_part_r438.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5235 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_control_edit_descriptor_r1011.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2862 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_cray_pointee_array_spec.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2900 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_cray_pointee_decl.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4867 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_cray_pointer_decl.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4495 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_cray_pointer_stmt.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6967 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_data_edit_desc_c1002.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2856 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_data_ref_r612.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5574 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_declaration_construct_r207.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3523 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_default_char_expr_r726.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2916 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_defined_operator_r311.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3237 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_defined_operators_r703_r723.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5441 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_derived_type_stmt_r430.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7630 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_designator_r603.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2856 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_entity_decl_r504.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4292 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_executable_construct_r213.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3115 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_extended_intrinsic_op_r312.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4392 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_forall_header_r754.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5475 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_forall_stmt_r759.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4368 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_format_item_c1002.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7202 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_format_item_list.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7391 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_format_item_r1003.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11518 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_format_specification_r1002.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2714 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_function_stmt_r1224.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5051 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_hollerith_item.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8547 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_if_construct_r802.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3458 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_if_stmt_r807.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3000 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_import_stmt_r1209.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3483 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_include_filename.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5059 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_include_statement.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3328 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_int_expr_r727.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10013 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_intrinsics.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10401 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_io_control_spec_r913.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8077 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_kindselector_r404.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3324 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_level_2_expr_r706.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3839 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_logical_expr_r724.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7005 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_main_program_r1101.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2593 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_module_r1104.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2713 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_name_r304.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4233 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_nonblock_do_construct_r835.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5475 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_numeric_expr_r728.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4844 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_position_edit_desc_r1013.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5628 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_prefix_r1227.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10363 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_primary_r701.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13292 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_program_r201.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3451 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_program_stmt_r1102.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2759 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_rename_r1111.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4663 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_select_type_construct_r821.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6104 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_specific_binding_r451.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2979 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_stmt_function_stmt_r1238.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2718 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_subroutine_stmt_r1232.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4543 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_type_decl_stmt_r501.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13819 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_usestmt_r1109.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7251 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_where_construct_r744.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5487 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2003/test_write_stmt_r911.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.915221 fparser-0.1.0/src/fparser/two/tests/fortran2008/
+-rw-r--r--   0 runner    (1001) docker     (123)     2275 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6560 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_action_stmt_r214.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2832 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_alloc_opt_r627.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7171 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_attr_spec_r502.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6649 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_block.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2922 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_coarray_spec_r509.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5019 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_component_attr_spec_r437.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4381 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_critical.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1898 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_data_component_def_stmt_r436.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2405 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_deferred_coshape_spec_r510.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3440 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_end_submodule_stmt_r1119.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3494 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_error_stop_stmt_r856.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3712 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_explicit_coshape_spec_r511.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3493 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_if_stmt_r837.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2682 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_lower_cobound_r512.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6121 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_open_stmt_r904.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4233 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_parent_identifier_r1118.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2963 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_program_unit_r202.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7801 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_submodule_r1116.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5422 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_submodule_stmt_r1117.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4493 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_type_declaration_stmt_r501.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2682 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/fortran2008/test_upper_cobound_r513.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6016 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_bases.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17753 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_c99preprocessor.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12866 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_comments.py
+-rw-r--r--   0 runner    (1001) docker     (123)   100844 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_fortran2003.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7119 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_module_use.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3834 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5730 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_pattern_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12803 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_symbol_table.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6657 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_symbol_tables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5768 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/test_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.915221 fparser-0.1.0/src/fparser/two/tests/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     3611 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7854 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_binaryopbase.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9674 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_blockbase.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7581 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_bracket_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4376 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_call_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2987 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_get_child.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5179 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_sequencebase.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4903 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_stringbase_upper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4838 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_walk.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7596 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/tests/utils/test_wordclsbase.py
+-rw-r--r--   0 runner    (1001) docker     (123)    70927 2023-04-18 07:31:15.000000 fparser-0.1.0/src/fparser/two/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 07:31:30.875220 fparser-0.1.0/src/fparser.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     3317 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     9717 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       59 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      116 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        8 2023-04-18 07:31:30.000000 fparser-0.1.0/src/fparser.egg-info/top_level.txt
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `fparser-0.0.9/LICENSE` & `fparser-0.1.0/LICENSE`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-Modified work Copyright (c) 2017 Science and Technology Facilities Council
+Modified work Copyright (c) 2017-2022 Science and Technology
+Facilities Council.
 Original work Copyright (c) 1999-2008 Pearu Peterson
 
 All rights reserved.
 
 Modifications made as part of the fparser project are distributed
 under the following license:
```

### Comparing `fparser-0.0.9/MANIFEST.in` & `fparser-0.1.0/MANIFEST.in`

 * *Files identical despite different names*

### Comparing `fparser-0.0.9/doc/developers_guide.rst` & `fparser-0.1.0/doc/source/developers_guide.rst`

 * *Files 23% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-..  Copyright (c) 2017-2019 Science and Technology Facilities Council.
+..  Copyright (c) 2017-2023 Science and Technology Facilities Council.
 
     All rights reserved.
 
     Modifications made as part of the fparser project are distributed
     under the following license:
 
     Redistribution and use in source and binary forms, with or without
@@ -30,77 +30,57 @@
     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 .. _developers:
 
-Developers' Guide
-=================
+Developer Guide
+===============
 
 Reading Fortran
 ---------------
 
 A key part of the fparser package is support for reading Fortran code.
 `fparser.common.readfortran.FortranFileReader` provides this functionality
 for source files while `FortranStringReader` supports Fortran source
 provided as a string. Both of these classes sub-class `FortranReaderBase`:
 
 .. autoclass:: fparser.common.readfortran.FortranReaderBase
 
 Note that the setting for `ignore_comments` provided here can be overridden
 on a per-call basis by methods such as `get_single_line`.
+The 'mode' of the reader is controlled by passing in a suitable instance of
+the `FortranFormat` class:
+
+.. autoclass:: fparser.common.sourceinfo.FortranFormat
+
+Due to its origins in the f2py project, the reader contains support
+for recognising `f2py` directives
+(https://numpy.org/devdocs/f2py/signature-file.html). However, this
+functionality is disabled by default.
 
 A convenience script called read.py is provided in the scripts
 directory which takes a filename as input and returns the file
 reader's representation of that file. This could be useful for
 debugging purposes.
 
 Invalid input
 -------------
 
-The file reader uses 'open' to open a Fortran file. If invalid input
-is found then Python2 does not complain, however Python3 raises a
-`UnicodeDecodeError` exception.
-
-To get round this problem a utility function has been written in
-`utils.py` called `make_clean_tmpfile`. This utility gives control
-over whether an exception is raised or not in both Python2 and 3. It
-also allows the offending errors to be stripped so that the rest of
-the file can be processed successfully.
-
-The uility is required in two places in the code, in `readfortran.py`
-by the file reader and in `sourceinfo.py`. The latter is used to
-determine which Fortran formatting to use (fixed, free etc).
-
-The utility makes use of the `codec.open(errors="ignore")`
-function. Whilst it would have been easier in theory to replace the
-existing `open` calls with `codec.open` this led to many Python2
-problems due to `codec.open` returning `unicode` for both Python 2 and
-3 (whereas open returns `str`). The changes that would need to be made
-to make Python2 and the Python2 tests, work were significant.
-
-Therefore it was decided to use `codec.open` to check for errors and
-to strip out any errors if requested. Once checked and stripped, the
-resultant code is written into a temporary file (regardless of whether
-there were errors in it or not). This then allows the unchanged
-original code to continue to use the `open` function to open the newly
-created temporary file.
-
-Note, if Python2 support is dropped in the future then this function
-can be re-worked so that `codec.open` replaces `open` and no temporary
-file would be required.
-
-In Python, temporary files are usually deleted when closed. This
-feature is not wanted here. Therefore the `make_clean_tmpfile`
-function creates a temporary file that will not be deleted when
-closed. This means that the main code must take responsibility for
-deleting the file once it is no longer required. Logic has been added
-to the Fortran file reading and formatting code to make sure any
-temporary files are removed when required.
+The file reader uses :py:func:`open` to open a Fortran file. If
+invalid input is found then Python raises a `UnicodeDecodeError`
+exception by default. Since we typically wish to skip invalid
+characters (on the principle that, for valid Fortran, they can only
+occur in comments) while logging their presence, a bespoke error
+handler named "fparser-logging" is implemented in
+``fparser/__init__.py`` and registered using
+:py:func:`codecs.register_error`.  This handler may be specified when
+using :py:func:`open` to open a file by supplying the
+``errors='fparser-logging'`` argument.
 
 Fparser2
 --------
 
 Fparser2 supports Fortran2003 and is being extended to support
 Fortran2008. Fparser2 is being actively developed and will fully
 replace fparser1 in the future.
@@ -186,17 +166,19 @@
 A `subclass_names` list of classes should be provided when the rule is
 a simple choice between classes. In this case the `Base` class ensures that each
 child class is tested for a match and the one that matches is
 returned. An example of a simple choice rule is `R202`. See the
 :ref:`program-unit-class` section for a description of its
 implementation.
 
-.. note::
-
-   A `use_names` description, explanation and example needs to be added.
+The `use_names` list should contain any classes that are referenced by the
+implementation of the current class. These lists of names are aggregated
+(along with `subclass_names`) and used to ensure that all necessary `Scalar_`,
+`_List` and `_Name` classes are generated (in code at the end of the
+`Fortran2003` and `Fortran2008` modules - see :ref:`class-generation`).
 
 When the rule is not a simple choice the developer needs to supply a
 static `match` method. An example of this is rule `R201`. See the
 :ref:`program-class` section for a description of its implementation.
 
 .. note::
 
@@ -245,14 +227,87 @@
     >>> parser_f2003.__name__
     'Program'
     >>> parser_f2003.subclasses['Program']
     []
     >>> parser_f2003.subclasses['Program_Unit']
     [<class 'fparser.two.Fortran2003.Main_Program'>, <class 'fparser.two.Fortran2003.Function_Subprogram'>, <class 'fparser.two.Fortran2003.Subroutine_Subprogram'>, <class 'fparser.two.Fortran2003.Module'>, <class 'fparser.two.Fortran2003.Block_Data'>]
 
+Symbol Table
+++++++++++++
+
+There are many situations when it is not possible to disambiguate the
+precise form of the Fortran being parsed without additional type
+information (e.g. whether code of the form `a(i,j)` is an array
+access or a function call).  Therefore fparser2 contains a single,
+global instance of a `SymbolTables` class, accessed as
+`fparser.two.symbol_table.SYMBOL_TABLES`. As its name implies, this
+holds a collection of symbol tables, one for each top-level scoping
+unit (e.g. module or program unit). This is implemented as a
+dictionary where the keys are the names of the scoping units e.g. the
+name of the associated module, program, subroutine or function. The
+corresponding dictionary entries are instances of the `SymbolTable`
+class:
+
+.. autoclass:: fparser.two.symbol_table.SymbolTable
+
+The entries in these tables are instances of the named tuple,
+`SymbolTable.Symbol` which currently has the properties:
+
+ * name
+ * primitive_type
+
+Both of these are stored as strings. In future, support for more
+properties (e.g. kind, shape, visibility) will be added and strings
+replaced with enumerations where it makes sense. Similarly, support
+will be added for other types of symbols (e.g. those representing
+program/subroutine names or reserved Fortran keywords).
+
+Symbols available in the scoping region of a module may be made
+available in another scoping region through one or more `USE` statements.
+In a `SymbolTable` such uses are captured as instances of `ModuleUse`:
+
+.. autoclass:: fparser.two.symbol_table.ModuleUse
+
+These instances are created by calling:
+
+.. automethod:: fparser.two.symbol_table.SymbolTable.add_use_symbols
+
+Fortran has support for nested scopes - e.g. variables declared within
+a module are in scope within any routines defined within that
+module. Therefore, when searching for the definition a symbol, we
+require the ability to search up through all symbol tables accessible
+from the current scope. In order to support this functionality, each
+`SymbolTable` instance therefore has a `parent` property. This holds a
+reference to the table that contains the current table (if any).
+
+Since fparser2 relies heavily upon recursion, it is important that the
+current scoping unit always be available from any point in the code.
+Therefore, the `SymbolTables` class has the `current_scope` property
+which contains a reference to the current `SymbolTable`. Obviously,
+this property must be updated as the parser enters and leaves scoping
+units.  This is handled for all cases bar one within the `BlockBase`
+base class since this is sub-classed by all classes which represent a
+block of code and that therefore includes all those which define a
+scoping region. The exception is the helper class
+`Fortran2003.Main_Program0` which represents Program units that do not
+include the (optional) program-stmt (see R1101 in the Fortran
+standard).  The creation of a scoping unit for such a program is
+handled within the `Fortran2003.Main_Program0.match()` method. Since
+there is no name associated with such a program, the corresponding
+symbol table is given the name "fparser2:main_program", chosen so as
+to prevent any clashes with other Fortran names.
+
+Those classes which define scoping regions must subclass the
+`ScopingRegionMixin` class:
+
+.. autoclass:: fparser.two.utils.ScopingRegionMixin
+
+
+.. _class-generation:
+
 Class Generation
 ++++++++++++++++
 
 Some classes that are specified as strings in the `subclass_names` or
 `use_names` variables do not require class implementations. There are 3
 categories of these:
 
@@ -310,18 +365,20 @@
 certain types of pattern in a rule. The two most commonly used are
 given below. As mentioned earlier, the class `Base` supports a choice
 between classes. The class `BlockBase` supports an initial and final
 match with optional subclasses inbetween (useful for matching rules
 such as programs, subroutines, if statements etc.).
 
 .. autoclass:: fparser.two.utils.Base
-	       :members:
+               :members:
+               :noindex:
 
 .. autoclass:: fparser.two.utils.BlockBase
-	       :members:
+               :members:
+               :noindex:
 
 .. note::
 
    The `BlockBase` `match` method is complicated. One way to simplify this
    would be to create a `NamedBlockBase` which subclasses `BlockBase`. This
    would include the code associated with a block having a name.
 
@@ -720,14 +777,81 @@
 The top level Program rule R201 supports includes at the level of
 multiple program units by again making use of the `add_c_and_i()`
 function before any 'program units', between 'program units' and after
 any 'program units'. This completes all valid locations for include
 statements, including the missing last statement mentioned in the
 previous paragraph.
 
+Preprocessing Directives
+++++++++++++++++++++++++
+
+fparser2 retains preprocessing directives as nodes in the parse tree
+but does not interpret them. This has been implemented in
+`C99Preprocessor.py` as a number of classes that have names with the
+prefix `Cpp_`. This allows fparser2 to parse code successfully that
+contains preprocessing directives but reduces to valid Fortran if the
+directives are omitted.
+
+Similarly to comments, the readers represent preprocessing directives
+by a dedicated class `CppDirective`, which is a subclass of `Line`.
+This allows directives to be detected early and matches to be limited
+to source lines that are instances of `CppDirective`. Matching of directives
+is performed in the same place as include statements to make sure that they
+are recognized at all locations in a source file.
+
+Most directives are implemented as subclasses of `WORDClsBase` or
+`StringBase` (with the only exceptions being macro definition and
+null directive).
+
+Conditional inclusion directives (`#if...[#elif...]...#endif` or their
+variants `#ifdef`/`#ifndef`) are represented as individual nodes by
+classes `fparser.two.C99Preprocessor.Cpp_If_Stmt`,
+`fparser.two.C99Preprocessor.Cpp_Elif_Stmt`,
+`fparser.two.C99Preprocessor.Cpp_Else_Stmt`, and
+`fparser.two.C99Preprocessor.Cpp_Endif_Stmt` but
+currently not grouped together in any way since directives can appear
+at any point in a file and thus the span of conditional inclusions may
+be orthogonal to a Fortran block. In `#if(n)def` directives the
+identifier is matched using
+`fparser.two.C99Preprocessor.Cpp_Macro_Identifier`
+and may contain only letters and underscore. In `#if` or `#elif`
+directives the constant expression is matched very loosely by
+`fparser.two.C99Preprocessor.Cpp_Pp_Tokens`
+which accepts any non-empty string.
+
+Include directives (`#include`) are handled similarly to Fortran
+include statements with the matching of filenames being done by the
+same class and therefore with the same (loose) restrictions.
+
+Directives that define macro replacements (`#define`) contain a
+macro identifier that is matched using `Cpp_Macro_Identifier`.
+This is followed by an optional identifier list in parentheses
+(and without white space separating identifier and opening
+parenthesis) that defines parameters to the macro for use in the
+replacement expression. The identifier list is matched by
+`fparser.two.C99Preprocessor.Cpp_Macro_Identifier_List`
+which, however, does not treat individual identifiers as separate
+names but matches the entire list as a single string.
+The replacement expression is matched and represented as
+`Cpp_Pp_Tokens`.
+
+The matching of `#undef` statements is implemented in class
+`fparser.two.C99Preprocessor.Cpp_Undef_Stmt` with the identifier again
+matched by `Cpp_Macro_Identifier`.
+
+Directives `#line`, `#error`, and `#warning` are implemented in classes
+`fparser.two.C99Preprocessor.Cpp_Line_Stmt`,
+`fparser.two.C99Preprocessor.Cpp_Error_Stmt`, and
+`fparser.two.C99Preprocessor.Cpp_Warning_Stmt` with the corresponding
+right hand sides matched by `Cpp_Pp_Tokens`.
+
+A single preprocessing directive token `#` without any directive is
+a null statement and is matched by
+`fparser.two.C99Preprocessor.Cpp_Null_Stmt`.
+
 Utils
 +++++
 
 fparser2 includes a `utils.py` file. This file contains the base
 classes (discussed in the :ref:`base-classes` section), the
 fparser2-specific exceptions (discussed in the :ref:`exceptions`
 section), a list of extensions (see previous section) and a tree-walk
@@ -744,7 +868,160 @@
 .. skip
    # Constraints
    # +++++++++++
    # TBD
    # Comment Class
    # +++++++++++++
    # TBD
+
+.. _tokenisation:
+
+Tokenisation
+++++++++++++
+
+In order to simplify the problem of parsing code containing
+potentially complex expressions, fparser2 performs some limited
+tokenisation of a string before proceeding to attempt to match it.
+Currently, this tokenisation replaces three different types of quantity with
+simple names:
+
+ 1. the content of strings;
+ 2. expressions in parentheses;
+ 3. literal constants involving exponents (e.g. ``1.0d-3``)
+
+This tokenisation is performed by the `string_replace_map` function:
+
+.. autofunction:: fparser.common.splitline.string_replace_map
+
+In turn, this function uses `splitquote` and `splitparen` (in the same
+module) to split a supplied string into quanties within quotes or
+parentheses, respectively. The matching for literal constants involving
+exponents is implemented using a regular expression.
+
+`string_replace_map` is used in the `match()` method of many of the classes
+that implement the various language rules. Note that the tokenisation must
+be undone before passing a given string on to a child class (or returning
+it). This is performed using the reverse-map that `string_replace_map`
+returns, e.g.::
+
+    line, repmap = string_replace_map(string)
+    ...
+    type_spec = Declaration_Type_Spec(repmap(line[:i].rstrip()))
+
+(The reverse map is an instance of `fparser.common.splitline.StringReplaceDict`
+which subclasses`dict` and makes it callable.)
+
+   
+Expression matching
++++++++++++++++++++
+
+The Fortran2003 rules specify a hierarchy of expressions (specified in
+levels). In summary::
+
+    R722 expr is [ expr defined-binary-op ] level-5-expr
+    R717 level-5-expr is [ level-5-expr equiv-op ] equiv-operand
+    R716 equiv-operand is [ equiv-operand or-op ] or-operand
+    R715 or-operand is [ or-operand and-op ] and-operand
+    R714 and-operand is [ not-op ] level-4-expr
+    R712 level-4-expr is [ level-3-expr rel-op ] level-3-expr    
+    R710 level-3-expr is [ level-3-expr concat-op ] level-2-expr
+    R706 level-2-expr is [[level-2-expr] add_op ] add-operand
+    R705 add-operand is [ add-operand mult-op ] mult-operand
+    R704 mult-operand is level-1-expr [ power-op mult-operand ]
+    R702 level-1-expr is [ defined-unary-op ] primary
+
+As can hopefully be seen, the "top level" rule is `expr`, this depends
+on a `level-5_expr`, which depends on an `equiv-operand` and so on in
+a hierarchy in the order listed.
+
+Fparser2 naturally follows this hierarchy, attempting to match in the
+order specified. This works well apart from one case, which is the
+matching of a Level-2 expression::
+
+    R706 level-2-expr is [[level-2-expr] add_op ] add-operand
+
+The problem is to do with falsely matching an exponent in a
+literal. Take the following example::
+
+    a - 1.0e-1
+
+When searching for a match, the following pattern is a valid candidate
+and will be the candidate used in fparser2 as fparser2 matches from the
+right hand side of a string by default::
+
+    level-2-expr = "a - 1.0e"
+    add-op = "-"
+    add-operand = "1"
+
+As expected, this would fail to match, due to the level-2 expression
+("a - 1.0e") being invalid. However, once R706 failed to match it
+would not be called again as fparser2 follows the rule hierarchy
+mentioned earlier. Therefore fparser2 would fail to match this string.
+
+To solve this problem, fparser2 performs limited tokenisation of a string
+before attempting to perform a match. Amongst other things, this tokenisation
+replaces any numerical constants containing exponents with simple symbols
+(see :ref:`tokenisation` for more details). For the example above this means
+that the code being matched would now look like::
+
+    a - F2PY_REAL_CONSTANT_1_
+
+which is readily matched as a level-2 expression.
+
+Continuous Integration
+----------------------
+
+GitHub Actions are used to run the test suite for a number of different
+Python versions and the coverage reports are uploaded automatically to CodeCov
+(https://codecov.io/gh/stfc/fparser). The configuration for this is in the
+`.github/workflows/unit-tests.yml` file.
+
+In addition, an Action is also used check that all of the code conforms
+to Black (https://black.readthedocs.io) formatting. It is up to the developer
+to ensure that this passes (e.g. by running `black` locally and committing
+the results). Note that it is technically possibly to have the Action
+actually make the changes and commit them but this was found to break
+the Github review process since the automated commit is not permitted to
+trigger further Actions and this then leaves GitHub thinking that the
+various checks have not run.
+
+Automatic Packaging
+-------------------
+
+A GitHub Action (https://github.com/pypa/gh-action-pypi-publish)
+is also used to automate the process of uploading a new
+release of fparser to the Python Package Index (pypi). This action is
+configured in the `.github/workflows/python_publish.yml` file and is
+triggered by the creation of a new release on GitHub.
+
+Test Fixtures
+-------------
+
+Various pytest fixtures
+(https://docs.pytest.org/en/stable/fixture.html) are provided so as to
+aid in the mock-up of a suitable environment in which to run
+tests. These are defined in `two/tests/conftest.py`:
+
+=================== ======================= ===================================
+Name                Returns                 Purpose
+=================== ======================= ===================================
+f2003_create        --                      Sets-up the class hierarchy for the
+                                            Fortran2003 parser.
+f2003_parser        `Fortran2003.Program`   Sets-up the class hierarchy for the
+                                            Fortran2003 parser and returns the
+					    top-level Program object.
+clear_symbol_table  --                      Removes all stored symbol tables.
+fake_symbol_table   --                      Creates a fake scoping region and
+                                            associated symbol table.
+=================== ======================= ===================================
+
+
+Performance Benchmark
+---------------------
+
+The fparser scripts folder contains a benchmarking script to assess the
+performance of the parser by generating a synthetic Fortran file with
+multiple subroutines and the associated subroutine calls. It can be executed
+with the following command::
+
+    ./src/fparser/scripts/fparser2_bench.py
+
```

### Comparing `fparser-0.0.9/doc/fparser.rst` & `fparser-0.1.0/doc/source/fparser.rst`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 .. -*- rest -*-
 
 ..
-    Copyright (c) 2017-2018 Science and Technology Facilities Council.
+    Copyright (c) 2017-2023 Science and Technology Facilities Council.
 
     All rights reserved.
 
     Modifications made as part of the fparser project are distributed
     under the following license:
 
     Redistribution and use in source and binary forms, with or without
@@ -45,17 +45,15 @@
 
 fparser was the original parser provided by the fparser package and
 was implemented to parse Fortran code written in Fortran 66, 70 or 90
 syntax. It is gradually being extended on an as-required basis in
 order to support some of the aspects of more recent versions of
 Fortran (see :ref:`beyond_f90`). In order to use it you will need to
 have installed the fparser package which is available from the Python
-Packagage Index (pypi) or github (https://github.com/stfc/fparser). In
-turn fparser requires the "six" package. When installing using `pip`
-this dependency should be installed automatically for you.
+Packagage Index (pypi) or github (https://github.com/stfc/fparser).
 
 Once installed, you should be able to open the python interpreter and
 try it out, e.g.:
 
 ::
 
   >>> from fparser.api import parse
@@ -98,15 +96,15 @@
               name='foo'
               item=Line('end',(6, 6),'')
 
 As indicated by the above output, the `fparser.api.parse()` function
 returns a `Statement` tree representation of the parsed source code.
 This `parse()` function is actually a convenience method that wraps
 the creation of a reader for Fortran source code (either
-FortranStringReader or FortranFileReader) followed by a call to use
+`FortranStringReader` or `FortranFileReader`) followed by a call to use
 that reader to create the tree, e.g.:
 
 ::
 
   >>> from fparser.common.readfortran import FortranStringReader
   >>> from fparser.one.parsefortran import FortranParser
   >>> reader = FortranStringReader(code, FortranFormat(isfree, isstrict))
@@ -230,14 +228,22 @@
   >>> reader.next()
   Comment('c     constant times a vector plus a vector.\nc     uses unrolled loops for increments equal to one.\nc     jack dongarra, linpack, 3/11/78.\nc     modified 12/3/93, array(1) declarations changed to array(*)',(3, 6))
   >>> reader.next()
   Line('double precision dx(*),dy(*),da',(8, 8),'')
   >>> reader.next()
   Line('integer i,incx,incy,ix,iy,m,mp1,n',(9, 9),'')
 
+Owing to its origins in the f2py project, the reader contains functionality
+to identify the format of the provided source by examining Python-style
+encoding information (c.f. `PEP 263`). Since this is not a part of the Fortran
+standard, this functionality is disabled by default. It can be enabled by
+providing the argument `ignore_encoding=False` to the reader.
+
+.. _PEP 263: https://peps.python.org/pep-0263/
+
 Note that the `FortranReaderBase.next()` method may return `Line`,
 `SyntaxErrorLine`, `Comment`, `MultiLine`, or `SyntaxErrorMultiLine`
 instances.
 
 A `Line` instance has the following attributes:
 
   * `.line` - contains Fortran code line
```

### Comparing `fparser-0.0.9/doc/fparser2.rst` & `fparser-0.1.0/doc/source/fparser2.rst`

 * *Files 23% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-..  Copyright (c) 2017-2019 Science and Technology Facilities Council.
+..  Copyright (c) 2017-2022 Science and Technology Facilities Council.
 
     All rights reserved.
 
     Modifications made as part of the fparser project are distributed
     under the following license:
 
     Redistribution and use in source and binary forms, with or without
@@ -38,47 +38,66 @@
 ========
 
 Fparser2 provides support for parsing Fortran up to and including
 Fortran 2003. This is implemented in the Fortran2003.py `file`__ and
 contains an entirely separate parser to fparser1 that includes rules
 for Fortran 2003 syntax. Support for Fortran 2008 is being added in
 the Fortran2008.py `file`__ which extends the Fortran2003 rules
-appropriately. At this time Fortran2008 support is limited to
-submodules.
+appropriately. At this time fparser2 supports submodules, co-arrays,
+the 'mold' argument to allocate and the 'contiguous' keyword in Fortran2008.
 
 __ https://github.com/stfc/fparser/blob/master/src/fparser/two/Fortran2003.py
 __ https://github.com/stfc/fparser/blob/master/src/fparser/two/Fortran2008.py
 
 
 Getting Going : Script
 ----------------------
 
-fparser2 can be run from the command line by using the `fparser2.py`
-script located in the `scripts` directory. One or more input files can
-be provided. These files are parsed in turn and the parsed Fortran is output
-to the screen (most likely with a different formatting to the input as
+Once installed, fparser2 can be run from the command line by using the
+`fparser2` script. One or more input files can be provided. These
+files are parsed in turn and the parsed Fortran is output to the
+screen (most likely with a different formatting to the input as
 fparser2 does not preserve format), or an appropriate error is output.
 ::
 
-   >>> cat simple.f90
+   > cat simple.f90
    program simple
    end
-   >>> src/fparser/scripts/fparser2.py simple.f90
+   > fparser2 simple.f90
    PROGRAM simple
    END PROGRAM simple
-   >>> cat error.f90
+   > cat error.f90
    prog error
    end
-   >>> src/fparser/scripts/fparser2.py error.f90
+   > fparser2 error.f90
+   File: 'error.f90'
    Syntax error: at line 1
    >>>prog error
 
-   parsing 'src/error.f90' failed at line #1'prog error'
-   started at line #1'prog error'
+fparser2 provides a number of command line options
+::
+
+   > fparser2 -h
+   Usage: fparser2 [options] <Fortran files>
+
+   Description:
+     fparser2 parses Fortran code.
+
+   Options:
+     -h, --help     show this help message and exit
+     --task=TASK    Specify parsing result task. Default: show.
+     --std=STD      Specify the Fortran standard to use. Default: f2003.
+
+The ``--task`` option supports `show` (the default) which outputs the
+parsed code to stdout, `repr` which outputs the fparser2
+representation of its internal parse tree and `none` which outputs
+nothing.
 
+The ``--std`` option chooses the flavour of Fortran to parse. Valid
+options are currently limited to `f2003` (the default) and `f2008`.
 
 Getting Going : Python
 ----------------------
 
 As with the other parser (:ref:`fparser`), the source code to parse
 must be provided via a Fortran reader which is an instance of either
 `FortranFileReader` or `FortranStringReader` (see
@@ -132,14 +151,18 @@
 default. If you wish comments to be retained then you must set
 `ignore_comments=False` when creating the reader. The parse tree
 created by fparser2 will then have `Comment` nodes representing any
 comments found in the code. Nodes representing in-line comments will
 be added immediately following the node representing the code in which
 they were encountered.
 
+Preprocessing directives are retained as `CppDirective` objects by the
+readers and are represented by matching nodes in the parse tree created
+by fparser2. See section `Preprocessing Directives`_ for more details.
+
 Note that empty input, or input that consists of purely white space
 and/or newlines, is not treated as invalid Fortran and an empty parse
 tree is returned. Whilst this is not strictly valid, most compilers
 have this behaviour so we follow their lead.
 
 If the code is invalid Fortran then a `FortranSyntaxError` exception
 will be raised which indicates the offending line of code and its line
@@ -156,35 +179,100 @@
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "fparser/two/Fortran2003.py", line 1300, in __new__
        raise FortranSyntaxError(error)
    fparser.two.Fortran2003.FortranSyntaxError: at line 2
    >>>en
 
-Unsupported Features
---------------------
+Matching Multiple Rules
+-----------------------
+
+There are a number of situations where more than one Fortran rule
+could match some input text. For example, the following text could be
+an array section or a substring::
+
+  a(1:2)
+
+The Fortran specifications deal with such ambiguities by specifying
+constraints. In this case, constraint `C608` in the Fortran2003
+specification states that this text can only be a substring if the
+variable `a` is of type `character`.
+
+At the moment, fparser2 attempts to match rules but does very little
+constraint checking and is implemented such that when there is a
+choice of rules, the first matching rule in the associated internal
+rule-list is returned. This approach is fine for parsing and
+de-parsing code, but it does means that the resultant parse tree might
+not be what would be expected. This problem is therefore passed on to
+any tool that makes use of the parse tree.
+
+For example, the text `a(1:2)` would always match an array section
+(Fortran2003 rule R617) and never a substring (Fortran2003 rule
+R609), even when variable `a` is declared as type `character`. The
+reason for this is that Fortran2003 rule R603 specifies the matching
+of array section before the matching of substring which is how it is
+implemented in fparser2.
+
+In many cases any ambiguity in rule matching can and will be removed
+by adding constraint checking to fparser2 and the first step in
+supporting this is the subject of issue #201.
+
+However, in some situations it is not possible to disambiguate rules
+via constraints by simply parsing a valid Fortran file. As an
+illustration, if we again take the example of the text `a(1:2)` and
+constraint `C608` where we need to determine whether the variable `a`
+is of type `character`, it may be that this variable is brought into
+scope via a `use` statement and so its datatype is unknown without
+finding its declaration in another module.
+
+Fortran compilers deal with this problem by requiring code associated
+with use statements to have already been compiled creating `mod` files
+which contain the required information. It has not yet been
+decided how to deal with this problem in fparser2, but it is likely
+that some on-demand parsing of other files will be used to determine
+appropriate types.
+
+Situations where fparser2 is known to choose the wrong parsing rule
+are given in the following sections.
+
+Array element, array section or substring
++++++++++++++++++++++++++++++++++++++++++
+
+A substring will always be matched as an array element. An array
+section will also be matched as an array element unless the array
+section contains an additional substring range (see Fortran 2003 rule
+R617).
+
+Array or function
++++++++++++++++++
+
+A function will always be matched as an array element unless that
+function is an intrinsic. An array access with the same name as an
+intrinsic function will be matched as an intrinsic function but will
+raise an exception if the number of dimensions of the array does not
+match the number of arguments expected by the intrinsic.
 
-Statement Functions
-+++++++++++++++++++
+Statement function or array assignment
+++++++++++++++++++++++++++++++++++++++
 
 Fparser2 is currently not able to distinguish between statement
 functions and array assignments when one or more array assignment
 statements are the first statements after a declaration section. This
-limitation leads to these particular array assignments being
+limitation would lead to these particular array assignments being
 incorrectly parsed as statement functions.
 
-To avoid this incorrect behaviour, support for statement functions has
+To avoid this behaviour, support for statement functions has
 been temporarily removed from fparser2. However, with this change,
-statement functions will be incorrectly parsed as array assignments
+statement functions will now be incorrectly parsed as array assignments
 when one or more statement function statements are the last statements
 in a declaration section.
 
 Whilst any incorrect behaviour should be avoided, the behaviour of
 this temporary change is considered preferable to the former case, as
-array assigments are more common than statement functions.
+array assignments are more common than statement functions.
 
 Extensions
 ----------
 
 Many compilers support extensions to standard Fortran and codes often
 make use of them. This section documents the extensions to the
 standard that are supported by fparser2.
@@ -366,17 +454,94 @@
 content of ``endprogram.inc`` is ``end program`` then the following
 example would be parsed successfully if the `endprogram.inc` include
 file was found but would fail if the include file was not found::
 
   program x
   include 'endprogram.inc'
 
-Walking the parse tree
+Preprocessing Directives
+------------------------
+
+Preprocessing directives are language constructs that specify how a
+source file should be processed upon compilation or translation.
+They are most commonly used to conditionally include or exclude parts
+of a source file, include other source files in place, or define
+macros for expansion. As part of the compilation process these
+directives are interpreted to produce a preprocessed variant of the
+source file before translating it to the target language (e.g.,
+assembly or machine code). Most compilers have a separate program
+("preprocessor") that is invoked by the compiler to carry out
+preprocessing.
+
+While directives are not specified in any Fortran standard itself,
+Fortran compilers often support preprocessing of Fortran source files
+nonetheless. Consequently, the extent and limitations of this support
+depends on the compiler toolchain used.
+
+fparser2 does not support preprocessing of source files but it allows
+to represent preprocessor directives as dedicated nodes in the parse
+tree.
+
+.. note:: With all preprocessor directives removed the source code
+          must reduce to valid Fortran. This is due to the fact that
+          fparser2 only keeps directives but does not interpret them
+          (thus essentially treats them like comments).
+
+The support for preprocessing directives in fparser2 comprises that
+defined by the `C99 standard`__. Left out are pragma directives as
+those are typically specified in the form of comments in Fortran.
+Preprocessing directives consist of the character `#` as the first
+character in a line (optionally after white space containing no
+new-line characters) followed by the actual directive and is ended
+by a new-line character. Line continuation is specified by a single
+backslash character `\\` at the end of the line.
+
+__ http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf#page=157
+
+The implementation of directives is in the C99Preprocessor.py `file`__
+with support for the following::
+
+  #if ...
+  #ifdef ...
+  #ifndef ...
+  #elif ...
+  #else
+  #endif
+  #include ...
+  #define ...
+  #undef ...
+  #line ...
+  #error
+  #warning
+  #
+
+__ https://github.com/stfc/fparser/blob/master/src/fparser/two/C99Preprocessor.py
+
+
+Walking the Parse Tree
 ----------------------
 
-fparser2 provides two functions to support the traversal of the
-parse tree that it constructs:
+Properties and Methods of Nodes
++++++++++++++++++++++++++++++++
+
+The majority of the nodes in the parse tree produced by fparser2 are
+instances of (sub-classes of) the ``fparser.two.utils.Base``
+class. This class provides the ``parent`` and ``children`` properties
+which return the *immediate* parent/children of a given node.
+		
+In addition to these properties, the ``Base`` class also provides the method:
+
+.. automethod:: fparser.two.utils.Base.get_root
+
+.. note:: The parse tree produced by fparser2 can contain some nodes that are
+	  *not* instances of ``fparser.two.utils.Base`` (e.g. ``None`` or
+	  ``str``). Obviously such nodes do not have the ``parent`` and
+	  ``children`` properties.
 
-.. automethod:: fparser.two.utils.walk_ast
+Utilities
++++++++++
 
-.. automethod:: fparser.two.utils.get_child
+The ``utils`` module of fparser2 provides two utility functions to
+support the traversal of the parse tree that it constructs:
 
+.. autofunction:: fparser.two.utils.walk
+.. autofunction:: fparser.two.utils.get_child
```

### Comparing `fparser-0.0.9/doc/index.rst` & `fparser-0.1.0/doc/source/index.rst`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 ..  fparser documentation master file, created by
     sphinx-quickstart on Mon Feb  6 10:31:52 2017.
     You can adapt this file completely to your liking, but it should at least
     contain the root `toctree` directive.
 
-    Modified work Copyright (c) 2017 Science and Technology Facilities Council
+    Modified work Copyright (c) 2017-2022 Science and Technology Facilities
+    Council.
     Original work Copyright (c) 1999-2008 Pearu Peterson
 
     All rights reserved.
 
     Modifications made as part of the fparser project are distributed
     under the following license:
 
@@ -68,13 +69,15 @@
     DAMAGE.
 
 Welcome to fparser's documentation!
 ===================================
 
 .. toctree::
    :maxdepth: 3
+   :caption: Contents:
 
    license
    introduction
    fparser
    fparser2
    developers_guide
+   reference_guide
```

### Comparing `fparser-0.0.9/doc/introduction.rst` & `fparser-0.1.0/doc/source/introduction.rst`

 * *Files 8% similar despite different names*

```diff
@@ -69,7 +69,10 @@
 
 This code was originally developed by Pearu Peterson as part of the
 f2py project (https://github.com/pearu/f2py). The fparser package is
 used in the PSyclone (https://github.com/stfc/PSyclone) and Habakkuk
 (https://github.com/arporter/habakkuk) tools. If you make use of
 fparser and want your project added to this list, please let the
 developers know.
+
+For a full list of the contributors please see the `CHANGELOG.md`
+file in the root directory.
```

### Comparing `fparser-0.0.9/doc/license.rst` & `fparser-0.1.0/doc/source/license.rst`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 
 .. _license:
 
 License
 =======
 
-| Modified work Copyright (c) 2017-2018 Science and Technology Facilities Council
-| Authors: **Andrew Porter** and **Rupert Ford**, STFC Daresbury Laboratory
+| Modified work Copyright (c) 2017-2021 Science and Technology Facilities Council
+| Authors: **Andrew Porter** and **Rupert Ford**, STFC Daresbury Laboratory, and
+|          **Balthasar Reuter**, ECMWF
 | Original work Copyright (c) 1999-2008 **Pearu Peterson**
 | All rights reserved.
 
 Modifications made as part of the fparser project are distributed
 under the following (3-part BSD) license:
 
 Redistribution and use in source and binary forms, with or without
```

### Comparing `fparser-0.0.9/setup.py` & `fparser-0.1.0/src/fparser/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,9 @@
-#!/usr/bin/env python
-
-# Modified work Copyright (c) 2017-2018 Science and Technology
-# Facilities Council.
-# Original work Copyright (c) 1999-2008 Pearu Peterson.
+# Copyright (c) 2017-2023 Science and Technology Facilities Council.
+# Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
 # Redistribution and use in source and binary forms, with or without
@@ -61,71 +58,58 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-"""Setup script. Used by easy_install and pip."""
+# First version by: Pearu Peterson <pearu@cens.ioc.ee>
+# First created: Oct 2006
+
+try:
+    from importlib.metadata import PackageNotFoundError
+    from importlib import metadata
+except ImportError:
+    # Use backport package for python <3.8
+    from importlib_metadata import PackageNotFoundError
+    import importlib_metadata as metadata
+
+import logging
+import codecs
+
+
+def _get_version():
+    """
+    :returns: the version of this package.
+    :rtype: str
+    """
+    try:
+        return metadata.version(__name__)
+    except PackageNotFoundError:
+        # Package is not installed.
+        from setuptools_scm import get_version
+
+        return get_version(root="../..", relative_to=__file__)
+
+
+__version__ = _get_version()
+
+logging.getLogger(__name__).addHandler(logging.NullHandler())
+
+
+def log_decode_error_handler(err):
+    """
+    A custom error handler for use when reading files. Removes any
+    characters that cause decoding errors and logs the error.
+
+    :returns: 2-tuple containing replacement for bad chars (an empty string \
+              and the position from where encoding should continue.
+    :rtype: Tuple[str, int]
 
-from setuptools import setup, find_packages
+    """
+    message = f"character in input file. Error returned was {str(err)}."
+    # Log the fact that this character will be removed from the input file
+    logging.getLogger(__name__).warning("Skipped bad %s", message)
+    return ("", err.end)
 
-PACKAGES = find_packages(where="src")
 
-NAME = 'fparser'
-AUTHOR = 'Andrew Porter'
-AUTHOR_EMAIL = 'trackstand.andy@gmail.com'
-URL = 'https://github.com/stfc/fparser'
-DOWNLOAD_URL = 'https://github.com/stfc/fparser'
-DESCRIPTION = 'The fparser Project'
-LONG_DESCRIPTION = '''\
-The fparser project is created to develop a parser for
-Fortran 77..2008 code. It is based on the work of Pearu Peterson in
-the F2PY project (http://www.f2py.com).
-
-See https://github.com/stfc/fparser for more information.
-'''
-LICENSE = 'OSI Approved :: BSD 3-Clause License'
-
-CLASSIFIERS = [
-    'Development Status :: 3 - Alpha',
-    'Environment :: Console',
-    'Intended Audience :: Developers',
-    'Intended Audience :: Science/Research',
-    'Natural Language :: English',
-    'Programming Language :: Fortran',
-    'Programming Language :: Python',
-    'Topic :: Scientific/Engineering',
-    'Topic :: Software Development',
-    'Topic :: Utilities',
-    'Operating System :: POSIX',
-    'Operating System :: Unix',
-    'Operating System :: MacOS']
-
-MAJOR = 0
-MINOR = 0
-MICRO = 9
-VERSION = '%d.%d.%d' % (MAJOR, MINOR, MICRO)
-
-if __name__ == '__main__':
-
-    setup(
-        name=NAME,
-        version=VERSION,
-        author=AUTHOR,
-        author_email=(AUTHOR_EMAIL),
-        license=LICENSE,
-        url=URL,
-        description=DESCRIPTION,
-        long_description=LONG_DESCRIPTION,
-        classifiers=CLASSIFIERS,
-        packages=PACKAGES,
-        package_dir={"": "src"},
-        install_requires=['six'],
-        entry_points={
-            'console_scripts': [
-                'fparser2=fparser.scripts.fparser2:main',
-            ],
-        },
-        # We need the following line to ensure we get the fparser/log.config
-        # file installed.
-        include_package_data=True)
+codecs.register_error("fparser-logging", log_decode_error_handler)
```

### Comparing `fparser-0.0.9/src/fparser/__init__.py` & `fparser-0.1.0/setup.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,12 @@
-# Copyright (c) 2017 Science and Technology Facilities Council
-# Original work Copyright (c) 1999-2008 Pearu Peterson
+#!/usr/bin/env python
+
+# Modified work Copyright (c) 2017-2023 Science and Technology
+# Facilities Council.
+# Original work Copyright (c) 1999-2008 Pearu Peterson.
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
 # Redistribution and use in source and binary forms, with or without
@@ -58,14 +61,14 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-# First version by: Pearu Peterson <pearu@cens.ioc.ee>
-# First created: Oct 2006
-
-import logging
+"""Setup script. Used by easy_install and pip. This is now just a stub
+which ensures that 'python setup.py' still works. All configuration is done
+in setup.cfg."""
 
+from setuptools import setup
 
-logging.getLogger(__name__).addHandler(logging.NullHandler())
+setup()
```

### Comparing `fparser-0.0.9/src/fparser/api.py` & `fparser-0.1.0/src/fparser/api.py`

 * *Files 4% similar despite different names*

```diff
@@ -68,25 +68,30 @@
 Module content
 --------------
 """
 # Author: Pearu Peterson <pearu@cens.ioc.ee>
 # Created: Oct 2006
 
 
-from six import string_types
 # import all Statement classes:
 from fparser.common.base_classes import classes
 from fparser.common.utils import AnalyzeError
 
-__autodoc__ = ['get_reader', 'parse', 'walk']
+__autodoc__ = ["get_reader", "parse", "walk"]
 
 
-def get_reader(source, isfree=None, isstrict=None, include_dirs=None,
-               source_only=None, ignore_comments=True):
-    '''
+def get_reader(
+    source,
+    isfree=None,
+    isstrict=None,
+    include_dirs=None,
+    source_only=None,
+    ignore_comments=True,
+):
+    """
     Returns Fortran reader instance.
 
     If ``source`` is a C filename then the functions searches for comment
     lines starting with ``/*f2py`` and reads following lines as PYF file
     content until a line ``*/`` is found.
 
     :param str source: Specify a string or filename containing Fortran code.
@@ -100,60 +105,71 @@
                              searched when the ``USE`` statement is
                              encountered.
     :param bool ignore_comments: Whether or not to ignore (and discard)
                                  comments when parsing the source.
 
     :returns: a reader instance
     :rtype: :py:class:`fparser.common.readfortran.FortranReader`
-    '''
+    """
     import os
     import re
-    from fparser.common.readfortran import FortranFileReader, \
-        FortranStringReader
+    from fparser.common.readfortran import FortranFileReader, FortranStringReader
     from fparser.common.sourceinfo import FortranFormat
 
     if os.path.isfile(source):
         _name, ext = os.path.splitext(source)
-        if ext.lower() in ['.c']:
+        if ext.lower() in [".c"]:
             # get signatures from C file comments starting with
             # `/*f2py` and ending with `*/`.
             # TODO: improve parser to take line number offset making line
             #       numbers in parser messages correct.
-            f2py_c_comments = re.compile(r'/[*]\s*f2py\s.*[*]/', re.I | re.M)
-            handle = open(source, 'r')
-            c_input = ''
+            f2py_c_comments = re.compile(r"/[*]\s*f2py\s.*[*]/", re.I | re.M)
+            handle = open(source, "r")
+            c_input = ""
             for line in f2py_c_comments.findall(handle.read()):
-                c_input += line[2:-2].lstrip()[4:] + '\n'
+                c_input += line[2:-2].lstrip()[4:] + "\n"
             handle.close()
             if isfree is None:
                 isfree = True
             if isstrict is None:
                 isstrict = True
             return parse(c_input, isfree, isstrict, include_dirs)
-        reader = FortranFileReader(source, include_dirs=include_dirs,
-                                   source_only=source_only,
-                                   ignore_comments=ignore_comments)
-    elif isinstance(source, string_types):
-        reader = FortranStringReader(source, include_dirs=include_dirs,
-                                     source_only=source_only,
-                                     ignore_comments=ignore_comments)
+        reader = FortranFileReader(
+            source,
+            include_dirs=include_dirs,
+            source_only=source_only,
+            ignore_comments=ignore_comments,
+        )
+    elif isinstance(source, str):
+        reader = FortranStringReader(
+            source,
+            include_dirs=include_dirs,
+            source_only=source_only,
+            ignore_comments=ignore_comments,
+        )
     else:
-        raise TypeError('Expected string or filename input but got %s' %
-                        (type(input)))
+        raise TypeError("Expected string or filename input but got %s" % (type(input)))
     if isfree is None:
         isfree = reader.format.is_free
     if isstrict is None:
         isstrict = reader.format.is_strict
     reader.set_format(FortranFormat(isfree, isstrict))
     return reader
 
 
-def parse(source, isfree=None, isstrict=None, include_dirs=None,
-          source_only=None, ignore_comments=True, analyze=True,
-          clear_cache=True):
+def parse(
+    source,
+    isfree=None,
+    isstrict=None,
+    include_dirs=None,
+    source_only=None,
+    ignore_comments=True,
+    analyze=True,
+    clear_cache=True,
+):
     """
     Parse input and return Statement tree. Raises an AnalyzeError if the
     parser can not parse the Fortran code.
 
     :param str source: Specify a string or filename containing Fortran code.
     :param bool isfree: Whether the Fortran source is free-format.
     :param bool isstrict: Whether we are to strictly enforce the `isfree`
@@ -178,29 +194,35 @@
     """
     from fparser.one.parsefortran import FortranParser
 
     if clear_cache:
         # Wipe the parser cache if requested
         FortranParser.cache.clear()
 
-    reader = get_reader(source, isfree, isstrict, include_dirs, source_only,
-                        ignore_comments=ignore_comments)
+    reader = get_reader(
+        source,
+        isfree,
+        isstrict,
+        include_dirs,
+        source_only,
+        ignore_comments=ignore_comments,
+    )
     parser = FortranParser(reader, ignore_comments=ignore_comments)
     try:
         parser.parse()
     except AnalyzeError:
         raise
     if analyze:
         parser.analyze()
 
     return parser.block
 
 
 def walk(stmt, depth=-1, _initial_depth=None):
-    """ Generate Fortran statements by walking the stmt tree until given depth.
+    """Generate Fortran statements by walking the stmt tree until given depth.
 
     For each block statement in stmt, the walk functions yields a
     tuple ``(statement, depth)`` where ``depth`` is the depth of tree
     stucture for statement.
 
     Parameters
     ----------
@@ -252,12 +274,13 @@
         last_index = len(stmt.content)
         if isinstance(last_stmt, classes.EndStatement):
             last_index -= 1
         else:
             last_stmt = None
         if depth != 0:
             for substmt in stmt.content[:last_index]:
-                for statement, statement_depth in walk(substmt, depth-1,
-                                                       _initial_depth):
+                for statement, statement_depth in walk(
+                    substmt, depth - 1, _initial_depth
+                ):
                     yield statement, statement_depth
         if last_stmt is not None:
             yield last_stmt, _initial_depth - depth
```

### Comparing `fparser-0.0.9/src/fparser/common/base_classes.py` & `fparser-0.1.0/src/fparser/common/base_classes.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 # -*- coding: utf-8 -*-
-# Modified work Copyright (c) 2017-2019 Science and Technology
+# Modified work Copyright (c) 2017-2022 Science and Technology
 # Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
@@ -64,126 +64,124 @@
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 """
 Base classes for all Fortran statement types
 """
 
-__all__ = ['Statement', 'BeginStatement', 'EndStatement', 'Variable',
-           'AttributeHolder', 'ProgramBlock']
+__all__ = [
+    "Statement",
+    "BeginStatement",
+    "EndStatement",
+    "Variable",
+    "AttributeHolder",
+    "ProgramBlock",
+]
 
 import copy
 import logging
 
-from six import with_metaclass
 from fparser.common.readfortran import Line, Comment
-from fparser.common.utils import split_comma,       \
-                                 specs_split_comma, \
-                                 is_int_literal_constant
+from fparser.common.utils import split_comma, specs_split_comma, is_int_literal_constant
 from fparser.common.utils import classes, AnalyzeError
 
 
-class AttributeHolder(object):
+class AttributeHolder:
     # copied from symbolic.base module
     """
     Defines a object with predefined attributes. Only those attributes
     are allowed that are specified as keyword arguments of a constructor.
     When an argument is callable then the corresponding attribute will
     be read-only and set by the value the callable object returns.
     """
+
     def __init__(self, **kws):
         self._attributes = {}
         self._readonly = []
         for k, v in list(kws.items()):
             self._attributes[k] = v
             if callable(v):
                 self._readonly.append(k)
-        return
 
     def __getattr__(self, name):
         if name not in self._attributes:
-            message = '%s instance has no attribute %r, '\
-                      + 'expected attributes: %s'
-            attributes = ', '.join(list(self._attributes.keys()))
-            raise AttributeError(message % (self.__class__.__name__,
-                                            name,
-                                            attributes))
+            message = "%s instance has no attribute %r, " + "expected attributes: %s"
+            attributes = ", ".join(list(self._attributes.keys()))
+            raise AttributeError(message % (self.__class__.__name__, name, attributes))
         value = self._attributes[name]
         if callable(value):
             value = value()
             self._attributes[name] = value
         return value
 
     def __setattr__(self, name, value):
-        if name in ['_attributes', '_readonly']:
+        if name in ["_attributes", "_readonly"]:
             self.__dict__[name] = value
             return
         if name in self._readonly:
-            message = '%s instance attribute %r is readonly'
+            message = "%s instance attribute %r is readonly"
             raise AttributeError(message % (self.__class__.__name__, name))
         if name not in self._attributes:
-            message = '%s instance has no attribute %r, ' \
-                      + 'expected attributes: %s'
-            attributes = ','.join(list(self._attributes.keys()))
-            raise AttributeError(message % (self.__class__.__name__,
-                                            name,
-                                            attributes))
+            message = "%s instance has no attribute %r, " + "expected attributes: %s"
+            attributes = ",".join(list(self._attributes.keys()))
+            raise AttributeError(message % (self.__class__.__name__, name, attributes))
         self._attributes[name] = value
 
     def isempty(self):
         for k in list(self._attributes.keys()):
             v = getattr(self, k)
             if v:
                 return False
         return True
 
     def __repr__(self):
         return self.torepr()
 
-    def torepr(self, depth=-1, tab=''):
+    def torepr(self, depth=-1, tab=""):
         if depth == 0:
             return tab + self.__class__.__name__
-        lines = [self.__class__.__name__+':']
-        ttab = tab + '    '
+        lines = [self.__class__.__name__ + ":"]
+        ttab = tab + "    "
         for k in list(self._attributes.keys()):
             v = getattr(self, k)
             if v:
                 if isinstance(v, list):
-                    lines.append(ttab + '%s=<%s-list>' % (k, len(v)))
+                    lines.append(ttab + "%s=<%s-list>" % (k, len(v)))
                 elif isinstance(v, dict):
-                    lines.append(ttab + '%s=<dict with keys %s>'
-                                 % (k, list(v.keys())))
+                    lines.append(ttab + "%s=<dict with keys %s>" % (k, list(v.keys())))
                 else:
-                    lines.append(ttab + '%s=<%s>' % (k, type(v)))
-        return '\n'.join(lines)
+                    lines.append(ttab + "%s=<%s>" % (k, type(v)))
+        return "\n".join(lines)
 
     def todict(self):
         d = {}
         for k in list(self._attributes.keys()):
             v = getattr(self, k)
             d[k] = v
         return d
 
 
 def get_base_classes(cls):
     bases = ()
     for c in cls.__bases__:
         bases += get_base_classes(c)
-    return bases + cls.__bases__ + (cls, )
+    return bases + cls.__bases__ + (cls,)
 
 
-class Variable(object, with_metaclass(classes)):
+class Variable(metaclass=classes):
     """
-    Variable instance has attributes:
-      name
-      typedecl
-      dimension
-      attributes
-      intent
-      parent - Statement instances defining the variable
+    Variable instance has attributes::
+
+        name
+        typedecl
+        dimension
+        attributes
+        intent
+        parent - Statement instances defining the variable
+
     """
 
     def __init__(self, parent, name):
         self.parent = parent
         self.parents = [parent]
         self.name = name
         self.typedecl = None
@@ -196,306 +194,338 @@
         self.check = []
         self.init = None
 
         # after calling analyze the following additional attributes are set:
         # .is_array:
         #    rank
         #    shape
-        return
 
     def __repr__(self):
         line = []
-        for a in ['name', 'typedecl', 'dimension', 'bounds', 'length',
-                  'attributes', 'intent', 'bind', 'check', 'init']:
+        for a in [
+            "name",
+            "typedecl",
+            "dimension",
+            "bounds",
+            "length",
+            "attributes",
+            "intent",
+            "bind",
+            "check",
+            "init",
+        ]:
             v = getattr(self, a)
             if v:
-                line.append('%s=%r' % (a, v))
-        return 'Variable: ' + ', '.join(line)
+                line.append("%s=%r" % (a, v))
+        return "Variable: " + ", ".join(line)
 
     def get_typedecl(self):
         if self.typedecl is None:
             self.set_type(self.parent.get_type(self.name))
         return self.typedecl
 
     def add_parent(self, parent):
         if id(parent) not in list(map(id, self.parents)):
             self.parents.append(parent)
         self.parent = parent
-        return
 
     def set_type(self, typedecl):
         if self.typedecl is not None:
             if not self.typedecl == typedecl:
                 self.parent.warning(
-                    'variable %r already has type %s, '
-                    'resetting to %s'
-                    % (self.name, self.typedecl.tostr(), typedecl.tostr()))
+                    "variable %r already has type %s, "
+                    "resetting to %s"
+                    % (self.name, self.typedecl.tostr(), typedecl.tostr())
+                )
         assert typedecl is not None
         self.typedecl = typedecl
-        return
 
     def set_init(self, expr):
         if self.init is not None:
             if not self.init == expr:
                 self.parent.warning(
-                    'variable %r already has initialization %r, '
-                    'resetting to %r' % (self.name, self.expr, expr))
+                    "variable %r already has initialization %r, "
+                    "resetting to %r" % (self.name, self.expr, expr)
+                )
         self.init = expr
-        return
 
     def set_dimension(self, dims):
-        import six
-        dims = [tuple(dim.split(':')) for dim in dims]
-        dims = [tuple(map(six.text_type.strip, dim)) for dim in dims]
+        dims = [tuple(dim.split(":")) for dim in dims]
+        dims = [tuple(map(str.strip, dim)) for dim in dims]
         if self.dimension is not None:
             if not self.dimension == dims:
                 self.parent.warning(
-                    'variable %r already has dimension %r, '
-                    'resetting to %r' % (self.name, self.dimension, dims))
+                    "variable %r already has dimension %r, "
+                    "resetting to %r" % (self.name, self.dimension, dims)
+                )
         self.dimension = dims
-        return
 
     def set_bounds(self, bounds):
         if self.bounds is not None:
             if not self.bounds == bounds:
                 self.parent.warning(
-                    'variable %r already has bounds %r, '
-                    'resetting to %r' % (self.name, self.bounds, bounds))
+                    "variable %r already has bounds %r, "
+                    "resetting to %r" % (self.name, self.bounds, bounds)
+                )
         self.bounds = bounds
-        return
 
     def set_length(self, length):
         if self.length is not None:
             if not self.length == length:
                 self.parent.warning(
-                    'variable %r already has length %r, '
-                    'resetting to %r' % (self.name, self.length, length))
+                    "variable %r already has length %r, "
+                    "resetting to %r" % (self.name, self.length, length)
+                )
         self.length = length
-        return
 
-    known_intent_specs = ['IN', 'OUT', 'INOUT', 'CACHE', 'HIDE', 'COPY',
-                          'OVERWRITE', 'CALLBACK', 'AUX', 'C', 'INPLACE',
-                          'OUT=']
+    known_intent_specs = [
+        "IN",
+        "OUT",
+        "INOUT",
+        "CACHE",
+        "HIDE",
+        "COPY",
+        "OVERWRITE",
+        "CALLBACK",
+        "AUX",
+        "C",
+        "INPLACE",
+        "OUT=",
+    ]
 
     def set_intent(self, intent):
         if self.intent is None:
             self.intent = []
         for i in intent:
             if i not in self.intent:
                 if i not in self.known_intent_specs:
-                    self.parent.warning('unknown intent-spec %r for %r'
-                                        % (i, self.name))
+                    self.parent.warning(
+                        "unknown intent-spec %r for %r" % (i, self.name)
+                    )
                 self.intent.append(i)
-        return
 
-    known_attributes = ['PUBLIC', 'PRIVATE', 'ALLOCATABLE', 'ASYNCHRONOUS',
-                        'EXTERNAL', 'INTRINSIC', 'OPTIONAL', 'PARAMETER',
-                        'POINTER', 'PROTECTED', 'SAVE', 'TARGET', 'VALUE',
-                        'VOLATILE', 'REQUIRED']
+    known_attributes = [
+        "PUBLIC",
+        "PRIVATE",
+        "ALLOCATABLE",
+        "ASYNCHRONOUS",
+        "EXTERNAL",
+        "INTRINSIC",
+        "OPTIONAL",
+        "PARAMETER",
+        "POINTER",
+        "PROTECTED",
+        "SAVE",
+        "TARGET",
+        "VALUE",
+        "VOLATILE",
+        "REQUIRED",
+    ]
 
     def is_intent_in(self):
         # TODO Something hinky is going on here. self.intent is a list which
         #      doesn't make a lot of sense. How can a variable have more
         #      than one intent?
         # TODO Furthermore if no intent is specified the assumed intent is
         #      "inout". Below an explicit "inout" returns False but a None
         #      returns True.
         if not self.intent:
             return True
-        if 'HIDE' in self.intent:
+        if "HIDE" in self.intent:
             return False
-        if 'INPLACE' in self.intent:
+        if "INPLACE" in self.intent:
             return False
-        if 'IN' in self.intent:
+        if "IN" in self.intent:
             return True
-        if 'OUT' in self.intent:
+        if "OUT" in self.intent:
             return False
-        if 'INOUT' in self.intent:
+        if "INOUT" in self.intent:
             return False
-        if 'OUTIN' in self.intent:
+        if "OUTIN" in self.intent:
             return False
         return True
 
     def is_intent_inout(self):
         if not self.intent:
             return False
-        if 'INOUT' in self.intent:
-            if 'IN' in self.intent \
-               or 'HIDE' in self.intent \
-               or 'INPLACE' in self.intent:
-                message = 'INOUT ignored in INPUT(%s)'
-                self.warning(message % (', '.join(self.intent)))
+        if "INOUT" in self.intent:
+            if "IN" in self.intent or "HIDE" in self.intent or "INPLACE" in self.intent:
+                message = "INOUT ignored in INPUT(%s)"
+                self.warning(message % (", ".join(self.intent)))
                 return False
             return True
         return False
 
     def is_intent_hide(self):
         if not self.intent:
             return False
-        if 'HIDE' in self.intent:
+        if "HIDE" in self.intent:
             return True
-        if 'OUT' in self.intent:
-            return 'IN' not in self.intent \
-                   and 'INPLACE' not in self.intent \
-                   and 'INOUT' not in self.intent
+        if "OUT" in self.intent:
+            return (
+                "IN" not in self.intent
+                and "INPLACE" not in self.intent
+                and "INOUT" not in self.intent
+            )
         return False
 
     def is_intent_inplace(self):
-        return self.intent and 'INPLACE' in self.intent
+        return self.intent and "INPLACE" in self.intent
 
     def is_intent_out(self):
-        return self.intent and 'OUT' in self.intent
+        return self.intent and "OUT" in self.intent
 
     def is_intent_c(self):
-        return self.intent and 'C' in self.intent
+        return self.intent and "C" in self.intent
 
     def is_intent_cache(self):
-        return self.intent and 'CACHE' in self.intent
+        return self.intent and "CACHE" in self.intent
 
     def is_intent_copy(self):
-        return self.intent and 'COPY' in self.intent
+        return self.intent and "COPY" in self.intent
 
     def is_intent_overwrite(self):
-        return self.intent and 'OVERWRITE' in self.intent
+        return self.intent and "OVERWRITE" in self.intent
 
     def is_intent_callback(self):
-        return self.intent and 'CALLBACK' in self.intent
+        return self.intent and "CALLBACK" in self.intent
 
     def is_intent_aux(self):
-        return self.intent and 'AUX' in self.intent
+        return self.intent and "AUX" in self.intent
 
     def is_private(self):
-        if 'PUBLIC' in self.attributes:
+        if "PUBLIC" in self.attributes:
             return False
-        if 'PRIVATE' in self.attributes:
+        if "PRIVATE" in self.attributes:
             return True
         return self.parent.parent.check_private(self.name)
 
     def is_public(self):
         return not self.is_private()
 
     def is_allocatable(self):
-        return 'ALLOCATABLE' in self.attributes
+        return "ALLOCATABLE" in self.attributes
 
     def is_external(self):
-        return 'EXTERNAL' in self.attributes
+        return "EXTERNAL" in self.attributes
 
     def is_intrinsic(self):
-        return 'INTRINSIC' in self.attributes
+        return "INTRINSIC" in self.attributes
 
     def is_parameter(self):
-        return 'PARAMETER' in self.attributes
+        return "PARAMETER" in self.attributes
 
     def is_optional(self):
-        return 'OPTIONAL' in self.attributes \
-               and 'REQUIRED' not in self.attributes \
-               and not self.is_intent_hide()
+        return (
+            "OPTIONAL" in self.attributes
+            and "REQUIRED" not in self.attributes
+            and not self.is_intent_hide()
+        )
 
     def is_required(self):
         return self.is_optional() and not self.is_intent_hide()
 
     def is_pointer(self):
-        return 'POINTER' in self.attributes
+        return "POINTER" in self.attributes
 
     def is_array(self):
         return not not (self.bounds or self.dimension)
 
     def is_scalar(self):
         return not self.is_array()
 
     def update(self, *attrs):
         attributes = self.attributes
         if len(attrs) == 1 and isinstance(attrs[0], (tuple, list)):
             attrs = attrs[0]
         for attr in attrs:
             lattr = attr.lower()
             uattr = attr.upper()
-            if lattr.startswith('dimension'):
+            if lattr.startswith("dimension"):
                 assert self.dimension is None, repr((self.dimension, attr))
                 line = attr[9:].lstrip()
-                assert line[0] + line[-1] == '()', repr(line)
-                self.set_dimension(
-                        split_comma(line[1:-1].strip(), self.parent.item))
+                assert line[0] + line[-1] == "()", repr(line)
+                self.set_dimension(split_comma(line[1:-1].strip(), self.parent.item))
                 continue
-            if lattr.startswith('intent'):
+            if lattr.startswith("intent"):
                 line = attr[6:].lstrip()
-                assert line[0] + line[-1] == '()', repr(line)
-                self.set_intent(specs_split_comma(line[1:-1].strip(),
-                                                  self.parent.item,
-                                                  upper=True))
+                assert line[0] + line[-1] == "()", repr(line)
+                self.set_intent(
+                    specs_split_comma(line[1:-1].strip(), self.parent.item, upper=True)
+                )
                 continue
-            if lattr.startswith('bind'):
+            if lattr.startswith("bind"):
                 line = attr[4:].lstrip()
-                assert line[0] + line[-1] == '()', repr(line)
-                self.bind = specs_split_comma(line[1:-1].strip(),
-                                              self.parent.item,
-                                              upper=True)
+                assert line[0] + line[-1] == "()", repr(line)
+                self.bind = specs_split_comma(
+                    line[1:-1].strip(), self.parent.item, upper=True
+                )
                 continue
-            if lattr.startswith('check'):
+            if lattr.startswith("check"):
                 line = attr[5:].lstrip()
-                assert line[0] + line[-1] == '()', repr(line)
-                self.check.extend(split_comma(line[1:-1].strip(),
-                                              self.parent.item))
+                assert line[0] + line[-1] == "()", repr(line)
+                self.check.extend(split_comma(line[1:-1].strip(), self.parent.item))
                 continue
             if uattr not in attributes:
                 if uattr not in self.known_attributes:
-                    self.parent.warning('unknown attribute %r' % (attr))
+                    self.parent.warning("unknown attribute %r" % (attr))
                 attributes.append(uattr)
-        return
 
     def __str__(self):
-        s = ''
+        s = ""
         typedecl = self.get_typedecl()
         if typedecl is not None:
-            s += typedecl.tostr() + ' '
+            s += typedecl.tostr() + " "
         a = self.attributes[:]
         if self.dimension is not None:
-            dimensions = [':'.join(spec) for spec in self.dimension]
-            a.append('DIMENSION(%s)' % (', '.join(dimensions)))
+            dimensions = [":".join(spec) for spec in self.dimension]
+            a.append("DIMENSION(%s)" % (", ".join(dimensions)))
         if self.intent is not None:
-            a.append('INTENT(%s)' % (', '.join(self.intent)))
+            a.append("INTENT(%s)" % (", ".join(self.intent)))
         if self.bind:
-            a.append('BIND(%s)' % (', '.join(self.bind)))
+            a.append("BIND(%s)" % (", ".join(self.bind)))
         if self.check:
-            a.append('CHECK(%s)' % (', '.join(self.check)))
+            a.append("CHECK(%s)" % (", ".join(self.check)))
         if a:
-            s += ', ' + ', '.join(a) + ' :: '
+            s += ", " + ", ".join(a) + " :: "
         s += self.name
         if self.bounds:
-            s += '(%s)' % (', '.join([':'.join(spec) for spec in self.bounds]))
+            s += "(%s)" % (", ".join([":".join(spec) for spec in self.bounds]))
         if self.length:
             if is_int_literal_constant(self.length):
-                s += '*%s' % (self.length)
+                s += "*%s" % (self.length)
             else:
-                s += '*(%s)' % (self.length)
+                s += "*(%s)" % (self.length)
         if self.init:
-            s += ' = ' + self.init
+            s += " = " + self.init
         return s
 
     def get_array_spec(self):
-        assert self.is_array(), 'array_spec is available only for arrays'
+        assert self.is_array(), "array_spec is available only for arrays"
         if self.bounds:
             if self.dimension:
-                message = 'both bounds=%r and dimension=%r are defined, ' \
-                          + 'ignoring dimension.'
+                message = (
+                    "both bounds=%r and dimension=%r are defined, "
+                    + "ignoring dimension."
+                )
                 self.parent.warning(message % (self.bounds, self.dimension))
             array_spec = self.bounds
         else:
             array_spec = self.dimension
         return array_spec
 
     def is_deferred_shape_array(self):
         if not self.is_array():
             return False
         return self.is_allocatable() or self.is_pointer()
 
     def is_assumed_size_array(self):
         if not self.is_array():
             return False
-        return self.get_array_spec()[-1][-1] == '*'
+        return self.get_array_spec()[-1][-1] == "*"
 
     def is_assumed_shape_array(self):
         if not self.is_array():
             return False
         if self.is_deferred_shape_array():
             return False
         for spec in self.get_array_spec():
@@ -505,15 +535,15 @@
 
     def is_explicit_shape_array(self):
         if not self.is_array():
             return False
         if self.is_deferred_shape_array():
             return False
         for spec in self.get_array_spec():
-            if not spec[-1] or spec[-1] == '*':
+            if not spec[-1] or spec[-1] == "*":
                 return False
         return True
 
     def is_allocatable_array(self):
         return self.is_array() and self.is_allocatable()
 
     def is_array_pointer(self):
@@ -526,304 +556,301 @@
             self.rank = len(array_spec)
             if self.is_deferred_shape_array():  # a(:, :)
                 pass
             elif self.is_explicit_shape_array():
                 shape = []
                 for spec in array_spec:
                     if len(spec) == 1:
-                        shape.append(spec[0].replace(' ', ''))
+                        shape.append(spec[0].replace(" ", ""))
                     else:
                         try:
                             # lower subscript
-                            lss = int(spec[0].replace(' ', ''))
+                            lss = int(spec[0].replace(" ", ""))
                             # upper subscript
-                            uss = int(spec[1].replace(' ', ''))
+                            uss = int(spec[1].replace(" ", ""))
                             n = uss - (lss - 1)
                         except ValueError:
-                            n = '(%s)-(%s)' % (spec[1], spec[0])
+                            n = "(%s)-(%s)" % (spec[1], spec[0])
                         shape.append(str(n))
                 self.shape = shape
-        return
 
     def error(self, message):
         return self.parent.error(message)
 
     def warning(self, message):
         return self.parent.warning(message)
 
     def info(self, message):
         return self.parent.info(message)
 
 
-class ProgramBlock(object, with_metaclass(classes)):
+class ProgramBlock(metaclass=classes):
     pass
 
 
-class Statement(object, with_metaclass(classes)):
+class Statement(metaclass=classes):
     """
-    Statement instance has attributes:
-      parent  - Parent BeginStatement or FortranParser instance
-      item    - Line instance containing the statement line
-      isvalid - boolean, when False, the Statement instance will be ignored
+    Statement instance has attributes::
+
+        parent  - Parent BeginStatement or FortranParser instance
+        item    - Line instance containing the statement line
+        isvalid - boolean, when False, the Statement instance will be ignored
+
     """
 
-    modes = ['free', 'fix', 'f77', 'pyf']
+    modes = ["free", "fix", "f77", "pyf"]
     _repr_attr_names = []
 
     def __init__(self, parent, item):
         self.parent = parent
         if item is not None:
             self.reader = item.reader
         else:
             self.reader = parent.reader
-        self.top = getattr(parent, 'top', None)  # the top of statement tree
+        self.top = getattr(parent, "top", None)  # the top of statement tree
         self.item = item
 
         if isinstance(parent, ProgramBlock):
             self.programblock = parent
         elif isinstance(self, ProgramBlock):
             self.programblock = self
-        elif hasattr(parent, 'programblock'):
+        elif hasattr(parent, "programblock"):
             self.programblock = parent.programblock
         else:
             pass
 
         # When a statement instance is constructed by error, set isvalid to
         # False
         self.isvalid = True
         # when a statement should be ignored, set ignore to True
         self.ignore = False
 
         # attribute a will hold analyze information.
         a_dict = {}
         for cls in get_base_classes(self.__class__):
-            if hasattr(cls, 'a'):
+            if hasattr(cls, "a"):
                 a_dict.update(copy.deepcopy(cls.a.todict()))
         self.a = AttributeHolder(**a_dict)
-        if hasattr(self.__class__, 'a'):
+        if hasattr(self.__class__, "a"):
             assert self.a is not self.__class__.a
 
         self.process_item()
 
-        return
-
     def __repr__(self):
         return self.torepr()
 
-    def torepr(self, depth=-1, incrtab=''):
+    def torepr(self, depth=-1, incrtab=""):
         tab = incrtab + self.get_indent_tab()
         clsname = self.__class__.__name__
         lines = [tab + clsname]
         if depth == 0:
-            return '\n'.join(lines)
-        ttab = tab + '  '
+            return "\n".join(lines)
+        ttab = tab + "  "
         for n in self._repr_attr_names:
             attr = getattr(self, n, None)
             if not attr:
                 continue
-            if hasattr(attr, 'torepr'):
-                r = attr.torepr(depth-1, incrtab)
+            if hasattr(attr, "torepr"):
+                r = attr.torepr(depth - 1, incrtab)
             else:
                 r = repr(attr)
-            lines.append(ttab + '%s=%s' % (n, r))
+            lines.append(ttab + "%s=%s" % (n, r))
         if self.item is not None:
-            lines.append(ttab + 'item=%r' % (self.item))
+            lines.append(ttab + "item=%r" % (self.item))
         if not self.isvalid:
-            lines.append(ttab + 'isvalid=%r' % (self.isvalid))
+            lines.append(ttab + "isvalid=%r" % (self.isvalid))
         if self.ignore:
-            lines.append(ttab + 'ignore=%r' % (self.ignore))
+            lines.append(ttab + "ignore=%r" % (self.ignore))
         if not self.a.isempty():
-            lines.append(ttab
-                         + 'a='
-                         + self.a.torepr(depth-1, incrtab+'  ').lstrip())
-        return '\n'.join(lines)
+            lines.append(
+                ttab + "a=" + self.a.torepr(depth - 1, incrtab + "  ").lstrip()
+            )
+        return "\n".join(lines)
 
     def get_indent_tab(self, deindent=False, isfix=None):
         if isfix is None:
             isfix = self.reader.format.is_fixed
         if isfix:
-            tab = ' '*6
+            tab = " " * 6
         else:
-            tab = ''
+            tab = ""
         p = self.parent
         while isinstance(p, Statement):
-            tab += '  '
+            tab += "  "
             p = p.parent
         if deindent:
             tab = tab[:-2]
-        label = getattr(self.item, 'label', None)
+        label = getattr(self.item, "label", None)
         if label is None:
             return tab
         s = str(label)
         if isfix:
-            s = ' '+s
-        tab = tab[len(s):]
+            s = " " + s
+        tab = tab[len(s) :]
         if not tab:
-            tab = ' '
+            tab = " "
         tab = s + tab
         return tab
 
     def __str__(self):
         return self.tofortran()
 
     def asfix(self):
         lines = []
-        for line in self.tofortran(isfix=True).split('\n'):
-            if len(line) > 72 and line[0] == ' ':
-                lines.append(line[:72]+'&\n     &')
+        for line in self.tofortran(isfix=True).split("\n"):
+            if len(line) > 72 and line[0] == " ":
+                lines.append(line[:72] + "&\n     &")
                 line = line[72:]
                 while len(line) > 66:
-                    lines.append(line[:66]+'&\n     &')
+                    lines.append(line[:66] + "&\n     &")
                     line = line[66:]
-                lines.append(line+'\n')
+                lines.append(line + "\n")
             else:
-                lines.append(line+'\n')
-        return ''.join(lines).replace('\n     &\n', '\n')
+                lines.append(line + "\n")
+        return "".join(lines).replace("\n     &\n", "\n")
 
     def format_message(self, kind, message):
         if self.item is not None:
-            message = self.reader.format_message(kind, message,
-                                                 self.item.span[0],
-                                                 self.item.span[1])
+            message = self.reader.format_message(
+                kind, message, self.item.span[0], self.item.span[1]
+            )
         else:
             return message
         return message
 
     # def show_message(self, message, stream=sys.stderr):
     #     print >> stream, message
     #     stream.flush()
     #     return
 
     def error(self, message):
-        message = self.format_message('ERROR', message)
+        message = self.format_message("ERROR", message)
         logging.getLogger(__name__).error(message)
-        return
 
     def warning(self, message):
-        message = self.format_message('WARNING', message)
+        message = self.format_message("WARNING", message)
         logging.getLogger(__name__).warning(message)
-        return
 
     def info(self, message):
-        message = self.format_message('INFO', message)
+        message = self.format_message("INFO", message)
         logging.getLogger(__name__).info(message)
-        return
 
     def analyze(self):
-        self.warning('nothing analyzed')
-        return
+        self.warning("nothing analyzed")
 
     def get_variable(self, name):
-        """ Return Variable instance of variable name.
-        """
-        mth = getattr(self, 'get_variable_by_name', self.parent.get_variable)
+        """Return Variable instance of variable name."""
+        mth = getattr(self, "get_variable_by_name", self.parent.get_variable)
         return mth(name)
 
     def get_type(self, name):
-        """ Return type declaration using implicit rules
+        """Return type declaration using implicit rules
         for name.
         """
-        mth = getattr(self, 'get_type_by_name', self.parent.get_type)
+        mth = getattr(self, "get_type_by_name", self.parent.get_type)
         return mth(name)
 
     def get_type_decl(self, kind):
-        mth = getattr(self, 'get_type_decl_by_kind', self.parent.get_type_decl)
+        mth = getattr(self, "get_type_decl_by_kind", self.parent.get_type_decl)
         return mth(kind)
 
     def get_provides(self):
         """
         Returns dictonary containing statements that block provides or None
         when N/A.
         """
-        return
+        return None
 
 
 class BeginStatement(Statement):
-    """[ construct_name : ] <blocktype> [ <name> ]
+    """
+    ::
+
+        [ construct_name : ] <blocktype> [ <name> ]
+
+    BeginStatement instances have additional attributes::
+
+        name
+        blocktype
 
-    BeginStatement instances have additional attributes:
-      name
-      blocktype
-
-    Block instance has attributes:
-      content - list of Line or Statement instances
-      name    - name of the block, unnamed blocks are named
-                with the line label
-      construct_name - name of a construct
-      parent  - Block or FortranParser instance
-      item    - Line instance containing the block start statement
-      get_item, put_item - methods to retrive/submit Line instances
-                from/to Fortran reader.
-      isvalid - boolean, when False, the Block instance will be ignored.
+    Block instance has attributes::
 
-      stmt_cls, end_stmt_cls
+        content - list of Line or Statement instances
+        name    - name of the block, unnamed blocks are named
+                  with the line label
+        construct_name - name of a construct
+        parent  - Block or FortranParser instance
+        item    - Line instance containing the block start statement
+        get_item, put_item - methods to retrive/submit Line instances
+                  from/to Fortran reader.
+        isvalid - boolean, when False, the Block instance will be ignored.
+
+        stmt_cls, end_stmt_cls
 
     """
-    _repr_attr_names = ['blocktype',
-                        'name',
-                        'construct_name'] + Statement._repr_attr_names
 
-    def __init__(self, parent, item=None):
+    _repr_attr_names = [
+        "blocktype",
+        "name",
+        "construct_name",
+    ] + Statement._repr_attr_names
 
+    def __init__(self, parent, item=None):
         self.content = []
         self.get_item = parent.get_item  # get line function
         self.put_item = parent.put_item  # put line function
-        if not hasattr(self, 'blocktype'):
+        if not hasattr(self, "blocktype"):
             self.blocktype = self.__class__.__name__.lower()
-        if not hasattr(self, 'name'):
+        if not hasattr(self, "name"):
             # process_item may change this
-            self.name = '__'+self.blocktype.upper()+'__'
-        self.construct_name = getattr(item, 'name', None)
+            self.name = "__" + self.blocktype.upper() + "__"
+        self.construct_name = getattr(item, "name", None)
         Statement.__init__(self, parent, item)
-        return
 
     def tostr(self):
-        return self.blocktype.upper() + ' ' + self.name
+        return self.blocktype.upper() + " " + self.name
 
     def tofortran(self, isfix=None):
         construct_name = self.construct_name
-        construct_name = construct_name + ': ' if construct_name else ''
-        lines = [self.get_indent_tab(isfix=isfix)
-                 + construct_name + self.tostr()]
+        construct_name = construct_name + ": " if construct_name else ""
+        lines = [self.get_indent_tab(isfix=isfix) + construct_name + self.tostr()]
         for c in self.content:
             lines.append(c.tofortran(isfix=isfix))
-        return '\n'.join(lines)
+        return "\n".join(lines)
 
-    def torepr(self, depth=-1, incrtab=''):
+    def torepr(self, depth=-1, incrtab=""):
         tab = incrtab + self.get_indent_tab()
-        ttab = tab + '  '
+        ttab = tab + "  "
         lines = [Statement.torepr(self, depth=depth, incrtab=incrtab)]
         if depth == 0 or not self.content:
-            return '\n'.join(lines)
-        lines.append(ttab+'content:')
+            return "\n".join(lines)
+        lines.append(ttab + "content:")
         for c in self.content:
             if isinstance(c, EndStatement):
-                lines.append(c.torepr(depth-1, incrtab))
+                lines.append(c.torepr(depth - 1, incrtab))
             else:
-                lines.append(c.torepr(depth-1, incrtab + '  '))
-        return '\n'.join(lines)
+                lines.append(c.torepr(depth - 1, incrtab + "  "))
+        return "\n".join(lines)
 
     def process_item(self):
-        """ Process the line
-        """
+        """Process the line"""
         item = self.item
         if item is None:
             return
         self.fill()
-        return
 
     def fill(self, end_flag=False):
         """
         Fills blocks content until the end of block statement.
         """
 
         mode = self.reader.format.mode
         class_list = self.get_classes()
         self.classes = [cls for cls in class_list if mode in cls.modes]
-        self.pyf_classes = [cls for cls in class_list if 'pyf' in cls.modes]
+        self.pyf_classes = [cls for cls in class_list if "pyf" in cls.modes]
 
         item = self.get_item()
         while item is not None:
             if isinstance(item, Line):
                 if self.process_subitem(item):
                     end_flag = True
                     break
@@ -831,16 +858,15 @@
                 # TODO: FIX ME, Comment content is a string
                 self.content.append(classes.Comment(self, item))
             else:
                 raise NotImplementedError(repr(item))
             item = self.get_item()
 
         if not end_flag:
-            self.warning('failed to find the end of block')
-        return
+            self.warning("failed to find the end of block")
 
     def process_subitem(self, item):
         """
         Check if item is blocks start statement, if it is, read the block.
 
         Return True to stop adding items to given block.
         """
@@ -869,138 +895,166 @@
                     return False
                 # item may be cloned that changes the items line:
                 line = item.get_line()
 
         # Check if f77 code contains inline comments or other f90
         # constructs that got undetected by get_source_info.
         if item.reader.format.is_f77:
-            i = line.find('!')
+            i = line.find("!")
             if i != -1:
                 message = item.reader.format_message(
-                        'WARNING',
-                        'no parse pattern found for "%s" in %r block, '
-                        'trying to remove inline comment (not in Fortran 77).'
-                        % (item.get_line(), self.__class__.__name__),
-                        item.span[0], item.span[1])
+                    "WARNING",
+                    'no parse pattern found for "%s" in %r block, '
+                    "trying to remove inline comment (not in Fortran 77)."
+                    % (item.get_line(), self.__class__.__name__),
+                    item.span[0],
+                    item.span[1],
+                )
                 # .. but at the expense of loosing the comment.
                 logging.getLogger(__name__).warning(message)
                 if line[:i]:
                     newitem = item.copy(line[:i].rstrip())
                     return self.process_subitem(newitem)
                 else:
                     return True
 
             # try fix statement classes
             f77_classes = self.classes
             classes = []
             for cls in self.get_classes():
-                if 'f77' in cls.modes and cls not in f77_classes:
+                if "f77" in cls.modes and cls not in f77_classes:
                     classes.append(cls)
             if classes:
                 message = item.reader.format_message(
-                        'WARNING',
-                        'no parse pattern found for "%s" in %r block'
-                        ' maybe due to strict f77 mode.'
-                        ' Trying f90 fix mode patterns..'
-                        % (item.get_line(), self.__class__.__name__),
-                        item.span[0], item.span[1])
+                    "WARNING",
+                    'no parse pattern found for "%s" in %r block'
+                    " maybe due to strict f77 mode."
+                    " Trying f90 fix mode patterns.."
+                    % (item.get_line(), self.__class__.__name__),
+                    item.span[0],
+                    item.span[1],
+                )
                 logging.getLogger(__name__).warning(message)
 
                 item.reader.set_mode(False, False)
                 self.classes = classes
 
                 r = BeginStatement.process_subitem(self, item)
                 if r is None:
                     # restore f77 fix mode
                     self.classes = f77_classes
                     item.reader.set_mode(False, True)
                 else:
                     message = item.reader.format_message(
-                        'INFORMATION',
-                        'The f90 fix mode resolved the parse pattern issue.'
-                        ' Setting reader to f90 fix mode.',
-                        item.span[0], item.span[1])
+                        "INFORMATION",
+                        "The f90 fix mode resolved the parse pattern issue."
+                        " Setting reader to f90 fix mode.",
+                        item.span[0],
+                        item.span[1],
+                    )
                     logging.getLogger(__name__).info(message)
                     # set f90 fix mode
                     self.classes = f77_classes + classes
                     self.reader.set_mode(False, False)
                 return r
 
-        self.handle_unknown_item(item)
-        return
+        self.handle_unknown_item_and_raise(item)
 
-    def handle_unknown_item(self, item):
-        '''Called when process_subitem does not find a start or end of block.
+    def handle_unknown_item_and_raise(self, item):
+        """Called when process_subitem does not find a start or end of block.
         It adds the item (which is an instance of Line) to the content, but
         then raises an AnalyzeError. An instance of Line in content typically
         results in other errors later (e.g. because Line has no analyze
         method).
-        '''
+        """
         message = item.reader.format_message(
-            'WARNING',
+            "WARNING",
             'no parse pattern found for "%s" in %r block.'
             % (item.get_line(), self.__class__.__name__),
-            item.span[0], item.span[1])
+            item.span[0],
+            item.span[1],
+        )
         logging.getLogger(__name__).warning(message)
         self.content.append(item)
         raise AnalyzeError(message)
 
     def analyze(self):
         for stmt in self.content:
             stmt.analyze()
-        return
 
 
 class EndStatement(Statement):
     """
     END [<blocktype> [<name>]]
 
-    EndStatement instances have additional attributes:
-      name
-      blocktype
+    EndStatement instances have additional attributes::
+
+        name
+        blocktype
+
     """
-    _repr_attr_names = ['blocktype', 'name'] + Statement._repr_attr_names
+
+    _repr_attr_names = ["blocktype", "name"] + Statement._repr_attr_names
 
     def __init__(self, parent, item):
-        if not hasattr(self, 'blocktype'):
+        if not hasattr(self, "blocktype"):
             self.blocktype = self.__class__.__name__.lower()[3:]
         Statement.__init__(self, parent, item)
 
     def process_item(self):
         item = self.item
-        line = item.get_line().replace(' ', '')[3:]
+        line = item.get_line().replace(" ", "")[3:]
         line = item.apply_map(line)
         blocktype = self.blocktype
 
         if line.lower().startswith(blocktype):
-            line = line[len(blocktype):].strip()
+            line = line[len(blocktype) :].strip()
         else:
             if line:
                 # not the end of expected block
-                line = ''
+                line = ""
                 self.isvalid = False
         if self.parent.construct_name:
             name = self.parent.construct_name
         else:
             name = self.parent.name
         if line:
             # line variable is already cast to lower case so would fail if any
             # upper case letters exist in the label. Also, fortran is case
             # insensitive anyway so we should assume labels may have a
             # different case and therefore cast both to the same case in our
             # equivalence test.
             if line.lower() != name.lower():
-                message = 'expected the end of %r block ' \
-                          + 'but got the end of %r, skipping.'
+                message = (
+                    "expected the end of %r block " + "but got the end of %r, skipping."
+                )
                 self.warning(message % (name, line))
                 self.isvalid = False
         self.name = name
 
     def analyze(self):
-        return
+        pass
 
     def get_indent_tab(self, deindent=False, isfix=None):
         return Statement.get_indent_tab(self, deindent=True, isfix=isfix)
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'END %s %s'\
-               % (self.blocktype.upper(), self.name or '')
+        """Returns a valid Fortran string for this END statement. It
+        guarantees that there is no white space after the 'END' in case
+        of an unnamed statement.
+
+        :param bool isfix: True if the code is in fixed format.
+
+        :returns: the (named or unnamed) valid Fortran END statement \
+                  as a string.
+        :rtype: str
+
+        """
+        if self.name:
+            return self.get_indent_tab(isfix=isfix) + "END {0} {1}".format(
+                self.blocktype.upper(), self.name
+            )
+
+        # Make sure there is no space after an unnamed END:
+        return self.get_indent_tab(isfix=isfix) + "END {0}".format(
+            self.blocktype.upper()
+        )
```

### Comparing `fparser-0.0.9/src/fparser/common/readfortran.py` & `fparser-0.1.0/src/fparser/common/readfortran.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
-# Modified work Copyright (c) 2017-2019 Science and Technology
-# Facilities Council
+# Modified work Copyright (c) 2017-2023 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -63,30 +63,26 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 #
 # Author: Pearu Peterson <pearu@cens.ioc.ee>
 # Created: May 2006
-# Modified by R. W. Ford, STFC Daresbury Lab
+# Modified by R. W. Ford and A. R. Porter, STFC Daresbury Lab
 # Modified by P. Elson, Met Office
 
 """Provides Fortran reader classes.
 
 Overview
-========
 
 Provides FortranReader classes for reading Fortran codes from files and
 strings. FortranReader handles comments and line continuations of both
 fix and free format Fortran codes.
 
-Examples
-========
-
-::
+Examples::
 
     >> from fparser.common.readfortran import FortranFileReader
     >>> import os
     >>> reader = FortranFileReader(os.path.expanduser('~/src/blas/daxpy.f'))
     >>> print reader.next()
     line #1 'subroutine daxpy(n,da,dx,incx,dy,incy)'
     >>> print `reader.next()`
@@ -135,188 +131,234 @@
     >>> reader.next()
         Line('integer a',(3, 3),'')
     >>> reader.next()
         Line('print*,\"a=\",a',(4, 4),'')
 
 """
 
-from __future__ import print_function
-
 import logging
-import io
 import os
 import re
 import sys
 import traceback
-import six
+from io import StringIO
 import fparser.common.sourceinfo
 from fparser.common.splitline import String, string_replace_map, splitquote
 
 
-__all__ = ['FortranFileReader',
-           'FortranStringReader',
-           'FortranReaderError',
-           'Line',
-           'SyntaxErrorLine',
-           'Comment',
-           'MultiLine',
-           'SyntaxErrorMultiLine']
-
-_SPACEDIGITS = ' 0123456789'
-_CF2PY_RE = re.compile(r'(?P<indent>\s*)!f2py(?P<rest>.*)', re.I)
-_LABEL_RE = re.compile(r'\s*(?P<label>\d+)\s*(\b|(?=&)|\Z)', re.I)
-_CONSTRUCT_NAME_RE = re.compile(r'\s*(?P<name>\w+)\s*:\s*(\b|(?=&)|\Z)', re.I)
-_IS_INCLUDE_LINE = re.compile(r'\s*include\s*("[^"]+"'
-                              + r'|\'[^\']+\')\s*\Z', re.I).match
+__all__ = [
+    "FortranFileReader",
+    "FortranStringReader",
+    "FortranReaderError",
+    "Line",
+    "SyntaxErrorLine",
+    "Comment",
+    "MultiLine",
+    "SyntaxErrorMultiLine",
+]
+
+_SPACEDIGITS = " 0123456789"
+_CF2PY_RE = re.compile(r"(?P<indent>\s*)!f2py(?P<rest>.*)", re.I)
+_LABEL_RE = re.compile(r"\s*(?P<label>\d+)\s*(\b|(?=&)|\Z)", re.I)
+_CONSTRUCT_NAME_RE = re.compile(r"\s*(?P<name>\w+)\s*:\s*(\b|(?=&)|\Z)", re.I)
+_IS_INCLUDE_LINE = re.compile(
+    r'\s*include\s*("[^"]+"' + r"|\'[^\']+\')\s*\Z", re.I
+).match
 
 
 def _is_fix_cont(line):
-    return line and len(line) > 5 and line[5] != ' ' and line[:5] == 5 * ' '
+    return line and len(line) > 5 and line[5] != " " and line[:5] == 5 * " "
 
 
-def _is_fix_comment(line, isstrict):
+def _is_fix_comment(line, isstrict, f2py_enabled):
     """
     Check whether line is a comment line in fixed format Fortran source.
 
-    :param str line: Line of code to check
-    :param bool isstrict: Whether we are strictly enforcing fixed/free fmt
+    References - Fortran2008 3.3.3.
+
+    :param str line: line of code to check.
+    :param bool isstrict: whether we are strictly enforcing fixed/free fmt.
+    :param bool f2py_enabled: whether support for f2py directives is enabled.
+
+    :returns: whether or not the supplied line is a fixed-format comment.
+    :rtype: bool
 
-    References
-    ----------
-    :f2008:`3.3.3`
     """
     if line:
-        if line[0] in '*cC!':
+        if line[0] in "*cC!":
+            if f2py_enabled and line[1:5].lower() == "f2py":
+                return False
             return True
         if not isstrict:
-            i = line.find('!')
+            i = line.find("!")
             if i != -1:
                 start = line[:i].lstrip()
                 if not start:
                     if i == 5:
                         # line continuation
                         return False
                     return True
                 else:
                     # inline comment or ! is used in character context
                     # inline comments are handled elsewhere
                     pass
-    elif line == '':
+    elif line == "":
         return True
     return False
 
 
-_HOLLERITH_START_SEARCH = re.compile(r'(?P<pre>\A|,\s*)'
-                                     + r'(?P<num>\d+)h', re.I).search
-_IS_CALL_STMT = re.compile(r'call\b', re.I).match
+_HOLLERITH_START_SEARCH = re.compile(
+    r"(?P<pre>\A|,\s*)" + r"(?P<num>\d+)h", re.I
+).search
+_IS_CALL_STMT = re.compile(r"call\b", re.I).match
+
+
+def extract_label(line):
+    """Look for an integer label at the start of 'line' and if there is
+    one then remove it from 'line' and store it as an integer in
+    'label', returning both in a tuple.
+
+    :param str line: a string that potentially contains a label at the \
+        start.
+
+    :returns: a 2-tuple containing the label and updated line if a \
+        label is found or None and the unchanged line if a label is \
+        not found.
+    :rtype: (int or NoneType, str)
+
+    """
+    label = None
+    match = _LABEL_RE.match(line)
+    if match:
+        label = int(match.group("label"))
+        line = line[match.end() :].lstrip()
+    return label, line
+
+
+def extract_construct_name(line):
+    """Look for a construct name at the start of 'line' and if there is
+    one then remove it from 'line' and return it as a string in
+    'name', returning both in a tuple.
+
+    :param str line: a string that potentially contains a construct \
+        name at the start.
+
+    :returns: a 2-tuple containing the construct name and updated line \
+        if a construct name is found or None and the unchanged line if \
+        a construct name is not found.
+    :rtype: (str or NoneType, str)
+
+    """
+    construct_name = None
+    match = _CONSTRUCT_NAME_RE.match(line)
+    if match:
+        construct_name = match.group("name")
+        line = line[match.end() :].lstrip()
+    return construct_name, line
 
 
 class FortranReaderError(Exception):
-    '''
+    """
     Thrown when there is an error reading the Fortran source file.
-    '''
+    """
+
     pass
 
 
-class Line(object):
-    """ Holds a Fortran source line.
+class Line:
+    """Holds a Fortran source line.
 
-    Attributes
-    ----------
-    line : str
-      code line
-    span : 2-tuple
-      starting and ending line numbers
-    label : {int, None}
-      Specify statement label
-    name : {str, None}
-      Specify construct name.
-    reader : FortranReaderBase
-    strline : {None, str}
-    is_f2py_directive : bool
-      the line contains f2py directive
-    """
+    Attributes::
 
-    f2py_strmap_findall = re.compile(r'(_F2PY_STRING_CONSTANT_\d+_'
-                                     + r'|F2PY_EXPR_TUPLE_\d+)').findall
+        line : str
+          code line
+        span : 2-tuple
+          starting and ending line numbers
+        label : {int, None}
+          Specify statement label
+        name : {str, None}
+          Specify construct name.
+        reader : FortranReaderBase
+        strline : {None, str}
+        is_f2py_directive : bool
+          the line contains f2py directive
+
+    """
 
     def __init__(self, line, linenospan, label, name, reader):
         self.line = line.strip()
         if not self.line:
-            raise FortranReaderError("Got empty line: '{0}'. linenospan={1}, "
-                                     "label='{2}'".format(line,
-                                                          linenospan, label))
+            raise FortranReaderError(
+                "Got empty line: '{0}'. linenospan={1}, "
+                "label='{2}'".format(line, linenospan, label)
+            )
         self.span = linenospan
         assert label is None or isinstance(label, int), repr(label)
-        assert name is None or isinstance(name, str) and name != '', repr(name)
+        assert name is None or isinstance(name, str) and name != "", repr(name)
         self.label = label
         self.name = name
         self.reader = reader
         self.strline = None
         self.is_f2py_directive = linenospan[0] in reader.f2py_comment_lines
         self.parse_cache = {}
 
     def has_map(self):
-        '''
+        """
         Returns true when a substitution map has been registered.
-        '''
-        return hasattr(self, 'strlinemap') and self.strlinemap
+        """
+        return hasattr(self, "strlinemap") and self.strlinemap
 
     def apply_map(self, line):
-        '''
+        """
         Substitutes magic strings in a line with values specified in a map.
-        '''
-        if not hasattr(self, 'strlinemap') or not self.strlinemap:
+        """
+        if not hasattr(self, "strlinemap") or not self.strlinemap:
             return line
-        findall = self.f2py_strmap_findall
-        str_map = self.strlinemap
-        keys = findall(line)
-        for k in keys:
-            line = line.replace(k, str_map[k])
-        return line
+        return self.strlinemap(line)
 
     def copy(self, line=None, apply_map=False):
-        '''
+        """
         Creates a Line object from a string.
 
         If no line argument is specified a copy is made of this Line.
 
         If a substitution map is provided it is used while making the copy.
-        '''
+        """
         if line is None:
             line = self.line
         if apply_map:
             line = self.apply_map(line)
         return Line(line, self.span, self.label, self.name, self.reader)
 
     def clone(self, line):
-        '''
+        """
         This Line has its contents overwitten by the passed string. The
         incoming string has substitution applied.
-        '''
+        """
         self.line = self.apply_map(line)
         self.strline = None
-        return
 
     def __repr__(self):
-        return self.__class__.__name__+'(%r,%s,%r,%r,<reader>)' \
-               % (self.line, self.span, self.label, self.name)
+        return self.__class__.__name__ + "(%r,%s,%r,%r,<reader>)" % (
+            self.line,
+            self.span,
+            self.label,
+            self.name,
+        )
 
     def __str__(self):
-        s = 'line #%s' % (self.span[0])
+        s = "line #%s" % (self.span[0])
         if self.label is not None:
-            s += ' %s ' % (self.label)
+            s += " %s " % (self.label)
         if self.name is not None:
-            s += '%s: ' % (self.name)
+            s += "%s: " % (self.name)
         return s + repr(self.line)
 
     def isempty(self, ignore_comments=False):
-        return not (self.line
-                    or self.label is not None
-                    or self.name is not None)
+        return not (self.line or self.label is not None or self.name is not None)
 
     def get_line(self, apply_map=False):
         if apply_map:
             return self.apply_map(self.get_line(apply_map=False))
         if self.strline is not None:
             return self.strline
         line = self.line
@@ -328,33 +370,32 @@
             # in the argument list of CALL statement.
             # Hollerith constants were removed from the Fortran 77 standard.
             # The following handling is not perfect but works for simple
             # usage cases.
             # todo: Handle hollerith constants in DATA statement
             if _IS_CALL_STMT(line):
                 l2 = self.line[4:].lstrip()
-                i = l2.find('(')
-                if i != -1 and l2[-1] == ')':
-                    substrings = ['call '+l2[:i+1]]
+                i = l2.find("(")
+                if i != -1 and l2[-1] == ")":
+                    substrings = ["call " + l2[: i + 1]]
                     start_search = _HOLLERITH_START_SEARCH
-                    l2 = l2[i+1:-1].strip()
+                    l2 = l2[i + 1 : -1].strip()
                     m = start_search(l2)
                     while m:
-                        substrings.append(l2[:m.start()])
-                        substrings.append(m.group('pre'))
-                        num = int(m.group('num'))
-                        substrings.append("'"+l2[m.end():m.end()+num]+"'")
-                        l2 = l2[m.end()+num:]
+                        substrings.append(l2[: m.start()])
+                        substrings.append(m.group("pre"))
+                        num = int(m.group("num"))
+                        substrings.append("'" + l2[m.end() : m.end() + num] + "'")
+                        l2 = l2[m.end() + num :]
                         m = start_search(l2)
                     substrings.append(l2)
-                    substrings.append(')')
-                    line = ''.join(substrings)
+                    substrings.append(")")
+                    line = "".join(substrings)
 
-        line, str_map = string_replace_map(line,
-                                           lower=not self.reader.format.is_pyf)
+        line, str_map = string_replace_map(line, lower=not self.reader.format.is_pyf)
         self.strline = line
         self.strlinemap = str_map
         return line
 
     def parse_line(self, cls, parent_cls):
         if cls not in self.parse_cache:
             self.parse_cache[cls] = None
@@ -371,232 +412,252 @@
             self.parse_cache[key] = obj
         else:
             obj = self.parse_cache[key]
         return obj
 
 
 class SyntaxErrorLine(Line, FortranReaderError):
-    '''
+    """
     Indicates a syntax error while processing a line.
-    '''
+    """
+
     def __init__(self, line, linenospan, label, name, reader, message):
         Line.__init__(self, line, linenospan, label, name, reader)
         FortranReaderError.__init__(self, message)
 
 
-class Comment(object):
-    '''Holds a Fortran comment.
+class Comment:
+    """Holds a Fortran comment.
 
     :param str comment: String containing the text of a single or \
     multi-line comment
     :param linenospan: A 2-tuple containing the start and end line \
     numbers of the comment from the input source.
     :type linenospan: (int, int)
     :param reader: The reader object being used to read the input \
     source.
     :type reader: :py:class:`fparser.common.readfortran.FortranReaderBase`
 
-    '''
-    def __init__(self, comment, linenospan, reader):
+    """
 
+    def __init__(self, comment, linenospan, reader):
         self.comment = comment
         self.span = linenospan
         self.reader = reader
         # self.line provides a common way to retrieve the content from
         # either a 'Line' or a 'Comment' class. This is useful for
         # tests as a reader can return an instance of either class and
         # we might want to check the contents in a consistent way.
         self.line = comment
 
     def __repr__(self):
-        return self.__class__.__name__+'(%r,%s)' \
-               % (self.comment, self.span)
+        return self.__class__.__name__ + "(%r,%s)" % (self.comment, self.span)
 
     def isempty(self, ignore_comments=False):
-        '''
+        """
         Whether or not this comment is in fact empty (or we are ignoring
         it). Provided for compatibility with Line.isempty()
 
         :param bool ignore_comments: whether we ignore comments
         :return: True if we are ignoring comments, False otherwise
         :rtype: bool
-        '''
+        """
         return ignore_comments
 
 
-class MultiLine(object):
-    """ Holds PYF file multiline.
+class MultiLine:
+    """Holds PYF file multiline.
 
     PYF file multiline is represented as follows::
-      prefix+'''+lines+'''+suffix.
 
-    Attributes
-    ----------
-    prefix : str
-    block : list
-      list of lines
-    suffix : str
-    span : 2-tuple
-      starting and ending line numbers
-    reader : FortranReaderBase
+        prefix+'''+lines+'''+suffix.
+
+    :param str prefix: the prefix of the line(s)
+    :param block: list of lines
+    :type block: List[:py:class:`fparser.common.readfortran.Line`]
+    :param str suffix: the suffix of the block of lines
+    :param linenospan: starting and ending line numbers
+    :type linenospan: Tuple[int, int]
+    :param reader: the current reader instance.
+    :type reader: :py:class:`fparser.common.readfortran.FortranReaderBase`
+
     """
+
     def __init__(self, prefix, block, suffix, linenospan, reader):
         self.prefix = prefix
         self.block = block
         self.suffix = suffix
         self.span = linenospan
         self.reader = reader
 
     def __repr__(self):
-        string = '{cls}({prefix!r},{block},{suffix!r},{span})'
-        return string.format(cls=self.__class__.__name__,
-                             prefix=self.prefix,
-                             block=self.block,
-                             suffix=self.suffix,
-                             span=self.span)
+        string = "{cls}({prefix!r},{block},{suffix!r},{span})"
+        return string.format(
+            cls=self.__class__.__name__,
+            prefix=self.prefix,
+            block=self.block,
+            suffix=self.suffix,
+            span=self.span,
+        )
 
     def isempty(self, ignore_comments=False):
-        '''
+        """
         Returns true if there is no significant text in this multi-line
         string.
-        '''
+        """
         return not (self.prefix or self.block or self.suffix)
 
 
 class SyntaxErrorMultiLine(MultiLine, FortranReaderError):
-    '''
+    """
     Indicates a syntax error while processing Python multi-line strings.
-    '''
+    """
+
     def __init__(self, prefix, block, suffix, linenospan, reader, message):
         MultiLine.__init__(self, prefix, block, suffix, linenospan, reader)
         FortranReaderError.__init__(self, message)
 
 
+class CppDirective(Line):
+    """Holds a preprocessor directive source line.
+
+    :param str line: string containing the text of a single or \
+                     multi-line preprocessor directive.
+    :param linenospan: a 2-tuple containing the start and end line \
+                       numbers of the directive from the input source.
+    :type linenospan: (int, int)
+    :param reader: The reader object being used to read the input \
+                   source.
+    :type reader: :py:class:`fparser.common.readfortran.FortranReaderBase`
+
+    """
+
+    def __init__(self, line, linenospan, reader):
+        super(CppDirective, self).__init__(line, linenospan, None, None, reader)
+
+
 ##############################################################################
 
-class FortranReaderBase(object):
+
+class FortranReaderBase:
     """
     Base class for reading Fortran sources.
 
     A Fortran source must be a file-like object (have a ``.next()``
     method) and it may hold Fortran 77 code, fixed format Fortran
     code, free format Fortran code, or PYF signatures (with extended
     free format Fortran syntax).
 
-    :param source: A file-like object with .next() method used to
+    :param source: a file-like object with .next() method used to \
                    retrive a line.
-    :type source: either :py:class:`six.StringIO` or a file handle
-    :param mode: A FortranFormat object as returned by
+    :type source: :py:class:`StringIO` or a file handle
+    :param mode: a FortranFormat object as returned by \
                  `sourceinfo.get_source_info()`
     :type mode: :py:class:`fparser.common.sourceinfo.Format`
-    :param bool isstrict: Whether we are strictly enforcing fixed format
-    :param bool ignore_comments: Whether or not to discard comments
+    :param bool isstrict: whether we are strictly enforcing fixed format.
+    :param bool ignore_comments: whether or not to discard comments.
 
     The Fortran source is iterated by `get_single_line`,
     `get_next_line`, `put_single_line` methods.
 
     """
 
     def __init__(self, source, mode, ignore_comments):
         self.source = source
         self._format = mode
 
-        self.linecount = 0   # the current number of consumed lines
+        self.linecount = 0  # the current number of consumed lines
         self.isclosed = False
         # This value for ignore_comments can be overridden by using the
         # ignore_comments optional argument to e.g. get_single_line()
         self._ignore_comments = ignore_comments
 
         self.filo_line = []  # used for un-consuming lines.
         self.fifo_item = []
         self.source_lines = []  # source lines cache
 
         self.f2py_comment_lines = []  # line numbers of f2py directives
 
         self.reader = None
-        self.include_dirs = ['.']
+        self.include_dirs = ["."]
 
         self.source_only = None
 
         self.exit_on_error = True
         self.restore_cache = []
 
-        return
-
     ##########################################################################
 
     def __repr__(self):
-        return '%s(%r, %r, %r)' % (self.__class__.__name__,
-                                   self.source,
-                                   self._format.is_free,
-                                   self._format.is_strict)
+        return "%s(%r, %r, %r)" % (
+            self.__class__.__name__,
+            self.source,
+            self._format.is_free,
+            self._format.is_strict,
+        )
 
     def find_module_source_file(self, mod_name):
-        '''
+        """
         Scans registered dependees for a named module.
-        '''
+        """
         from .utils import get_module_file, module_in_file
+
         if self.source_only:
             for sf in self.source_only:
                 if module_in_file(mod_name, sf):
                     return sf
         else:
             fn = None
             for d in self.include_dirs:
                 fn = get_module_file(mod_name, d)
                 if fn is not None:
                     return fn
 
     def set_format(self, mode):
-        '''
+        """
         Set Fortran code mode (fixed/free format etc).
 
         :param mode: Object describing the desired mode for the reader
         :type mode: :py:class:`fparser.common.sourceinfo.FortranFormat`
-        '''
+        """
         self._format = mode
 
     @property
     def format(self):
-        '''
+        """
         :returns: the currently applicable format.
         :rtype: :py:class:`fparser.sourceinfo.FortranFormat`
-        '''
+        """
         return self._format
 
     @property
     def name(self):
-        '''
+        """
         :returns: the name of this reader.
         :rtype: str
-        '''
-        return '{source} mode={mode}'.format(source=self.source,
-                                             mode=self._format.mode)
+        """
+        return "{source} mode={mode}".format(source=self.source, mode=self._format.mode)
 
     def close_source(self):
-        """ Called when self.source.next() raises StopIteration.
-        """
+        """Called when self.source.next() raises StopIteration."""
         pass
 
     # For handling raw source lines:
 
     def put_single_line(self, line):
-        """ Put single line to FILO line buffer.
+        """Put single line to FILO line buffer.
 
         ``linecount`` will be decremented, that is, the line was
         returned by ``get_single_line`` call then it will be
         un-consumed.
 
-        See also
-        --------
-        get_single_line, get_next_line
+        See also - get_single_line, get_next_line
         """
         self.filo_line.append(line)
         self.linecount -= 1
-        return
 
     def get_single_line(self, ignore_empty=False, ignore_comments=None):
         """ Return line from FILO line buffer or from source.
 
         First try getting the line from FILO line buffer.
 
         If FILO line buffer is empty then get the next line from
@@ -604,21 +665,19 @@
         line characters will be removed.  The source line will be
         added to ``source_lines`` list. If source line is empty then
         recursively get next non-empty line.
 
         In both situations ``linecount`` will be incremented, that is,
         the line will be consumed.
 
-        :param bool ignore_empty: If True then ignore empty lines.
-        :param bool ignore_comments: If True then ignore comments (overrides
+        :param bool ignore_empty: if True then ignore empty lines.
+        :param bool ignore_comments: if True then ignore comments (overrides \
                                      self._ignore_comments)
 
-        See also
-        --------
-        put_single_line, get_next_line
+        See also - put_single_line, get_next_line
         """
         if ignore_comments is None:
             ignore_comments = self._ignore_comments
 
         try:
             line = self.filo_line.pop()
             self.linecount += 1
@@ -631,134 +690,107 @@
             line = next(self.source)
         except StopIteration:
             self.isclosed = True
             self.close_source()
             return None
         self.linecount += 1
 
-        if six.PY2 and not isinstance(line, six.text_type):
-            # Ensure we always have a unicode object in Python 2.
-            line = unicode(line, 'UTF-8')
-
         # expand tabs, replace special symbols, get rid of nl characters
-        line = line.expandtabs().replace(u'\xa0', u' ').rstrip()
-
-        if six.PY2:
-            # Cast the unicode to str if we can do so safely. This
-            # maximises compatibility with the existing Python 2 tests
-            # and avoids the need to proliferate the use of unicode
-            # literals (e.g. u"") in the parse tree repr.
-            try:
-                line = line.encode('ascii', errors='strict')
-            except UnicodeEncodeError:
-                # Can't cast to str as there are non-ascii characters
-                # in the line.
-                pass
+        line = line.expandtabs().replace("\xa0", " ").rstrip()
 
         self.source_lines.append(line)
 
-        if ignore_comments and (self.format.is_fixed or self.format.is_f77):
+        if ignore_comments and (self._format.is_fixed or self._format.is_f77):
             # Check for a fixed-format comment. If the current line *is*
             # a comment and we are ignoring them, then recursively call this
             # routine again to get the next source line.
-            if _is_fix_comment(line, isstrict=self.format.is_strict):
+            if _is_fix_comment(
+                line,
+                isstrict=self._format.is_strict,
+                f2py_enabled=self._format.f2py_enabled,
+            ):
                 return self.get_single_line(ignore_empty, ignore_comments)
 
         if ignore_empty and not line:
             return self.get_single_line(ignore_empty, ignore_comments)
 
         return line
 
     def get_next_line(self, ignore_empty=False, ignore_comments=None):
-        """ Return next non-empty line from FILO line buffer or from source.
+        """Return next non-empty line from FILO line buffer or from source.
 
         The line will be put to FILO line buffer. So, this method can
         be used for looking forward lines without consuming them.
 
-        See also
-        --------
-        get_single_line, put_single_line
+        See also - get_single_line, put_single_line
         """
         if ignore_comments is None:
             ignore_comments = self._ignore_comments
 
         line = self.get_single_line(ignore_empty, ignore_comments)
         if line is None:
             return
         self.put_single_line(line)
         return line
 
     # Parser methods:
     def get_item(self, ignore_comments=None):
-        """ Return next item.
-        """
+        """Return next item."""
         if ignore_comments is None:
             ignore_comments = self._ignore_comments
 
         try:
             item = self.next(ignore_comments=ignore_comments)
         except StopIteration:
             return
         return item
 
     def put_item(self, item):
-        """ Insert item to FIFO item buffer.
-        """
+        """Insert item to FIFO item buffer."""
         self.fifo_item.insert(0, item)
-        return
 
     # Iterator methods:
 
     def __iter__(self):
-        """ Make FortranReader an iterator.
-        """
+        """Make FortranReader an iterator."""
         return self
 
     def __next__(self):
         return self.next()
 
     def next(self, ignore_comments=None):
-        '''Return the next Fortran code item. Include statements are dealt
+        """Return the next Fortran code item. Include statements are dealt
         with here.
 
         :param bool ignore_comments: When True then act as if Fortran \
         code does not contain any comments or blank lines. if this \
         optional arguement is not provided then use the default \
         value.
 
         :returns: the next line item. This can be from a local fifo \
         buffer, from an include reader or from this reader.
         :rtype: py:class:`fparser.common.readfortran.Line`
 
         :raises StopIteration: if no more lines are found.
         :raises StopIteration: if a general error has occured.
 
-        '''
+        """
         if ignore_comments is None:
             ignore_comments = self._ignore_comments
         try:
             if self.reader is not None:
                 # inside INCLUDE statement
                 try:
-                    # Manually check to see if something has not
-                    # matched and has been placed in the fifo. We
-                    # can't use _next() as this method is associated
-                    # with the include reader (self.reader._next()),
-                    # not this reader (self._next()).
-                    return self.fifo_item.pop(0)
-                except IndexError:
-                    # There is nothing in the fifo buffer.
-                    try:
-                        # Return a line from the include.
-                        return self.reader.next(ignore_comments)
-                    except StopIteration:
-                        # There is nothing left in the include
-                        # file. Setting reader to None indicates that
-                        # we should now read from the main reader.
-                        self.reader = None
+                    # Return a line from the include.
+                    return self.reader.next(ignore_comments)
+                except StopIteration:
+                    # There is nothing left in the include
+                    # file. Setting reader to None indicates that
+                    # we should now read from the main reader.
+                    self.reader = None
             item = self._next(ignore_comments)
             if isinstance(item, Line) and _IS_INCLUDE_LINE(item.line):
                 # catch INCLUDE statement and create a new FortranReader
                 # to enter to included file.
                 reader = item.reader
                 filename = item.line.strip()[7:].lstrip()[1:-1]
                 include_dirs = self.include_dirs[:]
@@ -774,242 +806,299 @@
                     # The Fortran standard states that an INCLUDE line
                     # is not a Fortran statement. However, fparser is
                     # a parser not a compiler and some subsequent tool
                     # might need to make use of this include so we
                     # return it and let the parser deal with it.
                     #
                     return item
-                reader.info('including file %r' % (path), item)
+                reader.info("including file %r" % (path), item)
                 self.reader = FortranFileReader(
-                    path,
-                    include_dirs=include_dirs,
-                    ignore_comments=ignore_comments)
+                    path, include_dirs=include_dirs, ignore_comments=ignore_comments
+                )
                 result = self.reader.next(ignore_comments=ignore_comments)
                 return result
             return item
         except StopIteration:
             raise
         # TODO can we specify one or more specific exception types
         # rather than catching *every* exception.
         except Exception as err:
-            message = self.format_message('FATAL ERROR',
-                                          'while processing line',
-                                          self.linecount, self.linecount)
+            message = self.format_message(
+                "FATAL ERROR", "while processing line", self.linecount, self.linecount
+            )
             logging.getLogger(__name__).critical(message)
-            message = 'Traceback\n' + ''.join(traceback.format_stack())
+            message = "Traceback\n" + "".join(traceback.format_stack())
             logging.getLogger(__name__).debug(message)
-            logging.getLogger(__name__).debug(six.text_type(err))
-            logging.getLogger(__name__).critical('STOPPED READING')
+            logging.getLogger(__name__).debug(str(err))
+            logging.getLogger(__name__).critical("STOPPED READING")
             raise StopIteration
 
     def _next(self, ignore_comments=None):
         """
         Return the next item from FIFO item buffer or construct
         one from source line.
 
         Resolves ``;`` statement terminations.
 
-        :param bool ignore_comments: Whether or not to ignore comments
+        See also - next, get_source_item
+
+        :param bool ignore_comments: Whether or not to ignore comments \
                                      (overrides self._ignore_comments)
 
-        See also
-        --------
-        next, get_source_item
+        :returns: the next line of Fortran.
+        :rtype: :py:class:`fparser.common.readfortran.Line`
+
+        :raises StopIteration: if no new items are found.
+
         """
         if ignore_comments is None:
             ignore_comments = self._ignore_comments
         fifo_item_pop = self.fifo_item.pop
         while 1:
             try:
                 # first empty the FIFO item buffer:
                 item = fifo_item_pop(0)
             except IndexError:
                 # construct a new item from source
                 item = self.get_source_item()
-                if item is None:
-                    raise StopIteration
-            if not (item.isempty(ignore_comments)):
+            if item is None:
+                raise StopIteration
+            if not item.isempty(ignore_comments):
                 break
             # else ignore empty lines and comments by getting next line
 
         if not isinstance(item, Comment):
             # resolve `;` statement terminations
-            if not self._format.is_pyf and isinstance(item, Line) \
-                   and not item.is_f2py_directive \
-                   and ';' in item.get_line():
+            if (
+                not self._format.is_pyf
+                and isinstance(item, Line)
+                and not item.is_f2py_directive
+                and ";" in item.get_line()
+            ):
                 # ;-separator not recognized in pyf-mode
                 items = []
-                for line in item.get_line().split(';'):
+                # Deal with each Fortran statement separately.
+                split_line_iter = iter(item.get_line().split(";"))
+                first = next(split_line_iter)
+                # The full line has already been processed as a Line
+                # object in 'item' (and may therefore have label
+                # and/or construct name properties extracted from the
+                # start of the line). The simplest way to avoid losing
+                # any label or construct name properties for the first
+                # statement is to copy the 'item' object and update it
+                # so that it only includes text for the first
+                # statement (rather than the full line). Subsequent
+                # statements need to be processed into Line
+                # objects.
+                items.append(item.copy(first.strip(), apply_map=True))
+                for line in split_line_iter:
+                    # Any subsequent statements have not been processed
+                    # before, so new Line objects need to be created.
                     line = line.strip()
                     if line:
-                        items.append(item.copy(line, apply_map=True))
+                        # The statement might have a label and/or construct
+                        # name.
+                        label, line = extract_label(line)
+                        name, line = extract_construct_name(line)
+                        # Create a new Line object and append to items
+                        # using the existing span (line numbers) and
+                        # reader.
+                        new_line = Line(
+                            item.apply_map(line), item.span, label, name, item.reader
+                        )
+                        items.append(new_line)
                 items.reverse()
                 for newitem in items:
                     self.fifo_item.insert(0, newitem)
                 return fifo_item_pop(0)
         return item
 
     # Interface to returned items:
 
-    def line_item(self,
-                  line,
-                  startlineno,
-                  endlineno,
-                  label,
-                  name,
-                  errmessage=None):
-        """ Construct Line item.
-        """
+    def line_item(self, line, startlineno, endlineno, label, name, errmessage=None):
+        """Construct Line item."""
         if errmessage is None:
             return Line(line, (startlineno, endlineno), label, name, self)
-        return SyntaxErrorLine(line, (startlineno, endlineno),
-                               label, name, self, errmessage)
-
-    def multiline_item(self, prefix, lines, suffix,
-                       startlineno, endlineno, errmessage=None):
-        """ Construct MultiLine item.
-        """
+        return SyntaxErrorLine(
+            line, (startlineno, endlineno), label, name, self, errmessage
+        )
+
+    def multiline_item(
+        self, prefix, lines, suffix, startlineno, endlineno, errmessage=None
+    ):
+        """Construct MultiLine item."""
         if errmessage is None:
-            return MultiLine(prefix,
-                             lines,
-                             suffix,
-                             (startlineno, endlineno),
-                             self)
-        return SyntaxErrorMultiLine(prefix,
-                                    lines,
-                                    suffix,
-                                    (startlineno, endlineno),
-                                    self,
-                                    errmessage)
+            return MultiLine(prefix, lines, suffix, (startlineno, endlineno), self)
+        return SyntaxErrorMultiLine(
+            prefix, lines, suffix, (startlineno, endlineno), self, errmessage
+        )
 
     def comment_item(self, comment, startlineno, endlineno):
-        """ Construct Comment item.
-        """
+        """Construct Comment item."""
         return Comment(comment, (startlineno, endlineno), self)
 
+    def cpp_directive_item(self, line, startlineno, endlineno):
+        """
+        Construct :py:class:`fparser.common.readfortran.CppDirective` item.
+
+        :param str line: string containing the text of a single or \
+                         multi-line preprocessor directive.
+        :param int startlineno: start line number of the directive from \
+                                the input source.
+        :param int endlineno: end line number of the directive from \
+                              the input source.
+
+        """
+        return CppDirective(line, (startlineno, endlineno), self)
+
     # For handling messages:
 
-    def format_message(self, kind, message, startlineno, endlineno,
-                       startcolno=0, endcolno=-1):
-        '''
+    def format_message(
+        self, kind, message, startlineno, endlineno, startcolno=0, endcolno=-1
+    ):
+        """
         Prepares a string for logging.
-        '''
-        back_index = {'warning': 2,
-                      'error': 3,
-                      'info': 0}.get(kind.lower(), 3)
-        r = ['While processing %r (mode=%r)..' % (self.id,
-                                                  self._format.mode)]
+        """
+        back_index = {"warning": 2, "error": 3, "info": 0}.get(kind.lower(), 3)
+        r = ["While processing %r (mode=%r).." % (self.id, self._format.mode)]
         for i in range(max(1, startlineno - back_index), startlineno):
-            r.append('%5d:%s' % (i, self.source_lines[i - 1]))
-        for i in range(startlineno, min(endlineno+back_index,
-                                        len(self.source_lines))+1):
+            r.append("%5d:%s" % (i, self.source_lines[i - 1]))
+        for i in range(
+            startlineno, min(endlineno + back_index, len(self.source_lines)) + 1
+        ):
             if i == 0 and not self.source_lines:
                 break
-            linenostr = '%5d:' % (i)
+            linenostr = "%5d:" % (i)
             if i == endlineno:
-                sourceline = self.source_lines[i-1]
-                l0 = linenostr+sourceline[:startcolno]
+                sourceline = self.source_lines[i - 1]
+                l0 = linenostr + sourceline[:startcolno]
                 if endcolno == -1:
                     l1 = sourceline[startcolno:]
-                    l2 = ''
+                    l2 = ""
                 else:
                     l1 = sourceline[startcolno:endcolno]
                     l2 = sourceline[endcolno:]
-                r.append('%s%s%s <== %s' % (l0, l1, l2, message))
+                r.append("%s%s%s <== %s" % (l0, l1, l2, message))
             else:
-                r.append(linenostr + self.source_lines[i-1])
-        return '\n'.join(r)
+                r.append(linenostr + self.source_lines[i - 1])
+        return "\n".join(r)
 
-    def format_error_message(self, message, startlineno, endlineno,
-                             startcolno=0, endcolno=-1):
-        '''Create a string with an error message.'''
-        return self.format_message('ERROR', message, startlineno,
-                                   endlineno, startcolno, endcolno)
-
-    def format_warning_message(self, message, startlineno, endlineno,
-                               startcolno=0, endcolno=-1):
-        '''Create a string with a warning message. '''
-        return self.format_message('WARNING', message, startlineno,
-                                   endlineno, startcolno, endcolno)
+    def format_error_message(
+        self, message, startlineno, endlineno, startcolno=0, endcolno=-1
+    ):
+        """Create a string with an error message."""
+        return self.format_message(
+            "ERROR", message, startlineno, endlineno, startcolno, endcolno
+        )
+
+    def format_warning_message(
+        self, message, startlineno, endlineno, startcolno=0, endcolno=-1
+    ):
+        """Create a string with a warning message."""
+        return self.format_message(
+            "WARNING", message, startlineno, endlineno, startcolno, endcolno
+        )
 
     def info(self, message, item=None):
-        '''
+        """
         Logs an information message.
-        '''
+        """
         if item is None:
-            m = self.format_message('INFORMATION',
-                                    message,
-                                    len(self.source_lines)-2,
-                                    len(self.source_lines))
+            m = self.format_message(
+                "INFORMATION",
+                message,
+                len(self.source_lines) - 2,
+                len(self.source_lines),
+            )
         else:
-            m = self.format_message('INFORMATION',
-                                    message,
-                                    item.span[0], item.span[1])
+            m = self.format_message("INFORMATION", message, item.span[0], item.span[1])
         logging.getLogger(__name__).info(m)
-        return
 
     def error(self, message, item=None):
-        '''
+        """
         Logs an error message.
-        '''
+        """
         if item is None:
-            m = self.format_error_message(message, len(self.source_lines)-2,
-                                          len(self.source_lines))
+            m = self.format_error_message(
+                message, len(self.source_lines) - 2, len(self.source_lines)
+            )
         else:
             m = self.format_error_message(message, item.span[0], item.span[1])
         logging.getLogger(__name__).error(m)
         if self.exit_on_error:
             sys.exit(1)
-        return
 
     def warning(self, message, item=None):
-        '''
+        """
         Logs a warning message.
-        '''
+        """
         if item is None:
-            m = self.format_warning_message(message,
-                                            len(self.source_lines) - 2,
-                                            len(self.source_lines))
+            m = self.format_warning_message(
+                message, len(self.source_lines) - 2, len(self.source_lines)
+            )
         else:
-            m = self.format_warning_message(message,
-                                            item.span[0],
-                                            item.span[1])
+            m = self.format_warning_message(message, item.span[0], item.span[1])
         logging.getLogger(__name__).warning(m)
-        return
 
     # Auxiliary methods for processing raw source lines:
 
+    def handle_cpp_directive(self, line):
+        """
+        Determine whether the current line is likely to hold
+        C preprocessor directive.
+
+        If the first non whitespace character of a line is the symbol ``#``
+        it is assumed this is a preprocessor directive.
+
+        Preprocessor directives can be used only in Fortran codes. They are
+        ignored when used inside PYF files.
+
+        The actual line content is not altered.
+
+        :param str line: the line to be tested for directives.
+
+        :return: a tuple containing the line and True/False depending on \
+                 whether it holds a C preprocessor directive.
+        :rtype: (str, bool)
+
+        """
+        if not line or self._format.is_pyf:
+            return (line, False)
+        return (line, line.lstrip().startswith("#"))
+
     def handle_cf2py_start(self, line):
-        """ Apply f2py directives to line.
+        """
+        Process any f2py directives contained in the supplied line. If
+        support for such directives has been disabled then the line is
+        returned unchanged.
 
         F2py directives are specified in the beginning of the line.
 
         f2py directives can be used only in Fortran codes.  They are
         ignored when used inside PYF files.
 
-        Parameters
-        ----------
-        line : str
+        :param str line: the line to check for f2py directives.
+
+        :returns: the line with any f2py directives applied (if they are \
+                  enabled in the reader).
+        :rtype: str
 
-        Returns
-        -------
-        line : str
         """
-        if not line or self._format.is_pyf:
+        if not line or self._format.is_pyf or not self._format.f2py_enabled:
             return line
         if self._format.is_fixed:
-            if line[0] in '*cC!#':
-                if line[1:5].lower() == 'f2py':
-                    line = 5*' ' + line[5:]
+            if line[0] in "*cC!#":
+                if line[1:5].lower() == "f2py":
+                    line = 5 * " " + line[5:]
                     self.f2py_comment_lines.append(self.linecount)
             if self._format.is_f77:
                 return line
         m = _CF2PY_RE.match(line)
         if m:
-            newline = m.group('indent')+5*' '+m.group('rest')
+            newline = m.group("indent") + 5 * " " + m.group("rest")
             self.f2py_comment_lines.append(self.linecount)
             assert len(newline) == len(line), repr((newline, line))
             return newline
         return line
 
     def handle_inline_comment(self, line, lineno, quotechar=None):
         """
@@ -1021,515 +1110,545 @@
         :param str line: line of code from which to remove in-line comment
         :param int lineno: line-no. in orig. file
         :param quotechar: String to use as character-string delimiter
         :type quotechar: {None, str}
 
         :return: line_with_no_comments, quotechar, had_comment
         :rtype: 3-tuple of str, str, bool
+
         """
         had_comment = False
-        if quotechar is None and '!' not in line and \
-           '"' not in line and "'" not in line:
+        if (
+            quotechar is None
+            and "!" not in line
+            and '"' not in line
+            and "'" not in line
+        ):
             # There's no comment on this line
             return line, quotechar, had_comment
 
-        idx = line.find('!')
+        idx = line.find("!")
         put_item = self.fifo_item.append
         if quotechar is None and idx != -1:
             # first try a quick method:
             newline = line[:idx]
-            if '"' not in newline and '\'' not in newline:
-                if self.format.is_f77 or not line[idx:].startswith('!f2py'):
+            if '"' not in newline and "'" not in newline:
+                if self.format.is_f77 or not line[idx:].startswith("!f2py"):
                     put_item(self.comment_item(line[idx:], lineno, lineno))
                     return newline, quotechar, True
 
         # We must allow for quotes...
         items, newquotechar = splitquote(line, quotechar)
         noncomment_items = []
         noncomment_items_append = noncomment_items.append
-        n = len(items)
+
         commentline = None
-        for k in range(n):
-            item = items[k]
-            if isinstance(item, String) or '!' not in item:
+        for idx, item in enumerate(items[:]):
+            if isinstance(item, String) or "!" not in item:
                 noncomment_items_append(item)
                 continue
-            j = item.find('!')
+            j = item.find("!")
             noncomment_items_append(item[:j])
-            items[k] = item[j:]
-            commentline = ''.join(items[k:])
+            items[idx] = item[j:]
+            # The rest of the line must be a comment.
+            commentline = "".join(items[idx:])
+            # As such, any quotation marks in it can be ignored.
+            newquotechar = None
             break
         if commentline is not None:
-            if commentline.startswith('!f2py'):
+            if self._format.f2py_enabled and commentline.startswith("!f2py"):
                 # go to next iteration:
-                newline = ''.join(noncomment_items) + commentline[5:]
+                newline = "".join(noncomment_items) + commentline[5:]
                 self.f2py_comment_lines.append(lineno)
                 return self.handle_inline_comment(newline, lineno, quotechar)
             put_item(self.comment_item(commentline, lineno, lineno))
             had_comment = True
-        return ''.join(noncomment_items), newquotechar, had_comment
+        return "".join(noncomment_items), newquotechar, had_comment
 
     def handle_multilines(self, line, startlineno, mlstr):
         '''
         Examines line for Python triple quote strings (f2py feature).
 
         :param str line: line of Fortran source text
-        :param int startlineno: the number of the line on which this
+        :param int startlineno: the number of the line on which this \
                                  multi-line string began.
-        :param list mlstr: list of delimiters for a multi-line string
+        :param list mlstr: list of delimiters for a multi-line string \
                            (e.g. '"""')
         '''
         i = line.find(mlstr)
         if i != -1:
             prefix = line[:i]
             # skip fake multiline starts
             p, k = prefix, 0
-            while p.endswith('\\'):
+            while p.endswith("\\"):
                 p, k = p[:-1], k + 1
             if k % 2:
                 return
-        if i != -1 and '!' not in prefix:
+        if i != -1 and "!" not in prefix:
             # Note character constants like 'abc"""123',
             # so multiline prefix should better not contain `'' or `"' not `!'.
-            for quote in '"\'':
+            for quote in "\"'":
                 if prefix.count(quote) % 2:
-                    message = 'multiline prefix contains odd number of' \
-                              + ' {!r} characters'.format(quote)
-                    message = self.format_warning_message(message,
-                                                          startlineno,
-                                                          startlineno,
-                                                          0,
-                                                          len(prefix))
+                    message = (
+                        "multiline prefix contains odd number of"
+                        + " {!r} characters".format(quote)
+                    )
+                    message = self.format_warning_message(
+                        message, startlineno, startlineno, 0, len(prefix)
+                    )
                     logging.getLogger(__name__).warning(message)
 
             suffix = None
             multilines = []
-            line = line[i+3:]
+            line = line[i + 3 :]
             while line is not None:
                 j = line.find(mlstr)
-                if j != -1 and '!' not in line[:j]:
+                if j != -1 and "!" not in line[:j]:
                     multilines.append(line[:j])
-                    suffix = line[j+3:]
+                    suffix = line[j + 3 :]
                     break
                 multilines.append(line)
                 line = self.get_single_line()
             if line is None:
-                message = 'multiline block never ends'
-                message = self.format_error_message(message,
-                                                    startlineno,
-                                                    startlineno,
-                                                    i)
-                return self.multiline_item(prefix,
-                                           multilines,
-                                           suffix,
-                                           startlineno,
-                                           self.linecount,
-                                           message)
-            suffix, qc, had_comment \
-                = self.handle_inline_comment(suffix, self.linecount)
+                message = "multiline block never ends"
+                message = self.format_error_message(
+                    message, startlineno, startlineno, i
+                )
+                return self.multiline_item(
+                    prefix, multilines, suffix, startlineno, self.linecount, message
+                )
+            suffix, qc, had_comment = self.handle_inline_comment(suffix, self.linecount)
             # no line continuation allowed in multiline suffix
             if qc is not None:
-                message = 'following character continuation: {!r},' \
-                          + ' expected None.'
-                message = self.format_message('ASSERTION FAILURE(pyf)',
-                                              message.format(qc),
-                                              startlineno,
-                                              self.linecount)
+                message = "following character continuation: {!r}," + " expected None."
+                message = self.format_message(
+                    "ASSERTION FAILURE(pyf)",
+                    message.format(qc),
+                    startlineno,
+                    self.linecount,
+                )
                 logging.getLogger(__name__).warning(message)
             # XXX: should we do line.replace('\\'+mlstr[0],mlstr[0])
             #      for line in multilines?
-            return self.multiline_item(prefix,
-                                       multilines,
-                                       suffix,
-                                       startlineno,
-                                       self.linecount)
+            return self.multiline_item(
+                prefix, multilines, suffix, startlineno, self.linecount
+            )
 
     # The main method of interpreting raw source lines within
     # the following contexts: f77, fixed, free, pyf.
 
     def get_source_item(self):
-        """ Return next source item.
+        """
+        Return the next source item.
 
-        A source item is ..
+        A source item is\:
         - a fortran line
         - a list of continued fortran lines
-        - a multiline - lines inside triple-qoutes, only when in ispyf mode
+        - a multiline - lines inside triple-quotes, only when in ispyf mode
         - a comment line
+        - a preprocessor directive line
+
+        :returns: the next source item.
+        :rtype: :py:class:`fparser.common.readfortran.Line` or \
+            :py:class:`fparser.common.readfortran.MultiLine` or \
+            :py:class:`fparser.common.readfortran.Comment` or \
+            :py:class:`fparser.common.readfortran.CppDirective` or \
+            :py:class:`fparser.common.readfortran.SyntaxErrorLine` or \
+            :py:class:`fparser.common.readfortran.SyntaxErrorMultiLine`
+
         """
         get_single_line = self.get_single_line
         line = get_single_line()
         if line is None:
-            return
+            return None
         startlineno = self.linecount
+        line, is_cpp_directive = self.handle_cpp_directive(line)
+        if is_cpp_directive:
+            # CPP directive line
+            lines = []
+            while line.rstrip().endswith("\\"):
+                # Line continuation
+                lines.append(line.rstrip()[:-1])
+                line = get_single_line()
+            lines.append(line)
+            endlineno = self.linecount
+            return self.cpp_directive_item("".join(lines), startlineno, endlineno)
+
         line = self.handle_cf2py_start(line)
-        is_f2py_directive = startlineno in self.f2py_comment_lines
+        is_f2py_directive = (
+            self._format.f2py_enabled and startlineno in self.f2py_comment_lines
+        )
         isstrict = self._format.is_strict
         have_comment = False
         label = None
         name = None
 
         if self._format.is_pyf:
             # handle multilines
             for mlstr in ['"""', "'''"]:
-                r = self.handle_multilines(line, startlineno, mlstr)
-                if r:
-                    return r
+                multiline = self.handle_multilines(line, startlineno, mlstr)
+                if multiline:
+                    return multiline
         if self._format.is_fixed:
-            if _is_fix_comment(line, isstrict):
+            if _is_fix_comment(line, isstrict, self._format.f2py_enabled):
                 # comment line:
                 return self.comment_item(line, startlineno, startlineno)
 
             for i in range(min(5, len(line))):
                 # check that fixed format line starts according to Fortran
                 # standard
                 if line[i] not in _SPACEDIGITS:
-                    message = 'non-space/digit char %r found in column %i'\
-                              ' of fixed Fortran code' % (line[i], i + 1)
+                    message = (
+                        "non-space/digit char %r found in column %i"
+                        " of fixed Fortran code" % (line[i], i + 1)
+                    )
                     if i == 0:
-                        message += ', interpreting line as comment line'
+                        message += ", interpreting line as comment line"
                     if self._format.is_fix:
                         if i != 0:
-                            message += ', switching to free format mode'
-                        message = self.format_warning_message(message,
-                                                              startlineno,
-                                                              self.linecount)
+                            message += ", switching to free format mode"
+                        message = self.format_warning_message(
+                            message, startlineno, self.linecount
+                        )
                         logging.getLogger(__name__).warning(message)
                         if i == 0:
                             # non standard comment line:
-                            return self.comment_item(line,
-                                                     startlineno,
-                                                     startlineno)
-                        mode = fparser.common.sourceinfo.FortranFormat(True,
-                                                                       False)
+                            return self.comment_item(line, startlineno, startlineno)
+                        mode = fparser.common.sourceinfo.FortranFormat(True, False)
                         self.set_format(mode)
                     else:
-                        message = self.format_warning_message(message,
-                                                              startlineno,
-                                                              self.linecount)
+                        message = self.format_warning_message(
+                            message, startlineno, self.linecount
+                        )
                         logging.getLogger(__name__).warning(message)
                         if i == 0:
                             # non standard comment line:
-                            return self.comment_item(line,
-                                                     startlineno,
-                                                     startlineno)
+                            return self.comment_item(line, startlineno, startlineno)
                         # return line item with error message
                         # TODO: handle cases with line[6:]==''
-                        message = self.format_error_message(message,
-                                                            startlineno,
-                                                            self.linecount)
-                        return self.line_item(line[6:],
-                                              startlineno,
-                                              self.linecount,
-                                              label,
-                                              name,
-                                              message)
+                        message = self.format_error_message(
+                            message, startlineno, self.linecount
+                        )
+                        return self.line_item(
+                            line[6:], startlineno, self.linecount, label, name, message
+                        )
             if self._format.is_fixed:  # Check for switched to free format
                 # check for label
                 s = line[:5].strip().lower()
                 if s:
                     label = int(s)
                 if not self._format.is_f77:
                     m = _CONSTRUCT_NAME_RE.match(line[6:])
                     if m:
-                        name = m.group('name')
-                        line = line[:6] + line[6:][m.end():].lstrip()
+                        name = m.group("name")
+                        line = line[:6] + line[6:][m.end() :].lstrip()
                 if not line[6:].strip():
                     # check for a blank line
                     if name is not None:
-                        self.error('No construct following construct-name.')
+                        self.error("No construct following construct-name.")
                     elif label is not None:
-                        self.warning('Label must follow nonblank character'
-                                     + ' (F2008:3.2.5_2)')
-                    return self.comment_item('', startlineno, self.linecount)
+                        self.warning(
+                            "Label must follow nonblank character" + " (F2008:3.2.5_2)"
+                        )
+                    return self.comment_item("", startlineno, self.linecount)
                 # line is not a comment and the start of the line is valid
 
         if self._format.is_f77 and not is_f2py_directive:
             # Fortran 77 is easy..
             lines = [line[6:72]]
             # get_next_line does not actually consume lines - they are put
             # into the FILO buffer as well as being returned. This means
             # that we can ignore comments for the purposes of dealing
             # with the continued line and then handle them as though they
             # follow on after the single line constructed from the multiple
             # continued lines.
-            while _is_fix_cont(self.get_next_line(ignore_empty=True,
-                                                  ignore_comments=True)):
+            while _is_fix_cont(
+                self.get_next_line(ignore_empty=True, ignore_comments=True)
+            ):
                 # handle fix format line continuations for F77 code
                 line = get_single_line()
                 lines.append(line[6:72])
-            return self.line_item(''.join(lines), startlineno,
-                                  self.linecount, label, name)
+            return self.line_item(
+                "".join(lines), startlineno, self.linecount, label, name
+            )
 
         handle_inline_comment = self.handle_inline_comment
 
         endlineno = self.linecount
         if self._format.is_fix and not is_f2py_directive:
             # handle inline comment
-            newline, qc, had_comment = handle_inline_comment(line[6:],
-                                                             startlineno)
+            newline, qc, had_comment = handle_inline_comment(line[6:], startlineno)
             have_comment |= had_comment
             lines = [newline]
             next_line = self.get_next_line()
 
-            while _is_fix_cont(next_line) or _is_fix_comment(next_line,
-                                                             isstrict):
+            while _is_fix_cont(next_line) or _is_fix_comment(
+                next_line, isstrict, self._format.f2py_enabled
+            ):
                 # handle fix format line continuations for F90 or
                 # newer code.  Mixing fix format and free format line
                 # continuations is not allowed nor detected, just
                 # eject warnings.
                 line2 = get_single_line()  # consume next_line as line2
-                if _is_fix_comment(line2, isstrict):
+                if _is_fix_comment(line2, isstrict, self._format.f2py_enabled):
                     # handle fix format comments inside line continuations
                     # after the line construction
-                    citem = self.comment_item(line2,
-                                              self.linecount,
-                                              self.linecount)
+                    citem = self.comment_item(line2, self.linecount, self.linecount)
                     self.fifo_item.append(citem)
                 else:
                     # line continuation
-                    newline, qc, had_comment \
-                        = self.handle_inline_comment(line2[6:],
-                                                     self.linecount,
-                                                     qc)
+                    newline, qc, had_comment = self.handle_inline_comment(
+                        line2[6:], self.linecount, qc
+                    )
                     have_comment |= had_comment
                     lines.append(newline)
                     endlineno = self.linecount
                 next_line = self.get_next_line()
             # no character continuation should follows now
             if qc is not None:
-                message = 'following character continuation: ' \
-                          + '{!r}, expected None.'
-                message = self.format_message('ASSERTION FAILURE(fix)',
-                                              message.format(qc),
-                                              startlineno,
-                                              self.linecount)
+                message = "following character continuation: " + "{!r}, expected None."
+                message = self.format_message(
+                    "ASSERTION FAILURE(fix)",
+                    message.format(qc),
+                    startlineno,
+                    self.linecount,
+                )
                 logging.getLogger(__name__).warning(message)
             if len(lines) > 1:
                 for i in range(len(lines)):
                     line = lines[i]
-                    if line.rstrip().endswith('&'):
-                        message = 'free format line continuation character ' \
-                                  + "`&' detected in fix format code"
-                        location = line.rfind('&') + 5
-                        message = self.format_warning_message(message,
-                                                              startlineno + i,
-                                                              startlineno + i,
-                                                              location)
+                    if line.rstrip().endswith("&"):
+                        message = (
+                            "free format line continuation character "
+                            + "`&' detected in fix format code"
+                        )
+                        location = line.rfind("&") + 5
+                        message = self.format_warning_message(
+                            message, startlineno + i, startlineno + i, location
+                        )
                         logging.getLogger(__name__).warning(message)
-            return self.line_item(''.join(lines),
-                                  startlineno,
-                                  endlineno,
-                                  label,
-                                  name)
+            return self.line_item("".join(lines), startlineno, endlineno, label, name)
 
         # line is free format or fixed format with f2py directive (that
-        # will be interpretted as free format line).
+        # will be interpreted as free format line).
 
         start_index = 0
         if self._format.is_fix:
             start_index = 6
         lines = []
         lines_append = lines.append
         put_item = self.fifo_item.append
-        qc = None
+        qchar = None
         while line is not None:
             if start_index:  # fix format code
-                line, qc, had_comment \
-                    = handle_inline_comment(line[start_index:],
-                                            self.linecount, qc)
+                line, qchar, had_comment = handle_inline_comment(
+                    line[start_index:], self.linecount, qchar
+                )
                 have_comment |= had_comment
                 is_f2py_directive = self.linecount in self.f2py_comment_lines
             else:
                 # free format
                 line_lstrip = line.lstrip()
                 if lines:
-                    if line_lstrip.startswith('!'):
+                    if line_lstrip.startswith("!"):
                         # check for comment line within line continuation
-                        put_item(self.comment_item(line_lstrip,
-                                                   self.linecount,
-                                                   self.linecount))
+                        put_item(
+                            self.comment_item(
+                                line_lstrip, self.linecount, self.linecount
+                            )
+                        )
                         have_comment = True
                         line = get_single_line()
                         continue
                     elif line_lstrip == "":
                         # skip blank lines within a line continuation
                         line = get_single_line()
                         continue
                 else:
-                    # first line, check for a label
-                    m = _LABEL_RE.match(line)
-                    if m:
-                        assert not label, repr(label)
-                        label = int(m.group('label'))
-                        line = line[m.end():]
-                    # check for a construct name
-                    m = _CONSTRUCT_NAME_RE.match(line)
-                    if m:
-                        name = m.group('name')
-                        line = line[m.end():].lstrip()
-                line, qc, had_comment = handle_inline_comment(line,
-                                                              self.linecount,
-                                                              qc)
+                    # Extract label and/or construct name from line if
+                    # there is one.
+                    label, line = extract_label(line)
+                    name, line = extract_construct_name(line)
+
+                line, qchar, had_comment = handle_inline_comment(
+                    line, self.linecount, qchar
+                )
                 have_comment |= had_comment
                 is_f2py_directive = self.linecount in self.f2py_comment_lines
 
-            i = line.rfind('&')
+            i = line.rfind("&")
             if i != -1:
-                line_i1_rstrip = line[i+1:].rstrip()
+                line_i1_rstrip = line[i + 1 :].rstrip()
             if not lines:
                 # first line
                 if i == -1 or line_i1_rstrip:
                     lines_append(line)
                     break
                 endlineno = self.linecount
                 lines_append(line[:i])
                 line = get_single_line()
                 continue
             if i == -1 or line_i1_rstrip:
                 # no line continuation follows
                 i = len(line)
             k = -1
             if i != -1:
-                # handle the beggining of continued line
-                k = line[:i].find('&')
+                # handle the beginning of continued line
+                k = line[:i].find("&")
                 if k != 1 and line[:k].lstrip():
                     k = -1
             endlineno = self.linecount
-            lines_append(line[k+1:i])
+            lines_append(line[k + 1 : i])
             if i == len(line):
                 break
             line = get_single_line()
 
-        if qc is not None:
-            message = 'following character continuation: {!r}, ' \
-                      + 'expected None.'
-            message = self.format_message('ASSERTION FAILURE(free)',
-                                          message.format(qc),
-                                          startlineno,
-                                          endlineno)
+        if qchar is not None:
+            message = "following character continuation: {!r}, " + "expected None."
+            message = self.format_message(
+                "ASSERTION FAILURE(free)", message.format(qchar), startlineno, endlineno
+            )
             logging.getLogger(__name__).error(message)
-        line_content = ''.join(lines).strip()
+        line_content = "".join(lines).strip()
         if line_content:
-            return self.line_item(line_content,
-                                  startlineno,
-                                  endlineno,
-                                  label,
-                                  name)
+            return self.line_item(line_content, startlineno, endlineno, label, name)
         if label is not None:
-            message = 'Label must follow nonblank character (F2008:3.2.5_2)'
+            message = "Label must follow nonblank character (F2008:3.2.5_2)"
             self.warning(message)
         if name is not None:
-            self.error('No construct following construct-name.')
-        if have_comment:
-            return next(self)
-        return self.comment_item('', startlineno, endlineno)
+            self.error("No construct following construct-name.")
+
+        # If this point is reached, the line is a comment or is
+        # blank. If it is a comment, it has been pushed onto the
+        # fifo_item list.
+        try:
+            return self.fifo_item.pop(0)
+        except IndexError:
+            # A blank line is represented as an empty comment
+            return Comment("", (startlineno, endlineno), self)
 
 
 class FortranFileReader(FortranReaderBase):
-    '''
+    """
     Constructs a FortranFileReader object from a file.
 
     :param file_candidate: A filename or file-like object.
     :param list include_dirs: Directories in which to look for inclusions.
-    :param list source_only: Fortran source files to search for modules
+    :param list source_only: Fortran source files to search for modules \
                              required by "use" statements.
     :param bool ignore_comments: Whether or not to ignore comments
+    :param Optional[bool] ignore_encoding: whether or not to ignore Python-style \
+        encoding information (e.g. "-*- fortran -*-") when attempting to determine \
+        the format of the file. Default is True.
+
+    For example::
+
+        >>> from fparser.common.readfortran import FortranFileReader
+        >>> import os
+        >>> reader = FortranFileReader(\'myfile.f90\')
 
-    For example:
-
-    >>> from fparser.common.readfortran import FortranFileReader
-    >>> import os
-    >>> reader = FortranFileReader(\'myfile.f90\')
+    """
 
-    '''
-    def __init__(self, file_candidate, include_dirs=None, source_only=None,
-                 ignore_comments=True):
+    def __init__(
+        self,
+        file_candidate,
+        include_dirs=None,
+        source_only=None,
+        ignore_comments=True,
+        ignore_encoding=True,
+    ):
         # The filename is used as a unique ID. This is then used to cache the
         # contents of the file. Obviously if the file changes content but not
         # filename, problems will ensue.
         #
-        self._remove_on_destruction = False
         self._close_on_destruction = False
-        if isinstance(file_candidate, six.string_types):
+        if isinstance(file_candidate, str):
             self.id = file_candidate
-            from fparser.common.utils import make_clean_tmpfile
-            # Handle potential invalid characters in the input. Done
-            # by creating a new file (tmpfile) with any errors removed
-            # (or raising an exception - see make_clean_tmpfile).
-            tmpfile = make_clean_tmpfile(file_candidate)
-            self.file = io.open(tmpfile, 'r', encoding='UTF-8')
+            # The 'fparser-logging' handler for errors ensures that any invalid
+            # characters in the input are skipped but logged.
+            self.file = open(
+                file_candidate, "r", encoding="UTF-8", errors="fparser-logging"
+            )
             self._close_on_destruction = True
-            self._remove_on_destruction = True
-        elif hasattr(file_candidate,
-                     'read') and hasattr(file_candidate,
-                                         'name'):  # Is likely a file
+        elif hasattr(file_candidate, "read") and hasattr(
+            file_candidate, "name"
+        ):  # Is likely a file
             self.id = file_candidate.name
             self.file = file_candidate
         else:  # Probably not something we can deal with
-            message = 'FortranFileReader is used with a filename'
-            message += ' or file-like object.'
+            message = "FortranFileReader is used with a filename"
+            message += " or file-like object."
             raise ValueError(message)
-        mode = fparser.common.sourceinfo.get_source_info(file_candidate)
+        mode = fparser.common.sourceinfo.get_source_info(
+            file_candidate, ignore_encoding
+        )
 
-        FortranReaderBase.__init__(self, self.file, mode, ignore_comments)
+        super().__init__(self.file, mode, ignore_comments)
 
         if include_dirs is None:
             self.include_dirs.insert(0, os.path.dirname(self.id))
         else:
             self.include_dirs = include_dirs[:]
         if source_only is not None:
             self.source_only = source_only[:]
-        return
 
     def __del__(self):
         if self._close_on_destruction:
             self.file.close()
-            if self._remove_on_destruction:
-                os.remove(self.file.name)
 
     def close_source(self):
         self.file.close()
 
 
 class FortranStringReader(FortranReaderBase):
-    '''
+    """
     Reads Fortran source code as a string.
 
     :param str string: string to read
     :param list include_dirs: List of dirs to search for include files
-    :param list source_only: Fortran source files to search for modules
+    :param list source_only: Fortran source files to search for modules \
                              required by "use" statements.
     :param bool ignore_comments: Whether or not to ignore comments
+    :param Optional[bool] ignore_encoding: whether or not to ignore Python-style \
+        encoding information (e.g. "-*- fortran -*-") when attempting to determine \
+        the format of the source. Default is True.
 
     For example:
 
     >>> from fparser.common.readfortran import FortranStringReader
     >>> code = \'\'\'
              subroutine foo(a)
                 integer a
                 print*,\"a=\",a
               end
         \'\'\'
     >>> reader = FortranStringReader(code)
 
-    '''
-    def __init__(self, string, include_dirs=None, source_only=None,
-                 ignore_comments=True):
+    """
+
+    def __init__(
+        self,
+        string,
+        include_dirs=None,
+        source_only=None,
+        ignore_comments=True,
+        ignore_encoding=True,
+    ):
         # The Python ID of the string was used to uniquely identify it for
         # caching purposes. Unfortunately this ID is only unique for the
         # lifetime of the string. In CPython it is the address of the string
         # and the chance of a new string being allocated to the same address
         # is actually quite high. Particularly in a unit-testing scenario.
         #
         # For this reason the hash is used instead. A much better solution
         # anyway.
         #
-        self.id = 'string-' + str(hash(string))
-        source = six.StringIO(string)
-        mode = fparser.common.sourceinfo.get_source_info_str(string)
-        FortranReaderBase.__init__(self, source, mode,
-                                   ignore_comments)
+        self.id = "string-" + str(hash(string))
+        source = StringIO(string)
+        mode = fparser.common.sourceinfo.get_source_info_str(
+            string, ignore_encoding=ignore_encoding
+        )
+        super().__init__(source, mode, ignore_comments)
         if include_dirs is not None:
             self.include_dirs = include_dirs[:]
         if source_only is not None:
             self.source_only = source_only[:]
-        return
```

### Comparing `fparser-0.0.9/src/fparser/common/sourceinfo.py` & `fparser-0.1.0/src/fparser/common/sourceinfo.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,9 +1,9 @@
-# Modified work Copyright (c) 2017-2019 Science and Technology
-# Facilities Council
+# Modified work Copyright (c) 2017-2023 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -59,266 +59,285 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-'''
+"""
 Provides functions to determine whether a piece of Fortran source is free or
 fixed format. It also tries to differentiate between strict and "pyf" although
 I'm not sure what that is.
-'''
 
-import io
+"""
 import os
 import re
-import six
 
 
 ##############################################################################
 
-class FortranFormat(object):
-    '''
+
+class FortranFormat:
+    """
     Describes the nature of a piece of Fortran source.
 
     Source can be fixed or free format. It can also be "strict" or
     "not strict" although it's not entirely clear what that means. It may
     refer to the strictness of adherance to fixed format although what that
     means in the context of free format I don't know.
-    '''
-    def __init__(self, is_free, is_strict):
-        '''
-        Constructs a FortranFormat object from the describing parameters.
 
-        Arguments:
-            is_free   - (Boolean) True for free format, False for fixed.
-            is_strict - (Boolean) Some amount of strictness.
-        '''
+    :param bool is_free: True for free format, False for fixed.
+    :param bool is_strict: some amount of strictness.
+    :param bool enable_f2py: whether f2py directives are enabled or treated \
+                             as comments (the default).
+    """
+
+    def __init__(self, is_free, is_strict, enable_f2py=False):
         if is_free is None:
-            raise Exception('FortranFormat does not accept a None is_free')
+            raise Exception("FortranFormat does not accept a None is_free")
         if is_strict is None:
-            raise Exception('FortranFormat does not accept a None is_strict')
+            raise Exception("FortranFormat does not accept a None is_strict")
 
         self._is_free = is_free
         self._is_strict = is_strict
+        self._f2py_enabled = enable_f2py
 
     @classmethod
     def from_mode(cls, mode):
-        '''
+        """
         Constructs a FortranFormat object from a mode string.
 
         Arguments:
             mode - (String) One of 'free', 'fix', 'f77' or 'pyf'
-        '''
-        if mode == 'free':
+        """
+        if mode == "free":
             is_free, is_strict = True, False
-        elif mode == 'fix':
+        elif mode == "fix":
             is_free, is_strict = False, False
-        elif mode == 'f77':
+        elif mode == "f77":
             is_free, is_strict = False, True
-        elif mode == 'pyf':
+        elif mode == "pyf":
             is_free, is_strict = True, True
         else:
             raise NotImplementedError(repr(mode))
         return cls(is_free, is_strict)
 
     def __eq__(self, other):
         if isinstance(other, FortranFormat):
-            return self.is_free == other.is_free \
-                   and self.is_strict == other.is_strict
+            return (
+                self.is_free == other.is_free
+                and self.is_strict == other.is_strict
+                and self.f2py_enabled == other.f2py_enabled
+            )
         raise NotImplementedError
 
     def __str__(self):
         if self.is_strict:
-            string = 'Strict'
+            string = "Strict"
         else:
-            string = 'Non-strict'
+            string = "Non-strict"
 
         if self.is_free:
-            string += ' free'
+            string += " free"
         else:
-            string += ' fixed'
+            string += " fixed"
 
-        return string + ' format'
+        return string + " format"
 
     @property
     def is_free(self):
-        '''
+        """
         Returns true for free format.
-        '''
+        """
         return self._is_free
 
     @property
     def is_fixed(self):
-        '''
+        """
         Returns true for fixed format.
-        '''
+        """
         return not self._is_free
 
     @property
     def is_strict(self):
-        '''
+        """
         Returns true for strict format.
-        '''
+        """
         return self._is_strict
 
     @property
     def is_f77(self):
-        '''
+        """
         Returns true for strict fixed format.
-        '''
+        """
         return not self._is_free and self._is_strict
 
     @property
     def is_fix(self):
-        '''
+        """
         Returns true for slack fixed format.
-        '''
+        """
         return not self._is_free and not self._is_strict
 
     @property
     def is_pyf(self):
-        '''
+        """
         Returns true for strict free format.
-        '''
+        """
         return self._is_free and self._is_strict
 
     @property
+    def f2py_enabled(self):
+        """
+        :returns: whether or not f2py directives are enabled.
+        :rtype: bool
+        """
+        return self._f2py_enabled
+
+    @property
     def mode(self):
-        '''
+        """
         Returns a string representing this format.
-        '''
+        """
         if self._is_free and self._is_strict:
-            mode = 'pyf'
+            mode = "pyf"
         elif self._is_free:
-            mode = 'free'
+            mode = "free"
         elif self.is_fix:
-            mode = 'fix'
+            mode = "fix"
         elif self.is_f77:
-            mode = 'f77'
+            mode = "f77"
         # While mode is determined by is_free and is_strict all permutations
         # are covered. There is no need for a final "else" clause as the
         # object cannot get wedged in an invalid mode.
         return mode
 
 
 ##############################################################################
 
-_HAS_F_EXTENSION = re.compile(r'.*[.](for|ftn|f77|f)\Z', re.I).match
+_HAS_F_EXTENSION = re.compile(r".*[.](for|ftn|f77|f)\Z", re.I).match
 
-_HAS_F_HEADER = re.compile(r'-[*]-\s*(fortran|f77)\s*-[*]-', re.I).search
-_HAS_F90_HEADER = re.compile(r'-[*]-\s*f90\s*-[*]-', re.I).search
-_HAS_F03_HEADER = re.compile(r'-[*]-\s*f03\s*-[*]-', re.I).search
-_HAS_F08_HEADER = re.compile(r'-[*]-\s*f08\s*-[*]-', re.I).search
-_HAS_FREE_HEADER = re.compile(r'-[*]-\s*(f90|f95|f03|f08)\s*-[*]-',
-                              re.I).search
-_HAS_FIX_HEADER = re.compile(r'-[*]-\s*fix\s*-[*]-', re.I).search
-_HAS_PYF_HEADER = re.compile(r'-[*]-\s*pyf\s*-[*]-', re.I).search
+_HAS_F_HEADER = re.compile(r"-[*]-\s*(fortran|f77)\s*-[*]-", re.I).search
+_HAS_F90_HEADER = re.compile(r"-[*]-\s*f90\s*-[*]-", re.I).search
+_HAS_F03_HEADER = re.compile(r"-[*]-\s*f03\s*-[*]-", re.I).search
+_HAS_F08_HEADER = re.compile(r"-[*]-\s*f08\s*-[*]-", re.I).search
+_HAS_FREE_HEADER = re.compile(r"-[*]-\s*(f90|f95|f03|f08)\s*-[*]-", re.I).search
+_HAS_FIX_HEADER = re.compile(r"-[*]-\s*fix\s*-[*]-", re.I).search
+_HAS_PYF_HEADER = re.compile(r"-[*]-\s*pyf\s*-[*]-", re.I).search
 
-_FREE_FORMAT_START = re.compile(r'[^c*!]\s*[^\s\d\t]', re.I).match
+_FREE_FORMAT_START = re.compile(r"[^c*!]\s*[^\s\d\t]", re.I).match
 
 
-def get_source_info_str(source):
-    '''
+def get_source_info_str(source, ignore_encoding=True):
+    """
     Determines the format of Fortran source held in a string.
 
-    Returns a FortranFormat object.
-    '''
+    :param bool ignore_encoding: whether or not to ignore any Python-style \
+                                 encoding information in the first line of the file.
+
+    :returns: a FortranFormat object.
+    :rtype: :py:class:`fparser.common.sourceinfo.FortranFormat`
+
+    """
     lines = source.splitlines()
     if not lines:
         return FortranFormat(False, False)
 
-    firstline = lines[0].lstrip()
-    if _HAS_F_HEADER(firstline):
-        return FortranFormat(False, True)
-    if _HAS_FIX_HEADER(firstline):
-        return FortranFormat(False, False)
-    if _HAS_FREE_HEADER(firstline):
-        return FortranFormat(True, False)
-    if _HAS_PYF_HEADER(firstline):
-        return FortranFormat(True, True)
+    if not ignore_encoding:
+        # We check to see whether the file contains a comment describing its
+        # encoding. This has nothing to do with the Fortran standard (see e.g.
+        # https://peps.python.org/pep-0263/) and hence is not done by default.
+        firstline = lines[0].lstrip()
+        if _HAS_F_HEADER(firstline):
+            # -*- fortran -*- implies Fortran77 so fixed format.
+            return FortranFormat(False, True)
+        if _HAS_FIX_HEADER(firstline):
+            return FortranFormat(False, False)
+        if _HAS_FREE_HEADER(firstline):
+            return FortranFormat(True, False)
+        if _HAS_PYF_HEADER(firstline):
+            return FortranFormat(True, True)
 
     line_tally = 10000  # Check up to this number of non-comment lines
     is_free = False
     while line_tally > 0 and lines:
         line = lines.pop(0).rstrip()
-        if line and line[0] != '!':
+        if line and line[0] != "!":
             line_tally -= 1
-            if line[0] != '\t' and _FREE_FORMAT_START(line[:5]) \
-               or line[-1:] == '&':
+            if line[0] != "\t" and _FREE_FORMAT_START(line[:5]) or line[-1:] == "&":
                 is_free = True
                 break
 
     return FortranFormat(is_free, False)
 
 
 ##############################################################################
 
-def get_source_info(file_candidate):
-    '''
+
+def get_source_info(file_candidate, ignore_encoding=True):
+    """
     Determines the format of Fortran source held in a file.
 
     :param file_candidate: a filename or a file object
-    :type file_candidate: str or (file (py2) or _io.TextIOWrapper (py3))
+    :type file_candidate: str or _io.TextIOWrapper (py3)
 
     :returns: the Fortran format encoded as a string.
     :rtype: str
 
-    '''
-    if hasattr(file_candidate, 'name') and hasattr(file_candidate, 'read'):
+    """
+    if hasattr(file_candidate, "name") and hasattr(file_candidate, "read"):
         filename = file_candidate.name
 
-        # The behaviour of file.name when associated with a file without a
-        # file name has changed between Python 2 and 3.
-        #
-        # Under Python 3 file.name holds an integer file handle.
+        # Under Python 3 file.name holds an integer file handle when
+        # associated with a file without a name.
         if isinstance(filename, int):
             filename = None
 
-        # Under Python 2 file.name holds a string of the form "<..>".
-        elif filename.startswith('<') and filename.endswith('>'):
-            filename = None
-    elif isinstance(file_candidate, six.string_types):
-        # The preferred method for identifying strings changed between Python2
-        # and Python3.
+    elif isinstance(file_candidate, str):
         filename = file_candidate
     else:
-        message = 'Argument must be a filename or file-like object.'
+        message = "Argument must be a filename or file-like object."
         raise ValueError(message)
 
     if filename:
         _, ext = os.path.splitext(filename)
-        if ext == '.pyf':
+        if ext == ".pyf":
             return FortranFormat(True, True)
 
-    if hasattr(file_candidate, 'read'):
+    if hasattr(file_candidate, "read"):
         # If the candidate object has a "read" method we assume it's a file
         # object.
         #
         # If it is a file object then it may be in the process of being read.
         # As such we need to take a note of the current state of the file
         # pointer so we can restore it when we've finished what we're doing.
         #
         pointer = file_candidate.tell()
         file_candidate.seek(0)
-        source_info = get_source_info_str(file_candidate.read())
+        source_info = get_source_info_str(
+            file_candidate.read(), ignore_encoding=ignore_encoding
+        )
         file_candidate.seek(pointer)
         return source_info
-    else:
-        # It isn't a file and it passed the type check above so it must be
-        # a string.
-        #
-        # If it's a string we assume it is a filename. In which case we need
-        # to open the named file so we can read it.
-        #
-        # It is closed on completion so as to return it to the state it was
-        # found in.
-        #
-        from fparser.common.utils import make_clean_tmpfile
-        tmpfile = make_clean_tmpfile(file_candidate)
-        with io.open(tmpfile, 'r', encoding='utf8') as file_object:
-            string = get_source_info_str(file_object.read())
-        os.remove(tmpfile)
-        return string
+
+    # It isn't a file and it passed the type check above so it must be
+    # a string.
+    #
+    # If it's a string we assume it is a filename. In which case we need
+    # to open the named file so we can read it.
+    #
+    # It is closed on completion so as to return it to the state it was
+    # found in.
+    #
+    # The 'fparser-logging' handler is setup in fparser/__init__.py and
+    # ensures any occurrences of invalid characters are skipped and
+    # logged.
+    with open(
+        file_candidate, "r", encoding="utf-8", errors="fparser-logging"
+    ) as file_object:
+        string = get_source_info_str(
+            file_object.read(), ignore_encoding=ignore_encoding
+        )
+    return string
+
 
 ##############################################################################
```

### Comparing `fparser-0.0.9/src/fparser/common/splitline.py` & `fparser-0.1.0/src/fparser/common/utils.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-#!/usr/bin/env python
-
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
-# Modified work Copyright (c) 2017 by J. Henrichs, Bureau of Meteorology
+# Modified work Copyright (c) 2017-2022 Science and Technology
+# Facilities Council
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -62,241 +60,323 @@
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 """
-Defines LineSplitter and helper functions.
+Various utility functions.
 
-Original Author: Pearu Peterson <pearu@cens.ioc.ee>
-First version created: May 2006
+Permission to use, modify, and distribute this software is given under the
+terms of the NumPy License. See http://scipy.org.
 
------
-"""
+NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
+Author: Pearu Peterson <pearu@cens.ioc.ee>
+Created: May 2006
 
+"""
 
+__all__ = [
+    "split_comma",
+    "specs_split_comma",
+    "ParseError",
+    "AnalyzeError",
+    "get_module_file",
+    "parse_bind",
+    "parse_result",
+    "is_name",
+    "parse_array_spec",
+    "CHAR_BIT",
+    "str2stmt",
+    "classes",
+]
+
+import logging
+import glob
+import io
+import os
 import re
-import six
+import traceback
 
-class String(six.text_type):
-    ''' Dummy string class. '''
 
+class ParseError(Exception):
+    pass
 
-class ParenString(six.text_type):
-    ''' Class representing a parenthesis string. '''
 
+class AnalyzeError(Exception):
+    pass
+
+
+is_name = re.compile(r"^[a-z_]\w*$", re.I).match
+name_re = re.compile(r"[a-z_]\w*", re.I).match
+is_entity_decl = re.compile(r"^[a-z_]\w*", re.I).match
+is_int_literal_constant = re.compile(r"^\d+(_\w+|)$").match
+module_file_extensions = [".f", ".f90", ".f95", ".f03", ".f08"]
+
+
+def split_comma(line, item=None, comma=",", keep_empty=False, brackets=None):
+    """Split (an optionally bracketed) comma-separated list into
+    items and return a list containing them. If supplied then
+    brackets must be a list of containing two strings, the first
+    being the opening bracket and the second the closing bracket."""
+    # we may have blank space so strip the line
+    line = line.strip()
+    if not line:
+        return []
+    if brackets:
+        if not isinstance(brackets, tuple):
+            raise ParseError("split_comma: brackets must be a tuple")
+        if len(brackets) != 2:
+            raise ParseError(
+                "split_comma: brackets tuple must contain "
+                "just two items but got: {0}",
+                brackets,
+            )
+        open = brackets[0]
+        close = brackets[1]
+        if not line.startswith(open) or not line.endswith(close):
+            return []
+        line = line.strip(brackets[0])
+        line = line.strip(brackets[1])
+    items = []
+    if item is None:
+        for s in line.split(comma):
+            s = s.strip()
+            if not s and not keep_empty:
+                continue
+            items.append(s)
+        return items
+    newitem = item.copy(line, True)
+    apply_map = newitem.apply_map
+    for s in newitem.get_line().split(comma):
+        s = apply_map(s).strip()
+        if not s and not keep_empty:
+            continue
+        items.append(s)
+    return items
 
-__all__ = ['String', 'string_replace_map', 'splitquote', 'splitparen']
 
-_f2py_str_findall = re.compile(r"_F2PY_STRING_CONSTANT_\d+_").findall
-_is_name = re.compile(r'\w*\Z', re.I).match
-_is_simple_str = re.compile(r'\w*\Z', re.I).match
-_f2py_findall = re.compile(
-    r'(_F2PY_STRING_CONSTANT_\d+_|F2PY_EXPR_TUPLE_\d+)').findall
+def extract_bracketed_list_items(line, item=None):
+    """Takes any line that contains "xxx (a,b,...) yyy" and returns
+    a list of items corresponding to a, b, ... Anything outside of
+    the parentheses is ignored. Only works for strings containing
+    a single set of parentheses."""
+    if line.count("(") > 1 or line.count(")") > 1:
+        raise ParseError(
+            "parse_bracketed_list: more than one opening/closing parenthesis "
+            "found in string '{0}'; this is not supported".format(line)
+        )
+    idx1 = line.find("(")
+    idx2 = line.rfind(")")
+    if idx1 < 0 or idx2 < 0 or idx2 < idx1:
+        raise ParseError(
+            "parse_bracketed_list: failed to find expression within "
+            "parentheses in '{0}'".format(line)
+        )
+    items = split_comma(line[idx1 : idx2 + 1], item, brackets=("(", ")"))
+    if item:
+        for idx in range(len(items)):
+            itm = item.copy(items[idx])
+            rlst = []
+            for rpart in itm.get_line().split(":"):
+                rlst.append(itm.apply_map(rpart.strip()))
+            items[idx] = rlst
+    return items
 
 
-class string_replace_dict(dict):
-    """
-    Dictionary object that is callable for applying map returned
-    by string_replace_map() function.
-    """
-    def __call__(self, line):
-        for k in _f2py_findall(line):
-            line = line.replace(k, self[k])
-        return line
+def parse_array_spec(line, item=None):
+    items = []
+    for spec in split_comma(line, item):
+        items.append(tuple(split_comma(spec, item, comma=":", keep_empty=True)))
+    return items
 
 
-def string_replace_map(line, lower=False,
-                       _cache={'index': 0, 'pindex': 0}):
-    """
-    1) Replaces string constants with symbol `'_F2PY_STRING_CONSTANT_<index>_'`
-    2) Replaces (expression) with symbol `(F2PY_EXPR_TUPLE_<index>)`
-    Returns a new line and the replacement map.
-    """
-    items = []
-    string_map = string_replace_dict()
-    rev_string_map = {}
-    for item in splitquote(line, lower=lower)[0]:
-        if isinstance(item, String) and not _is_simple_str(item[1:-1]):
-            key = rev_string_map.get(item)
-            if key is None:
-                _cache['index'] += 1
-                index = _cache['index']
-                key = "_F2PY_STRING_CONSTANT_%s_" % (index)
-                it = item[1:-1]
-                string_map[key] = it
-                rev_string_map[it] = key
-            items.append(item[0]+key+item[-1])
+def specs_split_comma(line, item=None, upper=False):
+    specs0 = split_comma(line, item)
+    specs = []
+    for spec in specs0:
+        i = spec.find("=")
+        if i != -1:
+            kw = spec[:i].strip().upper()
+            v = spec[i + 1 :].strip()
+            specs.append("%s = %s" % (kw, v))
         else:
-            items.append(item)
-    newline = ''.join(items)
-    items = []
-    expr_keys = []
-    for item in splitparen(newline):
-        if isinstance(item, ParenString) and not _is_name(item[1:-1].strip()):
-            key = rev_string_map.get(item)
-            if key is None:
-                _cache['pindex'] += 1
-                index = _cache['pindex']
-                key = 'F2PY_EXPR_TUPLE_%s' % (index)
-                it = item[1:-1].strip()
-                string_map[key] = it
-                rev_string_map[it] = key
-                expr_keys.append(key)
-            items.append(item[0]+key+item[-1])
-        else:
-            items.append(item)
-    found_keys = set()
-    for k in expr_keys:
-        v = string_map[k]
-        l = _f2py_str_findall(v)
-        if l:
-            found_keys = found_keys.union(l)
-            for k1 in l:
-                v = v.replace(k1, string_map[k1])
-            string_map[k] = v
-    for k in found_keys:
-        del string_map[k]
-    return ''.join(items), string_map
+            if upper:
+                spec = spec.upper()
+            specs.append(spec)
+    return specs
+
+
+def parse_bind(line, item=None):
+    if not line.lower().startswith("bind"):
+        return None, line
+    if item is not None:
+        newitem = item.copy(line, apply_map=True)
+        newline = newitem.get_line()
+    else:
+        newitem = None
+    newline = newline[4:].lstrip()
+    i = newline.find(")")
+    assert i != -1, repr(newline)
+    args = []
+    for a in specs_split_comma(newline[1:i].strip(), newitem, upper=True):
+        args.append(a)
+    rest = newline[i + 1 :].lstrip()
+    if item is not None:
+        rest = newitem.apply_map(rest)
+    return args, rest
+
+
+def parse_result(line, item=None):
+    if not line.lower().startswith("result"):
+        return None, line
+    line = line[6:].lstrip()
+    i = line.find(")")
+    assert i != -1, repr(line)
+    name = line[1:i].strip()
+    assert is_name(name), repr(name)
+    return name, line[i + 1 :].lstrip()
+
+
+def filter_stmts(content, classes):
+    """Pop and return classes instances from content."""
+    stmts = []
+    indices = []
+    for i in range(len(content)):
+        stmt = content[i]
+        if isinstance(stmt, classes):
+            stmts.append(stmt)
+            indices.append(i)
+    indices.reverse()
+    for i in indices:
+        del content[i]
+    return stmts
+
+
+def get_module_files(directory, _cache={}):
+    if directory in _cache:
+        return _cache[directory]
+    module_line = re.compile(r"(\A|^)module\s+(?P<name>\w+)\s*(!.*|)$", re.I | re.M)
+    d = {}
+    files = []
+    for ext in module_file_extensions:
+        files += glob.glob(os.path.join(directory, "*" + ext))
+    for fn in files:
+        f = open(fn, "r")
+        for name in module_line.findall(f.read()):
+            name = name[1]
+            if name in d:
+                print(d[name], "already defines", name)
+                continue
+            d[name] = fn
+    _cache[directory] = d
+    return d
+
+
+def get_module_file(name, directory, _cache={}):
+    fn = _cache.get(name, None)
+    if fn is not None:
+        return fn
+    if name.endswith("_module"):
+        for ext in module_file_extensions:
+            f1 = os.path.join(directory, name[:-7] + ext)
+            if os.path.isfile(f1):
+                _cache[name] = fn
+                return f1
+    files = []
+    for ext in module_file_extensions:
+        files += glob.glob(os.path.join(directory, "*" + ext))
+    for fn in files:
+        if module_in_file(name, fn):
+            _cache[name] = fn
+            return fn
+    return None
+
+
+def module_in_file(name, filename):
+    name = name.lower()
+    pattern = re.compile(r"\s*module\s+(?P<name>[a-z]\w*)", re.I).match
+    encoding = {"encoding": "UTF-8"}
+    f = io.open(filename, "r", **encoding)
+    for line in f:
+        m = pattern(line)
+        if m and m.group("name").lower() == name:
+            f.close()
+            return filename
+    f.close()
+
+
+def str2stmt(string, isfree=True, isstrict=False):
+    """Convert Fortran code to Statement tree."""
+    from .readfortran import Line, FortranStringReader
+    from .parsefortran import FortranParser
+
+    reader = FortranStringReader(string, isfree, isstrict)
+    parser = FortranParser(reader)
+    parser.parse()
+    parser.analyze()
+    block = parser.block
+    while len(block.content) == 1:
+        block = block.content[0]
+    return block
 
 
-def splitquote(line, stopchar=None, lower=False, quotechars='"\''):
+def show_item_on_failure(func, _exception_depth=[0]):
     """
-    Fast LineSplitter
+    Decorator for analyze methods.
     """
-    items = []
-    i = 0
-    while 1:
+
+    def new_func(self):
         try:
-            char = line[i]
-            i += 1
-        except IndexError:
-            break
-        l = []
-        l_append = l.append
-        nofslashes = 0
-        if stopchar is None:
-            # search for string start
-            while 1:
-                if char in quotechars and not nofslashes % 2:
-                    stopchar = char
-                    i -= 1
-                    break
-                if char == '\\':
-                    nofslashes += 1
-                else:
-                    nofslashes = 0
-                l_append(char)
-                try:
-                    char = line[i]
-                    i += 1
-                except IndexError:
-                    break
-            if not l:
-                continue
-            item = ''.join(l)
-            if lower:
-                item = item.lower()
-            items.append(item)
-            continue
-        if char == stopchar:
-            # string starts with quotechar
-            l_append(char)
-            try:
-                char = line[i]
-                i += 1
-            except IndexError:
-                if l:
-                    item = String(u''.join(l))
-                    items.append(item)
-                break
-        # else continued string
-        while 1:
-            if char == stopchar and not nofslashes % 2:
-                l_append(char)
-                stopchar = None
-                break
-            if char == '\\':
-                nofslashes += 1
-            else:
-                nofslashes = 0
-            l_append(char)
-            try:
-                char = line[i]
-                i += 1
-            except IndexError:
-                break
-        if l:
-            item = String(u''.join(l))
-            items.append(item)
-    return items, stopchar
+            func(self)
+        except AnalyzeError as msg:
+            clsname = self.__class__.__name__
+            self.error("%s.analyze error: %s" % (clsname, msg))
+            traceback.print_exc()
+        except ParseError as msg:
+            self.error("parse error: %s" % (msg))
+        except Exception as msg:
+            _exception_depth[0] += 1
+            if _exception_depth[0] == 1:
+                self.error("exception triggered here: %s %s" % (Exception, msg))
+            raise
+        _exception_depth[0] = 0
 
+    return new_func
 
-def splitparen(line, paren_open="([", paren_close=")]"):
-    """
-    Splits a line into top-level parenthesis and not-parenthesised
-    parts. E.g.: "a( (1+2)*3) = b(x)" becomes:
-    ["a", "( (1+2)*3)", " = b", "(x)"]
-    :param str line: the string to split.
-    :param str paren_open: The characters that define an open parentheses.
-    :param str paren_close: The characters that define a closing parentheses.
-    :return: List of parenthesised and not-parenthesised parts
-    :rtype: list of str
-    The paren_open and paren_close strings must be matched in order:
-    paren_open[x] is closed by paren_close[x].
-    """
 
-    assert len(paren_open) == len(paren_close)
+_classes_cache = {}
 
-    items = []   # Result list
-    num_backslashes = 0   # Counts consecutive "\" characters
-    # Empty if outside quotes, or set to the starting (and therefore
-    # also the ending) quote character while reading text inside quotes.
-    inside_quotes_char = ""
-    start = 0    # Index of start of current part.
-    stack = []   # Stack keeping track of required closing brackets
-
-    for idx, char in enumerate(line):
-        if char == "\\":
-            num_backslashes = (num_backslashes+1) % 2
-            continue
 
-        # We had an odd number of \, so the next character is neither
-        # a real quote or parenthesis character, and can just be added.
-        if num_backslashes == 1:
-            num_backslashes = 0
-            continue
+class meta_classes(type):
+    """Meta class for ``classes``."""
 
-        # If we are reading a quote, keep on reading till closing
-        # quote is reached
-        if inside_quotes_char != '':
-            # Reset inside_quotes_char if we find the closing quote
-            if char == inside_quotes_char:
-                inside_quotes_char = ''
-            continue
+    __abstractmethods__ = False
 
-        if char == "\'" or char == '"':
-            inside_quotes_char = char
-            continue
+    def __getattr__(self, name):
+        # Expose created classes only as attributes to ``classes`` type.
+        cls = _classes_cache.get(name)
+        if cls is None:
+            raise AttributeError("instance does not have attribute %r" % (name))
+        return cls
 
-        pos = paren_open.find(char)
-        if pos > -1:
-            if len(stack) == 0:
-                # New part starts:
-                items.append(line[start:idx])
-                start = idx
-            stack.append(paren_close[pos])
-            continue
 
-        # Found closing bracket
-        if len(stack) > 0 and char == stack[-1]:
-            stack.pop()
-            if len(stack) == 0:
-                # Found last closing bracket
-                items.append(ParenString(line[start:idx+1]))
-                start = idx+1
-
-    # Add any leftover characters as a separate item
-    if start != len(line):
-        items.append(line[start:])
-    return items
+class classes(type, metaclass=meta_classes):
+    """Make classes available as attributes of this class.
+
+    To add a class to the attributes list, one must use::
+
+      class Name(metaclass=classes):
+
+    in the definition of the class.
+
+    In addition, apply the following tasks:
+
+    * decorate analyze methods with show_item_on_failure
+    """
+
+    def __new__(metacls, name, bases, dict):
+        if "analyze" in dict:
+            dict["analyze"] = show_item_on_failure(dict["analyze"])
+        cls = type.__new__(metacls, name, bases, dict)
+        _classes_cache[name] = cls
+        return cls
```

### Comparing `fparser-0.0.9/src/fparser/common/tests/conftest.py` & `fparser-0.1.0/src/fparser/common/tests/conftest.py`

 * *Files 4% similar despite different names*

```diff
@@ -28,21 +28,21 @@
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-'''Module which provides pytest fixtures for use by files in this
+"""Module which provides pytest fixtures for use by files in this
 directory
 
-'''
+"""
 import pytest
 
 
 @pytest.fixture(scope="module", params=[True, False])
 def ignore_comments(request):
-    '''Fixture for testing with and without the parser ignoring comments.
-       Returns the content of params in turn.
+    """Fixture for testing with and without the parser ignoring comments.
+    Returns the content of params in turn.
 
-    '''
+    """
     return request.param
```

### Comparing `fparser-0.0.9/src/fparser/common/tests/logging_utils.py` & `fparser-0.1.0/src/fparser/common/tests/logging_utils.py`

 * *Files 16% similar despite different names*

```diff
@@ -32,53 +32,56 @@
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ##############################################################################
 # Modified M.Hambley, UK Met Office
 ##############################################################################
-'''
+"""
 Helps with testing methods which write to the standard logger.
-'''
+"""
 import logging
 
 
 class CaptureLoggingHandler(logging.Handler):
-    '''
+    """
     Records logged output for later examination.
 
     This is a standard handler for the built-in Python logging system.
     To make use of it simply register an instance with the logger using a
     command such as
     "logging.getLogger(__class__).addHandler( CaptureLoggingHandler() )"
 
     Any log message raised while this handler is in use will be recorded to
     a memory buffer for later use. This object has attributes 'debug', 'info',
     'warning', 'error' and 'critical', each of which is a list of logged
     messages. Only the message text is recorded, everything else is lost.
-    '''
+    """
+
     def __init__(self, *args, **kwargs):
-        '''
+        """
         Constructs an instance of CaptureLoggingHandler using the arguments
         accepted by logging.Handler.
-        '''
+        """
         super(CaptureLoggingHandler, self).__init__(*args, **kwargs)
         self.reset()
 
     def emit(self, record):
-        '''
+        """
         Handles a logged event. The event is passed from the logging system
         and recorded for future inspection.
 
         :param :py:class:`logging.LogRecord` record The event being logged.
-        '''
+        """
         self.messages[record.levelname.lower()].append(record.getMessage())
 
     def reset(self):
-        '''
+        """
         Empties the log of previous messages.
-        '''
-        self.messages = {'debug': [],
-                         'info': [],
-                         'warning': [],
-                         'error': [],
-                         'critical': []}
+        """
+        self.messages = {
+            "debug": [],
+            "info": [],
+            "warning": [],
+            "error": [],
+            "critical": [],
+        }
```

### Comparing `fparser-0.0.9/src/fparser/common/tests/test_base_classes.py` & `fparser-0.1.0/src/fparser/common/tests/test_base_classes.py`

 * *Files 18% similar despite different names*

```diff
@@ -32,136 +32,188 @@
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ##############################################################################
 # Modified M.Hambley, UK Met Office
 ##############################################################################
-'''
+"""
 Test battery associated with fparser.common.base_classes package.
-'''
+"""
 import re
 import pytest
 
 import fparser.common.base_classes
 import fparser.common.readfortran
 import fparser.common.sourceinfo
 import fparser.common.utils
+from fparser import api
 
 
 def test_statement_logging(log, monkeypatch):
-    '''
+    """
     Tests the Statement class' logging methods.
-    '''
-    class DummyParser(object):
-        '''
+    """
+
+    class DummyParser:
+        """
         Null parser harness.
-        '''
+        """
+
         def __init__(self, reader):
             self.reader = reader
 
     reader = fparser.common.readfortran.FortranStringReader("dummy = 1")
     parser = DummyParser(reader)
 
-    monkeypatch.setattr(fparser.common.base_classes.Statement,
-                        'process_item', lambda x: None, raising=False)
+    monkeypatch.setattr(
+        fparser.common.base_classes.Statement,
+        "process_item",
+        lambda x: None,
+        raising=False,
+    )
     unit_under_test = fparser.common.base_classes.Statement(parser, None)
 
-    unit_under_test.error('Scary biscuits')
-    assert(log.messages == {'critical': [],
-                            'debug':    [],
-                            'error':    ['Scary biscuits'],
-                            'info':     [],
-                            'warning':  []})
+    unit_under_test.error("Scary biscuits")
+    assert log.messages == {
+        "critical": [],
+        "debug": [],
+        "error": ["Scary biscuits"],
+        "info": [],
+        "warning": [],
+    }
 
     log.reset()
-    unit_under_test.warning('Trepidacious Cetations')
-    assert(log.messages == {'critical': [],
-                            'debug':    [],
-                            'error':    [],
-                            'info':     [],
-                            'warning':  ['Trepidacious Cetations']})
+    unit_under_test.warning("Trepidacious Cetations")
+    assert log.messages == {
+        "critical": [],
+        "debug": [],
+        "error": [],
+        "info": [],
+        "warning": ["Trepidacious Cetations"],
+    }
 
     log.reset()
-    unit_under_test.info('Hilarious Ontologies')
-    assert(log.messages == {'critical': [],
-                            'debug':    [],
-                            'error':    [],
-                            'info':     ['Hilarious Ontologies'],
-                            'warning':  []})
+    unit_under_test.info("Hilarious Ontologies")
+    assert log.messages == {
+        "critical": [],
+        "debug": [],
+        "error": [],
+        "info": ["Hilarious Ontologies"],
+        "warning": [],
+    }
 
 
 def test_log_comment_mix(log):
-    '''
+    """
     Tests that unexpected Fortran 90 comment in fixed format source is logged.
-    '''
+    """
+
     class EndDummy(fparser.common.base_classes.EndStatement):
-        '''
+        """
         Dummy EndStatement.
-        '''
-        match = re.compile(r'\s*end(\s*thing\s*\w*|)\s*\Z', re.I).match
+        """
+
+        match = re.compile(r"\s*end(\s*thing\s*\w*|)\s*\Z", re.I).match
 
     class BeginHarness(fparser.common.base_classes.BeginStatement):
-        '''
+        """
         Dummy BeginStatement.
-        '''
+        """
+
         end_stmt_cls = EndDummy
         classes = []
-        match = re.compile(r'\s*thing\s+(\w*)\s*\Z', re.I).match
+        match = re.compile(r"\s*thing\s+(\w*)\s*\Z", re.I).match
 
         def get_classes(self):
-            '''
+            """
             Returns an empty list of contained statements.
-            '''
+            """
             return []
 
-    code = '      x=1 ! Cheese'
-    parent = fparser.common.readfortran.FortranStringReader(
-        code, ignore_comments=False)
+    code = "      x=1 ! Cheese"
+    parent = fparser.common.readfortran.FortranStringReader(code, ignore_comments=False)
     parent.set_format(fparser.common.sourceinfo.FortranFormat(False, True))
     item = fparser.common.readfortran.Line(code, (1, 1), None, None, parent)
     with pytest.raises(fparser.common.utils.AnalyzeError):
         __ = BeginHarness(parent, item)
-    expected = '    1:      x=1 ! Cheese <== ' \
-               + 'no parse pattern found for "x=1 ! cheese" ' \
-               + "in 'BeginHarness' block, " \
-               + 'trying to remove inline comment (not in Fortran 77).'
-    result = log.messages['warning'][0].split('\n')[1]
+    expected = (
+        "    1:      x=1 ! Cheese <== "
+        + 'no parse pattern found for "x=1 ! cheese" '
+        + "in 'BeginHarness' block, "
+        + "trying to remove inline comment (not in Fortran 77)."
+    )
+    result = log.messages["warning"][0].split("\n")[1]
     assert result == expected
 
 
 def test_log_unexpected(log):
-    '''
+    """
     Tests that an unexpected thing between begin and end statements logs an
     event.
-    '''
+    """
+
     class EndThing(fparser.common.base_classes.EndStatement):
-        '''
+        """
         Dummy EndStatement class.
-        '''
+        """
+
         isvalid = True
-        match = re.compile(r'\s*end(\s+thing(\s+\w+)?)?\s*$', re.I).match
+        match = re.compile(r"\s*end(\s+thing(\s+\w+)?)?\s*$", re.I).match
 
     class BeginThing(fparser.common.base_classes.BeginStatement):
-        '''
+        """
         Dummy BeginStatement class.
-        '''
+        """
+
         end_stmt_cls = EndThing
         classes = []
-        match = re.compile(r'\s*thing\s+(\w+)?\s*$', re.I).match
+        match = re.compile(r"\s*thing\s+(\w+)?\s*$", re.I).match
 
         def get_classes(self):
-            '''
+            """
             Returns an empty list of contained classes.
-            '''
+            """
             return []
 
-    code = ['      jumper', '      end thing']
-    parent = fparser.common.readfortran.FortranStringReader('\n'.join(code))
+    code = ["      jumper", "      end thing"]
+    parent = fparser.common.readfortran.FortranStringReader("\n".join(code))
     parent.set_format(fparser.common.sourceinfo.FortranFormat(False, True))
     item = fparser.common.readfortran.Line(code[0], (1, 1), None, None, parent)
     with pytest.raises(fparser.common.utils.AnalyzeError):
         __ = BeginThing(parent, item)
-    expected = '    1:      jumper <== no parse pattern found for "jumper" ' \
-               "in 'BeginThing' block."
-    result = log.messages['warning'][0].split('\n')[1]
+    expected = (
+        '    1:      jumper <== no parse pattern found for "jumper" '
+        "in 'BeginThing' block."
+    )
+    result = log.messages["warning"][0].split("\n")[1]
     assert result == expected
+
+
+def test_space_after_enddo():
+    """Make sure that there is no space after an 'END DO' without name,
+    but there is a space if there is a name after 'END DO'.
+    """
+
+    # Unnamed loop:
+    source_str = """\
+    subroutine foo
+    integer i, r
+    do i = 1,100
+      r = r + 1
+    end do
+    end subroutine foo
+    """
+    tree = api.parse(source_str, isfree=True, isstrict=False)
+    assert "END DO " not in tree.tofortran()
+
+    # Named loop:
+    source_str = """\
+    subroutine foo
+    integer i, r
+    loop1: do i = 1,100
+      r = r + 1
+    end do loop1
+    end subroutine foo
+    """
+    tree = api.parse(source_str, isfree=True, isstrict=False)
+    assert "END DO loop1" in tree.tofortran()
```

### Comparing `fparser-0.0.9/src/fparser/common/tests/test_sourceinfo.py` & `fparser-0.1.0/src/fparser/common/tests/test_sourceinfo.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 # -*- coding: utf-8 -*-
 ##############################################################################
-# Copyright (c) 2017-2018 Science and Technology Facilities Council
+# Copyright (c) 2017-2023 Science and Technology Facilities Council.
 #
 # All rights reserved.
 #
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 #
 # Redistribution and use in source and binary forms, with or without
@@ -32,154 +32,155 @@
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ##############################################################################
 # Modified M.Hambley, UK Met Office
 ##############################################################################
-'''
+"""
 Test battery associated with fparser.sourceinfo package.
-'''
-from __future__ import print_function
+"""
 
 import os
 import tempfile
 import pytest
-import six
 
-from fparser.common.sourceinfo import FortranFormat, \
-                                      get_source_info_str, get_source_info
+from fparser.common.sourceinfo import (
+    FortranFormat,
+    get_source_info_str,
+    get_source_info,
+)
 
 
 ##############################################################################
 
+
 def test_format_constructor_faults():
-    '''
+    """
     Tests that the constructor correctly rejects attempts to create an object
     with "None" arguments.
-    '''
+    """
     with pytest.raises(Exception):
         _unit_under_test = FortranFormat(True, None)
 
     with pytest.raises(Exception):
         _unit_under_test = FortranFormat(None, True)
 
 
 ##############################################################################
-@pytest.fixture(scope="module",
-                params=[(False, False, 'fix', 'Non-strict fixed format'),
-                        (False, True, 'f77', 'Strict fixed format'),
-                        (True, False, 'free', 'Non-strict free format'),
-                        (True, True, 'pyf', 'Strict free format')])
+@pytest.fixture(
+    scope="module",
+    params=[
+        (False, False, "fix", "Non-strict fixed format"),
+        (False, True, "f77", "Strict fixed format"),
+        (True, False, "free", "Non-strict free format"),
+        (True, True, "pyf", "Strict free format"),
+    ],
+)
 def pretty(request):
-    '''
+    """
     Returns all possible permutations of flags and their corresponding
     mode and descriptive strings.
-    '''
+    """
     return request.param
 
 
 ##############################################################################
 
+
 def test_fortranformat_constructor(pretty):
-    #pylint: disable=redefined-outer-name
-    '''
+    # pylint: disable=redefined-outer-name
+    """
     Tests the constructor correctly sets up the object.
-    '''
+    """
     unit_under_test = FortranFormat(pretty[0], pretty[1])
     assert str(unit_under_test) == pretty[3]
     assert unit_under_test.is_free == pretty[0]
     assert unit_under_test.is_fixed == (not pretty[0])
     assert unit_under_test.is_strict == pretty[1]
     assert unit_under_test.is_f77 == (not pretty[0] and pretty[1])
     assert unit_under_test.is_fix == (not pretty[0] and not pretty[1])
     assert unit_under_test.is_pyf == (pretty[0] and pretty[1])
     assert unit_under_test.mode == pretty[2]
+    assert not unit_under_test.f2py_enabled
 
 
-##############################################################################
-@pytest.fixture(scope="module",
-                params=[(False, False),
-                        (False, True),
-                        (True, False),
-                        (True, True)])
-def permutations(request):
-    '''
-    Returns all possible permutations of the input arguments.
-    '''
-    return request.param
-
-
-##############################################################################
-
+@pytest.mark.parametrize(
+    "permutations", [(False, False), (False, True), (True, False), (True, True)]
+)
 def test_fortranformat_equality(permutations, pretty):
-    #pylint: disable=redefined-outer-name
-    '''
+    # pylint: disable=redefined-outer-name
+    """
     Tests that the equality operator works as expected.
-    '''
-    expected = (permutations[0] == pretty[0]) \
-        and (permutations[1] == pretty[1])
+    """
+    expected = (permutations[0] == pretty[0]) and (permutations[1] == pretty[1])
     unit_under_test = FortranFormat(permutations[0], permutations[1])
     candidate = FortranFormat(pretty[0], pretty[1])
     assert (unit_under_test == candidate) == expected
 
 
 ##############################################################################
 
+
 def test_fortranformat_invalid():
-    '''
+    """
     Tests that the equality operator understands that it can't compare apples
     and oranges.
-    '''
+    """
     unit_under_test = FortranFormat(True, False)
     with pytest.raises(NotImplementedError):
-        if unit_under_test == 'oranges':
+        if unit_under_test == "oranges":
             raise Exception("That shouldn't have happened")
 
 
 ##############################################################################
 
-@pytest.fixture(scope="module",
-                params=[('free', True, False),
-                        ('f77', False, True),
-                        ('fix', False, False),
-                        ('pyf', True, True)])
+
+@pytest.fixture(
+    scope="module",
+    params=[
+        ("free", True, False),
+        ("f77", False, True),
+        ("fix", False, False),
+        ("pyf", True, True),
+    ],
+)
 def mode(request):
-    '''
+    """
     Returns all possible mode strings and their corresponding flags.
-    '''
+    """
     return request.param
 
 
 ##############################################################################
 
+
 def test_fortranformat_from_mode(mode):
-    #pylint: disable=redefined-outer-name
-    '''
+    # pylint: disable=redefined-outer-name
+    """
     Tests that the object is correctly created by the from_mode function.
-    '''
+    """
     unit_under_test = FortranFormat.from_mode(mode[0])
     assert unit_under_test.mode == mode[0]
     assert unit_under_test.is_free == mode[1]
     assert unit_under_test.is_fixed == (not mode[1])
     assert unit_under_test.is_strict == mode[2]
     assert unit_under_test.is_f77 == (not mode[1] and mode[2])
     assert unit_under_test.is_fix == (not mode[1] and not mode[2])
     assert unit_under_test.is_pyf == (mode[1] and mode[2])
     assert str(unit_under_test.mode) == mode[0]
+    assert not unit_under_test.f2py_enabled
 
 
-##############################################################################
-
 def test_format_from_mode_bad():
-    '''
+    """
     Tests that an exception is thrown for an unrecognised mode string.
-    '''
+    """
     with pytest.raises(NotImplementedError):
-        _unit_under_test = FortranFormat.from_mode('cheese')
+        _unit_under_test = FortranFormat.from_mode("cheese")
 
 
 ##############################################################################
 # Setting up a pytest fixture in this way is a mechanism for creating
 # parameterised tests.
 #
 # Normally when a test includes a fixture in its argument list the
@@ -189,201 +190,215 @@
 # function returns. So in this case any test including "header" in its
 # argument list will be run once with "header" equal to "! -*- fortran -*-",
 # then with "header" equal to "! -*- f77 -*-" and so on.
 #
 # If a test includes multiple parameter fixtures it will be called for every
 # permutation thus afforded.
 #
-@pytest.fixture(scope="module",
-                params=[(None, FortranFormat(True, True)),
-                        ("! -*- fortran -*-", FortranFormat(False, True)),
-                        ("! -*- f77 -*-", FortranFormat(False, True)),
-                        ('! -*- f90 -*-', FortranFormat(True, False)),
-                        ('! -*- f03 -*-', FortranFormat(True, False)),
-                        ('! -*- f08 -*-', FortranFormat(True, False)),
-                        ('! -*- fix -*-', FortranFormat(False, False)),
-                        ('! -*- pyf -*-', FortranFormat(True, True))])
-def header(request):
-    '''
+@pytest.fixture(
+    scope="module",
+    params=[
+        (None, FortranFormat(True, True)),
+        ("! -*- fortran -*-", FortranFormat(False, True)),
+        ("! -*- f77 -*-", FortranFormat(False, True)),
+        ("! -*- f90 -*-", FortranFormat(True, False)),
+        ("! -*- f03 -*-", FortranFormat(True, False)),
+        ("! -*- f08 -*-", FortranFormat(True, False)),
+        ("! -*- fix -*-", FortranFormat(False, False)),
+        ("! -*- pyf -*-", FortranFormat(True, True)),
+    ],
+    name="header",
+)
+def header_fixture(request):
+    """
     Returns parameters for header tests.
-    '''
+    """
     return request.param
 
 
 ##############################################################################
 
-_FIXED_SOURCE = '''      program main
+_FIXED_SOURCE = """      program main
       end program main
-'''
+"""
 
-_FREE_SOURCE = '''program main
+_FREE_SOURCE = """program main
 end program main
-'''
+"""
 
-_FIXED_WITH_CONTINUE = '''      program main
+_FIXED_WITH_CONTINUE = """      program main
           implicit none
           integer :: foo, &
                      bar
       end program main
-'''
+"""
 
-_FIXED_WITH_COMMENTS = '''!     The program
+_FIXED_WITH_COMMENTS = """!     The program
       program main
 c         Enforce explicit variable declaration
           implicit none
 *         variables
           integer :: foo
       end program main
-'''
+"""
 
 # Tabs are not actually in the Fortran character set but fparser has handled
 # them in the past even if it shouldn't have. We have to continue handling
 # them for the time being until we work out why they were supported.
 #
 _INITIAL_TAB = "\tprogram main\n"
 _MIDDLE_TAB = " \tprogram main\n"
 
 
 # Another parameterised test fixture. See "header" above.
 #
-@pytest.fixture(scope="module",
-                params=[(None, FortranFormat(False, False)),
-                        (_FIXED_SOURCE, FortranFormat(False, False)),
-                        (_FREE_SOURCE, FortranFormat(True, False)),
-                        (_FIXED_WITH_CONTINUE, FortranFormat(True, False)),
-                        (_FIXED_WITH_COMMENTS, FortranFormat(False, False)),
-                        (_INITIAL_TAB, FortranFormat(False, False)),
-                        (_MIDDLE_TAB, FortranFormat(True, False))])
+@pytest.fixture(
+    scope="module",
+    params=[
+        (None, FortranFormat(False, False)),
+        (_FIXED_SOURCE, FortranFormat(False, False)),
+        (_FREE_SOURCE, FortranFormat(True, False)),
+        (_FIXED_WITH_CONTINUE, FortranFormat(True, False)),
+        (_FIXED_WITH_COMMENTS, FortranFormat(False, False)),
+        (_INITIAL_TAB, FortranFormat(False, False)),
+        (_MIDDLE_TAB, FortranFormat(True, False)),
+    ],
+)
 def content(request):
-    '''
+    """
     Returns parameters for content tests.
-    '''
+    """
     return request.param
 
 
 ##############################################################################
 
+
 def test_get_source_info_str(header, content):
-    #pylint: disable=redefined-outer-name
-    '''
+    # pylint: disable=redefined-outer-name
+    """
     Tests that source format is correctly identified when read from a string.
-    '''
-    full_source = ''
+    """
+    full_source = ""
     if header[0] is not None:
-        full_source += header[0] + '\n'
+        full_source += header[0] + "\n"
     if content[0] is not None:
         full_source += content[0]
 
-    source_info = get_source_info_str(full_source)
+    source_info = get_source_info_str(full_source, ignore_encoding=False)
     if header[0]:
         assert source_info == header[1]
     else:  # No header
         assert source_info == content[1]
 
 
 ##############################################################################
 
+
 # Another parameterised test fixture. See "header" above.
 #
-@pytest.fixture(scope="module",
-                params=[('.f', None),
-                        ('.f90', None),
-                        ('.pyf', FortranFormat(True, True)),
-                        ('.guff', None)])
+@pytest.fixture(
+    scope="module",
+    params=[
+        (".f", None),
+        (".f90", None),
+        (".pyf", FortranFormat(True, True)),
+        (".guff", None),
+    ],
+)
 def extension(request):
-    '''
+    """
     Returns parameters for extension tests.
-    '''
+    """
     return request.param
 
 
 ##############################################################################
 
+
 def test_get_source_info_filename(extension, header, content):
-    #pylint: disable=redefined-outer-name
-    '''
+    # pylint: disable=redefined-outer-name
+    """
     Tests that source format is correctly identified when read from a file.
-    '''
-    full_source = ''
+    """
+    full_source = ""
     if header[0] is not None:
-        full_source += header[0] + '\n'
+        full_source += header[0] + "\n"
     if content[0] is not None:
         full_source += content[0]
 
     source_file, filename = tempfile.mkstemp(suffix=extension[0], text=True)
     os.close(source_file)
 
-    with open(filename, 'w') as source_file:
+    with open(filename, "w") as source_file:
         print(full_source, file=source_file)
 
     try:
-        source_info = get_source_info(filename)
+        source_info = get_source_info(filename, ignore_encoding=False)
         if extension[1] is not None:
             assert source_info == extension[1]
         elif header[0] is not None:
             assert source_info == header[1]
         else:  # No header
             assert source_info == content[1]
     except Exception as ex:
         os.remove(filename)
         raise ex
 
 
 ##############################################################################
 
+
 def test_get_source_info_file(extension, header, content):
-    #pylint: disable=redefined-outer-name
-    '''
+    # pylint: disable=redefined-outer-name
+    """
     Tests that source format is correctly identified when read from a file.
-    '''
-    full_source = ''
+    """
+    full_source = ""
     if header[0] is not None:
-        full_source += header[0] + '\n'
+        full_source += header[0] + "\n"
     if content[0] is not None:
         full_source += content[0]
 
-    with tempfile.TemporaryFile(mode='w+',
-                                suffix=extension[0]) as source_file:
+    with tempfile.TemporaryFile(mode="w+", suffix=extension[0]) as source_file:
         print(full_source, file=source_file)
         source_file.seek(0)
 
-        source_info = get_source_info(source_file)
+        source_info = get_source_info(source_file, ignore_encoding=False)
         if header[0] is not None:
             assert source_info == header[1]
         else:  # No header
             assert source_info == content[1]
 
 
 def test_get_source_info_utf8():
-    '''
+    """
     Tests that Fortran code containing a unicode character can be read
     by the get_source_info method.
 
-    '''
-    encoding = dict(encoding='UTF-8') if six.PY3 else {}
-    with tempfile.NamedTemporaryFile(mode='w', **encoding) as tmp_file:
-        content = u'''
-            ! A fortran comment with a unicode character "{0}"
-        '''.format(u"\u2014")
-        if six.PY2:
-            content = content.encode('UTF-8')
+    """
+    encoding = dict(encoding="UTF-8")
+    with tempfile.NamedTemporaryFile(mode="w", **encoding) as tmp_file:
+        content = '  ! A fortran comment with a unicode character "\u2014"'
         tmp_file.write(content)
         tmp_file.flush()
 
         source_info = get_source_info(tmp_file.name)
     assert source_info is not None
 
 
 ##############################################################################
 
+
 def test_get_source_info_wrong():
-    '''
+    """
     Tests that get_source_info throws an exception if passed the wrong type
     of argument.
-    '''
+    """
     with pytest.raises(ValueError):
         _source_info = get_source_info(42)  # Obviously wrong
 
     with pytest.raises(ValueError):
-        _source_info = get_source_info(['one'])  # Less obviously wrong
+        _source_info = get_source_info(["one"])  # Less obviously wrong
+
 
 ##############################################################################
```

### Comparing `fparser-0.0.9/src/fparser/conftest.py` & `fparser-0.1.0/src/fparser/conftest.py`

 * *Files 8% similar despite different names*

```diff
@@ -31,29 +31,29 @@
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ##############################################################################
-'''
+"""
 Shared fixtures.
-'''
+"""
 
 import logging
 import fparser.common.tests.logging_utils
 import pytest
 
 
 @pytest.fixture
 def log():
-    '''
+    """
     Prepare a fixture to capture logged events for inspection.
-    '''
-    logger = logging.getLogger('fparser')
+    """
+    logger = logging.getLogger("fparser")
     handler = fparser.common.tests.logging_utils.CaptureLoggingHandler()
     logger.addHandler(handler)
     logger.setLevel(logging.DEBUG)
     yield handler
     # When the fixture function is a generator, i.e. it uses "yield" rather
     # than "return", it will be called a second time after the test has
     # completed. Thus anything appearing after the "yield" is teardown which
```

### Comparing `fparser-0.0.9/src/fparser/one/block_statements.py` & `fparser-0.1.0/src/fparser/one/block_statements.py`

 * *Files 9% similar despite different names*

```diff
@@ -74,253 +74,286 @@
 import sys
 
 import fparser.one.statements as statements
 from fparser.one.statements import *
 import fparser.one.typedecl_statements as typedecl_statements
 from fparser.one.typedecl_statements import *
 
-from fparser.common.base_classes import BeginStatement, EndStatement, \
-                                        Statement, AttributeHolder,   \
-                                        ProgramBlock, Variable
-from fparser.common.utils import split_comma, filter_stmts, parse_bind, \
-                                 parse_result, AnalyzeError, is_name
-
-__all__ = ['BeginSource', 'Module', 'PythonModule', 'Program', 'BlockData',
-           'Interface', 'Subroutine', 'Function', 'SelectCase', 'SelectType',
-           'WhereConstruct', 'ForallConstruct', 'IfThen', 'If', 'Do',
-           'Associate', 'TypeDecl', 'Enum', 'EndSource', 'EndModule',
-           'EndPythonModule', 'EndProgram', 'EndBlockData', 'EndInterface',
-           'EndSubroutine', 'EndFunction', 'EndSelect', 'EndWhere',
-           'EndForall', 'EndIfThen', 'EndDo', 'EndAssociate', 'EndType',
-           'EndEnum']
+from fparser.common.base_classes import (
+    BeginStatement,
+    EndStatement,
+    Statement,
+    AttributeHolder,
+    ProgramBlock,
+    Variable,
+)
+from fparser.common.utils import (
+    split_comma,
+    filter_stmts,
+    parse_bind,
+    parse_result,
+    AnalyzeError,
+    is_name,
+)
+
+__all__ = [
+    "BeginSource",
+    "Module",
+    "PythonModule",
+    "Program",
+    "BlockData",
+    "Interface",
+    "Subroutine",
+    "Function",
+    "SelectCase",
+    "SelectType",
+    "WhereConstruct",
+    "ForallConstruct",
+    "IfThen",
+    "If",
+    "Do",
+    "Associate",
+    "TypeDecl",
+    "Enum",
+    "EndSource",
+    "EndModule",
+    "EndPythonModule",
+    "EndProgram",
+    "EndBlockData",
+    "EndInterface",
+    "EndSubroutine",
+    "EndFunction",
+    "EndSelect",
+    "EndWhere",
+    "EndForall",
+    "EndIfThen",
+    "EndDo",
+    "EndAssociate",
+    "EndType",
+    "EndEnum",
+]
 __all__.extend(statements.__all__)
 __all__.extend(typedecl_statements.__all__)
 
 
-class HasImplicitStmt(object):
-    '''
+class HasImplicitStmt:
+    """
     Class encapsulating information about any Implicit statements
     contained within a scoping block.
-    '''
+    """
+
     a = AttributeHolder(implicit_rules={})
 
     def get_type_by_name(self, name):
-        '''
+        """
         Returns an object of the correct type (Integer or Real) using
         Fortran's implicit typing rules for the supplied variable name.
 
         :param str name: The variable name.
         :returns: Object describing the variable.
         :rtype: Either :py:class:`fparser.one.typedecl_statements.Real` \
                 or :py:class:`fparser.one.typedecl_statements.Integer`.
 
-        '''
+        """
         # The implicit_rules dict is populated by the analyze() method
         # of one.typedecl_statements.Implicit
         implicit_rules = self.a.implicit_rules
         if implicit_rules is None:
-            raise AnalyzeError('Implicit rules mapping is null '
-                               'while getting %r type' % (name))
+            raise AnalyzeError(
+                "Implicit rules mapping is null " "while getting %r type" % (name)
+            )
         line = name[0].lower()
         if line in implicit_rules:
             return implicit_rules[line]
         # default rules:
-        if line in 'ijklmn':
-            line = 'default_integer'
+        if line in "ijklmn":
+            line = "default_integer"
         else:
-            line = 'default_real'
+            line = "default_real"
         var = implicit_rules.get(line, None)
         if var is None:
-            if line[8:] == 'real':
-                implicit_rules[line] = var = Real(self, self.item.copy('real'))
+            if line[8:] == "real":
+                implicit_rules[line] = var = Real(self, self.item.copy("real"))
             else:
-                implicit_rules[line] = var = Integer(self,
-                                                     self.item.copy('integer'))
+                implicit_rules[line] = var = Integer(self, self.item.copy("integer"))
         return var
 
-    def topyf(self, tab='  '):
-        '''
+    def topyf(self, tab="  "):
+        """
         Constructs a pyf representation of this class.
 
         :param str tab: White space to prepend to output.
         :returns: pyf code for this implicit statement.
         :rtype: str
-        '''
+        """
         implicit_rules = self.a.implicit_rules
         if implicit_rules is None:
-            return tab + 'IMPLICIT NONE\n'
+            return tab + "IMPLICIT NONE\n"
         # Construct a dict where the keys are types and the items are
         # the list of initial letters mapped to that type
         items = {}
         for char, itype in list(implicit_rules.items()):
-            if char.startswith('default'):
+            if char.startswith("default"):
                 continue
             type_str = itype.tostr()
             if type_str in items:
                 items[type_str].append(char)
             else:
                 items[type_str] = [char]
         if not items:
-            return tab + '! default IMPLICIT rules apply\n'
-        stmt = 'IMPLICIT'
+            return tab + "! default IMPLICIT rules apply\n"
+        stmt = "IMPLICIT"
         impl_list = []
         for itype, letter_list in list(items.items()):
             letter_list.sort()
-            impl_list.append(itype + ' (%s)' % (', '.join(letter_list)))
-        stmt += ' ' + ', '.join(impl_list)
-        return tab + stmt + '\n'
-
+            impl_list.append(itype + " (%s)" % (", ".join(letter_list)))
+        stmt += " " + ", ".join(impl_list)
+        return tab + stmt + "\n"
 
-class HasUseStmt(object):
 
-    a = AttributeHolder(use={},
-                        use_provides={})
+class HasUseStmt:
+    a = AttributeHolder(use={}, use_provides={})
 
     def get_entity(self, name):
         for modname, modblock in list(self.top.a.module.items()):
             for stmt in modblock.content:
-                if getattr(stmt, 'name', '') == name:
+                if getattr(stmt, "name", "") == name:
                     return stmt
         return
 
-    def topyf(self, tab='  '):
-        sys.stderr.write('HasUseStmt.topyf not implemented\n')
-        return ''
+    def topyf(self, tab="  "):
+        sys.stderr.write("HasUseStmt.topyf not implemented\n")
+        return ""
 
 
-class AccessSpecs(object):
-
+class AccessSpecs:
     a = AttributeHolder(private_id_list=[], public_id_list=[])
 
-    def topyf(self, tab='  '):
+    def topyf(self, tab="  "):
         private_list = self.a.private_id_list
         public_list = self.a.public_id_list
         lines = []
-        if '' in private_list:
-            lines.append(tab + 'PRIVATE\n')
-        if '' in public_list:
-            lines.append(tab + 'PUBLIC\n')
+        if "" in private_list:
+            lines.append(tab + "PRIVATE\n")
+        if "" in public_list:
+            lines.append(tab + "PUBLIC\n")
         for a in private_list:
             if not a:
                 continue
-            lines.append(tab + 'PRIVATE :: %s\n' % (a))
+            lines.append(tab + "PRIVATE :: %s\n" % (a))
         for a in public_list:
             if not a:
                 continue
-            lines.append(tab + 'PUBLIC :: %s\n' % (a))
-        return ''.join(lines)
-
+            lines.append(tab + "PUBLIC :: %s\n" % (a))
+        return "".join(lines)
 
-class HasVariables(object):
 
-    a = AttributeHolder(variables={},
-                        variable_names=[]  # defines the order of declarations
-                        )
+class HasVariables:
+    a = AttributeHolder(
+        variables={}, variable_names=[]  # defines the order of declarations
+    )
 
     def get_variable_by_name(self, name):
         variables = self.a.variables
         if name in variables:
             var = variables[name]
         else:
             var = variables[name] = Variable(self, name)
             self.a.variable_names.append(name)
         return var
 
-    def topyf(self, tab='', only_variables=None):
-        s = ''
+    def topyf(self, tab="", only_variables=None):
+        s = ""
         if only_variables is None:
             only_variables = list(self.a.variables.keys())
         for name in only_variables:
             var = self.a.variables[name]
-            s += tab + str(var) + '\n'
+            s += tab + str(var) + "\n"
         return s
 
 
-class HasTypeDecls(object):
-
+class HasTypeDecls:
     a = AttributeHolder(type_decls={})
 
-    def topyf(self, tab=''):
-        s = ''
+    def topyf(self, tab=""):
+        s = ""
         for name, stmt in list(self.a.type_decls.items()):
-            s += stmt.topyf(tab='  '+tab)
+            s += stmt.topyf(tab="  " + tab)
         return s
 
     def get_type_decl_by_kind(self, kind):
         type_decls = self.a.type_decls
         type_decl = type_decls.get(kind, None)
         if type_decl is None:
             return self.get_entity(kind)
         return type_decl
 
 
-class HasAttributes(object):
-
+class HasAttributes:
     known_attributes = []
     a = AttributeHolder(attributes=[])
 
-    def topyf(self, tab=''):
-        s = ''
+    def topyf(self, tab=""):
+        s = ""
         for attr in self.a.attributes:
-            s += tab + attr + '\n'
+            s += tab + attr + "\n"
         return s
 
     def update_attributes(self, *attrs):
         attributes = self.a.attributes
         known_attributes = self.known_attributes
         if len(attrs) == 1 and isinstance(attrs[0], (tuple, list)):
             attrs = attrs[0]
         for attr in attrs:
             uattr = attr.upper()
             if uattr not in attributes:
                 if isinstance(known_attributes, (list, tuple)):
                     if uattr not in known_attributes:
-                        self.warning('unknown attribute %r' % (attr))
+                        self.warning("unknown attribute %r" % (attr))
                 elif not known_attributes(uattr):
-                    self.warning('unknown attribute %r' % (attr))
+                    self.warning("unknown attribute %r" % (attr))
                 attributes.append(uattr)
             else:
-                self.warning('multiple specification of attribute %r' % (attr))
+                self.warning("multiple specification of attribute %r" % (attr))
         return
 
 
-class HasModuleProcedures(object):
-
+class HasModuleProcedures:
     a = AttributeHolder(module_procedures=[])
 
 
 # File block
 
+
 class EndSource(EndStatement):
     """
     Dummy End statement for BeginSource.
     """
+
     match = staticmethod(lambda s: False)
 
 
 class BeginSource(BeginStatement):
     """
     Fortran source content.
     """
+
     match = staticmethod(lambda s: True)
     end_stmt_cls = EndSource
-    a = AttributeHolder(module={},
-                        external_subprogram={},
-                        blockdata={},
-                        )
+    a = AttributeHolder(module={}, external_subprogram={}, blockdata={})
 
     def tofortran(self, isfix=None):
         if isfix:
-            tab = 'C'
+            tab = "C"
         else:
-            tab = self.get_indent_tab(isfix=isfix) + '!'
+            tab = self.get_indent_tab(isfix=isfix) + "!"
         return tab + BeginStatement.tofortran(self, isfix=isfix)
 
     def tostr(self):
-        return self.blocktype.upper() + ' ' + self.name
+        return self.blocktype.upper() + " " + self.name
 
     def process_item(self):
         self.name = self.reader.name
         self.top = self
         self.fill(end_flag=True)
         return
 
@@ -347,71 +380,82 @@
     def process_subitem(self, item):
         # MAIN block does not define start/end line conditions,
         # so it should never end until all lines are read.
         # However, sometimes F77 programs lack the PROGRAM statement,
         # and here we fix that:
         if self.reader.format.is_f77:
             line = item.get_line()
-            if line == 'end':
+            if line == "end":
                 message = item.reader.format_message(
-                    'WARNING',
-                    'assuming the end of undefined PROGRAM statement',
-                    item.span[0], item.span[1])
+                    "WARNING",
+                    "assuming the end of undefined PROGRAM statement",
+                    item.span[0],
+                    item.span[1],
+                )
                 logger.warning(message)
                 # print >> sys.stderr, message
                 p = Program(self)
                 p.content.extend(self.content)
                 p.content.append(EndProgram(p, item))
                 self.content[:] = [p]
                 return
         return BeginStatement.process_subitem(self, item)
 
-    def topyf(self, tab=''):  # XXXX
-        s = ''
+    def topyf(self, tab=""):  # XXXX
+        s = ""
         for name, stmt in list(self.a.module.items()):
             s += stmt.topyf(tab=tab)
         for name, stmt in list(self.a.external_subprogram.items()):
             s += stmt.topyf(tab=tab)
         for name, stmt in list(self.a.blockdata.items()):
             s += stmt.topyf(tab=tab)
         return s
 
 
 # Module
 
+
 class EndModule(EndStatement):
-    match = re.compile(r'end(\s*module\s*\w*|)\Z', re.I).match
+    match = re.compile(r"end(\s*module\s*\w*|)\Z", re.I).match
 
 
-class Module(BeginStatement, HasAttributes,
-             HasImplicitStmt, HasUseStmt, HasVariables,
-             HasTypeDecls, AccessSpecs):
+class Module(
+    BeginStatement,
+    HasAttributes,
+    HasImplicitStmt,
+    HasUseStmt,
+    HasVariables,
+    HasTypeDecls,
+    AccessSpecs,
+):
     """
     MODULE <name>
      ..
     END [MODULE [name]]
     """
-    match = re.compile(r'module\s*\w+\Z', re.I).match
+
+    match = re.compile(r"module\s*\w+\Z", re.I).match
     end_stmt_cls = EndModule
 
-    a = AttributeHolder(module_subprogram={},
-                        module_provides={},  # all symbols that are public and
-                                             # so can be imported via USE
-                                             # statement by other blocks
-                        module_interface={}
-                        )
+    a = AttributeHolder(
+        module_subprogram={},
+        module_provides={},  # all symbols that are public and
+        # so can be imported via USE
+        # statement by other blocks
+        module_interface={},
+    )
 
-    known_attributes = ['PUBLIC', 'PRIVATE']
+    known_attributes = ["PUBLIC", "PRIVATE"]
 
     def get_classes(self):
         return access_spec + specification_part + module_subprogram_part
 
     def process_item(self):
-        name = self.item.get_line().replace(' ', '')
-        name = name[len(self.blocktype):].strip()
+        name = self.item.get_line().replace(" ", "")
+        name = name[len(self.blocktype) :].strip()
         self.name = name
         return BeginStatement.process_item(self)
 
     def get_provides(self):
         return self.a.module_provides
 
     def get_interface(self):
@@ -426,207 +470,225 @@
                 for stmt in filter_stmts(content, SubProgramStatement):
                     stmt.analyze()
                     self.a.module_subprogram[stmt.name] = stmt
                 stmt = content.pop(0)
                 while isinstance(stmt, Comment):
                     stmt = content.pop(0)
                 if not isinstance(stmt, EndModule):
-                    stmt.error('Expected END MODULE statement (analyzer).')
+                    stmt.error("Expected END MODULE statement (analyzer).")
                 continue
             stmt.analyze()
 
         if content:
-            logger.info('Not analyzed content: %s' % content)
+            logger.info("Not analyzed content: %s" % content)
             # self.show_message('Not analyzed content: %s' % content)
 
         module_provides = self.a.module_provides
         for name, var in list(self.a.variables.items()):
             if var.is_public():
                 if name in module_provides:
-                    message = 'module data object name conflict with %s, ' \
-                              + 'overriding.'
+                    message = (
+                        "module data object name conflict with %s, " + "overriding."
+                    )
                     self.warning(message % (name))
                 module_provides[name] = var
 
         return
 
-    def topyf(self, tab=''):
-        s = tab + 'MODULE '+self.name + '\n'
-        s += HasImplicitStmt.topyf(self, tab=tab+'  ')
-        s += AccessSpecs.topyf(self, tab=tab+'  ')
-        s += HasAttributes.topyf(self, tab=tab+'  ')
-        s += HasTypeDecls.topyf(self, tab=tab+'  ')
-        s += HasVariables.topyf(self, tab=tab+'  ')
+    def topyf(self, tab=""):
+        s = tab + "MODULE " + self.name + "\n"
+        s += HasImplicitStmt.topyf(self, tab=tab + "  ")
+        s += AccessSpecs.topyf(self, tab=tab + "  ")
+        s += HasAttributes.topyf(self, tab=tab + "  ")
+        s += HasTypeDecls.topyf(self, tab=tab + "  ")
+        s += HasVariables.topyf(self, tab=tab + "  ")
         for name, stmt in list(self.a.module_interface.items()):
-            s += stmt.topyf(tab=tab+'    ')
-        s += tab + '  CONTAINS\n'
+            s += stmt.topyf(tab=tab + "    ")
+        s += tab + "  CONTAINS\n"
         for name, stmt in list(self.a.module_subprogram.items()):
-            s += stmt.topyf(tab=tab+'    ')
-        s += tab + 'END MODULE ' + self.name + '\n'
+            s += stmt.topyf(tab=tab + "    ")
+        s += tab + "END MODULE " + self.name + "\n"
         return s
 
     def check_private(self, name):
         if name in self.a.public_id_list:
             return False
         if name in self.a.private_id_list:
             return True
-        if '' in self.a.public_id_list:
+        if "" in self.a.public_id_list:
             return False
-        if '' in self.a.private_id_list:
+        if "" in self.a.private_id_list:
             return True
         # todo: handle generic-spec-s in id-lists.
         return
 
 
 # Python Module
 
+
 class EndPythonModule(EndStatement):
-    match = re.compile(r'end(\s*python\s*module\s*\w*|)\Z', re.I).match
+    match = re.compile(r"end(\s*python\s*module\s*\w*|)\Z", re.I).match
 
 
-class PythonModule(BeginStatement, HasImplicitStmt, HasUseStmt,
-                   HasVariables):
+class PythonModule(BeginStatement, HasImplicitStmt, HasUseStmt, HasVariables):
     """
     PYTHON MODULE <name>
      ..
     END [PYTHON MODULE [name]]
     """
-    modes = ['pyf']
-    match = re.compile(r'python\s*module\s*\w+\Z', re.I).match
+
+    modes = ["pyf"]
+    match = re.compile(r"python\s*module\s*\w+\Z", re.I).match
     end_stmt_cls = EndPythonModule
 
     def get_classes(self):
         return [Interface, Function, Subroutine, Module]
 
     def process_item(self):
-        self.name = self.item.get_line().replace(' ', '')
-        self.name = self.name[len(self.blocktype):].strip()
+        self.name = self.item.get_line().replace(" ", "")
+        self.name = self.name[len(self.blocktype) :].strip()
         return BeginStatement.process_item(self)
 
 
 # Program
 
+
 class EndProgram(EndStatement):
     """
     END [PROGRAM [name]]
     """
-    match = re.compile(r'end(\s*program\s*\w*|)\Z', re.I).match
 
+    match = re.compile(r"end(\s*program\s*\w*|)\Z", re.I).match
 
-class Program(BeginStatement, ProgramBlock,
-              # HasAttributes, # XXX: why Program needs .attributes?
-              HasVariables,
-              HasImplicitStmt, HasUseStmt, AccessSpecs):
-    """ PROGRAM [name]
-    """
-    match = re.compile(r'program\s*\w*\Z', re.I).match
+
+class Program(
+    BeginStatement,
+    ProgramBlock,
+    # HasAttributes, # XXX: why Program needs .attributes?
+    HasVariables,
+    HasImplicitStmt,
+    HasUseStmt,
+    AccessSpecs,
+):
+    """PROGRAM [name]"""
+
+    match = re.compile(r"program\s*\w*\Z", re.I).match
     end_stmt_cls = EndProgram
 
     def get_classes(self):
         return specification_part + execution_part + internal_subprogram_part
 
     def process_item(self):
         if self.item is not None:
-            name = self.item.get_line().replace(' ', '')
-            name = name[len(self.blocktype):].strip()
+            name = self.item.get_line().replace(" ", "")
+            name = name[len(self.blocktype) :].strip()
             if name:
                 self.name = name
         return BeginStatement.process_item(self)
 
 
 # BlockData
 
+
 class EndBlockData(EndStatement):
     """
     END [BLOCK DATA [<block-data-name>]]
     """
-    match = re.compile(r'end(\s*block\s*data\s*\w*|)\Z', re.I).match
-    blocktype = 'blockdata'
+
+    match = re.compile(r"end(\s*block\s*data\s*\w*|)\Z", re.I).match
+    blocktype = "blockdata"
 
 
-class BlockData(BeginStatement, HasImplicitStmt, HasUseStmt,
-                HasVariables, AccessSpecs):
+class BlockData(BeginStatement, HasImplicitStmt, HasUseStmt, HasVariables, AccessSpecs):
     """
     BLOCK DATA [<block-data-name>]
     """
+
     end_stmt_cls = EndBlockData
-    match = re.compile(r'block\s*data\s*\w*\Z', re.I).match
+    match = re.compile(r"block\s*data\s*\w*\Z", re.I).match
 
     def process_item(self):
         self.name = self.item.get_line()[5:].lstrip()[4:].lstrip()
         return BeginStatement.process_item(self)
 
     def get_classes(self):
         return specification_part
 
 
 # Interface
 
+
 class EndInterface(EndStatement):
-    match = re.compile(r'end\s*interface\s*(\w+\s*\(.*\)|\w*)\Z', re.I).match
-    blocktype = 'interface'
+    match = re.compile(r"end\s*interface\s*(\w+\s*\(.*\)|\w*)\Z", re.I).match
+    blocktype = "interface"
 
 
-class Interface(BeginStatement, HasAttributes, HasImplicitStmt, HasUseStmt,
-                HasModuleProcedures, AccessSpecs
-                ):
+class Interface(
+    BeginStatement,
+    HasAttributes,
+    HasImplicitStmt,
+    HasUseStmt,
+    HasModuleProcedures,
+    AccessSpecs,
+):
     """
     INTERFACE [<generic-spec>] | ABSTRACT INTERFACE
     END INTERFACE [<generic-spec>]
 
     <generic-spec> = <generic-name>
                    | OPERATOR ( <defined-operator> )
                    | ASSIGNMENT ( = )
                    | <dtio-generic-spec>
     <dtio-generic-spec> = READ ( FORMATTED )
                         | READ ( UNFORMATTED )
                         | WRITE ( FORMATTED )
                         | WRITE ( UNFORMATTED )
 
     """
-    modes = ['free', 'fix', 'pyf']
-    pattern = r'(interface\s*(\w+\s*\(.*\)|\w*)|abstract\s*interface)\Z'
+
+    modes = ["free", "fix", "pyf"]
+    pattern = r"(interface\s*(\w+\s*\(.*\)|\w*)|abstract\s*interface)\Z"
     match = re.compile(pattern, re.I).match
     end_stmt_cls = EndInterface
-    blocktype = 'interface'
+    blocktype = "interface"
 
     a = AttributeHolder(interface_provides={})
 
     def get_classes(self):
         line = intrinsic_type_spec + interface_specification
-        if self.reader.format.mode == 'pyf':
+        if self.reader.format.mode == "pyf":
             return [Subroutine, Function] + line
         return line
 
     def process_item(self):
         line = self.item.get_line()
         line = self.item.apply_map(line)
-        self.isabstract = line.startswith('abstract')
+        self.isabstract = line.startswith("abstract")
         if self.isabstract:
-            self.generic_spec = ''
+            self.generic_spec = ""
         else:
-            self.generic_spec = line[len(self.blocktype):].strip()
+            self.generic_spec = line[len(self.blocktype) :].strip()
         self.name = self.generic_spec  # XXX
         return BeginStatement.process_item(self)
 
     def tostr(self):
         if self.isabstract:
-            return 'ABSTRACT INTERFACE'
-        return 'INTERFACE ' + str(self.generic_spec)
+            return "ABSTRACT INTERFACE"
+        return "INTERFACE " + str(self.generic_spec)
 
     def analyze(self):
         content = self.content[:]
 
         while content:
             stmt = content.pop(0)
             if isinstance(stmt, self.end_stmt_cls):
                 break
             stmt.analyze()
         if content:
-            logger.info('Not analyzed content: %s' % content)
+            logger.info("Not analyzed content: %s" % content)
             # self.show_message('Not analyzed content: %s' % content)
 
         if self.name in self.parent.a.variables:
             var = self.parent.a.variables.pop(self.name)
             self.update_attributes(var.attributes)
 
         if isinstance(self.parent, Module):  # XXX
@@ -637,58 +699,64 @@
                 assert isinstance(last, EndInterface), repr(last.__class__)
                 p.content += self.content
                 p.update_attributes(self.a.attributes)
             else:
                 parent_interface[self.name] = self
             return
 
-    def topyf(self, tab=''):
-        s = tab + self.tostr() + '\n'
-        s += HasImplicitStmt.topyf(self, tab=tab+'  ')
-        s += HasAttributes.topyf(self, tab=tab+'  ')
-        s += HasUseStmt.topyf(self, tab=tab+'  ')
-        s += tab + 'END' + self.tostr() + '\n'
+    def topyf(self, tab=""):
+        s = tab + self.tostr() + "\n"
+        s += HasImplicitStmt.topyf(self, tab=tab + "  ")
+        s += HasAttributes.topyf(self, tab=tab + "  ")
+        s += HasUseStmt.topyf(self, tab=tab + "  ")
+        s += tab + "END" + self.tostr() + "\n"
         return s
 
 
 # Subroutine
 
-class SubProgramStatement(BeginStatement, ProgramBlock,
-                          HasImplicitStmt, HasAttributes,
-                          HasUseStmt,
-                          HasVariables, HasTypeDecls, AccessSpecs
-                          ):
+
+class SubProgramStatement(
+    BeginStatement,
+    ProgramBlock,
+    HasImplicitStmt,
+    HasAttributes,
+    HasUseStmt,
+    HasVariables,
+    HasTypeDecls,
+    AccessSpecs,
+):
     """
     [<prefix>] <FUNCTION|SUBROUTINE> <name> [( <args> )] [<suffix>]
     """
 
     a = AttributeHolder(internal_subprogram={})
-    known_attributes = ['RECURSIVE', 'PURE', 'ELEMENTAL']
+    known_attributes = ["RECURSIVE", "PURE", "ELEMENTAL"]
 
     def process_item(self):
         clsname = self.__class__.__name__.lower()
         item = self.item
         line = item.get_line()
         m = self.match(line)
         i = line.lower().find(clsname)
         assert i != -1, repr((clsname, line))
         self.prefix = line[:i].rstrip()
-        self.name = line[i:m.end()].lstrip()[len(clsname):].strip()
-        line = line[m.end():].lstrip()
+        self.name = line[i : m.end()].lstrip()[len(clsname) :].strip()
+        line = line[m.end() :].lstrip()
         args = []
-        if line.startswith('('):
-            i = line.find(')')
+        if line.startswith("("):
+            i = line.find(")")
             assert i != -1, repr(line)
-            line2 = item.apply_map(line[:i+1])
-            for a in line2[1:-1].split(','):
+            line2 = item.apply_map(line[: i + 1])
+            for a in line2[1:-1].split(","):
                 a = a.strip()
                 if not a:
                     continue
                 args.append(a)
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
         suffix = item.apply_map(line)
         self.bind, suffix = parse_bind(suffix, item)
         self.result = None
         if isinstance(self, Function):
             self.result, suffix = parse_result(suffix, item)
             if suffix:
                 assert self.bind is None, repr(self.bind)
@@ -698,47 +766,48 @@
         assert not suffix, repr(suffix)
         self.args = args
         self.typedecl = None
         return BeginStatement.process_item(self)
 
     def tostr(self):
         clsname = self.__class__.__name__.upper()
-        s = ''
+        s = ""
         if self.prefix:
-            s += self.prefix + ' '
+            s += self.prefix + " "
         if self.typedecl is not None:
             assert isinstance(self, Function), repr(self.__class__.__name__)
-            s += self.typedecl.tostr() + ' '
+            s += self.typedecl.tostr() + " "
         s += clsname
-        suf = ''
+        suf = ""
         if self.result and self.result != self.name:
-            suf += ' RESULT ( %s )' % (self.result)
+            suf += " RESULT ( %s )" % (self.result)
         if self.bind:
-            suf += ' BIND ( %s )' % (', '.join(self.bind))
-        return '%s %s(%s)%s' % (s, self.name, ', '.join(self.args), suf)
+            suf += " BIND ( %s )" % (", ".join(self.bind))
+        return "%s %s(%s)%s" % (s, self.name, ", ".join(self.args), suf)
 
     def get_classes(self):
-        return f2py_stmt + specification_part + execution_part \
-               + internal_subprogram_part
+        return (
+            f2py_stmt + specification_part + execution_part + internal_subprogram_part
+        )
 
     def analyze(self):
         content = self.content[:]
 
         if self.prefix:
             self.update_attributes(self.prefix.upper().split())
 
         variables = self.a.variables
         for a in self.args:
             assert a not in variables
             if is_name(a):
                 variables[a] = Variable(self, a)
-            elif a == '*':
+            elif a == "*":
                 variables[a] = Variable(self, a)  # XXX: fix me appropriately
             else:
-                message = 'argument must be a name or * but got %r'
+                message = "argument must be a name or * but got %r"
                 raise AnalyzeError(message % (a))
 
         if isinstance(self, Function):
             var = variables[self.result] = Variable(self, self.result)
             if self.typedecl is not None:
                 var.set_type(self.typedecl)
 
@@ -754,192 +823,210 @@
                 assert isinstance(stmt, self.end_stmt_cls), repr(stmt)
             elif isinstance(stmt, self.end_stmt_cls):
                 continue
             else:
                 if hasattr(stmt, "analyze"):
                     stmt.analyze()
                 else:
-                    message = 'Failed to parse: {0}'
+                    message = "Failed to parse: {0}"
                     raise AnalyzeError(message.format(str(stmt)))
 
         if content:
-            logger.info('Not analyzed content: %s' % content)
+            logger.info("Not analyzed content: %s" % content)
             # self.show_message('Not analyzed content: %s' % content)
 
         parent_provides = self.parent.get_provides()
         if parent_provides is not None:
             if self.name in parent_provides:
-                message = 'module subprogram name conflict with %s, ' \
-                          + 'overriding.'
+                message = "module subprogram name conflict with %s, " + "overriding."
                 self.warning(message % (self.name))
             if self.is_public():
                 parent_provides[self.name] = self
 
         if self.is_recursive() and self.is_elemental():
-            message = 'C1241 violation: prefix cannot specify both ' \
-                      + 'ELEMENTAL and RECURSIVE'
+            message = (
+                "C1241 violation: prefix cannot specify both "
+                + "ELEMENTAL and RECURSIVE"
+            )
             self.warning(message)
         return
 
-    def topyf(self, tab=''):
+    def topyf(self, tab=""):
         s = tab + self.__class__.__name__.upper()
-        s += ' ' + self.name + ' (%s)' % (', '.join(self.args))
+        s += " " + self.name + " (%s)" % (", ".join(self.args))
         if isinstance(self, Function) and self.result != self.name:
-            s += ' RESULT (%s)' % (self.result)
-        s += '\n'
-        s += HasImplicitStmt.topyf(self, tab=tab+'  ')
-        s += AccessSpecs.topyf(self, tab=tab+'  ')
-        s += HasTypeDecls.topyf(self, tab=tab+'  ')
-        s += HasVariables.topyf(self, tab=tab + '  ',
-                                only_variables=self.args)
-        s += tab + 'END ' + self.__class__.__name__.upper() \
-            + ' ' + self.name + '\n'
+            s += " RESULT (%s)" % (self.result)
+        s += "\n"
+        s += HasImplicitStmt.topyf(self, tab=tab + "  ")
+        s += AccessSpecs.topyf(self, tab=tab + "  ")
+        s += HasTypeDecls.topyf(self, tab=tab + "  ")
+        s += HasVariables.topyf(self, tab=tab + "  ", only_variables=self.args)
+        s += tab + "END " + self.__class__.__name__.upper() + " " + self.name + "\n"
         return s
 
-    def is_public(self): return not self.is_private()
+    def is_public(self):
+        return not self.is_private()
 
-    def is_private(self): return self.parent.check_private(self.name)
+    def is_private(self):
+        return self.parent.check_private(self.name)
 
-    def is_recursive(self): return 'RECURSIVE' in self.a.attributes
+    def is_recursive(self):
+        return "RECURSIVE" in self.a.attributes
 
-    def is_pure(self): return 'PURE' in self.a.attributes
+    def is_pure(self):
+        return "PURE" in self.a.attributes
 
-    def is_elemental(self): return 'ELEMENTAL' in self.a.attributes
+    def is_elemental(self):
+        return "ELEMENTAL" in self.a.attributes
 
 
 class EndSubroutine(EndStatement):
     """
     END [SUBROUTINE [name]]
     """
-    match = re.compile(r'end\s*(?:subroutine\s*(?:(?P<name>\w+)\s*)?)?$',
-                       re.IGNORECASE).match
+
+    match = re.compile(
+        r"end\s*(?:subroutine\s*(?:(?P<name>\w+)\s*)?)?$", re.IGNORECASE
+    ).match
 
 
 class Subroutine(SubProgramStatement):
     """
     [<prefix>] SUBROUTINE <name> [( [<dummy-arg-list>] )
     [<proc-language-binding-spec>]]
     """
+
     end_stmt_cls = EndSubroutine
-    pattern = r'(recursive|pure|elemental|\s)*subroutine\s*\w+'
+    pattern = r"(recursive|pure|elemental|\s)*subroutine\s*\w+"
     match = re.compile(pattern, re.I).match
-    _repr_attr_names = ['prefix', 'bind', 'suffix', 'args'] \
-        + Statement._repr_attr_names
+    _repr_attr_names = ["prefix", "bind", "suffix", "args"] + Statement._repr_attr_names
 
 
 # Function
 
+
 class EndFunction(EndStatement):
     """
     END [FUNCTION [name]]
     """
-    match = re.compile(r'end(\s*function\s*\w*|)\Z', re.I).match
+
+    match = re.compile(r"end(\s*function\s*\w*|)\Z", re.I).match
 
 
 class Function(SubProgramStatement):
     """
-    [<prefix>] FUNCTION <name> ( [<dummy-arg-list>] ) [<suffix>]
-    <prefix> = <prefix-spec> [<prefix-spec>]...
-    <prefix-spec> = <declaration-type-spec>
-                  | RECURSIVE | PURE | ELEMENTAL
-    <suffix> = <proc-language-binding-spec> [RESULT ( <result-name> )]
-             | RESULT ( <result-name> ) [<proc-language-binding-spec>]
+    ::
+
+        [<prefix>] FUNCTION <name> ( [<dummy-arg-list>] ) [<suffix>]
+        <prefix> = <prefix-spec> [<prefix-spec>]...
+        <prefix-spec> = <declaration-type-spec>
+                      | RECURSIVE | PURE | ELEMENTAL
+        <suffix> = <proc-language-binding-spec> [RESULT ( <result-name> )]
+                 | RESULT ( <result-name> ) [<proc-language-binding-spec>]
     """
+
     end_stmt_cls = EndFunction
-    pattern = r'(recursive|pure|elemental|\s)*function\s*\w+'
+    pattern = r"(recursive|pure|elemental|\s)*function\s*\w+"
     match = re.compile(pattern, re.I).match
-    _repr_attr_names = ['prefix', 'bind', 'suffix', 'args', 'typedecl'] \
-        + Statement._repr_attr_names
+    _repr_attr_names = [
+        "prefix",
+        "bind",
+        "suffix",
+        "args",
+        "typedecl",
+    ] + Statement._repr_attr_names
 
     def subroutine_wrapper_code(self):
-        name = 'f2pywrap_' + self.name
-        args = ['f2pyvalue_'+self.result] + self.args
+        name = "f2pywrap_" + self.name
+        args = ["f2pyvalue_" + self.result] + self.args
         var = self.a.variables[self.result]
         typedecl = var.get_typedecl().astypedecl()
         lines = []
-        tab = ' '*6
-        lines.append('%sSUBROUTINE %s(%s)' % (tab, name, ', '.join(args)))
+        tab = " " * 6
+        lines.append("%sSUBROUTINE %s(%s)" % (tab, name, ", ".join(args)))
         if isinstance(self.parent, Module):
-            lines.append('%s  USE %s' % (tab, self.parent.name))
+            lines.append("%s  USE %s" % (tab, self.parent.name))
         else:
             if isinstance(typedecl, TypeStmt):
                 type_decl = typedecl.get_type_decl(typedecl.name)
                 if type_decl.parent is self:
-                    for line in str(type_decl).split('\n'):
-                        lines.append('%s  %s' % (tab, line.lstrip()))
-            lines.append('%s  EXTERNAL %s' % (tab, self.name))
-            lines.append('%s  %s %s' % (tab,
-                                        str(typedecl).lstrip(),
-                                        self.name))
-        lines.append('%s  %s %s' % (tab, str(typedecl).lstrip(), args[0]))
-        lines.append('!f2py intent(out) %s' % (args[0]))
+                    for line in str(type_decl).split("\n"):
+                        lines.append("%s  %s" % (tab, line.lstrip()))
+            lines.append("%s  EXTERNAL %s" % (tab, self.name))
+            lines.append("%s  %s %s" % (tab, str(typedecl).lstrip(), self.name))
+        lines.append("%s  %s %s" % (tab, str(typedecl).lstrip(), args[0]))
+        lines.append("!f2py intent(out) %s" % (args[0]))
         for a in self.args:
             v = self.a.variables[a]
-            lines.append('%s  %s' % (tab, str(v).lstrip()))
-        lines.append('%s  %s = %s(%s)' % (tab,
-                                          args[0],
-                                          self.name,
-                                          ', '.join(self.args)))
-        lines.append('%sEND SUBROUTINE %s' % (tab, name))
-        return '\n'.join(lines)
+            lines.append("%s  %s" % (tab, str(v).lstrip()))
+        lines.append(
+            "%s  %s = %s(%s)" % (tab, args[0], self.name, ", ".join(self.args))
+        )
+        lines.append("%sEND SUBROUTINE %s" % (tab, name))
+        return "\n".join(lines)
 
     def subroutine_wrapper(self):
         code = self.subroutine_wrapper_code()
         from .api import parse
+
         block = parse(code)  # XXX: set include_dirs
         while len(block.content) == 1:
             block = block.content[0]
         return block
 
 
 # Handle subprogram prefixes
 
+
 class SubprogramPrefix(Statement):
     """
     <prefix> <declaration-type-spec> <function|subroutine> ...
     """
-    match = re.compile(r'(pure|elemental|recursive|\s)+\b', re.I).match
+
+    match = re.compile(r"(pure|elemental|recursive|\s)+\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()
         m = self.match(line)
-        prefix = line[:m.end()].rstrip()
-        rest = self.item.get_line()[m.end():].lstrip()
+        prefix = line[: m.end()].rstrip()
+        rest = self.item.get_line()[m.end() :].lstrip()
         if rest:
             self.parent.put_item(self.item.copy(prefix))
             self.item.clone(rest)
             self.isvalid = False
             return
         if self.parent.__class__ not in [Function, Subroutine]:
             self.isvalid = False
             return
-        prefix = prefix + ' ' + self.parent.prefix
+        prefix = prefix + " " + self.parent.prefix
         self.parent.prefix = prefix.strip()
         self.ignore = True
         return
 
+
 # SelectCase
 
 
 class EndSelect(EndStatement):
-    match = re.compile(r'end\s*select\s*\w*\Z', re.I).match
-    blocktype = 'select'
+    match = re.compile(r"end\s*select\s*\w*\Z", re.I).match
+    blocktype = "select"
 
 
 class Select(BeginStatement):
     """
     Base class for the Select (case/type) statement
 
     """
+
     end_stmt_cls = EndSelect
-    name = ''
+    name = ""
 
     def process_item(self):
-        ''' Populate the state of this Select object by parsing the
-        associated line of code '''
+        """Populate the state of this Select object by parsing the
+        associated line of code"""
         item = self.item
         # TODO make the following more robust, particularly to the
         # presence of a name at the beginning
         # (e.g. "a_name: select case(...)")
         line = item.get_line()[6:].lstrip()[4:].lstrip()[1:-1].strip()
         self.expr = item.apply_map(line)
         self.construct_name = self.item.name
@@ -947,61 +1034,66 @@
 
 
 class SelectCase(Select):
     """
     [<case-construct-name> :] SELECT CASE ( <case-expr> )
 
     """
-    match = re.compile(r'select\s*case\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"select\s*case\s*\(.*\)\Z", re.I).match
 
     def tostr(self):
-        return 'SELECT CASE ( %s )' % (self.expr)
+        return "SELECT CASE ( %s )" % (self.expr)
 
     def get_classes(self):
-        ''' Return the list of classes that this instance may
-        have as children '''
+        """Return the list of classes that this instance may
+        have as children"""
         return [Case] + execution_part_construct
 
 
 class SelectType(Select):
     """
     [<case-construct-name> :] SELECT TYPE ( <case-expr> )
 
     """
-    match = re.compile(r'select\s*type\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"select\s*type\s*\(.*\)\Z", re.I).match
 
     def tostr(self):
-        return 'SELECT TYPE ( %s )' % (self.expr)
+        return "SELECT TYPE ( %s )" % (self.expr)
 
     def get_classes(self):
-        ''' Return the list of classes that this instance may
-        have as children '''
+        """Return the list of classes that this instance may
+        have as children"""
         return [TypeIs, ClassIs] + execution_part_construct
 
 
 # Where
 
+
 class EndWhere(EndStatement):
     """
     END WHERE [<where-construct-name>]
     """
-    match = re.compile(r'end\s*\where\s*\w*\Z', re.I).match
+
+    match = re.compile(r"end\s*\where\s*\w*\Z", re.I).match
 
 
 class Where(BeginStatement):
     """
     [<where-construct-name> :] WHERE ( <mask-expr> )
     <mask-expr> = <logical-expr>
     """
-    match = re.compile(r'where\s*\([^)]*\)\Z', re.I).match
+
+    match = re.compile(r"where\s*\([^)]*\)\Z", re.I).match
     end_stmt_cls = EndWhere
-    name = ''
+    name = ""
 
     def tostr(self):
-        return 'WHERE ( %s )' % (self.expr)
+        return "WHERE ( %s )" % (self.expr)
 
     def process_item(self):
         self.expr = self.item.get_line()[5:].lstrip()[1:-1].strip()
         self.construct_name = self.item.name
         return BeginStatement.process_item(self)
 
     def get_classes(self):
@@ -1009,19 +1101,21 @@
 
 
 WhereConstruct = Where
 
 
 # Forall
 
+
 class EndForall(EndStatement):
     """
     END FORALL [<forall-construct-name>]
     """
-    match = re.compile(r'end\s*forall\s*\w*\Z', re.I).match
+
+    match = re.compile(r"end\s*forall\s*\w*\Z", re.I).match
 
 
 class Forall(BeginStatement):
     """
     [<forall-construct-name> :] FORALL <forall-header>
       [<forall-body-construct>]...
     <forall-body-construct> = <forall-assignment-stmt>
@@ -1031,88 +1125,96 @@
                             | <forall-stmt>
     <forall-header> = ( <forall-triplet-spec-list> [, <scalar-mask-expr>] )
     <forall-triplet-spec> = <index-name> = <subscript> : <subscript>
                             [: <stride>]
     <subscript|stride> = <scalar-int-expr>
     <forall-assignment-stmt> = <assignment-stmt> | <pointer-assignment-stmt>
     """
+
     end_stmt_cls = EndForall
-    match = re.compile(r'forall\s*\(.*\)\Z', re.I).match
-    name = ''
+    match = re.compile(r"forall\s*\(.*\)\Z", re.I).match
+    name = ""
 
     def process_item(self):
         self.specs = self.item.get_line()[6:].lstrip()[1:-1].strip()
         return BeginStatement.process_item(self)
 
     def tostr(self):
-        return 'FORALL (%s)' % (self.specs)
+        return "FORALL (%s)" % (self.specs)
 
     def get_classes(self):
-        return [GeneralAssignment, WhereStmt, WhereConstruct,
-                ForallConstruct, ForallStmt]
+        return [
+            GeneralAssignment,
+            WhereStmt,
+            WhereConstruct,
+            ForallConstruct,
+            ForallStmt,
+        ]
 
 
 ForallConstruct = Forall
 
 
 # IfThen
 
+
 class EndIfThen(EndStatement):
     """
     END IF [<if-construct-name>]
     """
-    match = re.compile(r'end\s*if\s*\w*\Z', re.I).match
-    blocktype = 'if'
+
+    match = re.compile(r"end\s*if\s*\w*\Z", re.I).match
+    blocktype = "if"
 
 
 class IfThen(BeginStatement):
     """
     [<if-construct-name> :] IF ( <scalar-logical-expr> ) THEN
 
     IfThen instance has the following attributes:
       expr
     """
 
-    match = re.compile(r'if\s*\(.*\)\s*then\Z', re.I).match
+    match = re.compile(r"if\s*\(.*\)\s*then\Z", re.I).match
     end_stmt_cls = EndIfThen
-    name = ''
+    name = ""
 
     def tostr(self):
-        return 'IF (%s) THEN' % (self.expr)
+        return "IF (%s) THEN" % (self.expr)
 
     def process_item(self):
         item = self.item
         line = item.get_line()[2:-4].strip()
-        assert line[0] == '(' and line[-1] == ')', repr(line)
+        assert line[0] == "(" and line[-1] == ")", repr(line)
         self.expr = item.apply_map(line[1:-1].strip())
         self.construct_name = item.name
         return BeginStatement.process_item(self)
 
     def get_classes(self):
         return [Else, ElseIf] + execution_part_construct
 
 
 class If(BeginStatement):
     """
     IF ( <scalar-logical-expr> ) action-stmt
     """
 
-    match = re.compile(r'if\s*\(', re.I).match
+    match = re.compile(r"if\s*\(", re.I).match
 
     def process_item(self):
         item = self.item
         mode = self.reader.format.mode
         classes = self.get_classes()
         classes = [cls for cls in classes if mode in cls.modes]
 
         line = item.get_line()[2:].lstrip()
-        i = line.find(')')
+        i = line.find(")")
         expr = line[1:i].strip()
-        line = line[i+1:].strip()
-        if line.lower() == 'then':
+        line = line[i + 1 :].strip()
+        if line.lower() == "then":
             self.isvalid = False
             return
         self.expr = item.apply_map(expr)
 
         if not line:
             newitem = self.get_item()
         else:
@@ -1127,271 +1229,287 @@
         if not line:
             self.put_item(newitem)
         self.isvalid = False
         return
 
     def tostr(self):
         assert len(self.content) == 1, repr(self.content)
-        return 'IF (%s) %s' % (self.expr, str(self.content[0]).lstrip())
+        return "IF (%s) %s" % (self.expr, str(self.content[0]).lstrip())
 
     def tofortran(self, isfix=None):
         return self.get_indent_tab(isfix=isfix) + self.tostr()
 
     def get_classes(self):
         return action_stmt
 
 
 # Do
 
+
 class EndDo(EndStatement):
     """
     END DO [<do-construct-name>]
     """
-    match = re.compile(r'end\s*do\s*(?:(?P<name>\w+)\s*)?\Z',
-                       re.IGNORECASE).match
-    blocktype = 'do'
+
+    match = re.compile(r"end\s*do\s*(?:(?P<name>\w+)\s*)?\Z", re.IGNORECASE).match
+    blocktype = "do"
 
     def process_item(self):
-        '''
+        """
         Parses the next line assuming it is an "End do" statement.
 
         Overrides method in `EndStatement`.
-        '''
+        """
         item = self.item
         line = item.get_line()
         matched = self.match(line)
         # Check for matching labels
-        found_label = getattr(self.item, 'label', None)
-        expected_label = getattr(self.parent, 'endlabel', None)
+        found_label = getattr(self.item, "label", None)
+        expected_label = getattr(self.parent, "endlabel", None)
         if expected_label:
             if found_label:
                 if found_label != expected_label:
-                    message = 'When entering the "do" block {start} was' \
-                              + ' given as the end label but {end} was found.'
-                    self.warning(message.format(start=expected_label,
-                                                end=found_label))
+                    message = (
+                        'When entering the "do" block {start} was'
+                        + " given as the end label but {end} was found."
+                    )
+                    self.warning(message.format(start=expected_label, end=found_label))
                     self.isvalid = False
             else:
-                message = 'A label was specified when entering the "do" ' \
-                          + ' block ({label}) but none was found at the end.'
+                message = (
+                    'A label was specified when entering the "do" '
+                    + " block ({label}) but none was found at the end."
+                )
                 self.warning(message.format(label=expected_label))
                 self.isvalid = False
         # Check for matching names
-        found_name = matched.group('name') or None
+        found_name = matched.group("name") or None
         expected_name = self.parent.construct_name
         if expected_name:
             if found_name:
                 if found_name != expected_name:
-                    message = 'The "do" block was specified with the name' \
-                              + ' "{open}" but was closed with the name' \
-                              + ' "{close}".'
-                    self.warning(message.format(open=expected_name,
-                                                close=found_name))
+                    message = (
+                        'The "do" block was specified with the name'
+                        + ' "{open}" but was closed with the name'
+                        + ' "{close}".'
+                    )
+                    self.warning(message.format(open=expected_name, close=found_name))
                     self.isvalid = False
             else:
-                message = 'A name ("{name}") was specified for the "do" ' \
-                          + 'block but was not given when closing the block.'
+                message = (
+                    'A name ("{name}") was specified for the "do" '
+                    + "block but was not given when closing the block."
+                )
                 self.warning(message.format(name=expected_name))
                 self.isvalid = False
         else:
             if found_name:
-                message = 'The name "{name}" was used when closing a "do"' \
-                          + 'block but none was specified when opening it.'
+                message = (
+                    'The name "{name}" was used when closing a "do"'
+                    + "block but none was specified when opening it."
+                )
                 self.warning(message.format(name=found_name))
                 self.isvalid = False
         return EndStatement.process_item(self)
 
 
 class Do(BeginStatement):
     """
     [<do-construct-name> :] DO label [loopcontrol]
     [<do-construct-name> :] DO [loopcontrol]
 
     """
 
-    match = re.compile(r'do\b\s*\d*', re.I).match
-    pattern = r'do\b\s*(?:(?P<label>\d+)\s*)?(?:,\s*)?(?P<loopcontrol>.+)?\Z'
+    match = re.compile(r"do\b\s*\d*", re.I).match
+    pattern = r"do\b\s*(?:(?P<label>\d+)\s*)?(?:,\s*)?(?P<loopcontrol>.+)?\Z"
     item_re = re.compile(pattern, re.IGNORECASE).match
     end_stmt_cls = EndDo
-    name = ''
+    name = ""
 
     def tostr(self):
-        lst = ['DO']
+        lst = ["DO"]
         for part in [self.endlabel, self.loopcontrol]:
             if part:
                 lst.append(str(part))
-        return ' '.join(lst)
+        return " ".join(lst)
 
     def process_item(self):
-        '''
+        """
         Parses the next line assuming it is a "Do" statement.
 
         Overrides method in `BeginStatement`.
-        '''
+        """
         item = self.item
         line = item.get_line()
         matched = self.item_re(line)
-        if matched.group('label'):
-            self.endlabel = int(matched.group('label').strip())
+        if matched.group("label"):
+            self.endlabel = int(matched.group("label").strip())
         else:
             self.endlabel = None
         self.construct_name = item.name
-        if matched.group('loopcontrol'):
-            self.loopcontrol \
-                = item.apply_map(matched.group('loopcontrol').strip())
+        if matched.group("loopcontrol"):
+            self.loopcontrol = item.apply_map(matched.group("loopcontrol").strip())
         else:
             self.loopcontrol = None
         return BeginStatement.process_item(self)
 
     def process_subitem(self, item):
         result = False
         if self.endlabel:
             label = item.label
             if label == self.endlabel:
                 result = True
-                if isinstance(self.parent,
-                              Do) and label == self.parent.endlabel:
+                if isinstance(self.parent, Do) and label == self.parent.endlabel:
                     # the same item label may be used for different block ends
                     self.put_item(item)
         return BeginStatement.process_subitem(self, item) or result
 
     def get_classes(self):
         return execution_part_construct
 
 
 # Associate
 
+
 class EndAssociate(EndStatement):
     """
     END ASSOCIATE [<associate-construct-name>]
     """
-    match = re.compile(r'end\s*associate\s*\w*\Z', re.I).match
+
+    match = re.compile(r"end\s*associate\s*\w*\Z", re.I).match
 
 
 class Associate(BeginStatement):
     """
     [<associate-construct-name> :] ASSOCIATE ( <association-list> )
       <block>
 
     <association> = <associate-name> => <selector>
     <selector> = <expr> | <variable>
     """
-    match = re.compile(r'associate\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"associate\s*\(.*\)\Z", re.I).match
     end_stmt_cls = EndAssociate
 
     def process_item(self):
         line = self.item.get_line()[9:].lstrip()
         self.associations = line[1:-1].strip()
         return BeginStatement.process_item(self)
 
     def tostr(self):
-        return 'ASSOCIATE (%s)' % (self.associations)
+        return "ASSOCIATE (%s)" % (self.associations)
 
     def get_classes(self):
         return execution_part_construct
 
 
 # Type
 
+
 class EndType(EndStatement):
     """
     END TYPE [<type-name>]
     """
-    match = re.compile(r'end\s*type\s*\w*\Z', re.I).match
-    blocktype = 'type'
+
+    match = re.compile(r"end\s*type\s*\w*\Z", re.I).match
+    blocktype = "type"
 
 
-class Type(BeginStatement, HasVariables, HasAttributes, HasModuleProcedures,
-           AccessSpecs):
+class Type(
+    BeginStatement, HasVariables, HasAttributes, HasModuleProcedures, AccessSpecs
+):
     """
     TYPE [[, <typ-attr-spec-list>] ::] <type-name> [( <type-param-name-list> )]
     <typ-attr-spec> = <access-spec> | EXTENDS ( <parent-type-name> )
                       | ABSTRACT | BIND(C)
     """
-    match = re.compile(r'type\b\s*').match
+
+    match = re.compile(r"type\b\s*").match
     end_stmt_cls = EndType
 
-    a = AttributeHolder(extends=None,
-                        parameters={},
-                        component_names=[],  # Order for sequence types
-                        components={}
-                        )
-    pattern = r'\A(PUBLIC|PRIVATE|SEQUENCE|ABSTRACT|BIND\s*\(.*\))\Z'
+    a = AttributeHolder(
+        extends=None,
+        parameters={},
+        component_names=[],  # Order for sequence types
+        components={},
+    )
+    pattern = r"\A(PUBLIC|PRIVATE|SEQUENCE|ABSTRACT|BIND\s*\(.*\))\Z"
     known_attributes = re.compile(pattern, re.I).match
 
     def process_item(self):
         line = self.item.get_line()[4:].lstrip()
-        if line.startswith('('):
+        if line.startswith("("):
             self.isvalid = False
             return
         specs = []
-        i = line.find('::')
+        i = line.find("::")
         if i != -1:
-            for s in line[:i].split(','):
+            for s in line[:i].split(","):
                 s = s.strip()
                 if s:
                     specs.append(s)
-            line = line[i+2:].lstrip()
+            line = line[i + 2 :].lstrip()
         self.specs = specs
-        i = line.find('(')
+        i = line.find("(")
         if i != -1:
             self.name = line[:i].rstrip()
-            assert line[-1] == ')', repr(line)
-            self.params = split_comma(line[i+1:-1].lstrip())
+            assert line[-1] == ")", repr(line)
+            self.params = split_comma(line[i + 1 : -1].lstrip())
         else:
             self.name = line
             self.params = []
         if not is_name(self.name):
             self.isvalid = False
             return
         return BeginStatement.process_item(self)
 
     def tostr(self):
-        s = 'TYPE'
+        s = "TYPE"
         if self.specs:
-            s += ', '.join(['']+self.specs) + ' ::'
-        s += ' ' + self.name
+            s += ", ".join([""] + self.specs) + " ::"
+        s += " " + self.name
         if self.params:
-            s += ' ('+', '.join(self.params)+')'
+            s += " (" + ", ".join(self.params) + ")"
         return s
 
     def get_classes(self):
-        return [Integer] + private_or_sequence + component_part +\
-               type_bound_procedure_part
+        return (
+            [Integer] + private_or_sequence + component_part + type_bound_procedure_part
+        )
 
     def analyze(self):
         for spec in self.specs:
-            i = spec.find('(')
+            i = spec.find("(")
             if i != -1:
-                assert spec.endswith(')'), repr(spec)
+                assert spec.endswith(")"), repr(spec)
                 s = spec[:i].rstrip().upper()
-                n = spec[i+1:-1].strip()
-                if s == 'EXTENDS':
+                n = spec[i + 1 : -1].strip()
+                if s == "EXTENDS":
                     self.a.extends = n
                     continue
-                elif s == 'BIND':
+                elif s == "BIND":
                     args, rest = parse_bind(spec)
                     assert not rest, repr(rest)
-                    spec = 'BIND(%s)' % (', '.join(args))
+                    spec = "BIND(%s)" % (", ".join(args))
                 else:
-                    spec = '%s(%s)' % (s, n)
+                    spec = "%s(%s)" % (s, n)
             else:
                 spec = spec.upper()
             self.update_attributes(spec)
 
         component_names = self.a.component_names
         content = self.content[:]
         while content:
             stmt = content.pop(0)
             if isinstance(stmt, self.end_stmt_cls):
                 break
             stmt.analyze()
 
         if content:
-            message = 'Not analyzed content: %s' % content
+            message = "Not analyzed content: %s" % content
             logging.getLogger(__class__).info(message)
 
         parameters = self.a.parameters
         components = self.a.components
         component_names = self.a.component_names
         for name in self.a.variable_names:
             var = self.a.variables[name]
@@ -1403,95 +1521,122 @@
 
         self.parent.a.type_decls[self.name] = self
 
         parent_provides = self.parent.get_provides()
         if parent_provides is not None:
             if self.is_public():
                 if self.name in parent_provides:
-                    message = 'type declaration name conflict with {}, ' \
-                              + 'overriding.'
+                    message = "type declaration name conflict with {}, " + "overriding."
                     self.warning(message.format(self.name))
                 parent_provides[self.name] = self
 
         return
 
-    def topyf(self, tab=''):
-        s = tab + 'TYPE'
+    def topyf(self, tab=""):
+        s = tab + "TYPE"
         if self.a.extends is not None:
-            s += ', EXTENDS(%s) ::' % (self.a.extends)
-        s += ' ' + self.name
+            s += ", EXTENDS(%s) ::" % (self.a.extends)
+        s += " " + self.name
         if self.a.parameters:
-            s += ' (%s)' % (', '.join(self.a.parameters))
-        s += '\n'
-        s += AccessSpecs.topyf(self, tab=tab+'  ')
-        s += HasAttributes.topyf(self, tab=tab+'  ')
-        s += HasVariables.topyf(self, tab=tab+'  ')
-        s += tab + 'END TYPE ' + self.name + '\n'
+            s += " (%s)" % (", ".join(self.a.parameters))
+        s += "\n"
+        s += AccessSpecs.topyf(self, tab=tab + "  ")
+        s += HasAttributes.topyf(self, tab=tab + "  ")
+        s += HasVariables.topyf(self, tab=tab + "  ")
+        s += tab + "END TYPE " + self.name + "\n"
         return s
 
     # Wrapper methods:
 
-    def is_public(self): return not self.is_private()
+    def is_public(self):
+        return not self.is_private()
 
     def is_private(self):
-        if 'PUBLIC' in self.a.attributes:
+        if "PUBLIC" in self.a.attributes:
             return False
-        if 'PRIVATE' in self.a.attributes:
+        if "PRIVATE" in self.a.attributes:
             return True
         return self.parent.check_private(self.name)
 
 
 TypeDecl = Type
 
 
 # Enum
 
+
 class EndEnum(EndStatement):
     """
     END ENUM
     """
-    match = re.compile(r'end\s*enum\Z', re.I).match
-    blocktype = 'enum'
+
+    match = re.compile(r"end\s*enum\Z", re.I).match
+    blocktype = "enum"
 
 
 class Enum(BeginStatement):
     """
     ENUM , BIND(C)
       <enumerator-def-stmt>
       [<enumerator-def-stmt>]...
     """
-    blocktype = 'enum'
+
+    blocktype = "enum"
     end_stmt_cls = EndEnum
-    match = re.compile(r'enum\s*,\s*bind\s*\(\s*c\s*\)\Z', re.I).match
+    match = re.compile(r"enum\s*,\s*bind\s*\(\s*c\s*\)\Z", re.I).match
 
     def process_item(self):
         return BeginStatement.process_item(self)
 
     def get_classes(self):
         return [Enumerator]
 
 
 ##############################################################################
 
-f2py_stmt = [Threadsafe, FortranName, Depend, Check, CallStatement,
-             CallProtoArgument]
+f2py_stmt = [Threadsafe, FortranName, Depend, Check, CallStatement, CallProtoArgument]
 
 access_spec = [Public, Private]
 
 interface_specification = [Function, Subroutine, ModuleProcedure]
 
 module_subprogram_part = [Contains, Function, Subroutine]
 
-specification_stmt = access_spec \
-    + [Allocatable, Asynchronous, Bind, Common, Data, Dimension, Equivalence,
-       External, Intent, Intrinsic, Namelist, Optional, Pointer, Protected,
-       Save, Target, Volatile, Value]
-
-intrinsic_type_spec = [SubprogramPrefix, Integer, Real,  DoublePrecision,
-                       Complex, DoubleComplex, Character, Logical, Byte]
+specification_stmt = access_spec + [
+    Allocatable,
+    Asynchronous,
+    Bind,
+    Common,
+    Data,
+    Dimension,
+    Equivalence,
+    External,
+    Intent,
+    Intrinsic,
+    Namelist,
+    Optional,
+    Pointer,
+    Protected,
+    Save,
+    Target,
+    Volatile,
+    Value,
+]
+
+intrinsic_type_spec = [
+    SubprogramPrefix,
+    Integer,
+    Real,
+    DoublePrecision,
+    Complex,
+    DoubleComplex,
+    Character,
+    Logical,
+    Byte,
+]
 
 derived_type_spec = []
 type_spec = intrinsic_type_spec + derived_type_spec
 declaration_type_spec = intrinsic_type_spec + [TypeStmt, Class]
 
 type_declaration_stmt = declaration_type_spec
 
@@ -1500,27 +1645,60 @@
 component_part = declaration_type_spec + [ModuleProcedure]
 
 proc_binding_stmt = [SpecificBinding, GenericBinding, FinalBinding]
 
 type_bound_procedure_part = [Contains, Private] + proc_binding_stmt
 
 # R214
-action_stmt = [Allocate, GeneralAssignment, Assign, Backspace, Call, Close,
-               Continue, Cycle, Deallocate, Endfile, Exit, Flush, ForallStmt,
-               Goto, If, Inquire, Nullify, Open, Print, Read, Return, Rewind,
-               Stop, Wait, WhereStmt, Write, ArithmeticIf, ComputedGoto,
-               AssignedGoto, Pause]
+action_stmt = [
+    Allocate,
+    GeneralAssignment,
+    Assign,
+    Backspace,
+    Call,
+    Close,
+    Continue,
+    Cycle,
+    Deallocate,
+    Endfile,
+    Exit,
+    Flush,
+    ForallStmt,
+    Goto,
+    If,
+    Inquire,
+    Nullify,
+    Open,
+    Print,
+    Read,
+    Return,
+    Rewind,
+    Stop,
+    Wait,
+    WhereStmt,
+    Write,
+    ArithmeticIf,
+    ComputedGoto,
+    AssignedGoto,
+    Pause,
+]
 # GeneralAssignment = Assignment + PointerAssignment
 # EndFunction, EndProgram, EndSubroutine - part of the corresponding blocks
 
-executable_construct = [Associate, Do, ForallConstruct, IfThen,
-                        SelectCase, SelectType, WhereConstruct] + action_stmt
+executable_construct = [
+    Associate,
+    Do,
+    ForallConstruct,
+    IfThen,
+    SelectCase,
+    SelectType,
+    WhereConstruct,
+] + action_stmt
 
-execution_part_construct = executable_construct + [Format, Entry,
-                                                   Data]
+execution_part_construct = executable_construct + [Format, Entry, Data]
 
 execution_part = execution_part_construct[:]
 
 # C201, R208
 for cls in [EndFunction, EndProgram, EndSubroutine]:
     try:
         execution_part.remove(cls)
@@ -1529,25 +1707,35 @@
 
 internal_subprogram = [Function, Subroutine]
 
 internal_subprogram_part = [Contains] + internal_subprogram
 
 # In Fortran2003 we can have a Procedure declaration. We therefore
 # include SpecificBinding as a valid declaration construct.
-declaration_construct = [TypeDecl, Entry, Enum, Format, Interface,
-                         Parameter, ModuleProcedure, SpecificBinding] + \
-    specification_stmt + type_declaration_stmt
+declaration_construct = (
+    [
+        TypeDecl,
+        Entry,
+        Enum,
+        Format,
+        Interface,
+        Parameter,
+        ModuleProcedure,
+        SpecificBinding,
+    ]
+    + specification_stmt
+    + type_declaration_stmt
+)
 # stmt-function-stmt
 
 implicit_part = [Implicit, Parameter, Format, Entry]
 
-specification_part = [Use, Import] + implicit_part + \
-                     declaration_construct
+specification_part = [Use, Import] + implicit_part + declaration_construct
 
 
 external_subprogram = [Function, Subroutine]
 
-main_program = [Program] + specification_part + execution_part + \
-               internal_subprogram_part
+main_program = (
+    [Program] + specification_part + execution_part + internal_subprogram_part
+)
 
-program_unit = main_program + external_subprogram + [Module,
-                                                     BlockData]
+program_unit = main_program + external_subprogram + [Module, BlockData]
```

### Comparing `fparser-0.0.9/src/fparser/one/parsefortran.py` & `fparser-0.1.0/src/fparser/one/parsefortran.py`

 * *Files 9% similar despite different names*

```diff
@@ -70,91 +70,94 @@
 # Created: May 2006
 
 import logging
 
 from fparser.one.block_statements import BeginSource
 from fparser.common.utils import AnalyzeError
 
-__autodoc__ = ['FortranParser']
-__all__ = ['FortranParser']
+__autodoc__ = ["FortranParser"]
+__all__ = ["FortranParser"]
 
 
-class FortranParser(object):
-    '''
+class FortranParser:
+    """
     Parser of FortranReader structure.
 
     Use .parse() method for parsing, parsing result is saved in .block
     attribute.
-    '''
+    """
+
     cache = {}
 
     def __init__(self, reader, ignore_comments=True):
         self.reader = reader
         logging.getLogger(__name__).setLevel(logging.DEBUG)
         if reader.id in self.cache:
             parser = self.cache[reader.id]
             self.block = parser.block
             self.is_analyzed = parser.is_analyzed
-            logging.getLogger(__name__).info('using cached %s', (reader.id))
+            logging.getLogger(__name__).info("using cached %s", (reader.id))
         else:
             self.cache[reader.id] = self
             self.block = None
             self.is_analyzed = False
         self.ignore_comments = ignore_comments
         return
 
     def get_item(self):
-        '''
+        """
         Retrieves the next item from the reader.
-        '''
+        """
         try:
             item = self.reader.next(ignore_comments=self.ignore_comments)
             return item
         except StopIteration:
             pass
         return
 
     def put_item(self, item):
-        '''
+        """
         Pushes the given item to the reader.
-        '''
+        """
         self.reader.fifo_item.insert(0, item)
         return
 
     def parse(self):
-        '''Parses the program specified in the reader object.'''
+        """Parses the program specified in the reader object."""
         if self.block is not None:
             return
         try:
             self.block = BeginSource(self)
         except KeyboardInterrupt:
             raise
         except Exception as error:
             reader = self.reader
             logger = logging.getLogger(__name__)
             while reader is not None:
-                message = \
-                    reader.format_message('FATAL ERROR',
-                                          'while processing line',
-                                          reader.linecount, reader.linecount)
+                message = reader.format_message(
+                    "FATAL ERROR",
+                    "while processing line",
+                    reader.linecount,
+                    reader.linecount,
+                )
                 logger.critical(message)
                 reader = reader.reader
-            logger.debug('An error occurred during parsing.', exc_info=error)
-            logger.critical('STOPPED PARSING')
+            logger.debug("An error occurred during parsing.", exc_info=error)
+            logger.critical("STOPPED PARSING")
             raise error
         return
 
     def analyze(self):
-        '''
+        """
         Attempts to analyse the parsed Fortran. It is not clear what for.
-        '''
+        """
         if self.is_analyzed:
             return
         if self.block is None:
-            logging.getLogger(__name__).info('Nothing to analyze.')
+            logging.getLogger(__name__).info("Nothing to analyze.")
             return
 
         try:
             self.block.analyze()
         except AnalyzeError:
             pass
         self.is_analyzed = True
```

### Comparing `fparser-0.0.9/src/fparser/one/statements.py` & `fparser-0.1.0/src/fparser/one/statements.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017-2018 Science and Technology
+# Modified work Copyright (c) 2017-2022 Science and Technology
 # Facilities Council
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
@@ -64,131 +64,205 @@
 # DAMAGE.
 
 """
 Fortran single line statements.
 
 """
 
-from __future__ import print_function
-
 import re
 import sys
 
 from fparser.common.base_classes import Statement
 
 # Auxiliary tools
 
-from fparser.common.utils import split_comma, specs_split_comma, \
-                                 AnalyzeError, ParseError,       \
-                                 parse_bind, parse_result,       \
-                                 is_name, extract_bracketed_list_items
+from fparser.common.utils import (
+    split_comma,
+    specs_split_comma,
+    AnalyzeError,
+    ParseError,
+    parse_bind,
+    parse_result,
+    is_name,
+    extract_bracketed_list_items,
+)
 from fparser.common.utils import classes
 
-__all__ = ['GeneralAssignment',
-           'Assignment', 'PointerAssignment', 'Assign', 'Call', 'Goto',
-           'ComputedGoto', 'AssignedGoto', 'Continue', 'Return', 'Stop',
-           'Print', 'Read', 'Read0', 'Read1', 'Write', 'Flush', 'Wait',
-           'Contains', 'Allocate', 'Deallocate', 'ModuleProcedure', 'Access',
-           'Public', 'Private', 'Close', 'Cycle', 'Backspace', 'Endfile',
-           'Rewind', 'Open', 'Format', 'Save', 'Data', 'Nullify', 'Use',
-           'Exit', 'Parameter', 'Equivalence', 'Dimension', 'Target',
-           'Pointer', 'Protected', 'Volatile', 'Value', 'ArithmeticIf',
-           'Intrinsic', 'Inquire', 'Sequence', 'External', 'Namelist',
-           'Common', 'Optional', 'Intent', 'Entry', 'Import', 'ForallStmt',
-           'SpecificBinding', 'GenericBinding', 'FinalBinding', 'Allocatable',
-           'Asynchronous', 'Bind', 'Else', 'ElseIf', 'Case', 'TypeIs',
-           'ClassIs', 'WhereStmt', 'ElseWhere', 'Enumerator', 'FortranName',
-           'Threadsafe', 'Depend', 'Check', 'CallStatement',
-           'CallProtoArgument', 'Pause', 'Comment']
+__all__ = [
+    "GeneralAssignment",
+    "Assignment",
+    "PointerAssignment",
+    "Assign",
+    "Call",
+    "Goto",
+    "ComputedGoto",
+    "AssignedGoto",
+    "Continue",
+    "Return",
+    "Stop",
+    "Print",
+    "Read",
+    "Read0",
+    "Read1",
+    "Write",
+    "Flush",
+    "Wait",
+    "Contains",
+    "Allocate",
+    "Deallocate",
+    "ModuleProcedure",
+    "Access",
+    "Public",
+    "Private",
+    "Close",
+    "Cycle",
+    "Backspace",
+    "Endfile",
+    "Rewind",
+    "Open",
+    "Format",
+    "Save",
+    "Data",
+    "Nullify",
+    "Use",
+    "Exit",
+    "Parameter",
+    "Equivalence",
+    "Dimension",
+    "Target",
+    "Pointer",
+    "Protected",
+    "Volatile",
+    "Value",
+    "ArithmeticIf",
+    "Intrinsic",
+    "Inquire",
+    "Sequence",
+    "External",
+    "Namelist",
+    "Common",
+    "Optional",
+    "Intent",
+    "Entry",
+    "Import",
+    "ForallStmt",
+    "SpecificBinding",
+    "GenericBinding",
+    "FinalBinding",
+    "Allocatable",
+    "Asynchronous",
+    "Bind",
+    "Else",
+    "ElseIf",
+    "Case",
+    "TypeIs",
+    "ClassIs",
+    "WhereStmt",
+    "ElseWhere",
+    "Enumerator",
+    "FortranName",
+    "Threadsafe",
+    "Depend",
+    "Check",
+    "CallStatement",
+    "CallProtoArgument",
+    "Pause",
+    "Comment",
+]
 
 
 class StatementWithNamelist(Statement):
     """
     <statement> [ :: ] <name-list>
     """
+
     def process_item(self):
         if self.item.has_map():
             self.isvalid = False
             return
-        if hasattr(self, 'stmtname'):
+        if hasattr(self, "stmtname"):
             clsname = self.stmtname
         else:
             clsname = self.__class__.__name__
-        line = self.item.get_line()[len(clsname):].lstrip()
-        if line.startswith('::'):
+        line = self.item.get_line()[len(clsname) :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = items = []
         for item in split_comma(line):
             if not is_name(item):
                 self.isvalid = False
                 return
             items.append(item)
         return
 
     def tofortran(self, isfix=None):
-        if hasattr(self, 'stmtname'):
+        if hasattr(self, "stmtname"):
             clsname = self.stmtname.upper()
         else:
             clsname = self.__class__.__name__.upper()
-        s = ', '.join(self.items)
+        s = ", ".join(self.items)
         if s:
-            s = ' ' + s
+            s = " " + s
         return self.get_indent_tab(isfix=isfix) + clsname + s
 
+
 # Execution statements
 
 
 class GeneralAssignment(Statement):
     """
     <variable> = <expr>
     <pointer variable> => <expr>
     """
 
-    match = re.compile(r'\w[^=]*\s*=\>?').match
+    match = re.compile(r"\w[^=]*\s*=\>?").match
     item_re = re.compile(
-        r'(?P<variable>\w[^=]*)\s*(?P<sign>=\>?)\s*(?P<expr>.*)\Z', re.I).match
-    _repr_attr_names = ['variable', 'sign', 'expr'] \
-        + Statement._repr_attr_names
+        r"(?P<variable>\w[^=]*)\s*(?P<sign>=\>?)\s*(?P<expr>.*)\Z", re.I
+    ).match
+    _repr_attr_names = ["variable", "sign", "expr"] + Statement._repr_attr_names
 
     def process_item(self):
         m = self.item_re(self.item.get_line())
         if not m:
             self.isvalid = False
             return
-        self.sign = sign = m.group('sign')
-        if isinstance(self, Assignment) and sign != '=':
+        self.sign = sign = m.group("sign")
+        if isinstance(self, Assignment) and sign != "=":
             self.isvalid = False
             return
-        elif isinstance(self, PointerAssignment) and sign != '=>':
+        elif isinstance(self, PointerAssignment) and sign != "=>":
             self.isvalid = False
             return
         else:
-            if sign == '=>':
+            if sign == "=>":
                 self.__class__ = PointerAssignment
             else:
                 self.__class__ = Assignment
         apply_map = self.item.apply_map
-        v1 = v = m.group('variable').replace(' ', '')
+        v1 = v = m.group("variable").replace(" ", "")
         while True:
-            i = v.find(')')
+            i = v.find(")")
             if i == -1:
                 break
-            v = v[i+1:]
-            if v.startswith('(') or v.startswith(r'%'):
+            v = v[i + 1 :]
+            if v.startswith("(") or v.startswith(r"%"):
                 continue
             if v:
                 self.isvalid = False
                 return
         self.variable = apply_map(v1)
-        self.expr = apply_map(m.group('expr'))
+        self.expr = apply_map(m.group("expr"))
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + '%s %s %s' \
-               % (self.variable, self.sign, self.expr)
+        return self.get_indent_tab(isfix=isfix) + "%s %s %s" % (
+            self.variable,
+            self.sign,
+            self.expr,
+        )
 
     def analyze(self):
         return
 
 
 class Assignment(GeneralAssignment):
     pass
@@ -198,615 +272,655 @@
     pass
 
 
 class Assign(Statement):
     """
     ASSIGN <label> TO <int-variable-name>
     """
-    modes = ['fix77']
-    match = re.compile(r'assign\s*\d+\s*to\s*\w+\s*\Z', re.I).match
+
+    modes = ["fix77"]
+    match = re.compile(r"assign\s*\d+\s*to\s*\w+\s*\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[6:].lstrip()
-        i = line.lower().find('to')
+        i = line.lower().find("to")
         assert not self.item.has_map()
-        self.items = [line[:i].rstrip(), line[i+2:].lstrip()]
+        self.items = [line[:i].rstrip(), line[i + 2 :].lstrip()]
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'ASSIGN %s TO %s' \
-               % (self.items[0], self.items[1])
+        return self.get_indent_tab(isfix=isfix) + "ASSIGN %s TO %s" % (
+            self.items[0],
+            self.items[1],
+        )
 
     def analyze(self):
         return
 
 
 class Call(Statement):
-    """Call statement class
-    CALL <procedure-designator> [ ( [ <actual-arg-spec-list> ] ) ]
+    """
+    Call statement class::
+
+        CALL <procedure-designator> [ ( [ <actual-arg-spec-list> ] ) ]
+
+        <procedure-designator> = <procedure-name>
+                               | <proc-component-ref>
+                               | <data-ref> % <binding-name>
+
+        <actual-arg-spec> = [ <keyword> = ] <actual-arg>
+        <actual-arg> = <expr>
+                     | <variable>
+                     | <procedure-name>
+                     | <proc-component-ref>
+                     | <alt-return-spec>
+        <alt-return-spec> = * <label>
+
+        <proc-component-ref> = <variable> % <procedure-component-name>
+
+        <variable> = <designator>
 
-    <procedure-designator> = <procedure-name>
-                           | <proc-component-ref>
-                           | <data-ref> % <binding-name>
-
-    <actual-arg-spec> = [ <keyword> = ] <actual-arg>
-    <actual-arg> = <expr>
-                 | <variable>
-                 | <procedure-name>
-                 | <proc-component-ref>
-                 | <alt-return-spec>
-    <alt-return-spec> = * <label>
-
-    <proc-component-ref> = <variable> % <procedure-component-name>
-
-    <variable> = <designator>
-
-    Call instance has attributes:
-      designator
-      arg_list
     """
+
     # As indicated in the specification above, a call to a subroutine
     # that has no arguments does *not* require parentheses.
     # e.g.:
     #   call bob
     # is valid Fortran.
-    match = re.compile(r'call\b\s*\w([\s\w\(\)\%]*\w)?\s*(\(.*\))?\s*$',
-                       re.I).match
+    match = re.compile(r"call\b\s*\w([\s\w\(\)\%]*\w)?\s*(\(.*\))?\s*$", re.I).match
 
     def process_item(self):
-        ''' Parse the string containing the Call and store the
-        designator and list of arguments (if any) '''
+        """Parse the string containing the Call and store the
+        designator and list of arguments (if any)"""
         item = self.item
         apply_map = item.apply_map
         line = item.get_line()[4:].strip()
         # Work backwards from the end of the line in order to allow
         # for code like:
         #     call my_type(1)%my_function(arg(2))
         # The following code will also support something like:
         #     call my_type(1)%my_function("(")
         # because fparser will previously have identified the "(" as a
         # string expression and replaced it with something like
         # "F2PY_EXPR_TUPLE_2"
-        if line.endswith(')'):
+        if line.endswith(")"):
             # Work back down the line until we find the matching '('
             i = len(line) - 2
             nopen = 1
             while i > 0:
-                if line[i] == ')':
+                if line[i] == ")":
                     nopen += 1
-                elif line[i] == '(':
+                elif line[i] == "(":
                     nopen -= 1
                 if nopen == 0:
                     # Have found the matching '(' at position i
                     break
                 i -= 1
             if i <= 0:
                 # Have reached the beginning of the string without
                 # finding the matching '('
                 self.isvalid = False
                 return
             self.designator = apply_map(line[:i]).strip()
-            items = split_comma(line[i+1:-1], item)
+            items = split_comma(line[i + 1 : -1], item)
         else:
             # Call has no argument list
             items = []
             self.designator = apply_map(line).strip()
         self.items = items
         return
 
     def tofortran(self, isfix=None):
-        ''' Returns the Fortran representation of this object as a string '''
-        txt = self.get_indent_tab(isfix=isfix) + 'CALL ' + str(self.designator)
+        """Returns the Fortran representation of this object as a string"""
+        txt = self.get_indent_tab(isfix=isfix) + "CALL " + str(self.designator)
         if self.items:
-            txt += '(' + ', '.join(map(str, self.items)) + ')'
+            txt += "(" + ", ".join(map(str, self.items)) + ")"
         return txt
 
     def analyze(self):
         a = self.programblock.a
         variables = a.variables
-        if hasattr(a, 'external'):
+        if hasattr(a, "external"):
             external = a.external
             if self.designator in external:
-                print('Need to analyze:', self, file=sys.stderr)
+                print("Need to analyze:", self, file=sys.stderr)
         return
 
 
 class Goto(Statement):
     """
     GO TO <label>
     """
-    match = re.compile(r'go\s*to\s*\d+\s*\Z', re.I).match
+
+    match = re.compile(r"go\s*to\s*\d+\s*\Z", re.I).match
 
     def process_item(self):
         assert not self.item.has_map()
         self.label = self.item.get_line()[2:].lstrip()[2:].lstrip()
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'GO TO %s' % (self.label)
+        return self.get_indent_tab(isfix=isfix) + "GO TO %s" % (self.label)
 
     def analyze(self):
         return
 
 
 class ComputedGoto(Statement):
     """
     GO TO ( <label-list> ) [ , ] <scalar-int-expr>
     """
-    match = re.compile(r'go\s*to\s*\(', re.I).match
+
+    match = re.compile(r"go\s*to\s*\(", re.I).match
 
     def process_item(self):
         apply_map = self.item.apply_map
         line = self.item.get_line()[2:].lstrip()[2:].lstrip()
-        i = line.index(')')
+        i = line.index(")")
         self.items = split_comma(line[1:i], self.item)
-        line = line[i+1:].lstrip()
-        if line.startswith(','):
+        line = line[i + 1 :].lstrip()
+        if line.startswith(","):
             line = line[1:].lstrip()
         self.expr = apply_map(line)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'GO TO (%s) %s' \
-               % (', '.join(self.items), self.expr)
+        return self.get_indent_tab(isfix=isfix) + "GO TO (%s) %s" % (
+            ", ".join(self.items),
+            self.expr,
+        )
 
     def analyze(self):
         return
 
 
 class AssignedGoto(Statement):
     """
     GO TO <int-variable-name> [ ( <label> [ , <label> ]... ) ]
     """
-    modes = ['fix77']
-    match = re.compile(r'go\s*to\s*\w+\s*\(?', re.I).match
+
+    modes = ["fix77"]
+    match = re.compile(r"go\s*to\s*\w+\s*\(?", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[2:].lstrip()[2:].lstrip()
-        i = line.find('(')
+        i = line.find("(")
         if i == -1:
             self.varname = line
             self.items = []
             return
         self.varname = line[:i].rstrip()
-        assert line[-1] == ')', repr(line)
+        assert line[-1] == ")", repr(line)
         self
-        self.items = split_comma(line[i+1:-1], self.item)
+        self.items = split_comma(line[i + 1 : -1], self.item)
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         if self.items:
-            return tab + 'GO TO %s (%s)' \
-                   % (self.varname, ', '.join(self.items))
-        return tab + 'GO TO %s' % (self.varname)
+            return tab + "GO TO %s (%s)" % (self.varname, ", ".join(self.items))
+        return tab + "GO TO %s" % (self.varname)
 
-    def analyze(self): return
+    def analyze(self):
+        return
 
 
 class Continue(Statement):
     """
     CONTINUE
     """
-    match = re.compile(r'continue\Z', re.I).match
+
+    match = re.compile(r"continue\Z", re.I).match
 
     def process_item(self):
         self.label = self.item.label
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(deindent=True) + 'CONTINUE'
+        return self.get_indent_tab(deindent=True) + "CONTINUE"
 
     def analyze(self):
         return
 
 
 class Return(Statement):
     """
     RETURN [ <scalar-int-expr> ]
     """
-    match = re.compile(r'return\b', re.I).match
+
+    match = re.compile(r"return\b", re.I).match
 
     def process_item(self):
         self.expr = self.item.apply_map(self.item.get_line()[6:].lstrip())
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         if self.expr:
-            return tab + 'RETURN %s' % (self.expr)
-        return tab + 'RETURN'
+            return tab + "RETURN %s" % (self.expr)
+        return tab + "RETURN"
 
     def analyze(self):
         return
 
 
 class Stop(Statement):
     """
     STOP [ <stop-code> ]
     <stop-code> = <scalar-char-constant> | <1-5-digit>
     """
+
     match = re.compile(r'stop\s*((\'\w*\'|"\w*")+|\d+|)\Z', re.I).match
 
     def process_item(self):
         self.code = self.item.apply_map(self.item.get_line()[4:].lstrip())
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         if self.code:
-            return tab + 'STOP %s' % (self.code)
-        return tab + 'STOP'
+            return tab + "STOP %s" % (self.code)
+        return tab + "STOP"
 
     def analyze(self):
         return
 
 
 class Print(Statement):
     """
-    PRINT <format> [, <output-item-list>]
-    <format> = <default-char-expr> | <label> | *
+    ::
+
+        PRINT <format> [, <output-item-list>]
+        <format> = <default-char-expr> | <label> | *
+
+        <output-item> = <expr> | <io-implied-do>
+        <io-implied-do> = ( <io-implied-do-object-list> , <implied-do-control> )
+        <io-implied-do-object> = <input-item> | <output-item>
+        <implied-do-control> = <do-variable>
+                             = <scalar-int-expr> ,
+                               <scalar-int-expr> [ , <scalar-int-expr> ]
+        <input-item> = <variable> | <io-implied-do>
 
-    <output-item> = <expr> | <io-implied-do>
-    <io-implied-do> = ( <io-implied-do-object-list> , <implied-do-control> )
-    <io-implied-do-object> = <input-item> | <output-item>
-    <implied-do-control> = <do-variable>
-                         = <scalar-int-expr> ,
-                           <scalar-int-expr> [ , <scalar-int-expr> ]
-    <input-item> = <variable> | <io-implied-do>
     """
-    match = re.compile(r'print\s*(\'\w*\'|\"\w*\"|\d+|[*]|\b\w)', re.I).match
+
+    match = re.compile(r"print\s*(\'\w*\'|\"\w*\"|\d+|[*]|\b\w)", re.I).match
 
     def process_item(self):
         item = self.item
         apply_map = item.apply_map
         line = item.get_line()[5:].lstrip()
         items = split_comma(line, item)
         self.format = items[0]
         self.items = items[1:]
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'PRINT %s' \
-               % (', '.join([self.format]+self.items))
+        return self.get_indent_tab(isfix=isfix) + "PRINT %s" % (
+            ", ".join([self.format] + self.items)
+        )
 
     def analyze(self):
         return
 
 
 class Read(Statement):
     """
-Read0:    READ ( <io-control-spec-list> ) [ <input-item-list> ]
+    Read0:    READ ( <io-control-spec-list> ) [ <input-item-list> ]
 
-    <io-control-spec-list> = [ UNIT = ] <io-unit>
-                             | [ FORMAT = ] <format>
-                             | [ NML = ] <namelist-group-name>
-                             | ADVANCE = <scalar-default-char-expr>
-                             ...
+        <io-control-spec-list> = [ UNIT = ] <io-unit>
+                                 | [ FORMAT = ] <format>
+                                 | [ NML = ] <namelist-group-name>
+                                 | ADVANCE = <scalar-default-char-expr>
+                                 ...
 
-Read1:    READ <format> [, <input-item-list>]
-    <format> == <default-char-expr> | <label> | *
+    Read1:    READ <format> [, <input-item-list>]
+        <format> == <default-char-expr> | <label> | *
     """
+
     match = re.compile(r'read\b\s*[\w(*\'"]', re.I).match
 
     def process_item(self):
         item = self.item
         line = item.get_line()[4:].lstrip()
-        if line.startswith('('):
+        if line.startswith("("):
             self.__class__ = Read0
         else:
             self.__class__ = Read1
         self.process_item()
         return
 
     def analyze(self):
         return
 
 
 class Read0(Read):
-
     def process_item(self):
         item = self.item
         line = item.get_line()[4:].lstrip()
-        i = line.find(')')
+        i = line.find(")")
         self.specs = specs_split_comma(line[1:i], item)
-        self.items = split_comma(line[i+1:], item)
+        self.items = split_comma(line[i + 1 :], item)
         return
 
     def tofortran(self, isfix=None):
-        s = self.get_indent_tab(isfix=isfix) \
-            + 'READ (%s)' % (', '.join(self.specs))
+        s = self.get_indent_tab(isfix=isfix) + "READ (%s)" % (", ".join(self.specs))
         if self.items:
-            return s + ' ' + ', '.join(self.items)
+            return s + " " + ", ".join(self.items)
         return s
 
 
 class Read1(Read):
-
     def process_item(self):
         item = self.item
         line = item.get_line()[4:].lstrip()
         items = split_comma(line, item)
         self.format = items[0]
         self.items = items[1:]
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'READ ' \
-               + ', '.join([self.format]+self.items)
+        return (
+            self.get_indent_tab(isfix=isfix)
+            + "READ "
+            + ", ".join([self.format] + self.items)
+        )
 
 
 class Write(Statement):
     """
     WRITE ( io-control-spec-list ) [<output-item-list>]
     """
-    match = re.compile(r'write\s*\(', re.I).match
+
+    match = re.compile(r"write\s*\(", re.I).match
 
     def process_item(self):
         item = self.item
         line = item.get_line()[5:].lstrip()
-        i = line.find(')')
+        i = line.find(")")
         assert i != -1, repr(line)
         self.specs = specs_split_comma(line[1:i], item)
-        self.items = split_comma(line[i+1:], item)
+        self.items = split_comma(line[i + 1 :], item)
         return
 
     def tofortran(self, isfix=None):
-        s = self.get_indent_tab(isfix=isfix) \
-            + 'WRITE (%s)' % ', '.join(self.specs)
+        s = self.get_indent_tab(isfix=isfix) + "WRITE (%s)" % ", ".join(self.specs)
         if self.items:
-            s += ' ' + ', '.join(self.items)
+            s += " " + ", ".join(self.items)
         return s
 
     def analyze(self):
         return
 
 
 class Flush(Statement):
     """
-    FLUSH <file-unit-number>
-    FLUSH ( <flush-spec-list> )
-    <flush-spec> = [ UNIT = ] <file-unit-number>
-                 | IOSTAT = <scalar-int-variable>
-                 | IOMSG = <iomsg-variable>
-                 | ERR = <label>
+    ::
+
+        FLUSH <file-unit-number>
+        FLUSH ( <flush-spec-list> )
+        <flush-spec> = [ UNIT = ] <file-unit-number>
+                     | IOSTAT = <scalar-int-variable>
+                     | IOMSG = <iomsg-variable>
+                     | ERR = <label>
     """
-    match = re.compile(r'flush\b', re.I).match
+
+    match = re.compile(r"flush\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[5:].lstrip()
         if not line:
             self.isvalid = False
             return
-        if line.startswith('('):
-            assert line[-1] == ')', repr(line)
+        if line.startswith("("):
+            assert line[-1] == ")", repr(line)
             self.specs = specs_split_comma(line[1:-1], self.item)
         else:
             self.specs = specs_split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'FLUSH (%s)' % (', '.join(self.specs))
+        return tab + "FLUSH (%s)" % (", ".join(self.specs))
 
     def analyze(self):
         return
 
 
 class Wait(Statement):
     """
-    WAIT ( <wait-spec-list> )
-    <wait-spec> = [ UNIT = ] <file-unit-number>
-                | END = <label>
-                | EOR = <label>
-                | ERR = <label>
-                | ID = <scalar-int-expr>
-                | IOMSG = <iomsg-variable>
-                | IOSTAT = <scalar-int-variable>
+    ::
+
+        WAIT ( <wait-spec-list> )
+        <wait-spec> = [ UNIT = ] <file-unit-number>
+                    | END = <label>
+                    | EOR = <label>
+                    | ERR = <label>
+                    | ID = <scalar-int-expr>
+                    | IOMSG = <iomsg-variable>
+                    | IOSTAT = <scalar-int-variable>
 
     """
-    match = re.compile(r'wait\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"wait\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         self.specs = specs_split_comma(
-            self.item.get_line()[4:].lstrip()[1:-1], self.item)
+            self.item.get_line()[4:].lstrip()[1:-1], self.item
+        )
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'WAIT (%s)' % (', '.join(self.specs))
+        return tab + "WAIT (%s)" % (", ".join(self.specs))
 
     def analyze(self):
         return
 
 
 class Contains(Statement):
     """
     CONTAINS
     """
-    match = re.compile(r'contains\Z', re.I).match
+
+    match = re.compile(r"contains\Z", re.I).match
 
     def process_item(self):
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'CONTAINS'
+        return self.get_indent_tab(isfix=isfix) + "CONTAINS"
 
 
 class Allocate(Statement):
     """
-    ALLOCATE ( [ <type-spec> :: ] <allocation-list> [ , <alloc-opt-list> ] )
-    <alloc-opt> = STAT = <stat-variable>
-                | ERRMSG = <errmsg-variable>
-                | SOURCE = <source-expr>
-    <allocation> = <allocate-object> [ ( <allocate-shape-spec-list> ) ]
+    ::
+
+        ALLOCATE ( [ <type-spec> :: ] <allocation-list> [ , <alloc-opt-list> ] )
+        <alloc-opt> = STAT = <stat-variable>
+                    | ERRMSG = <errmsg-variable>
+                    | SOURCE = <source-expr>
+        <allocation> = <allocate-object> [ ( <allocate-shape-spec-list> ) ]
     """
-    match = re.compile(r'allocate\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"allocate\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
-        '''
+        """
         Process the ALLOCATE statement and store the various entities being
         allocated in self.items. Any type-specification is stored in
         self.spec.
 
         :raises ParseError: if an invalid type-specification is used
-        '''
+        """
         line = self.item.get_line()[8:].lstrip()[1:-1].strip()
         item2 = self.item.copy(line, True)
         line2 = item2.get_line()
-        i = line2.find('::')
+        i = line2.find("::")
         if i != -1:
             spec = item2.apply_map(line2[:i].rstrip())
             from .block_statements import type_spec
+
             stmt = None
             for cls in type_spec:
                 if cls.match(spec):
                     stmt = cls(self, item2.copy(spec))
                     if stmt.isvalid:
                         break
             if stmt is not None and stmt.isvalid:
                 spec = stmt
             elif is_name(spec):
                 # Type spec is the name of a derived type
                 pass
             else:
                 raise ParseError(
                     "Unrecognised type-specification in ALLOCATE statement: "
-                    "{0}".format(self.item.line))
-            line2 = line2[i+2:].lstrip()
+                    "{0}".format(self.item.line)
+                )
+            line2 = line2[i + 2 :].lstrip()
         else:
             spec = None
         self.spec = spec
         self.items = specs_split_comma(line2, item2)
         return
 
     def tofortran(self, isfix=None):
-        '''
+        """
         Create the Fortran code for this ALLOCATE statement
 
         :param bool isfix: whether or not to generate fixed-format code
         :return: Fortran code
         :rtype: str
-        '''
-        import six
-        type_spec = ''
+        """
+        type_spec = ""
         if self.spec:
-            if isinstance(self.spec, six.text_type):
+            if isinstance(self.spec, str):
                 type_spec = self.spec
             else:
                 type_spec = self.spec.tostr()
-            type_spec += ' :: '
-        return self.get_indent_tab(isfix=isfix) \
-            + 'ALLOCATE (%s%s)' % (type_spec, ', '.join(self.items))
+            type_spec += " :: "
+        return self.get_indent_tab(isfix=isfix) + "ALLOCATE (%s%s)" % (
+            type_spec,
+            ", ".join(self.items),
+        )
 
     def analyze(self):
         return
 
 
 class Deallocate(Statement):
     """
-    DEALLOCATE ( <allocate-object-list> [ , <dealloc-opt-list> ] )
-    <allocate-object> = <variable-name>
-                      | <structure-component>
-    <structure-component> = <data-ref>
-    <dealloc-opt> = STAT = <stat-variable>
-                    | ERRMSG = <errmsg-variable>
+    ::
+
+        DEALLOCATE ( <allocate-object-list> [ , <dealloc-opt-list> ] )
+        <allocate-object> = <variable-name>
+                          | <structure-component>
+        <structure-component> = <data-ref>
+        <dealloc-opt> = STAT = <stat-variable>
+                        | ERRMSG = <errmsg-variable>
     """
-    match = re.compile(r'deallocate\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"deallocate\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[10:].lstrip()[1:-1].strip()
         self.items = specs_split_comma(line, self.item)
         return
 
-    def tofortran(self, isfix=None): return self.get_indent_tab(isfix=isfix) \
-        + 'DEALLOCATE (%s)' % (', '.join(self.items))
+    def tofortran(self, isfix=None):
+        return self.get_indent_tab(isfix=isfix) + "DEALLOCATE (%s)" % (
+            ", ".join(self.items)
+        )
 
     def analyze(self):
         return
 
 
 class ModuleProcedure(Statement):
     """
     [ MODULE ] PROCEDURE [::] <procedure-name-list>
     """
-    match = re.compile(r'(module\s*|)procedure\b\s*(::)?', re.I).match
+
+    match = re.compile(r"(module\s*|)procedure\b\s*(::)?", re.I).match
 
     def process_item(self):
         line = self.item.get_line()
         m = self.match(line)
         assert m, repr(line)
-        items = split_comma(line[m.end():].strip(), self.item)
+        items = split_comma(line[m.end() :].strip(), self.item)
         for n in items:
             if not is_name(n):
                 self.isvalid = False
                 return
         self.items = items
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'MODULE PROCEDURE %s' % (', '.join(self.items))
+        return tab + "MODULE PROCEDURE %s" % (", ".join(self.items))
 
     def analyze(self):
         module_procedures = self.parent.a.module_procedures
         module_procedures.extend(self.items)
         # XXX: add names to parent_provides
         return
 
 
 class Access(Statement):
     """
     <access-spec> [ [::] <access-id-list>]
     <access-spec> = PUBLIC | PRIVATE
     <access-id> = <use-name> | <generic-spec>
     """
-    match = re.compile(r'(public|private)\b', re.I).match
+
+    match = re.compile(r"(public|private)\b", re.I).match
 
     def process_item(self):
         clsname = self.__class__.__name__.lower()
         line = self.item.get_line()
         if not line.lower().startswith(clsname):
             self.isvalid = False
             return
-        line = line[len(clsname):].lstrip()
-        if line.startswith('::'):
+        line = line[len(clsname) :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
         clsname = self.__class__.__name__.upper()
         tab = self.get_indent_tab(isfix=isfix)
         if self.items:
-            return tab + clsname + ' ' + ', '.join(self.items)
+            return tab + clsname + " " + ", ".join(self.items)
         return tab + clsname
 
     def analyze(self):
         clsname = self.__class__.__name__
-        bits = getattr(self.parent.a, clsname.lower() + '_id_list')
+        bits = getattr(self.parent.a, clsname.lower() + "_id_list")
         if self.items:
             for name in self.items:
                 if name not in bits:
                     bits.append(name)
         else:
-            if '' not in bits:
-                bits.append('')
+            if "" not in bits:
+                bits.append("")
             if not isinstance(self.parent, classes.Module):
                 parentclsname = self.parent.__class__.__name__
-                message = 'C548 violation: %s statement only allowed in the'\
-                          ' specification-part of a module, not in a %s.'\
-                          % (clsname.upper(), parentclsname.lower())
+                message = (
+                    "C548 violation: %s statement only allowed in the"
+                    " specification-part of a module, not in a %s."
+                    % (clsname.upper(), parentclsname.lower())
+                )
                 self.warning(message)
-        access_id_list = self.parent.a.private_id_list \
-            + self.parent.a.public_id_list
-        if access_id_list.count('') > 1:
-            message = 'C548 violation: only one access-stmt with omitted'\
-                      ' access-id-list is permitted in'\
-                      ' the module-specification-part.'
+        access_id_list = self.parent.a.private_id_list + self.parent.a.public_id_list
+        if access_id_list.count("") > 1:
+            message = (
+                "C548 violation: only one access-stmt with omitted"
+                " access-id-list is permitted in"
+                " the module-specification-part."
+            )
             self.warning(message)
         # todo: check for conflicting access statement usages
         #       (e.g. private foo; public foo)
         # todo: check for conflicting generic-spec id-s.
         return
 
 
@@ -816,50 +930,54 @@
 
 class Private(Access):
     is_public = False
 
 
 class Close(Statement):
     """
-    CLOSE ( <close-spec-list> )
-    <close-spec> = [ UNIT = ] <file-unit-number>
-                   | IOSTAT = <scalar-int-variable>
-                   | IOMSG = <iomsg-variable>
-                   | ERR = <label>
-                   | STATUS = <scalar-default-char-expr>
+    ::
+
+        CLOSE ( <close-spec-list> )
+        <close-spec> = [ UNIT = ] <file-unit-number>
+                       | IOSTAT = <scalar-int-variable>
+                       | IOMSG = <iomsg-variable>
+                       | ERR = <label>
+                       | STATUS = <scalar-default-char-expr>
     """
-    match = re.compile(r'close\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"close\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[5:].lstrip()[1:-1].strip()
         self.specs = specs_split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'CLOSE (%s)' % (', '.join(self.specs))
+        return tab + "CLOSE (%s)" % (", ".join(self.specs))
 
     def analyze(self):
         return
 
 
 class Cycle(Statement):
     """
     CYCLE [ <do-construct-name> ]
     """
-    match = re.compile(r'cycle\b\s*\w*\s*\Z', re.I).match
+
+    match = re.compile(r"cycle\b\s*\w*\s*\Z", re.I).match
 
     def process_item(self):
         self.name = self.item.get_line()[5:].lstrip()
         return
 
     def tofortran(self, isfix=None):
         if self.name:
-            return self.get_indent_tab(isfix=isfix) + 'CYCLE ' + self.name
-        return self.get_indent_tab(isfix=isfix) + 'CYCLE'
+            return self.get_indent_tab(isfix=isfix) + "CYCLE " + self.name
+        return self.get_indent_tab(isfix=isfix) + "CYCLE"
 
     def analyze(self):
         return
 
 
 class FilePositioningStatement(Statement):
     """
@@ -867,35 +985,39 @@
     REWIND ( <position-spec-list> )
     <position-spec-list> = [ UNIT = ] <file-unit-number>
                            | IOMSG = <iomsg-variable>
                            | IOSTAT = <scalar-int-variable>
                            | ERR = <label>
     The same for BACKSPACE, ENDFILE.
     """
-    match = re.compile(r'(rewind|backspace|endfile)\b', re.I).match
+
+    match = re.compile(r"(rewind|backspace|endfile)\b", re.I).match
 
     def process_item(self):
         clsname = self.__class__.__name__.lower()
         line = self.item.get_line()
         if not line.lower().startswith(clsname):
             self.isvalid = False
             return
-        line = line[len(clsname):].lstrip()
-        if line.startswith('('):
-            assert line[-1] == ')', repr(line)
+        line = line[len(clsname) :].lstrip()
+        if line.startswith("("):
+            assert line[-1] == ")", repr(line)
             spec = line[1:-1].strip()
         else:
             spec = line
         self.specs = specs_split_comma(spec, self.item)
         return
 
     def tofortran(self, isfix=None):
         clsname = self.__class__.__name__.upper()
-        return self.get_indent_tab(isfix=isfix) + clsname \
-            + ' (%s)' % (', '.join(self.specs))
+        return (
+            self.get_indent_tab(isfix=isfix)
+            + clsname
+            + " (%s)" % (", ".join(self.specs))
+        )
 
     def analyze(self):
         return
 
 
 class Backspace(FilePositioningStatement):
     pass
@@ -907,748 +1029,797 @@
 
 class Rewind(FilePositioningStatement):
     pass
 
 
 class Open(Statement):
     """
-    OPEN ( <connect-spec-list> )
-    <connect-spec> = [ UNIT = ] <file-unit-number>
-                     | ACCESS = <scalar-default-char-expr>
-                     | ..
+    ::
+
+        OPEN ( <connect-spec-list> )
+        <connect-spec> = [ UNIT = ] <file-unit-number>
+                         | ACCESS = <scalar-default-char-expr>
+                         | ..
     """
-    match = re.compile(r'open\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"open\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[4:].lstrip()[1:-1].strip()
         self.specs = specs_split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'OPEN (%s)' % (', '.join(self.specs))
+        return self.get_indent_tab(isfix=isfix) + "OPEN (%s)" % (", ".join(self.specs))
 
     def analyze(self):
         return
 
 
 class Format(Statement):
     """
-    FORMAT <format-specification>
-    <format-specification> = ( [ <format-item-list> ] )
-    <format-item> = [ <r> ] <data-edit-descr>
-                    | <control-edit-descr>
-                    | <char-string-edit-descr>
-                    | [ <r> ] ( <format-item-list> )
-    <data-edit-descr> = I <w> [ . <m> ]
-                        | B <w> [ . <m> ]
-                        ...
-    <r|w|m|d|e> = <int-literal-constant>
-    <v> = <signed-int-literal-constant>
-    <control-edit-descr> = <position-edit-descr>
-                         | [ <r> ] /
-                         | :
-                         ...
-    <position-edit-descr> = T <n>
-                            | TL <n>
+    ::
+
+        FORMAT format-specification
+
+        format-specification is ( [ format-item-list ] )
+        format-item is [ r ] data-edit-descr
+                    or control-edit-descr
+                    or char-string-edit-descr
+                    or [ r ] ( format-item-list )
+        data-edit-descr is I w [ . m ]
+                        or B w [ . m ]
                             ...
-    <sign-edit-descr> = SS | SP | S
-    ...
+        r|w|m|d|e is int-literal-constant
+        v is signed-int-literal-constant
+        control-edit-descr is position-edit-descr
+                           or [ r ] /
+                           or :
+                           ...
+        position-edit-descr is T n
+                            or TL n
+                            ...
+        sign-edit-descr is SS | SP | S
+        ...
 
     """
-    match = re.compile(r'format\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"format\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         item = self.item
         if item.label is None:
             # R1001:
-            self.warning('FORMAT statement must be labeled (F2008:C1001).'
-                         % (item.label))
+            self.warning(
+                "FORMAT statement must be labeled (F2008:C1001)." % (item.label)
+            )
         line = item.get_line()[6:].lstrip()
-        assert line[0]+line[-1] == '()', repr(line)
+        assert line[0] + line[-1] == "()", repr(line)
         self.specs = split_comma(line[1:-1], item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'FORMAT (%s)' % (', '.join(self.specs))
+        return self.get_indent_tab(isfix=isfix) + "FORMAT (%s)" % (
+            ", ".join(self.specs)
+        )
 
     def analyze(self):
         return
 
 
 class Save(Statement):
     """
-    SAVE [ [ :: ] <saved-entity-list> ]
-    <saved-entity> = <object-name>
-                     | <proc-pointer-name>
-                     | / <common-block-name> /
-    <proc-pointer-name> = <name>
-    <object-name> = <name>
+    ::
+
+        SAVE [ [ :: ] saved-entity-list ]
+
+        saved-entity is object-name
+                     or proc-pointer-name
+                     or / common-block-name /
+        proc-pointer-name is name
+        object-name is name
     """
-    match = re.compile(r'save\b', re.I).match
+
+    match = re.compile(r"save\b", re.I).match
 
     def process_item(self):
         assert not self.item.has_map()
         line = self.item.get_line()[4:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         items = []
-        for s in line.split(','):
+        for s in line.split(","):
             s = s.strip()
             if not s:
                 continue
-            if s.startswith('/'):
-                assert s.endswith('/'), repr(s)
+            if s.startswith("/"):
+                assert s.endswith("/"), repr(s)
                 n = s[1:-1].strip()
                 assert is_name(n), repr(n)
-                items.append('/%s/' % (n))
+                items.append("/%s/" % (n))
             elif is_name(s):
                 items.append(s)
             else:
                 self.isvalid = False
                 return
         self.items = items
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         if not self.items:
-            return tab + 'SAVE'
-        return tab + 'SAVE %s' % (', '.join(self.items))
+            return tab + "SAVE"
+        return tab + "SAVE %s" % (", ".join(self.items))
 
     def analyze(self):
         return
 
 
 class Data(Statement):
     """
-    DATA <data-stmt-set> [ [ , ] <data-stmt-set> ]...
-    <data-stmt-set> = <data-stmt-object-list> / <data-stmt-value-list> /
-    <data-stmt-object> = <variable> | <data-implied-do>
-    <data-implied-do> = ( <data-i-do-object-list> ,
-                          <data-i-do-variable> = <scalar-int-expr> ,
-                          <scalar-int-expr> [ , <scalar-int-expr> ] )
-    <data-i-do-object> = <array-element>
-                         | <scalar-structure-component>
-                         | <data-implied-do>
-    <data-i-do-variable> = <scalar-int-variable>
-    <variable> = <designator>
-    <designator> = <object-name>
-                   | <array-element>
-                   | <array-section>
-                   | <structure-component>
-                   | <substring>
-    <array-element> = <data-ref>
-    <array-section> = <data-ref> [ ( <substring-range> ) ]
+    ::
+
+        DATA data-stmt-set [ [ , ] data-stmt-set ]...
+
+        data-stmt-set is data-stmt-object-list / data-stmt-value-list /
+        data-stmt-object is variable or data-implied-do
+        data-implied-do is ( data-i-do-object-list ,
+                              data-i-do-variable = scalar-int-expr ,
+                              scalar-int-expr [ , scalar-int-expr ] )
+        data-i-do-object is array-element
+                         or scalar-structure-component
+                         or data-implied-do
+        data-i-do-variable is scalar-int-variable
+        variable is designator
+        designator is object-name
+                   or array-element
+                   or array-section
+                   or structure-component
+                   or substring
+        array-element is data-ref
+        array-section is data-ref [ ( substring-range ) ]
 
     """
-    match = re.compile(r'data\b', re.I).match
+
+    match = re.compile(r"data\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[4:].lstrip()
         stmts = []
         self.isvalid = False
         while line:
-            i = line.find('/')
+            i = line.find("/")
             if i == -1:
                 return
-            j = line.find('/', i+1)
+            j = line.find("/", i + 1)
             if j == -1:
                 return
-            l1, l2 = line[:i].rstrip(), line[i+1:j].strip()
+            l1, l2 = line[:i].rstrip(), line[i + 1 : j].strip()
             l1 = split_comma(l1, self.item)
             l2 = split_comma(l2, self.item)
             stmts.append((l1, l2))
-            line = line[j+1:].lstrip()
-            if line.startswith(','):
+            line = line[j + 1 :].lstrip()
+            if line.startswith(","):
                 line = line[1:].lstrip()
         self.stmts = stmts
         self.isvalid = True
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         bits = []
         for o, v in self.stmts:
-            bits.append('%s / %s /' % (', '.join(o), ', '.join(v)))
-        return tab + 'DATA ' + ' '.join(bits)
+            bits.append("%s / %s /" % (", ".join(o), ", ".join(v)))
+        return tab + "DATA " + " ".join(bits)
 
     def analyze(self):
         return
 
 
 class Nullify(Statement):
     """
     NULLIFY ( <pointer-object-list> )
     <pointer-object> = <variable-name>
     """
-    match = re.compile(r'nullify\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"nullify\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[7:].lstrip()[1:-1].strip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'NULLIFY (%s)' % (', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "NULLIFY (%s)" % (
+            ", ".join(self.items)
+        )
 
     def analyze(self):
         return
 
 
 class Use(Statement):
     """Parses USE statement.
 
     :param class Statement: Base fparser class.
     :raises AnalyzeError: If entity name is not in module.
 
-    Fortran syntax construct:
+    Fortran syntax construct::
 
-    USE [ [ , <module-nature> ] :: ] <module-name> [ , <rename-list> ]
-    USE [ [ , <module-nature> ] :: ] <module-name> , ONLY : [ <only-list> ]
-    <module-nature> = INTRINSIC | NON_INTRINSIC
-    <rename> = <local-name> => <use-name>
-               | OPERATOR ( <local-defined-operator> ) =>
-                            OPERATOR ( <use-defined-operator> )
-    <only> = <generic-spec> | <only-use-name> | <rename>
-    <only-use-name> = <use-name>
+        USE [ [ , module-nature ] :: ] module-name [ , rename-list ]
+        USE [ [ , module-nature ] :: ] module-name , ONLY : [ only-list ]
+
+        module-nature is INTRINSIC or NON_INTRINSIC
+        rename is local-name => use-name
+                   or OPERATOR ( local-defined-operator ) =>
+                                OPERATOR ( use-defined-operator )
+        only is generic-spec or only-use-name or rename
+        only-use-name is use-name
     """
-    match = re.compile(r'use\b', re.I).match
+
+    match = re.compile(r"use\b", re.I).match
 
     def process_item(self):
-        ''' Parse the string containing the Use and store the
-        module name and list of attributes (if any) '''
+        """Parse the string containing the Use and store the
+        module name and list of attributes (if any)"""
         line = self.item.get_line()[3:].lstrip()
-        nature = ''
-        if line.startswith(','):
-            i = line.find('::')
+        nature = ""
+        if line.startswith(","):
+            i = line.find("::")
             nature = line[1:i].strip().upper()
-            line = line[i+2:].lstrip()
-        if line.startswith('::'):
+            line = line[i + 2 :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
         if nature and not is_name(nature):
             self.isvalid = False
             return
         self.nature = nature
-        i = line.find(',')
+        i = line.find(",")
         self.isonly = False
         if i == -1:
             self.name = line
             self.items = []
         else:
             self.name = line[:i].rstrip()
-            line = line[i+1:].lstrip()
-            if line.lower().startswith('only') and \
-               line[4:].lstrip().startswith(':'):
+            line = line[i + 1 :].lstrip()
+            if line.lower().startswith("only") and line[4:].lstrip().startswith(":"):
                 self.isonly = True
                 line = line[4:].lstrip()[1:].lstrip()
             self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):  # pylint: disable=invalid-name
-        '''
+        """
         Returns the Fortran representation of this object as a string
 
         :param bool isfix: Whether or not to generated fixed-format Fortran
         :return: Fortran representation of this object
         :rtype: str
-        '''
+        """
         tab = self.get_indent_tab(isfix=isfix)
-        s = 'USE'
+        s = "USE"
         if self.nature:
-            s += ', ' + self.nature + ' ::'
-        s += ' ' + self.name
+            s += ", " + self.nature + " ::"
+        s += " " + self.name
         if self.isonly:
-            s += ', ONLY:'
+            s += ", ONLY:"
         elif self.items:
-            s += ','
+            s += ","
         if self.items:
-            s += ' ' + ', '.join(self.items)
+            s += " " + ", ".join(self.items)
         return tab + s
 
     def analyze(self):  # pylint: disable=invalid-name
-        ''' Returns warnings if this object is incorrect '''
+        """Returns warnings if this object is incorrect"""
         use = self.parent.a.use
         if self.name in use:
             return
 
         modules = self.top.a.module
         if self.name not in modules:
             fn = self.reader.find_module_source_file(self.name)
             if fn is not None:
                 from fparser.common.readfortran import FortranFileReader
                 from fparser.one.parsefortran import FortranParser
-                self.info('looking module information from %r' % (fn))
+
+                self.info("looking module information from %r" % (fn))
                 reader = FortranFileReader(
-                    fn, include_dirs=self.reader.include_dirs,
-                    source_only=self.reader.source_only)
+                    fn,
+                    include_dirs=self.reader.include_dirs,
+                    source_only=self.reader.source_only,
+                )
                 parser = FortranParser(reader)
                 parser.parse()
                 parser.block.a.module.update(modules)
                 parser.analyze()
                 modules.update(parser.block.a.module)
 
         if self.name not in modules:
-            self.warning('no information about the module %r in use statement'
-                         % (self.name))
+            self.warning(
+                "no information about the module %r in use statement" % (self.name)
+            )
             return
 
         module = modules[self.name]
         use[self.name] = module
         use_provides = self.parent.a.use_provides
-        renames = [split_comma(item, comma='=>')
-                   for item in self.items if '=>' in item]
-        norenames = [item for item in self.items if '=>' not in item]
+        renames = [split_comma(item, comma="=>") for item in self.items if "=>" in item]
+        norenames = [item for item in self.items if "=>" not in item]
         all_mod_provides = dict(module.a.module_provides)
         all_mod_provides.update(module.a.use_provides)
         if self.isonly:
             # populate use_provides with items/renames only.
             for rename, orig in renames:
-                self.populate_use_provides(
-                    all_mod_provides, use_provides, orig, rename)
+                self.populate_use_provides(all_mod_provides, use_provides, orig, rename)
             for name in norenames:
-                self.populate_use_provides(
-                    all_mod_provides, use_provides, name)
+                self.populate_use_provides(all_mod_provides, use_provides, name)
         else:
             # norenames should be empty
             if norenames:
-                self.warning("'use' without 'only' clause does not rename the "
-                             "variables '%s'" % ', '.join(norenames))
+                self.warning(
+                    "'use' without 'only' clause does not rename the "
+                    "variables '%s'" % ", ".join(norenames)
+                )
             # populate use_provides with renamed vars from module.
             for rename, orig in renames:
-                self.populate_use_provides(
-                    all_mod_provides, use_provides, orig, rename)
+                self.populate_use_provides(all_mod_provides, use_provides, orig, rename)
             # get all the rest
             unrenamed = set(all_mod_provides) - set([b for (a, b) in renames])
             for name in unrenamed:
-                self.populate_use_provides(
-                    all_mod_provides, use_provides, name)
+                self.populate_use_provides(all_mod_provides, use_provides, name)
         return
 
-    def populate_use_provides(self, all_mod_provides, use_provides, name,
-                              rename=None):
-        ''' Checks for entity name in the module '''
+    def populate_use_provides(self, all_mod_provides, use_provides, name, rename=None):
+        """Checks for entity name in the module"""
         ovar = all_mod_provides.get(name, None)
         if ovar is None:
-            raise AnalyzeError("entity name '%s' is not in module '%s'"
-                               % (name, self.name))
+            raise AnalyzeError(
+                "entity name '%s' is not in module '%s'" % (name, self.name)
+            )
         if rename:
             # XXX: rename != ovar.name -- should mark this somehow?
             name_idx = rename
         else:
             name_idx = name
         if name_idx in use_provides:
             if ovar != use_provides[name_idx]:
-                self.warning("entity name '%s' is already declared in module "
-                             "'%s' while adding it to '%s', overriding."
-                             % (name, self.name, self.parent.name))
+                self.warning(
+                    "entity name '%s' is already declared in module "
+                    "'%s' while adding it to '%s', overriding."
+                    % (name, self.name, self.parent.name)
+                )
         use_provides[name_idx] = ovar
 
 
 class Exit(Statement):
     """
     EXIT [ <do-construct-name> ]
     """
-    match = re.compile(r'exit\b\s*\w*\s*\Z', re.I).match
+
+    match = re.compile(r"exit\b\s*\w*\s*\Z", re.I).match
 
     def process_item(self):
         self.name = self.item.get_line()[4:].lstrip()
         return
 
     def tofortran(self, isfix=None):
         if self.name:
-            return self.get_indent_tab(isfix=isfix) + 'EXIT ' + self.name
-        return self.get_indent_tab(isfix=isfix) + 'EXIT'
+            return self.get_indent_tab(isfix=isfix) + "EXIT " + self.name
+        return self.get_indent_tab(isfix=isfix) + "EXIT"
 
     def analyze(self):
         return
 
 
 class Parameter(Statement):
     """
     PARAMETER ( <named-constant-def-list> )
     <named-constant-def> = <named-constant> = <initialization-expr>
     """
-    match = re.compile(r'parameter\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"parameter\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[9:].lstrip()[1:-1].strip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'PARAMETER (%s)' % (', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "PARAMETER (%s)" % (
+            ", ".join(self.items)
+        )
 
     def analyze(self):
         for item in self.items:
-            i = item.find('=')
+            i = item.find("=")
             assert i != -1, repr(item)
             name = item[:i].rstrip()
-            value = item[i+1:].lstrip()
+            value = item[i + 1 :].lstrip()
             var = self.get_variable(name)
-            var.update('parameter')
+            var.update("parameter")
             var.set_init(value)
         return
 
 
 class Equivalence(Statement):
     """
     EQUIVALENCE <equivalence-set-list>
     <equivalence-set> = ( <equivalence-object> , <equivalence-object-list> )
     <equivalence-object> = <variable-name> | <array-element> | <substring>
     """
-    match = re.compile(r'equivalence\s*\(.*\)\Z', re.I).match
+
+    match = re.compile(r"equivalence\s*\(.*\)\Z", re.I).match
 
     def process_item(self):
         items = []
-        for s in self.item.get_line()[11:].lstrip().split(','):
+        for s in self.item.get_line()[11:].lstrip().split(","):
             s = s.strip()
-            assert s[0]+s[-1] == '()', repr((s, self.item.get_line()))
-            s = ', '.join(split_comma(s[1:-1], self.item))
-            items.append('('+s+')')
+            assert s[0] + s[-1] == "()", repr((s, self.item.get_line()))
+            s = ", ".join(split_comma(s[1:-1], self.item))
+            items.append("(" + s + ")")
         self.items = items
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'EQUIVALENCE %s' % (', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "EQUIVALENCE %s" % (
+            ", ".join(self.items)
+        )
 
     def analyze(self):
         return
 
 
 class Dimension(Statement):
     """
     DIMENSION [ :: ] <array-name> ( <array-spec> )
                                     [ , <array-name> ( <array-spec> ) ]...
 
     """
-    match = re.compile(r'dimension\b', re.I).match
+
+    match = re.compile(r"dimension\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[9:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'DIMENSION %s' % (', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "DIMENSION %s" % (
+            ", ".join(self.items)
+        )
 
     def analyze(self):
         for line in self.items:
-            i = line.find('(')
-            assert i != -1 and line.endswith(')'), repr(line)
+            i = line.find("(")
+            assert i != -1 and line.endswith(")"), repr(line)
             name = line[:i].rstrip()
-            array_spec = split_comma(line[i+1:-1].strip(), self.item)
+            array_spec = split_comma(line[i + 1 : -1].strip(), self.item)
             var = self.get_variable(name)
             var.set_bounds(array_spec)
         return
 
 
 class Target(Statement):
     """
     TARGET [ :: ] <object-name> ( <array-spec> )
                                   [ , <object-name> ( <array-spec> ) ]...
 
     """
-    match = re.compile(r'target\b', re.I).match
+
+    match = re.compile(r"target\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[6:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'TARGET %s' % (', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "TARGET %s" % (", ".join(self.items))
 
     def analyze(self):
         for line in self.items:
-            i = line.find('(')
-            assert i != -1 and line.endswith(')'), repr(line)
+            i = line.find("(")
+            assert i != -1 and line.endswith(")"), repr(line)
             name = line[:i].rstrip()
-            array_spec = split_comma(line[i+1:-1].strip(), self.item)
+            array_spec = split_comma(line[i + 1 : -1].strip(), self.item)
             var = self.get_variable(name)
             var.set_bounds(array_spec)
-            var.update('target')
+            var.update("target")
         return
 
 
 class Pointer(Statement):
     """
-    POINTER [ :: ] <pointer-decl-list>
-    <pointer-decl> = <object-name> [ ( <deferred-shape-spec-list> ) ]
-                   | <proc-entity-name>
+    ::
+
+        POINTER [ :: ] pointer-decl-list
+
+        pointer-decl is object-name [ ( deferred-shape-spec-list ) ]
+                     or proc-entity-name
 
     """
-    match = re.compile(r'pointer\b', re.I).match
+
+    match = re.compile(r"pointer\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[7:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'POINTER %s' % (', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "POINTER %s" % (", ".join(self.items))
 
     def analyze(self):
         for line in self.items:
-            i = line.find('(')
+            i = line.find("(")
             if i == -1:
                 name = line
                 array_spec = None
             else:
-                assert line.endswith(')'), repr(line)
+                assert line.endswith(")"), repr(line)
                 name = line[:i].rstrip()
-                array_spec = split_comma(line[i+1:-1].strip(), self.item)
+                array_spec = split_comma(line[i + 1 : -1].strip(), self.item)
             var = self.get_variable(name)
             var.set_bounds(array_spec)
-            var.update('pointer')
+            var.update("pointer")
         return
 
 
 class Protected(StatementWithNamelist):
     """
     PROTECTED [ :: ] <entity-name-list>
     """
-    match = re.compile(r'protected\b', re.I).match
+
+    match = re.compile(r"protected\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('protected')
+            var.update("protected")
         return
 
 
 class Volatile(StatementWithNamelist):
     """
     VOLATILE [ :: ] <object-name-list>
     """
-    match = re.compile(r'volatile\b', re.I).match
+
+    match = re.compile(r"volatile\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('volatile')
+            var.update("volatile")
         return
 
 
 class Value(StatementWithNamelist):
     """
     VALUE [ :: ] <dummy-arg-name-list>
     """
-    match = re.compile(r'value\b', re.I).match
+
+    match = re.compile(r"value\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('value')
+            var.update("value")
         return
 
 
 class ArithmeticIf(Statement):
     """
     IF ( <scalar-numeric-expr> ) <label> , <label> , <label>
     """
-    match = re.compile(r'if\s*\(.*\)\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\Z',
-                       re.I).match
+
+    match = re.compile(r"if\s*\(.*\)\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[2:].lstrip()
-        line, l2, l3 = line.rsplit(',', 2)
-        i = line.rindex(')')
-        l1 = line[i+1:]
+        line, l2, l3 = line.rsplit(",", 2)
+        i = line.rindex(")")
+        l1 = line[i + 1 :]
         self.expr = self.item.apply_map(line[1:i]).strip()
         self.labels = [l1.strip(), l2.strip(), l3.strip()]
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'IF (%s) %s' \
-               % (self.expr, ', '.join(self.labels))
+        return self.get_indent_tab(isfix=isfix) + "IF (%s) %s" % (
+            self.expr,
+            ", ".join(self.labels),
+        )
 
     def analyze(self):
         return
 
 
 class Intrinsic(StatementWithNamelist):
     """
     INTRINSIC [ :: ] <intrinsic-procedure-name-list>
     """
-    match = re.compile(r'intrinsic\b', re.I).match
+
+    match = re.compile(r"intrinsic\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('intrinsic')
+            var.update("intrinsic")
         return
 
 
 class Inquire(Statement):
     """
     INQUIRE ( <inquire-spec-list> )
     INQUIRE ( IOLENGTH = <scalar-int-variable> ) <output-item-list>
 
     <inquire-spec> = [ UNIT = ] <file-unit-number>
                      | FILE = <file-name-expr>
                      ...
     <output-item> = <expr>
                   | <io-implied-do>
     """
-    match = re.compile(r'inquire\s*\(', re.I).match
+
+    match = re.compile(r"inquire\s*\(", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[7:].lstrip()
-        i = line.index(')')
+        i = line.index(")")
         self.specs = specs_split_comma(line[1:i].strip(), self.item)
-        self.items = split_comma(line[i+1:].lstrip(), self.item)
+        self.items = split_comma(line[i + 1 :].lstrip(), self.item)
         return
 
     def tofortran(self, isfix=None):
         if self.items:
-            return self.get_indent_tab(isfix=isfix) + 'INQUIRE (%s) %s' \
-                   % (', '.join(self.specs), ', '.join(self.items))
-        return self.get_indent_tab(isfix=isfix) + 'INQUIRE (%s)' \
-            % (', '.join(self.specs))
+            return self.get_indent_tab(isfix=isfix) + "INQUIRE (%s) %s" % (
+                ", ".join(self.specs),
+                ", ".join(self.items),
+            )
+        return self.get_indent_tab(isfix=isfix) + "INQUIRE (%s)" % (
+            ", ".join(self.specs)
+        )
 
     def analyze(self):
         return
 
 
 class Sequence(Statement):
     """
     SEQUENCE
     """
-    match = re.compile(r'sequence\Z', re.I).match
+
+    match = re.compile(r"sequence\Z", re.I).match
 
     def process_item(self):
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'SEQUENCE'
+        return self.get_indent_tab(isfix=isfix) + "SEQUENCE"
 
     def analyze(self):
-        self.parent.update_attributes('SEQUENCE')
+        self.parent.update_attributes("SEQUENCE")
         return
 
 
 class External(StatementWithNamelist):
     """
     EXTERNAL [ :: ] <external-name-list>
     """
-    match = re.compile(r'external\b', re.I).match
+
+    match = re.compile(r"external\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('external')
+            var.update("external")
         return
 
 
 class Namelist(Statement):
     """
     NAMELIST / <namelist-group-name> / <namelist-group-object-list> [ [ , ]
              / <namelist-group-name> / <namelist-group-object-list> ]...
     <namelist-group-object> = <variable-name>
     """
-    match = re.compile(r'namelist\b', re.I).match
+
+    match = re.compile(r"namelist\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[8:].lstrip()
         items = []
         while line:
-            assert line.startswith('/'), repr(line)
-            i = line.find('/', 1)
+            assert line.startswith("/"), repr(line)
+            i = line.find("/", 1)
             assert i != -1, repr(line)
-            name = line[:i+1]
-            line = line[i+1:].lstrip()
-            i = line.find('/')
+            name = line[: i + 1]
+            line = line[i + 1 :].lstrip()
+            i = line.find("/")
             if i == -1:
                 items.append((name, line))
-                line = ''
+                line = ""
                 continue
             s = line[:i].rstrip()
-            if s.endswith(','):
+            if s.endswith(","):
                 s = s[:-1].rstrip()
             items.append((name, s))
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
         self.items = items
         return
 
     def tofortran(self, isfix=None):
         bits = []
         for name, s in self.items:
-            bits.append('%s %s' % (name, s))
+            bits.append("%s %s" % (name, s))
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'NAMELIST ' + ', '.join(bits)
+        return tab + "NAMELIST " + ", ".join(bits)
 
 
 class Common(Statement):
     """
-    COMMON [ / [ <common-block-name> ] / ]  <common-block-object-list> \
-      [ [ , ] / [ <common-block-name> ] /  <common-block-object-list> ]...
-    <common-block-object> = <variable-name> [ ( <explicit-shape-spec-list> ) ]
-                          | <proc-pointer-name>
+    ::
+
+        COMMON [ / [ common-block-name ] / ] common-block-object-list \
+          [ [ , ] / [ common-block-name ] / common-block-object-list ]...
+
+        common-block-object is variable-name [ ( explicit-shape-spec-list ) ]
+                            or proc-pointer-name
     """
-    match = re.compile(r'common\b', re.I).match
+
+    match = re.compile(r"common\b", re.I).match
 
     def process_item(self):
         item = self.item
         line = item.get_line()[6:].lstrip()
         items = []
         while line:
-            if not line.startswith('/'):
-                name = ''
+            if not line.startswith("/"):
+                name = ""
                 assert not items, repr(line)
             else:
-                i = line.find('/', 1)
+                i = line.find("/", 1)
                 assert i != -1, repr(line)
                 name = line[1:i].strip()
-                line = line[i+1:].lstrip()
-            i = line.find('/')
+                line = line[i + 1 :].lstrip()
+            i = line.find("/")
             if i == -1:
                 items.append((name, split_comma(line, item)))
-                line = ''
+                line = ""
                 continue
             s = line[:i].rstrip()
-            if s.endswith(','):
+            if s.endswith(","):
                 s = s[:-1].rstrip()
             items.append((name, split_comma(s, item)))
             line = line[i:].lstrip()
         self.items = items
         return
 
     def tofortran(self, isfix=None):
         bits = []
         for name, s in self.items:
-            s = ', '.join(s)
+            s = ", ".join(s)
             if name:
-                bits.append('/ %s / %s' % (name, s))
+                bits.append("/ %s / %s" % (name, s))
             else:
                 bits.append(s)
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'COMMON ' + ' '.join(bits)
+        return tab + "COMMON " + " ".join(bits)
 
     def analyze(self):
         for cname, items in self.items:
             for item in items:
-                i = item.find('(')
+                i = item.find("(")
                 if i != -1:
-                    assert item.endswith(')'), repr(item)
+                    assert item.endswith(")"), repr(item)
                     name = item[:i].rstrip()
-                    shape = split_comma(item[i+1:-1].strip(), self.item)
+                    shape = split_comma(item[i + 1 : -1].strip(), self.item)
                 else:
                     name = item
                     shape = None
                 var = self.get_variable(name)
                 if shape is not None:
                     var.set_bounds(shape)
             # XXX: add name,var to parent_provides
@@ -1656,177 +1827,186 @@
 
 
 class Optional(StatementWithNamelist):
     """
     OPTIONAL [ :: ] <dummy-arg-name-list>
     <dummy-arg-name> = <name>
     """
-    match = re.compile(r'optional\b', re.I).match
+
+    match = re.compile(r"optional\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('optional')
+            var.update("optional")
         return
 
 
 class Intent(Statement):
     """
     INTENT ( <intent-spec> ) [ :: ] <dummy-arg-name-list>
     <intent-spec> = IN | OUT | INOUT
 
     generalization for pyf-files:
     INTENT ( <intent-spec-list> ) [ :: ] <dummy-arg-name-list>
     <intent-spec> = IN | OUT | INOUT | CACHE | HIDE | OUT = <name>
     """
-    match = re.compile(r'intent\s*\(', re.I).match
+
+    match = re.compile(r"intent\s*\(", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[6:].lstrip()
-        i = line.find(')')
+        i = line.find(")")
         self.specs = specs_split_comma(line[1:i], self.item, upper=True)
-        line = line[i+1:].lstrip()
-        if line.startswith('::'):
+        line = line[i + 1 :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
-        self.items = [s.strip() for s in line.split(',')]
+        self.items = [s.strip() for s in line.split(",")]
         for n in self.items:
             if not is_name(n):
                 self.isvalid = False
                 return
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'INTENT (%s) %s' \
-               % (', '.join(self.specs), ', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "INTENT (%s) %s" % (
+            ", ".join(self.specs),
+            ", ".join(self.items),
+        )
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
             var.set_intent(self.specs)
         return
 
 
 class Entry(Statement):
     """
-    ENTRY <entry-name> [ ( [ <dummy-arg-list> ] ) [ <suffix> ] ]
-    <suffix> = <proc-language-binding-spec> [ RESULT ( <result-name> ) ]
-             | RESULT ( <result-name> ) [ <proc-language-binding-spec> ]
-    <proc-language-binding-spec> = <language-binding-spec>
-    <language-binding-spec> =
-                      BIND ( C [ , NAME = <scalar-char-initialization-expr> ] )
-    <dummy-arg> = <dummy-arg-name> | *
+    ::
+
+        ENTRY entry-name [ ( [ dummy-arg-list ] ) [ suffix ] ]
+
+        suffix is proc-language-binding-spec [ RESULT ( result-name ) ]
+                 | RESULT ( result-name ) [ proc-language-binding-spec ]
+        proc-language-binding-spec is language-binding-spec
+        language-binding-spec is
+                      BIND ( C [ , NAME = scalar-char-initialization-expr ] )
+        dummy-arg is dummy-arg-name | *
+
     """
-    match = re.compile(r'entry\s+[a-zA-Z]', re.I).match
+
+    match = re.compile(r"entry\s+[a-zA-Z]", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[5:].lstrip()
-        m = re.match(r'\w+', line)
-        name = line[:m.end()]
-        line = line[m.end():].lstrip()
-        if line.startswith('('):
-            i = line.find(')')
+        m = re.match(r"\w+", line)
+        name = line[: m.end()]
+        line = line[m.end() :].lstrip()
+        if line.startswith("("):
+            i = line.find(")")
             assert i != -1, repr(line)
             items = split_comma(line[1:i], self.item)
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
         else:
             items = []
         self.bind, line = parse_bind(line, self.item)
         self.result, line = parse_result(line, self.item)
         if line:
             assert self.bind is None, repr(self.bind)
             self.bind, line = parse_bind(line, self.item)
         assert not line, repr(line)
         self.name = name
         self.items = items
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        s = tab + 'ENTRY '+self.name
+        s = tab + "ENTRY " + self.name
         if self.items:
-            s += ' (%s)' % (', '.join(self.items))
+            s += " (%s)" % (", ".join(self.items))
         if self.result:
-            s += ' RESULT (%s)' % (self.result)
+            s += " RESULT (%s)" % (self.result)
         if self.bind:
-            s += ' BIND (%s)' % (', '.join(self.bind))
+            s += " BIND (%s)" % (", ".join(self.bind))
         return s
 
 
 class Import(StatementWithNamelist):
     """
     IMPORT [ [ :: ] <import-name-list> ]
     """
-    match = re.compile(r'import(\b|\Z)', re.I).match
+
+    match = re.compile(r"import(\b|\Z)", re.I).match
 
 
 class Forall(Statement):
     """
     FORALL <forall-header> <forall-assignment-stmt>
     <forall-header> = ( <forall-triplet-spec-list> [ , <scalar-mask-expr> ] )
     <forall-triplet-spec> =
                     <index-name> = <subscript> : <subscript> [ : <stride> ]
     <subscript|stride> = <scalar-int-expr>
     <forall-assignment-stmt> = <assignment-stmt> | <pointer-assignment-stmt>
     """
-    match = re.compile(r'forall\s*\(.*\).*=', re.I).match
+
+    match = re.compile(r"forall\s*\(.*\).*=", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[6:].lstrip()
-        i = line.index(')')
+        i = line.index(")")
 
         line0 = line[1:i]
-        line = line[i+1:].lstrip()
+        line = line[i + 1 :].lstrip()
         stmt = GeneralAssignment(self, self.item.copy(line, True))
         if stmt.isvalid:
             self.content = [stmt]
         else:
             self.isvalid = False
             return
 
         specs = []
-        mask = ''
+        mask = ""
         for l in split_comma(line0, self.item):
-            j = l.find('=')
+            j = l.find("=")
             if j == -1:
                 assert not mask, repr((mask, l))
                 mask = l
                 continue
             assert j != -1, repr(l)
             index = l[:j].rstrip()
-            it = self.item.copy(l[j+1:].lstrip())
+            it = self.item.copy(l[j + 1 :].lstrip())
             line = it.get_line()
-            k = line.split(':')
+            k = line.split(":")
             if len(k) == 3:
-                s1, s2, s3 = list(map(it.apply_map,
-                                      [k[0].strip(), k[1].strip(),
-                                       k[2].strip()]))
+                s1, s2, s3 = list(
+                    map(it.apply_map, [k[0].strip(), k[1].strip(), k[2].strip()])
+                )
             else:
                 assert len(k) == 2, repr(k)
-                s1, s2 = list(map(it.apply_map,
-                                  [k[0].strip(), k[1].strip()]))
-                s3 = '1'
+                s1, s2 = list(map(it.apply_map, [k[0].strip(), k[1].strip()]))
+                s3 = "1"
             specs.append((index, s1, s2, s3))
 
         self.specs = specs
         self.mask = mask
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         lines = []
         for index, s1, s2, s3 in self.specs:
-            s = '%s = %s : %s' % (index, s1, s2)
-            if s3 != '1':
-                s += ' : %s' % (s3)
+            s = "%s = %s : %s" % (index, s1, s2)
+            if s3 != "1":
+                s += " : %s" % (s3)
             lines.append(s)
-        s = ', '.join(lines)
+        s = ", ".join(lines)
         if self.mask:
-            s += ', ' + self.mask
-        return tab + 'FORALL (%s) %s' % \
-            (s, str(self.content[0]).lstrip())
+            s += ", " + self.mask
+        return tab + "FORALL (%s) %s" % (s, str(self.content[0]).lstrip())
 
     def analyze(self):
         return
 
 
 ForallStmt = Forall
 
@@ -1837,650 +2017,698 @@
               <binding-name> [ => <procedure-name> ]
     <binding-attr> = PASS [ ( <arg-name> ) ]
                    | NOPASS
                    | NON_OVERRIDABLE
                    | DEFERRED
                    | <access-spec>
     <access-spec> = PUBLIC | PRIVATE
+
     """
-    match = re.compile(r'procedure\b', re.I).match
+
+    match = re.compile(r"procedure\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[9:].lstrip()
-        if line.startswith('('):
-            i = line.index(')')
+        if line.startswith("("):
+            i = line.index(")")
             name = line[1:i].strip()
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
         else:
-            name = ''
+            name = ""
         self.iname = name
-        if line.startswith(','):
+        if line.startswith(","):
             line = line[1:].lstrip()
-        i = line.find('::')
+        i = line.find("::")
         if i != -1:
             attrs = split_comma(line[:i], self.item)
-            line = line[i+2:].lstrip()
+            line = line[i + 2 :].lstrip()
         else:
             attrs = []
         attrs1 = []
         for attr in attrs:
             if is_name(attr):
                 attr = attr.upper()
             else:
-                i = attr.find('(')
-                assert i != -1 and attr.endswith(')'), repr(attr)
-                attr = '%s (%s)' % (attr[:i].rstrip().upper(),
-                                    attr[i+1:-1].strip())
+                i = attr.find("(")
+                assert i != -1 and attr.endswith(")"), repr(attr)
+                attr = "%s (%s)" % (attr[:i].rstrip().upper(), attr[i + 1 : -1].strip())
             attrs1.append(attr)
         self.attrs = attrs1
-        i = line.find('=')
+        i = line.find("=")
         if i == -1:
             self.name = line
-            self.bname = ''
+            self.bname = ""
         else:
             self.name = line[:i].rstrip()
-            self.bname = line[i+1:].lstrip()[1:].lstrip()
+            self.bname = line[i + 1 :].lstrip()[1:].lstrip()
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        s = 'PROCEDURE '
+        s = "PROCEDURE "
         if self.iname:
-            s += '(' + self.iname + ') '
+            s += "(" + self.iname + ") "
         if self.attrs:
-            s += ', ' + ', '.join(self.attrs) + ' :: '
+            s += ", " + ", ".join(self.attrs) + " :: "
         if self.bname:
-            s += '%s => %s' % (self.name, self.bname)
+            s += "%s => %s" % (self.name, self.bname)
         else:
             s += self.name
         return tab + s
 
 
 class GenericBinding(Statement):
     """
     GENERIC [ , <access-spec> ] :: <generic-spec> => <binding-name-list>
+
     """
-    match = re.compile(r'generic\b.*::.*=\>.*\Z', re.I).match
+
+    match = re.compile(r"generic\b.*::.*=\>.*\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[7:].lstrip()
-        if line.startswith(','):
+        if line.startswith(","):
             line = line[1:].lstrip()
-        i = line.index('::')
+        i = line.index("::")
         self.aspec = line[:i].rstrip().upper()
-        line = line[i+2:].lstrip()
-        i = line.index('=>')
+        line = line[i + 2 :].lstrip()
+        i = line.index("=>")
         self.spec = self.item.apply_map(line[:i].rstrip())
-        self.items = split_comma(line[i+2:].lstrip())
+        self.items = split_comma(line[i + 2 :].lstrip())
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        s = 'GENERIC'
+        s = "GENERIC"
         if self.aspec:
-            s += ', '+self.aspec
-        s += ' :: ' + self.spec + ' => ' + ', '.join(self.items)
+            s += ", " + self.aspec
+        s += " :: " + self.spec + " => " + ", ".join(self.items)
         return tab + s
 
 
 class FinalBinding(StatementWithNamelist):
     """
     FINAL [ :: ] <final-subroutine-name-list>
+
     """
-    stmtname = 'final'
-    match = re.compile(r'final\b', re.I).match
+
+    stmtname = "final"
+    match = re.compile(r"final\b", re.I).match
 
 
 class Allocatable(Statement):
     """
     ALLOCATABLE [ :: ] <object-name> [ ( <deferred-shape-spec-list> ) ]
                                      [ , <object-name>
                                          [ ( <deferred-shape-spec-list> ) ]
                                      ]...
+
     """
-    match = re.compile(r'allocatable\b', re.I).match
+
+    match = re.compile(r"allocatable\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[11:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) \
-            + 'ALLOCATABLE ' + ', '.join(self.items)
+        return self.get_indent_tab(isfix=isfix) + "ALLOCATABLE " + ", ".join(self.items)
 
     def analyze(self):
         for line in self.items:
-            i = line.find('(')
+            i = line.find("(")
             if i == -1:
                 name = line
                 array_spec = None
             else:
-                assert line.endswith(')')
+                assert line.endswith(")")
                 name = line[:i].rstrip()
-                array_spec = split_comma(line[i+1:-1], self.item)
+                array_spec = split_comma(line[i + 1 : -1], self.item)
             var = self.get_variable(name)
-            var.update('allocatable')
+            var.update("allocatable")
             if array_spec is not None:
                 var.set_bounds(array_spec)
         return
 
 
 class Asynchronous(StatementWithNamelist):
     """
     ASYNCHRONOUS [ :: ] <object-name-list>
     """
-    match = re.compile(r'asynchronous\b', re.I).match
+
+    match = re.compile(r"asynchronous\b", re.I).match
 
     def analyze(self):
         for name in self.items:
             var = self.get_variable(name)
-            var.update('asynchronous')
+            var.update("asynchronous")
         return
 
 
 class Bind(Statement):
     """
-    <language-binding-spec> [ :: ] <bind-entity-list>
-    <language-binding-spec> =
-                      BIND ( C [ , NAME = <scalar-char-initialization-expr> ] )
-    <bind-entity> = <entity-name> | / <common-block-name> /
+    ::
+
+        language-binding-spec [ :: ] bind-entity-list
+        language-binding-spec is
+                      BIND ( C [ , NAME = scalar-char-initialization-expr ] )
+        bind-entity is entity-name> | / common-block-name /
+
     """
-    match = re.compile(r'bind\s*\(.*\)', re.I).match
+
+    match = re.compile(r"bind\s*\(.*\)", re.I).match
 
     def process_item(self):
         line = self.item.line
         self.specs, line = parse_bind(line, self.item)
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         items = []
         for item in split_comma(line, self.item):
-            if item.startswith('/'):
-                assert item.endswith('/'), repr(item)
-                item = '/ ' + item[1:-1].strip() + ' /'
+            if item.startswith("/"):
+                assert item.endswith("/"), repr(item)
+                item = "/ " + item[1:-1].strip() + " /"
             items.append(item)
         self.items = items
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'BIND (%s) %s' %\
-               (', '.join(self.specs), ', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "BIND (%s) %s" % (
+            ", ".join(self.specs),
+            ", ".join(self.items),
+        )
+
 
 # IF construct statements
 
 
 class Else(Statement):
     """
     ELSE [<if-construct-name>]
     """
-    match = re.compile(r'else\b\s*\w*\s*\Z', re.I).match
+
+    match = re.compile(r"else\b\s*\w*\s*\Z", re.I).match
 
     def process_item(self):
         item = self.item
         self.name = item.get_line()[4:].strip()
-        parent_name = getattr(self.parent, 'name', '')
+        parent_name = getattr(self.parent, "name", "")
         if self.name and self.name != parent_name:
-            self.warning('expected if-construct-name %r but got %r, skipping.'
-                         % (parent_name, self.name))
+            self.warning(
+                "expected if-construct-name %r but got %r, skipping."
+                % (parent_name, self.name)
+            )
             self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
         if self.name:
-            return self.get_indent_tab(deindent=True) + 'ELSE ' + self.name
-        return self.get_indent_tab(deindent=True) + 'ELSE'
+            return self.get_indent_tab(deindent=True) + "ELSE " + self.name
+        return self.get_indent_tab(deindent=True) + "ELSE"
 
     def analyze(self):
         return
 
 
 class ElseIf(Statement):
     """
     ELSE IF ( <scalar-logical-expr> ) THEN [ <if-construct-name> ]
     """
-    match = re.compile(r'else\s*if\s*\(.*\)\s*then\s*\w*\s*\Z', re.I).match
+
+    match = re.compile(r"else\s*if\s*\(.*\)\s*then\s*\w*\s*\Z", re.I).match
 
     def process_item(self):
         item = self.item
         line = item.get_line()[4:].lstrip()[2:].lstrip()
-        i = line.find(')')
-        assert line[0] == '('
+        i = line.find(")")
+        assert line[0] == "("
         self.expr = item.apply_map(line[1:i])
-        self.name = line[i+1:].lstrip()[4:].strip()
-        parent_name = getattr(self.parent, 'name', '')
+        self.name = line[i + 1 :].lstrip()[4:].strip()
+        parent_name = getattr(self.parent, "name", "")
         if self.name and self.name != parent_name:
-            self.warning('expected if-construct-name %r but got %r, skipping.'
-                         % (parent_name, self.name))
+            self.warning(
+                "expected if-construct-name %r but got %r, skipping."
+                % (parent_name, self.name)
+            )
             self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
-        s = ''
+        s = ""
         if self.name:
-            s = ' ' + self.name
-        return self.get_indent_tab(deindent=True) + 'ELSE IF (%s) THEN%s' \
-            % (self.expr, s)
+            s = " " + self.name
+        return self.get_indent_tab(deindent=True) + "ELSE IF (%s) THEN%s" % (
+            self.expr,
+            s,
+        )
 
     def analyze(self):
         return
 
 
 # SelectCase construct statements
 
 
 class Case(Statement):
     """
-    CASE <case-selector> [ <case-construct-name> ]
-    <case-selector> = ( <case-value-range-list> ) | DEFAULT
-    <case-value-range> = <case-value>
-                         | <case-value> :
-                         | : <case-value>
-                         | <case-value> : <case-value>
-    <case-value> = <scalar-(int|char|logical)-initialization-expr>
+    Captures a Case statement::
+
+        CASE case-selector [ case-construct-name ]
+        case-selector is ( case-value-range-list ) | DEFAULT
+        case-value-range is case-value
+                         or case-value :
+                         or : case-value
+                         or case-value : case-value
+        case-value is scalar-(int|char|logical)-initialization-expr
+
     """
-    match = re.compile(r'case\b\s*(\(.*\)|DEFAULT)\s*\w*\Z', re.I).match
+
+    match = re.compile(r"case\b\s*(\(.*\)|DEFAULT)\s*\w*\Z", re.I).match
 
     def process_item(self):
-        ''' Populate the state of this item by parsing the associated line
-        of code '''
+        """Populate the state of this item by parsing the associated line
+        of code"""
         line = self.item.get_line()[4:].lstrip()
         try:
             self.items = extract_bracketed_list_items(line, self.item)
-            idx = line.rfind(')')
-            self.name = line[idx+1:].lstrip()
+            idx = line.rfind(")")
+            self.name = line[idx + 1 :].lstrip()
         except ParseError:
             # No list in parentheses found so we must have a 'case default'
-            if not line.lower().startswith('default'):
+            if not line.lower().startswith("default"):
                 # We should never get to here because such a string should
                 # not have generated a match
                 self.warning(
-                    "Internal error when parsing CASE statement: {0}".
-                    format(line))
+                    "Internal error when parsing CASE statement: {0}".format(line)
+                )
                 self.isvalid = False
                 return
             self.items = []
             self.name = line[7:].lstrip()
-        parent_name = getattr(self.parent, 'name', '')
+        parent_name = getattr(self.parent, "name", "")
         if self.name and self.name != parent_name:
-            self.warning("Expected case-construct-name {0} but got {1}, "
-                         "skipping.".format(parent_name, self.name))
+            self.warning(
+                "Expected case-construct-name {0} but got {1}, "
+                "skipping.".format(parent_name, self.name)
+            )
             self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
-        ''' Return the Fortran for this object as a string '''
+        """Return the Fortran for this object as a string"""
         tab = self.get_indent_tab(isfix=isfix)
-        txt = tab + 'CASE'
+        txt = tab + "CASE"
         if self.items:
             lst = []
             for item in self.items:
-                lst.append((' : '.join(item)).strip())
-            txt += ' ( %s )' % (', '.join(lst))
+                lst.append((" : ".join(item)).strip())
+            txt += " ( %s )" % (", ".join(lst))
         else:
-            txt += ' DEFAULT'
+            txt += " DEFAULT"
         if self.name:
-            txt += ' ' + self.name
+            txt += " " + self.name
         return txt
 
     def analyze(self):
         return
 
 
 class TypeIs(Statement):
     """
     TYPE IS <type-selector> [ <case-construct-name> ]
     <type-selector> = ( <type-value-range-list> )
     <type-value-range> = <case-value>
     <case-value> = <char>
     """
-    match = re.compile(r'type\b\s*is\b\s*\(.*\)\s*\w*\Z', re.I).match
+
+    match = re.compile(r"type\b\s*is\b\s*\(.*\)\s*\w*\Z", re.I).match
 
     def process_item(self):
-        ''' Populate the state of this object by parsing the associated
-        line of code '''
+        """Populate the state of this object by parsing the associated
+        line of code"""
         line = self.item.get_line()
         # We have a 'type is (...)' statement. At this point
         # any expression used for the type specifier will have
         # been replaced with e.g. F2PY_EXPR_TUPLE_3 and so
         # will not itself contain any parentheses.
         self.items = extract_bracketed_list_items(line, self.item)
         # Get and store the case-construct-name (if any)
-        idx2 = line.rfind(')')
-        self.name = line[idx2+1:].lstrip()
-        parent_name = getattr(self.parent, 'name', '')
+        idx2 = line.rfind(")")
+        self.name = line[idx2 + 1 :].lstrip()
+        parent_name = getattr(self.parent, "name", "")
         if self.name and self.name != parent_name:
             self.warning(
-                'expected type-is-construct-name %r but got %r, skipping.'
-                % (parent_name, self.name))
+                "expected type-is-construct-name %r but got %r, skipping."
+                % (parent_name, self.name)
+            )
             self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
-        ''' Create the Fortran representation of this object and return
-        it as a string '''
+        """Create the Fortran representation of this object and return
+        it as a string"""
         tab = self.get_indent_tab(isfix=isfix)
-        text = tab + 'TYPE IS'
+        text = tab + "TYPE IS"
         if self.items:
             lst = []
             for item in self.items:
-                lst.append((' : '.join(item)).strip())
-            text += ' ( %s )' % (', '.join(lst))
+                lst.append((" : ".join(item)).strip())
+            text += " ( %s )" % (", ".join(lst))
         else:
             raise ParseError("TYPE IS construct must have arguments")
         if self.name:
-            text += ' ' + self.name
+            text += " " + self.name
         return text
 
     def analyze(self):
         return
 
 
 class ClassIs(Statement):
     """
     CLASS <class-selector>
     <class-selector> = ( IS <type-value-range-list> | DEFAULT )
     <type-value-range> = <case-value>
     <case-value> = <char>
     """
-    match = re.compile(r'class\b\s*(is\b\s*\(.*\)|default)\s*\w*\Z',
-                       re.I).match
+
+    match = re.compile(r"class\b\s*(is\b\s*\(.*\)|default)\s*\w*\Z", re.I).match
 
     def process_item(self):
-        ''' Populate the state of this object by parsing the string '''
+        """Populate the state of this object by parsing the string"""
         line = self.item.get_line()[5:].lstrip()
         try:
             self.items = extract_bracketed_list_items(line, self.item)
             # We have a 'class is ...' statement. At this point
             # any expression used for the class specifier will have
             # been replaced with e.g. F2PY_EXPR_TUPLE_3 and so
             # will not contain any parentheses.
-            idx = line.rfind(')')
-            self.name = line[idx+1:].lstrip()
+            idx = line.rfind(")")
+            self.name = line[idx + 1 :].lstrip()
         except ParseError:
             # We have a 'class default' statement
-            if not line.lower().startswith('default'):
+            if not line.lower().startswith("default"):
                 # We should never get here because such a string should
                 # not have generated a match
                 self.warning(
-                    "Internal error when parsing CLASS statement: {0}".
-                    format(line))
+                    "Internal error when parsing CLASS statement: {0}".format(line)
+                )
                 self.isvalid = False
                 return
             self.items = []
             self.name = line[7:].lstrip()
-        parent_name = getattr(self.parent, 'name', '')
+        parent_name = getattr(self.parent, "name", "")
         if self.name and self.name != parent_name:
             self.warning(
-                'expected class-construct-name %r but got %r, skipping.'
-                % (parent_name, self.name))
+                "expected class-construct-name %r but got %r, skipping."
+                % (parent_name, self.name)
+            )
             self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
-        ''' Returns the Fortran for this object as a string '''
+        """Returns the Fortran for this object as a string"""
         tab = self.get_indent_tab(isfix=isfix)
-        text = tab + 'CLASS'
+        text = tab + "CLASS"
         if self.items:
-            text += ' IS'
+            text += " IS"
             lchar = []
             for item in self.items:
-                lchar.append((' : '.join(item)).strip())
-            text += ' ( %s )' % (', '.join(lchar))
+                lchar.append((" : ".join(item)).strip())
+            text += " ( %s )" % (", ".join(lchar))
         else:
-            text += ' DEFAULT'
+            text += " DEFAULT"
         if self.name:
-            text += ' ' + self.name
+            text += " " + self.name
         return text
 
     def analyze(self):
         return
 
 
 # Where construct statements
 
 
 class Where(Statement):
     """
     WHERE ( <mask-expr> ) <where-assignment-stmt>
     """
-    match = re.compile(r'where\s*\(.*\)\s*\w.*\Z', re.I).match
+
+    match = re.compile(r"where\s*\(.*\)\s*\w.*\Z", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[5:].lstrip()
-        i = line.index(')')
+        i = line.index(")")
         self.expr = self.item.apply_map(line[1:i].strip())
-        line = line[i+1:].lstrip()
+        line = line[i + 1 :].lstrip()
         newitem = self.item.copy(line)
         cls = Assignment
         if cls.match(line):
             stmt = cls(self, newitem)
             if stmt.isvalid:
                 self.content = [stmt]
                 return
         self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        return tab + 'WHERE ( %s ) %s' % (self.expr,
-                                          str(self.content[0]).lstrip())
+        return tab + "WHERE ( %s ) %s" % (self.expr, str(self.content[0]).lstrip())
 
     def analyze(self):
         return
 
 
 WhereStmt = Where
 
 
 class ElseWhere(Statement):
     """
     ELSE WHERE ( <mask-expr> ) [ <where-construct-name> ]
     ELSE WHERE [ <where-construct-name> ]
     """
-    match = re.compile(r'else\s*where\b', re.I).match
+
+    match = re.compile(r"else\s*where\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[4:].lstrip()[5:].lstrip()
         self.expr = None
-        if line.startswith('('):
-            i = line.index(')')
+        if line.startswith("("):
+            i = line.index(")")
             assert i != -1, repr(line)
             self.expr = self.item.apply_map(line[1:i].strip())
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
         self.name = line
-        parent_name = getattr(self.parent, 'name', '')
+        parent_name = getattr(self.parent, "name", "")
         if self.name and not self.name == parent_name:
-            self.warning('expected where-construct-name %r but got %r, '
-                         'skipping.' % (parent_name, self.name))
+            self.warning(
+                "expected where-construct-name %r but got %r, "
+                "skipping." % (parent_name, self.name)
+            )
             self.isvalid = False
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
-        s = 'ELSE WHERE'
+        s = "ELSE WHERE"
         if self.expr is not None:
-            s += ' ( %s )' % (self.expr)
+            s += " ( %s )" % (self.expr)
         if self.name:
-            s += ' ' + self.name
+            s += " " + self.name
         return tab + s
 
     def analyze(self):
         return
 
+
 # Enum construct statements
 
 
 class Enumerator(Statement):
     """
     ENUMERATOR [ :: ] <enumerator-list>
     <enumerator> = <named-constant> [ = <scalar-int-initialization-expr> ]
     """
-    match = re.compile(r'enumerator\b', re.I).match
+
+    match = re.compile(r"enumerator\b", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[10:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line, self.item)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'ENUMERATOR ' \
-            + ', '.join(self.items)
+        return self.get_indent_tab(isfix=isfix) + "ENUMERATOR " + ", ".join(self.items)
+
 
 # F2PY specific statements
 
 
 class FortranName(Statement):
     """
     FORTRANNAME <name>
     """
-    match = re.compile(r'fortranname\s*\w+\Z', re.I).match
+
+    match = re.compile(r"fortranname\s*\w+\Z", re.I).match
 
     def process_item(self):
         self.value = self.item.get_line()[11:].lstrip()
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'FORTRANNAME ' \
-            + self.value
+        return self.get_indent_tab(isfix=isfix) + "FORTRANNAME " + self.value
 
 
 class Threadsafe(Statement):
     """
     THREADSAFE
     """
-    match = re.compile(r'threadsafe\Z', re.I).match
+
+    match = re.compile(r"threadsafe\Z", re.I).match
 
     def process_item(self):
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'THREADSAFE'
+        return self.get_indent_tab(isfix=isfix) + "THREADSAFE"
 
 
 class Depend(Statement):
     """
     DEPEND ( <name-list> ) [ :: ] <dummy-arg-name-list>
 
     """
-    match = re.compile(r'depend\s*\(', re.I).match
+
+    match = re.compile(r"depend\s*\(", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[6:].lstrip()
-        i = line.find(')')
+        i = line.find(")")
         self.depends = split_comma(line[1:i].strip(), self.item)
-        line = line[i+1:].lstrip()
-        if line.startswith('::'):
+        line = line[i + 1 :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.items = split_comma(line)
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'DEPEND ( %s ) %s' \
-               % (', '.join(self.depends), ', '.join(self.items))
+        return self.get_indent_tab(isfix=isfix) + "DEPEND ( %s ) %s" % (
+            ", ".join(self.depends),
+            ", ".join(self.items),
+        )
 
 
 class Check(Statement):
     """
     CHECK ( <c-int-scalar-expr> ) [ :: ] <name>
 
     """
-    match = re.compile(r'check\s*\(', re.I).match
+
+    match = re.compile(r"check\s*\(", re.I).match
 
     def process_item(self):
         line = self.item.get_line()[5:].lstrip()
-        i = line.find(')')
+        i = line.find(")")
         assert i != -1, repr(line)
         self.expr = self.item.apply_map(line[1:i].strip())
-        line = line[i+1:].lstrip()
-        if line.startswith('::'):
+        line = line[i + 1 :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
         self.value = line
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'CHECK ( %s ) %s' \
-               % (self.expr, self.value)
+        return self.get_indent_tab(isfix=isfix) + "CHECK ( %s ) %s" % (
+            self.expr,
+            self.value,
+        )
 
 
 class CallStatement(Statement):
     """
     CALLSTATEMENT <c-expr>
     """
-    match = re.compile(r'callstatement\b', re.I).match
+
+    match = re.compile(r"callstatement\b", re.I).match
 
     def process_item(self):
         self.expr = self.item.apply_map(self.item.get_line()[13:].lstrip())
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'CALLSTATEMENT ' + self.expr
+        return self.get_indent_tab(isfix=isfix) + "CALLSTATEMENT " + self.expr
 
 
 class CallProtoArgument(Statement):
     """
     CALLPROTOARGUMENT <c-type-spec-list>
     """
-    match = re.compile(r'callprotoargument\b', re.I).match
+
+    match = re.compile(r"callprotoargument\b", re.I).match
 
     def process_item(self):
         self.specs = self.item.apply_map(self.item.get_line()[17:].lstrip())
         return
 
     def tofortran(self, isfix=None):
-        return self.get_indent_tab(isfix=isfix) + 'CALLPROTOARGUMENT ' \
-            + self.specs
+        return self.get_indent_tab(isfix=isfix) + "CALLPROTOARGUMENT " + self.specs
+
 
 # Non-standard statements
 
 
 class Pause(Statement):
     """
     PAUSE [ <char-literal-constant|int-literal-constant> ]
     """
+
     match = re.compile(r'pause\s*(\d+|\'\w*\'|"\w*"|)\Z', re.I).match
 
     def process_item(self):
         self.value = self.item.apply_map(self.item.get_line()[5:].lstrip())
         return
 
     def tofortran(self, isfix=None):
         if self.value:
-            return self.get_indent_tab(isfix=isfix) + 'PAUSE ' + self.value
-        return self.get_indent_tab(isfix=isfix) + 'PAUSE'
+            return self.get_indent_tab(isfix=isfix) + "PAUSE " + self.value
+        return self.get_indent_tab(isfix=isfix) + "PAUSE"
 
     def analyze(self):
         return
 
 
 class Comment(Statement):
     """
 
     Attributes
-    ----------
+
     content : str
       Content of the comment.
     is_blank : bool
       When True then Comment represents blank line.
+
     """
+
     match = lambda s: True
 
     def process_item(self):
-        assert self.item.comment.count('\n') <= 1, repr(self.item)
+        assert self.item.comment.count("\n") <= 1, repr(self.item)
         stripped = self.item.comment.lstrip()
         self.is_blank = not stripped
-        self.content = stripped[1:] if stripped else ''
+        self.content = stripped[1:] if stripped else ""
 
     def tofortran(self, isfix=None):
         if self.is_blank:
-            return ''
+            return ""
         if isfix:
-            tab = 'C' + self.get_indent_tab(isfix=isfix)[1:]
+            tab = "C" + self.get_indent_tab(isfix=isfix)[1:]
         else:
-            tab = self.get_indent_tab(isfix=isfix) + '!'
+            tab = self.get_indent_tab(isfix=isfix) + "!"
         return tab + self.content
 
     def analyze(self):
         return
```

### Comparing `fparser-0.0.9/src/fparser/one/tests/test_block_stmts.py` & `fparser-0.1.0/src/fparser/one/tests/test_block_stmts.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,37 +29,37 @@
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-'''
+"""
 File containing tests for the one.block_statements module.
-'''
-from __future__ import absolute_import, print_function
+"""
 
 import pytest
 
 from fparser.common.utils import AnalyzeError
 from fparser.common.sourceinfo import FortranFormat
 from fparser.one.parsefortran import FortranParser
 from fparser.common.readfortran import FortranStringReader
 
 
 def test_get_type_by_name(monkeypatch):
-    ''' Tests for HasImplicitStmt.get_type_by_name(). '''
+    """Tests for HasImplicitStmt.get_type_by_name()."""
     from fparser.one.typedecl_statements import Real, Integer
+
     # We can't just create a HasImplicitStmt object so we get the parser
     # to create a module object as that sub-classes HasImplicitStmt (amongst
     # other things).
-    string = '''\
+    string = """\
 module some_block
 end module some_block
-'''
+"""
     reader = FortranStringReader(string)
     reader.set_format(FortranFormat(True, False))
     parser = FortranParser(reader)
     parser.parse()
     mod = parser.block.content[0]
     # Now we have a Module object, we can call get_type_by_name()...
     rtype = mod.get_type_by_name("a_real")
@@ -71,26 +71,27 @@
     monkeypatch.setattr(mod.a, "implicit_rules", None)
     with pytest.raises(AnalyzeError) as err:
         _ = mod.get_type_by_name("i_int")
     assert "Implicit rules mapping is null" in str(err.value)
 
 
 def test_get_type_by_name_implicit():
-    ''' Tests for HasImplicitStmt.get_type_by_name() when the source code
-    contains IMPLICIT statements. '''
+    """Tests for HasImplicitStmt.get_type_by_name() when the source code
+    contains IMPLICIT statements."""
     from fparser.one.typedecl_statements import Real, Integer
+
     # We can't just create a HasImplicitStmt object so we get the parser
     # to create a module object as that sub-classes HasImplicitStmt (amongst
     # other things).
-    string = '''\
+    string = """\
 module some_block
   implicit real (a-e)
   implicit integer (f-z)
 end module some_block
-'''
+"""
     reader = FortranStringReader(string)
     reader.set_format(FortranFormat(True, False))
     parser = FortranParser(reader)
     parser.parse()
     # Get the module object
     mod = parser.block.content[0]
     # We have to run the analyze method on the Implicit objects
@@ -102,24 +103,24 @@
     rtype = mod.get_type_by_name("a_real")
     assert isinstance(rtype, Real)
     itype = mod.get_type_by_name("f_int")
     assert isinstance(itype, Integer)
 
 
 def test_implicit_topyf(monkeypatch):
-    ''' Tests for the topyf() method of HasImplicitStmt. '''
+    """Tests for the topyf() method of HasImplicitStmt."""
     # We can't just create a HasImplicitStmt object so we get the parser
     # to create a module object as that sub-classes HasImplicitStmt (amongst
     # other things).
-    string = '''\
+    string = """\
 module some_block
   implicit real (a-e)
   implicit integer (f-z)
 end module some_block
-'''
+"""
     reader = FortranStringReader(string)
     reader.set_format(FortranFormat(True, False))
     parser = FortranParser(reader)
     parser.parse()
     # Get the module object
     mod = parser.block.content[0]
     code = mod.topyf()
```

### Comparing `fparser-0.0.9/src/fparser/one/tests/test_do_block_r814.py` & `fparser-0.1.0/src/fparser/one/tests/test_do_block_r814.py`

 * *Files 23% similar despite different names*

```diff
@@ -28,119 +28,145 @@
 # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-'''
+"""
 Tests the parser against "do" block syntax.
 
 This is a complicated piece of syntax with many axes of movement. A
 comprehensive testing was felt to be too onerous so this stripped down
 version checks only a subset. Hopefully it is representative.
-'''
-from __future__ import absolute_import, print_function
+"""
 
 import pytest
 
 from fparser.common.utils import AnalyzeError
 from fparser.common.sourceinfo import FortranFormat
 from fparser.one.parsefortran import FortranParser
 from fparser.common.readfortran import FortranStringReader
 
 
-@pytest.mark.parametrize('name', [None, 'loop_name'])
-@pytest.mark.parametrize('label', [None, '123'])
-@pytest.mark.parametrize('control_comma', [False, True])
-@pytest.mark.parametrize('terminal_expression',
-                         ['1', '10', 'x+y', 'size(array)', 'size(this%array)'])
-@pytest.mark.parametrize('end_name', [None, 'loop_name', 'wrong_name'])
-@pytest.mark.parametrize('end_label', [None, '123', '456'])
-def test_do(name, label, control_comma, terminal_expression,
-            end_name, end_label):
+def get_end_do(name):
+    """A small helper function to return either "END DO" (without space) if
+    name is empty, or "END DO "+name. This simplifies the tests now that
+    tofortran does not return an "END DO" with one space in case of an
+    unnamed end statement.
+
+    :param str name: Either None if it is an unnamed statement, or \
+        the label to use in the end statement.
+
+    :returns: either "END DO" (without space) if name is empty, or \
+        "END DO "+name.
+    :rtype: str
+
+    """
+
+    if name:
+        return "END DO {0}".format(name)
+    return "END DO"
+
+
+@pytest.mark.parametrize("name", [None, "loop_name"])
+@pytest.mark.parametrize("label", [None, "123"])
+@pytest.mark.parametrize("control_comma", [False, True])
+@pytest.mark.parametrize(
+    "terminal_expression", ["1", "10", "x+y", "size(array)", "size(this%array)"]
+)
+@pytest.mark.parametrize("end_name", [None, "loop_name", "wrong_name"])
+@pytest.mark.parametrize("end_label", [None, "123", "456"])
+def test_do(name, label, control_comma, terminal_expression, end_name, end_label):
     # pylint: disable=redefined-outer-name, too-many-arguments, too-many-locals
-    '''
+    """
     Checks that the "do" loop parser understands the "for-next" variant of
     the syntax. This is defined in BS ISO/IEC 1539-1:2010 with R814-R822.
 
     TODO: Only the terminal expression is tested. This is a short-cut and
           relies on expression handling being applied identically across
           all expressions. This was true at the time of writing the test.
-    '''
-    name_snippet = name + ': ' if name else None
-    label_snippet = label + ' ' if label else None
-    comma_snippet = ', ' if control_comma else None
+    """
+    name_snippet = name + ": " if name else None
+    label_snippet = label + " " if label else None
+    comma_snippet = ", " if control_comma else None
     # TODO: Although the Fortran standard allows for "continue" to be used in
     # place of "end do" fparser does not support it.
-    end_snippet = 'continue' if end_name == 'continue' \
-                  else 'end do {endname}'.format(endname=end_name or '')
-    do_code = '''{name}do {label}{comma}variable = 1, {term}, 1
+    end_snippet = "continue" if end_name == "continue" else get_end_do(end_name)
+    do_code = """{name}do {label}{comma}variable = 1, {term}, 1
   write (6, '(I0)') variable
 {endlabel} {end}
-'''.format(name=name_snippet or '',
-           label=label_snippet or '',
-           comma=comma_snippet or '',
-           term=terminal_expression,
-           endlabel=end_label or '',
-           end=end_snippet)
-    do_expected = '''  {name}DO {label}variable = 1, {term}, 1
+""".format(
+        name=name_snippet or "",
+        label=label_snippet or "",
+        comma=comma_snippet or "",
+        term=terminal_expression,
+        endlabel=end_label or "",
+        end=end_snippet,
+    )
+    do_expected = """  {name}DO {label}variable = 1, {term}, 1
     WRITE (6, '(I0)') variable
-{endlabel} END DO {endname}
-'''.format(name=name_snippet or '',
-           label=label_snippet or '',
-           term=terminal_expression,
-           endlabel=end_label or ' ',
-           endname=end_name or '')
+{endlabel} {endstmt}
+""".format(
+        name=name_snippet or "",
+        label=label_snippet or "",
+        term=terminal_expression,
+        endlabel=end_label or " ",
+        endstmt=get_end_do(end_name),
+    )
     do_reader = FortranStringReader(do_code)
     do_reader.set_format(FortranFormat(True, False))
     do_parser = FortranParser(do_reader)
     if (name != end_name) or (label and (label != end_label)):
         with pytest.raises(AnalyzeError):
             do_parser.parse()
     else:
         do_parser.parse()
         loop = do_parser.block.content[0]
         assert str(loop).splitlines() == do_expected.splitlines()
 
 
-@pytest.mark.parametrize('name', [None, 'loop_name'])
-@pytest.mark.parametrize('label', [None, '123'])
-@pytest.mark.parametrize('control_comma', [False, True])
-@pytest.mark.parametrize('terminal_expression',
-                         ['1', 'x+y', 'size(array)', 'size(this%array)'])
-@pytest.mark.parametrize('end_name', [None, 'loop_name', 'wrong_name'])
-@pytest.mark.parametrize('end_label', [None, '123', '456'])
-def test_do_while(name, label, control_comma, terminal_expression,
-                  end_name, end_label):
+@pytest.mark.parametrize("name", [None, "loop_name"])
+@pytest.mark.parametrize("label", [None, "123"])
+@pytest.mark.parametrize("control_comma", [False, True])
+@pytest.mark.parametrize(
+    "terminal_expression", ["1", "x+y", "size(array)", "size(this%array)"]
+)
+@pytest.mark.parametrize("end_name", [None, "loop_name", "wrong_name"])
+@pytest.mark.parametrize("end_label", [None, "123", "456"])
+def test_do_while(name, label, control_comma, terminal_expression, end_name, end_label):
     # pylint: disable=redefined-outer-name, too-many-arguments
-    '''
+    """
     Checks that the "do" loop parser understands the "do-while" variant of
     the syntax. This is defined in BS ISO/IEC 1539-1:2010 with R814-R822.
-    '''
-    name_snippet = name + ': ' if name else None
-    label_snippet = label + ' ' if label else None
-    comma_snippet = ', ' if control_comma else None
-    code = '''{name}do {label}{comma}while ({term})
+    """
+    name_snippet = name + ": " if name else None
+    label_snippet = label + " " if label else None
+    comma_snippet = ", " if control_comma else None
+    code = """{name}do {label}{comma}while ({term})
   write (6, '(I0)') variable
-{endlabel} end do {endname}
-'''.format(name=name_snippet or '',
-           label=label_snippet or '',
-           comma=comma_snippet or '',
-           term=terminal_expression,
-           endlabel=end_label or '',
-           endname=end_name or '')
-    expected = '''  {name}DO {label}while ({term})
+{endlabel} {endstmt}
+""".format(
+        name=name_snippet or "",
+        label=label_snippet or "",
+        comma=comma_snippet or "",
+        term=terminal_expression,
+        endlabel=end_label or "",
+        endstmt=get_end_do(end_name),
+    )
+    expected = """  {name}DO {label}while ({term})
     WRITE (6, '(I0)') variable
-{endlabel} END DO {endname}
-'''.format(name=name_snippet or '',
-           label=label_snippet or '',
-           term=terminal_expression,
-           endlabel=end_label or ' ',
-           endname=end_name or '')
+{endlabel} {endstmt}
+""".format(
+        name=name_snippet or "",
+        label=label_snippet or "",
+        term=terminal_expression,
+        endlabel=end_label or " ",
+        endstmt=get_end_do(end_name),
+    )
     print(code)
     reader = FortranStringReader(code)
     reader.set_format(FortranFormat(True, False))
     parser = FortranParser(reader)
     if (name != end_name) or (label and (label != end_label)):
         with pytest.raises(AnalyzeError):
             parser.parse()
```

### Comparing `fparser-0.0.9/src/fparser/one/tests/test_parsefortran.py` & `fparser-0.1.0/src/fparser/one/tests/test_parsefortran.py`

 * *Files 22% similar despite different names*

```diff
@@ -32,137 +32,153 @@
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ##############################################################################
-'''
+"""
 Tests the fparser.one.parsefortran module.
-'''
+"""
 
 import pytest
 import fparser.one.parsefortran
 import fparser.common.readfortran
 
 
 def test_log_empty(log):
-    '''
+    """
     Tests that a reader without next() method causes an event to be logged.
-    '''
-    class EmptyReader(object):
-        '''
+    """
+
+    class EmptyReader:
+        """
         A faux reader with no next() method.
-        '''
-        id = 'thingumy'
+        """
+
+        id = "thingumy"
 
     unit_under_test = fparser.one.parsefortran.FortranParser(EmptyReader())
     unit_under_test.analyze()
-    assert log.messages == {'debug':    [],
-                            'info':     ['Nothing to analyze.'],
-                            'warning':  [],
-                            'error':    [],
-                            'critical': []}
+    assert log.messages == {
+        "debug": [],
+        "info": ["Nothing to analyze."],
+        "warning": [],
+        "error": [],
+        "critical": [],
+    }
+    unit_under_test.cache.clear()
 
 
 def test_log_cache(log):
-    '''
+    """
     Tests that using a cached reader object logs an event.
-    '''
-    class Readerlike(object):
-        '''
+    """
+
+    class Readerlike:
+        """
         Dummy reader class, the only purpose of which is to have an id and not
         cause the parser to fail.
-        '''
-        id = 'thisun'
+        """
+
+        id = "thisun"
 
         def next(self):
-            '''
+            """
             Simple non-failure-causing method.
-            '''
-            yield 'NOT A THING'
+            """
+            yield "NOT A THING"
             raise StopIteration
 
     # Expect everything to go okay, no log messages.
     log.reset()
-    _ = fparser.one.parsefortran.FortranParser(Readerlike())
-    assert log.messages == {'debug':    [],
-                            'info':     [],
-                            'warning':  [],
-                            'error':    [],
-                            'critical': []}
+    parser = fparser.one.parsefortran.FortranParser(Readerlike())
+    assert log.messages == {
+        "debug": [],
+        "info": [],
+        "warning": [],
+        "error": [],
+        "critical": [],
+    }
 
     # This time we should use a cached log.
-    _ = fparser.one.parsefortran.FortranParser(Readerlike())
-    assert log.messages == {'debug':    [],
-                            'info':     ['using cached thisun'],
-                            'warning':  [],
-                            'error':    [],
-                            'critical': []}
+    parser = fparser.one.parsefortran.FortranParser(Readerlike())
+    assert log.messages == {
+        "debug": [],
+        "info": ["using cached thisun"],
+        "warning": [],
+        "error": [],
+        "critical": [],
+    }
+    parser.cache.clear()
 
 
 def test_log_failure(log, monkeypatch):
-    '''
+    """
     Tests that an unexpected read failure causes an event to be logged.
-    '''
+    """
+
     def faulty_next(self, ignore_comments=False):
-        '''
+        """
         Raies any old exception.
-        '''
-        raise Exception('That''s all folks!')
+        """
+        raise Exception("That" "s all folks!")
 
-    monkeypatch.setattr('fparser.common.readfortran.FortranStringReader.next',
-                        faulty_next)
-    reader = fparser.common.readfortran.FortranStringReader('')
+    monkeypatch.setattr(
+        "fparser.common.readfortran.FortranStringReader.next", faulty_next
+    )
+    reader = fparser.common.readfortran.FortranStringReader("")
     unit_under_test = fparser.one.parsefortran.FortranParser(reader)
     with pytest.raises(Exception):
         unit_under_test.parse()
-    assert log.messages['debug'][0] \
-        .startswith('An error occurred during parsing.')
-    assert log.messages['info'] == []
-    assert log.messages['warning'] == []
-    assert log.messages['error'] == []
-    assert log.messages['critical'][0].startswith('While processing')
-    assert log.messages['critical'][1] == 'STOPPED PARSING'
+    assert log.messages["debug"][0].startswith("An error occurred during parsing.")
+    assert log.messages["info"] == []
+    assert log.messages["warning"] == []
+    assert log.messages["error"] == []
+    assert log.messages["critical"][0].startswith("While processing")
+    assert log.messages["critical"][1] == "STOPPED PARSING"
+    unit_under_test.cache.clear()
 
 
 def test_pyf():
-    '''
+    """
     Tests inherited from implementation code.
-    '''
+    """
     string = """
 python module foo
   interface tere
     subroutine bar
     real r
     end subroutine bar
   end interface tere
 end python module foo
 """
-    expected = ['  PYTHONMODULE foo',
-                '    INTERFACE tere',
-                '      SUBROUTINE bar()',
-                '        REAL r',
-                '      END SUBROUTINE bar',
-                '    END INTERFACE tere',
-                '  END PYTHONMODULE foo']
+    expected = [
+        "  PYTHONMODULE foo",
+        "    INTERFACE tere",
+        "      SUBROUTINE bar()",
+        "        REAL r",
+        "      END SUBROUTINE bar",
+        "    END INTERFACE tere",
+        "  END PYTHONMODULE foo",
+    ]
 
     reader = fparser.common.readfortran.FortranStringReader(string)
-    reader.set_format(fparser.common.sourceinfo.FortranFormat.from_mode('pyf'))
+    reader.set_format(fparser.common.sourceinfo.FortranFormat.from_mode("pyf"))
     parser = fparser.one.parsefortran.FortranParser(reader)
     parser.parse()
     caught = parser.block.tofortran().splitlines()
-    assert caught[0][:13] == '!BEGINSOURCE '
+    assert caught[0][:13] == "!BEGINSOURCE "
     assert caught[1:] == expected
 
 
 def test_free90():
-    '''
+    """
     Tests inherited from implementation code.
-    '''
+    """
     string = """
 module foo
 
    subroutine bar
     real r
     if ( pc_get_lun() .ne. 6) &
     write ( pc_get_lun(), '( &
@@ -180,93 +196,97 @@
     end subroutine bar
     abstract interface
 
     end interface
 
 end module foo
 """
-    expected = ['  MODULE foo',
-                '    SUBROUTINE bar()',
-                '      REAL r',
-                '      IF (pc_get_lun() .ne. 6)' +
-                ' WRITE (pc_get_lun(), \'(  /, A, /, " P = ", i4,' +
-                ' " stopping c_flag=", a,  /, " print unit=", i8)\')' +
-                ' trim(title), pcpsx_i_pel(), trim(c_flag), pc_get_lun()',
-                '      IF (.true.) THEN',
-                '        CALL smth',
-                '      END IF ',
-                '      aaa: IF (.false.) THEN',
-                '      ELSE IF (a) THEN',
-                '      ELSE',
-                '      END IF aaa',
-                '      hey = 1',
-                '    END SUBROUTINE bar',
-                '    ABSTRACT INTERFACE',
-                '    END INTERFACE ',
-                '  END MODULE foo']
+    expected = [
+        "  MODULE foo",
+        "    SUBROUTINE bar()",
+        "      REAL r",
+        "      IF (pc_get_lun() .ne. 6)"
+        + ' WRITE (pc_get_lun(), \'(  /, A, /, " P = ", i4,'
+        + ' " stopping c_flag=", a,  /, " print unit=", i8)\')'
+        + " trim(title), pcpsx_i_pel(), trim(c_flag), pc_get_lun()",
+        "      IF (.true.) THEN",
+        "        CALL smth",
+        "      END IF",
+        "      aaa: IF (.false.) THEN",
+        "      ELSE IF (a) THEN",
+        "      ELSE",
+        "      END IF aaa",
+        "      hey = 1",
+        "    END SUBROUTINE bar",
+        "    ABSTRACT INTERFACE",
+        "    END INTERFACE",
+        "  END MODULE foo",
+    ]
 
     reader = fparser.common.readfortran.FortranStringReader(string)
-    mode = fparser.common.sourceinfo.FortranFormat.from_mode('free')
+    mode = fparser.common.sourceinfo.FortranFormat.from_mode("free")
     reader.set_format(mode)
     parser = fparser.one.parsefortran.FortranParser(reader)
     parser.parse()
     caught = parser.block.tofortran().splitlines()
-    assert caught[0][:13] == '!BEGINSOURCE '
+    assert caught[0][:13] == "!BEGINSOURCE "
     assert caught[1:] == expected
 
 
 def test_module_procedure():
-    '''
+    """
     Tests a type that contains a procedure, and makes sure
     it has a module_procedures attribute
-    '''
+    """
     string = """
 module foo
     type, public :: grid_type
    contains
         procedure :: get_tmask
    end type grid_type
 end module foo
 """
 
     reader = fparser.common.readfortran.FortranStringReader(string)
-    mode = fparser.common.sourceinfo.FortranFormat.from_mode('free')
+    mode = fparser.common.sourceinfo.FortranFormat.from_mode("free")
     reader.set_format(mode)
     parser = fparser.one.parsefortran.FortranParser(reader)
     parser.parse()
 
     # Fails if the class Type does not have a "module_procedures" attribute
     parser.analyze()
 
 
 def test_f77():
-    '''
+    """
     Tests inherited from implementation code.
-    '''
+    """
     string = """\
       program foo
       a = 3
       end
       subroutine bar
       end
       pure function foo(a)
       end
       pure real*4 recursive function bar()
       end
 """
-    expected = ['        PROGRAM foo',
-                '          a = 3',
-                '        END PROGRAM foo',
-                '        SUBROUTINE bar()',
-                '        END SUBROUTINE bar',
-                '        pure FUNCTION foo(a)',
-                '        END FUNCTION foo',
-                '        pure recursive REAL*4 FUNCTION bar()',
-                '        END FUNCTION bar']
+    expected = [
+        "        PROGRAM foo",
+        "          a = 3",
+        "        END PROGRAM foo",
+        "        SUBROUTINE bar()",
+        "        END SUBROUTINE bar",
+        "        pure FUNCTION foo(a)",
+        "        END FUNCTION foo",
+        "        pure recursive REAL*4 FUNCTION bar()",
+        "        END FUNCTION bar",
+    ]
 
     reader = fparser.common.readfortran.FortranStringReader(string)
     parser = fparser.one.parsefortran.FortranParser(reader)
     parser.parse()
     assert isinstance(parser.block, fparser.one.block_statements.BeginSource)
     caught = parser.block.tofortran().splitlines()
-    assert caught[0][:25] == '      !      BEGINSOURCE '
+    assert caught[0][:25] == "      !      BEGINSOURCE "
     assert caught[1:] == expected
```

### Comparing `fparser-0.0.9/src/fparser/one/tests/test_scripts.py` & `fparser-0.1.0/src/fparser/one/tests/test_scripts.py`

 * *Files 9% similar despite different names*

```diff
@@ -28,62 +28,62 @@
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-'''Test fparser one scripts
+"""Test fparser one scripts
 
-'''
+"""
 
-from __future__ import print_function
 import os
 import sys
 from fparser.scripts import parse
 
 # Section 1: tests for pytest.py:runner
 
 
 def test_runner(capsys, tmpdir, monkeypatch):
-    '''Test that the main function works as expected.'''
+    """Test that the main function works as expected."""
     # Create a temporary file containing Fortran code.
     my_file = tmpdir.mkdir("sub").join("hello.f90")
     my_file.write("program hello\nend program hello\n")
     # Use monkeypatch to spoof the command-line argument
     monkeypatch.setattr(sys, "argv", ["read", str(my_file)])
     # run the relevant script method (main())
     parse.main()
     # capture the output and check that the code has been output
     stdout, _ = capsys.readouterr()
     print(stdout)
-    assert(
+    assert (
         "    Program\n"
         "      blocktype='program'\n"
         "      name='hello'\n"
         "      item=Line('program hello',(1, 1),None,None,<reader>)\n"
         "      content:\n"
         "    EndProgram\n"
         "      blocktype='program'\n"
         "      name='hello'\n"
         "      item=Line('end program hello',"
-        "(2, 2),None,None,<reader>)") in stdout
+        "(2, 2),None,None,<reader>)"
+    ) in stdout
 
 
 def test_log(caplog, monkeypatch):
-    '''Test that logging is enabled and works as expected.'''
-    my_file = os.path.join(os.path.dirname(os.path.abspath(__file__)),
-                           "bad_char.f90")
+    """Test that logging is enabled and works as expected."""
+    my_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "bad_char.f90")
     # Use monkeypatch to spoof the command-line argument
     monkeypatch.setattr(sys, "argv", ["read", str(my_file)])
     # run the relevant script method (main())
     parse.main()
     # Check the log messages
     for record in caplog.records:
-        assert record.levelname != 'CRITICAL'
-    assert ("Skipped bad character in input file. Error returned was "
-            "'utf") in caplog.text
+        assert record.levelname != "CRITICAL"
+    assert (
+        "Skipped bad character in input file. Error returned was " "'utf"
+    ) in caplog.text
     # Output can be utf8 or utf-8 so split test in two.
     assert "8' codec can't decode byte " in caplog.text
     # Can't check the actual value as some versions of Python3 return
     # a different value to the one above.
     assert "in position 1815: invalid continuation byte." in caplog.text
```

### Comparing `fparser-0.0.9/src/fparser/one/tests/test_select.py` & `fparser-0.1.0/src/fparser/one/tests/test_select.py`

 * *Files 12% similar despite different names*

```diff
@@ -75,89 +75,91 @@
 # We need to monkeypatch the logger used by fparser because it grabs
 # stdout before the pytest framework can intercept it. In python < 3
 # you can't make a lambda out of 'print' because print is not a
 # function (you cannot do "x = print y" for instance). Therefore we
 # have to create our own function that simply wraps print and returns
 # a value.
 def print_wrapper(arg):
-    ''' A wrapper that allows us to call print as a function. Used for
-    monkeypatching logging calls. '''
+    """A wrapper that allows us to call print as a function. Used for
+    monkeypatching logging calls."""
     print(arg)
     return None
 
 
 def test_case():
-    ''' Basic tests for parsing of individual case statements '''
+    """Basic tests for parsing of individual case statements"""
     from fparser.one.tests.test_parser import parse
     from fparser.one.block_statements import Case
-    assert parse(Case, 'case (1)') == 'CASE ( 1 )'
-    assert parse(Case, 'case (1:)') == 'CASE ( 1 : )'
-    assert parse(Case, 'case (:1)') == 'CASE ( : 1 )'
-    assert parse(Case, 'case (1:2)') == 'CASE ( 1 : 2 )'
-    assert parse(Case, 'case (a(1,2))') == 'CASE ( a(1,2) )'
+
+    assert parse(Case, "case (1)") == "CASE ( 1 )"
+    assert parse(Case, "case (1:)") == "CASE ( 1 : )"
+    assert parse(Case, "case (:1)") == "CASE ( : 1 )"
+    assert parse(Case, "case (1:2)") == "CASE ( 1 : 2 )"
+    assert parse(Case, "case (a(1,2))") == "CASE ( a(1,2) )"
     assert parse(Case, 'case ("ab")') == 'CASE ( "ab" )'
-    assert parse(Case, 'case default') == 'CASE DEFAULT'
-    assert parse(Case, 'case (1:2 ,3:4)') == 'CASE ( 1 : 2, 3 : 4 )'
-    assert parse(Case, 'case (a(1,:):)') == 'CASE ( a(1,:) : )'
-    assert parse(Case, 'case default') == 'CASE DEFAULT'
+    assert parse(Case, "case default") == "CASE DEFAULT"
+    assert parse(Case, "case (1:2 ,3:4)") == "CASE ( 1 : 2, 3 : 4 )"
+    assert parse(Case, "case (a(1,:):)") == "CASE ( a(1,:) : )"
+    assert parse(Case, "case default") == "CASE DEFAULT"
 
 
 def test_case_internal_error(monkeypatch, capsys):
-    ''' Check that expected errors are raised when invalid case
-    statements are encountered '''
+    """Check that expected errors are raised when invalid case
+    statements are encountered"""
     from fparser.one.block_statements import Case
     from fparser.common.readfortran import FortranStringReader
-    reader = FortranStringReader('CASE (yes)')
+
+    reader = FortranStringReader("CASE (yes)")
     reader.set_format(fparser.common.sourceinfo.FortranFormat(True, False))
     item = next(reader)
     stmt = Case(item, item)
     # Monkeypatch our valid Case object so that get_line() now
     # returns something invalid. We have to do it this way
     # because if we started with this text then we wouldn't get
     # past the match() method
-    monkeypatch.setattr(stmt.item, "get_line",
-                        lambda: "case invalid")
+    monkeypatch.setattr(stmt.item, "get_line", lambda: "case invalid")
     # Monkeypatch the Case object so that a call to self.warning
     # (which normally results in a call to the logger) gets replaced
     # with a call to our print_wrapper() function
     monkeypatch.setattr(stmt, "warning", print_wrapper)
     stmt.process_item()
     output, _ = capsys.readouterr()
     print(output)
     assert "Internal error when parsing CASE statement" in output
 
 
 def test_class_internal_error(monkeypatch, capsys):
-    ''' Check that expected errors are raised when invalid CLASS
-    statements are encountered '''
+    """Check that expected errors are raised when invalid CLASS
+    statements are encountered"""
     from fparser.one.block_statements import ClassIs
     from fparser.common.readfortran import FortranStringReader
-    reader = FortranStringReader('CLASS IS (yes)')
+
+    reader = FortranStringReader("CLASS IS (yes)")
     reader.set_format(fparser.common.sourceinfo.FortranFormat(True, False))
     item = next(reader)
     stmt = ClassIs(item, item)
     # Monkeypatch our valid Case object so that get_line() now
     # returns something invalid. We have to do it this way
     # because if we started with this text then we wouldn't get
     # past the match() method
-    monkeypatch.setattr(stmt.item, "get_line",
-                        lambda: "class invalid")
+    monkeypatch.setattr(stmt.item, "get_line", lambda: "class invalid")
     # Monkeypatch the Case object so that a call to self.warning
     # (which normally results in a call to the logger) gets replaced
     # with a call to our print_wrapper() function
     monkeypatch.setattr(stmt, "warning", print_wrapper)
     stmt.process_item()
     output, _ = capsys.readouterr()
     assert "Internal error when parsing CLASS statement" in output
 
 
 def test_select_case():
-    '''Test that fparser correctly recognises select case'''
+    """Test that fparser correctly recognises select case"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo
     integer :: iflag = 1
     real    :: aval = 0.0
     select case(iflag)
     case(1)
       aval = 1.0
     case default
@@ -167,84 +169,83 @@
     select   case(iflag)
     case ( 1 )
       aval = 1.0
     case  default
       aval = 0.0
     end select
     end subroutine foo
-    '''
-    tree = api.parse(source_str, isfree=True, isstrict=False,
-                     ignore_comments=True)
+    """
+    tree = api.parse(source_str, isfree=True, isstrict=False, ignore_comments=True)
     assert tree
     select_list = []
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectCase):
             select_list.append(statement)
     assert len(select_list) == 2
     for statement in select_list:
         assert isinstance(statement, fparser.one.block_statements.SelectCase)
         assert isinstance(statement.content[0], fparser.one.statements.Case)
         assert isinstance(statement.content[2], fparser.one.statements.Case)
-        assert isinstance(statement.content[3],
-                          fparser.one.statements.Assignment)
+        assert isinstance(statement.content[3], fparser.one.statements.Assignment)
     gen = str(tree)
     print(gen)
     assert "SELECT CASE ( iflag )" in gen
 
 
 @pytest.mark.xfail(reason="fparser does not work with named select statements")
 def test_named_select_case():
-    '''Test that fparser correctly recognises a named select case'''
+    """Test that fparser correctly recognises a named select case"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo
     integer :: iflag = 1
     real    :: aval = 0.0
     incase: select case(iflag)
     case(1) incase
       aval = 1.0
     case default   incase
       aval = 0.0
     end select  incase
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     select_list = []
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectCase):
             select_list.append(statement)
     assert len(select_list) == 2
     for statement in select_list:
         assert isinstance(statement, fparser.one.block_statements.SelectCase)
         assert isinstance(statement.content[0], fparser.one.statements.Case)
         assert isinstance(statement.content[2], fparser.one.statements.Case)
-        assert isinstance(statement.content[3],
-                          fparser.one.statements.Assignment)
+        assert isinstance(statement.content[3], fparser.one.statements.Assignment)
     gen = str(tree)
     print(gen)
     assert "incase: SELECT CASE ( iflag )" in gen
 
 
 def test_select_case_brackets():
-    '''Test that fparser correctly parses a select case involving
-    parentheses '''
+    """Test that fparser correctly parses a select case involving
+    parentheses"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo
     integer :: iflag(2) = 1
     real    :: aval = 0.0
     select case(iflag(1))
     case(1)
       aval = 1.0
     case default
       aval = 0.0
     end select
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     statement = None  # Keep pylint happy
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectCase):
             break
     assert isinstance(statement, fparser.one.block_statements.SelectCase)
@@ -253,17 +254,18 @@
     assert isinstance(statement.content[3], fparser.one.statements.Assignment)
     gen = str(tree)
     print(gen)
     assert "SELECT CASE ( iflag(1) )" in gen
 
 
 def test_select_type():
-    '''Test that fparser correctly recognises select type'''
+    """Test that fparser correctly recognises select type"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo(an_object)
     class(*) :: an_object
     real    :: aval = 0.0
     select type(an_object)
     type is (some_type)
       aval = 1.0
     class is (some_class)
@@ -277,92 +279,92 @@
       aval = 1.0
     class  is  ( some_class(1), some_other_class )
       aval = 0.0
     class   default
       aval = -1.0
     end select
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     select_list = []
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectType):
             select_list.append(statement)
     assert len(select_list) == 2
     for statement in select_list:
         assert isinstance(statement, fparser.one.block_statements.SelectType)
         assert isinstance(statement.content[0], fparser.one.statements.TypeIs)
         assert isinstance(statement.content[2], fparser.one.statements.ClassIs)
-        assert isinstance(statement.content[3],
-                          fparser.one.statements.Assignment)
+        assert isinstance(statement.content[3], fparser.one.statements.Assignment)
         assert isinstance(statement.content[4], fparser.one.statements.ClassIs)
     gen = str(tree)
     print(gen)
     assert "SELECT TYPE ( an_object )" in gen
     assert "TYPE IS ( some_type )" in gen
     assert "TYPE IS ( some_type(i), some_other_type )" in gen
     assert "CLASS IS ( some_class )" in gen
     assert "CLASS DEFAULT" in gen
     assert "CLASS IS ( some_class(1), some_other_class )" in gen
 
 
 def test_type_is_process_item(monkeypatch, capsys):
-    ''' Test error condition raised in TypeIs.process_item() method '''
+    """Test error condition raised in TypeIs.process_item() method"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo(an_object)
     class(*) :: an_object
     real    :: aval = 0.0
     select type(an_object)
     type is (some_type)
       aval = 1.0
     class is (some_class)
       aval = 0.0
     end select
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     statement = None  # Keeps pylint happy
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectType):
             break
     assert isinstance(statement, fparser.one.block_statements.SelectType)
     assert isinstance(statement.content[0], fparser.one.statements.TypeIs)
     typeis = statement.content[0]
     typeis.parent.name = "not_a_name"
-    monkeypatch.setattr(typeis.item, "get_line",
-                        lambda: "type is (blah): wrong_name")
+    monkeypatch.setattr(typeis.item, "get_line", lambda: "type is (blah): wrong_name")
     # Monkeypatch the typeis object so that a call to self.warning
     # (which normally results in a call to the logger) gets replaced
     # with a call to our print_wrapper() function
     monkeypatch.setattr(typeis, "warning", print_wrapper)
     typeis.process_item()
     output, _ = capsys.readouterr()
     print(output)
     assert "expected type-is-construct-name 'not_a_name' but got " in output
 
 
 def test_type_is_to_fortran():
-    ''' Test error condition raised in TypeIs.to_fortran() method '''
+    """Test error condition raised in TypeIs.to_fortran() method"""
     from fparser import api
     from fparser.common.utils import ParseError
-    source_str = '''
+
+    source_str = """
     subroutine foo(an_object)
     class(*) :: an_object
     real    :: aval = 0.0
     select type(an_object)
     type is (some_type)
       aval = 1.0
     class is (some_class)
       aval = 0.0
     end select
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     statement = None  # Keeps pylint happy
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectType):
             break
     assert isinstance(statement, fparser.one.block_statements.SelectType)
@@ -375,63 +377,64 @@
     typeis.items = None
     with pytest.raises(ParseError) as excinfo:
         _ = typeis.tofortran()
     assert "TYPE IS construct must have arguments" in str(excinfo.value)
 
 
 def test_class_is_process_item(monkeypatch, capsys):
-    ''' Test error condition raised in ClassIs.process_item() method '''
+    """Test error condition raised in ClassIs.process_item() method"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo(an_object)
     class(*) :: an_object
     real    :: aval = 0.0
     select type(an_object)
     class is (some_class)
       aval = 0.0
     class default
       aval = -1.0
     end select
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     statement = None  # Keeps pylint happy
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectType):
             break
     assert isinstance(statement, fparser.one.block_statements.SelectType)
     assert isinstance(statement.content[0], fparser.one.statements.ClassIs)
     clsis = statement.content[0]
     clsis.parent.name = "not_a_name"
-    monkeypatch.setattr(clsis.item, "get_line",
-                        lambda: "class is (blah): wrong_name")
+    monkeypatch.setattr(clsis.item, "get_line", lambda: "class is (blah): wrong_name")
     # Monkeypatch the typeis object so that a call to self.warning
     # (which normally results in a call to the logger) gets replaced
     # with a call to our print_wrapper() function
     monkeypatch.setattr(clsis, "warning", print_wrapper)
     clsis.process_item()
     output, _ = capsys.readouterr()
     print(output)
     assert "expected class-construct-name 'not_a_name' but got " in output
 
 
 def test_class_is_to_fortran():
-    ''' Test ClassIs.to_fortran() method '''
+    """Test ClassIs.to_fortran() method"""
     from fparser import api
-    source_str = '''
+
+    source_str = """
     subroutine foo(an_object)
     class(*) :: an_object
     real    :: aval = 0.0
     select type(an_object)
     class is (some_class)
       aval = 0.0
     end select
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     assert tree
     statement = None  # Keeps pylint happy
     for statement in tree.content[0].content:
         if isinstance(statement, fparser.one.block_statements.SelectType):
             break
     assert isinstance(statement, fparser.one.block_statements.SelectType)
```

### Comparing `fparser-0.0.9/src/fparser/one/typedecl_statements.py` & `fparser-0.1.0/src/fparser/one/typedecl_statements.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -63,311 +64,349 @@
 # DAMAGE.
 
 """
 Fortran type-declaration statements.
 
 """
 
-__all__ = ['Integer', 'Real', 'DoublePrecision', 'Complex', 'DoubleComplex',
-           'Character', 'Logical', 'Byte', 'TypeStmt','Class',
-           'intrinsic_type_spec', 'declaration_type_spec',
-           'Implicit']
+__all__ = [
+    "Integer",
+    "Real",
+    "DoublePrecision",
+    "Complex",
+    "DoubleComplex",
+    "Character",
+    "Logical",
+    "Byte",
+    "TypeStmt",
+    "Class",
+    "intrinsic_type_spec",
+    "declaration_type_spec",
+    "Implicit",
+]
 
 import re
 import string
-from fparser.common.base_classes import Statement, BeginStatement, EndStatement,\
-     AttributeHolder, Variable
-from fparser.common.utils import split_comma, AnalyzeError, name_re, is_entity_decl, \
-                   is_name, parse_array_spec
+from fparser.common.base_classes import (
+    Statement,
+    BeginStatement,
+    EndStatement,
+    AttributeHolder,
+    Variable,
+)
+from fparser.common.utils import (
+    split_comma,
+    AnalyzeError,
+    name_re,
+    is_entity_decl,
+    is_name,
+    parse_array_spec,
+)
 
 # Intrinsic type specification statements
 
+
 class TypeDeclarationStatement(Statement):
     """
-    <declaration-type-spec> [ [, <attr-spec>] :: ] <entity-decl-list>
-    <declaration-type-spec> = <intrinsic-type-spec>
-                              | TYPE ( <derived-type-spec> )
-                              | CLASS ( <derived-type-spec> )
-                              | CLASS ( * )
-
-    <derived-type-spec> = <type-name> [ ( <type-param-spec-list> ) ]
-    <type-param-spec> = [ <keyword> = ] <type-param-value>
-    <type-param-value> = <scalar-int-expr> | * | :
-
-    <intrinsic-type-spec> = INTEGER [<kind-selector>]
-                            | REAL [<kind-selector>]
-                            | DOUBLE PRECISION
-                            | COMPLEX [<kind-selector>]
-                            | CHARACTER [<char-selector>]
-                            | LOGICAL [<kind-selector>]
-
-    <kind-selector> = ( [ KIND = ] <scalar-int-initialization-expr> )
-    EXTENSION:
-      <kind-selector> = ( [ KIND = ] <scalar-int-initialization-expr> )
-                        | * <length>
-
-    <char-selector> = <length-selector>
-                      | ( LEN = <type-param-value>, KIND = <scalar-int-initialization-expr> )
-                      | ( <type-param-value>, [ KIND = ] <scalar-int-initialization-expr> )
-                      | ( KIND = <scalar-int-initialization-expr> [, LEN = <type-param-value>] )
-    <length-selector> = ( [ LEN = ] <type-param-value> )
-                        | * <char-length> [ , ]
-    <char-length> = ( <type-param-value> ) | <scalar-int-literal-constant>
-
-    <attr-spec> = <access-spec> | ALLOCATABLE | ASYNCHRONOUS
-                  | DIMENSION ( <array-spec> ) | EXTERNAL
-                  | INTENT ( <intent-spec> ) | INTRINSIC
-                  | <language-binding-spec> | OPTIONAL
-                  | PARAMETER | POINTER | PROTECTED | SAVE
-                  | TARGET | VALUE | VOLATILE
-    <entity-decl> = <object-name> [ ( <array-spec> ) ] [ * <char-length> ] [ <initialization> ]
-                  | <function-name> [ * <char-length> ]
-    <initialization> =  = <initialization-expr>
-                        | => NULL
-    <access-spec> = PUBLIC | PRIVATE
-    <language-binding-spec> = BIND ( C [ , NAME = <scalar-char-initialization-expr>] )
-    <array-spec> =   <explicit-shape-spec-list>
-                   | <assumed-shape-spec-list>
-                   | <deferred-shape-spec-list>
-                   | <assumed-size-spec>
-    <explicit-shape-spec> = [ <lower-bound> : ] <upper-bound>
-    <assumed-shape-spec> = [ <lower-bound> ] :
-    <deferred-shape-spec> = :
-    <assumed-size-spec> = [ <explicit-shape-spec-list> , ] [ <lower-bound> : ] *
-    <bound> = <specification-expr>
-
-    <int-literal-constant> = <digit-string> [ _ <kind-param> ]
-    <digit-string> = <digit> [ <digit> ]..
-    <kind-param> = <digit-string> | <scalar-int-constant-name>
+    Class capturing various sorts of type declaration.
+
+    ::
+
+        <declaration-type-spec> [ [, <attr-spec>] :: ] <entity-decl-list>
+        <declaration-type-spec> = <intrinsic-type-spec>
+                                  | TYPE ( <derived-type-spec> )
+                                  | CLASS ( <derived-type-spec> )
+                                  | CLASS ( * )
+
+        <derived-type-spec> = <type-name> [ ( <type-param-spec-list> ) ]
+        <type-param-spec> = [ <keyword> = ] <type-param-value>
+        <type-param-value> = <scalar-int-expr> | * | :
+
+        <intrinsic-type-spec> = INTEGER [<kind-selector>]
+                                | REAL [<kind-selector>]
+                                | DOUBLE PRECISION
+                                | COMPLEX [<kind-selector>]
+                                | CHARACTER [<char-selector>]
+                                | LOGICAL [<kind-selector>]
+
+        <kind-selector> = ( [ KIND = ] <scalar-int-initialization-expr> )
+        EXTENSION:
+          <kind-selector> = ( [ KIND = ] <scalar-int-initialization-expr> )
+                            | * <length>
+
+        <char-selector> = <length-selector>
+                          | ( LEN = <type-param-value>,
+                              KIND = <scalar-int-initialization-expr> )
+                          | ( <type-param-value>, [ KIND = ]
+                              <scalar-int-initialization-expr> )
+                          | ( KIND = <scalar-int-initialization-expr> [,
+                              LEN = <type-param-value>] )
+        <length-selector> = ( [ LEN = ] <type-param-value> )
+                            | * <char-length> [ , ]
+        <char-length> = ( <type-param-value> ) | <scalar-int-literal-constant>
+
+        <attr-spec> = <access-spec> | ALLOCATABLE | ASYNCHRONOUS
+                      | DIMENSION ( <array-spec> ) | EXTERNAL
+                      | INTENT ( <intent-spec> ) | INTRINSIC
+                      | <language-binding-spec> | OPTIONAL
+                      | PARAMETER | POINTER | PROTECTED | SAVE
+                      | TARGET | VALUE | VOLATILE
+        <entity-decl> = <object-name> [ ( <array-spec> ) ] [ * <char-length> ]
+                        [ <initialization> ]
+                      | <function-name> [ * <char-length> ]
+        <initialization> =  = <initialization-expr>
+                            | => NULL
+        <access-spec> = PUBLIC | PRIVATE
+        <language-binding-spec> = BIND ( C [ , NAME =
+                                         <scalar-char-initialization-expr>] )
+        <array-spec> =   <explicit-shape-spec-list>
+                       | <assumed-shape-spec-list>
+                       | <deferred-shape-spec-list>
+                       | <assumed-size-spec>
+        <explicit-shape-spec> = [ <lower-bound> : ] <upper-bound>
+        <assumed-shape-spec> = [ <lower-bound> ] :
+        <deferred-shape-spec> = :
+        <assumed-size-spec> = [ <explicit-shape-spec-list> , ] [ <lower-bound> : ] *
+        <bound> = <specification-expr>
+
+        <int-literal-constant> = <digit-string> [ _ <kind-param> ]
+        <digit-string> = <digit> [ <digit> ]..
+        <kind-param> = <digit-string> | <scalar-int-constant-name>
+
     """
-    _repr_attr_names = ['selector','attrspec','entity_decls'] + Statement._repr_attr_names
+
+    _repr_attr_names = [
+        "selector",
+        "attrspec",
+        "entity_decls",
+    ] + Statement._repr_attr_names
 
     def process_item(self):
         item = self.item
         apply_map = item.apply_map
         clsname = self.__class__.__name__.lower()
         line = item.get_line()
         from .block_statements import Function
 
         if not line.lower().startswith(clsname):
             i = 0
             j = 0
             for c in line:
                 i += 1
-                if c==' ': continue
+                if c == " ":
+                    continue
                 j += 1
-                if j==len(clsname):
+                if j == len(clsname):
                     break
-            line = line[:i].replace(' ','') + line[i:]
+            line = line[:i].replace(" ", "") + line[i:]
 
-        assert line.lower().startswith(clsname),repr((line,clsname))
-        line = line[len(clsname):].lstrip()
+        assert line.lower().startswith(clsname), repr((line, clsname))
+        line = line[len(clsname) :].lstrip()
 
-        if line.startswith('('):
-            i = line.find(')')
-            selector = apply_map(line[:i+1].strip())
-            line = line[i+1:].lstrip()
-        elif line.startswith('*'):
-            selector = '*'
+        if line.startswith("("):
+            i = line.find(")")
+            selector = apply_map(line[: i + 1].strip())
+            line = line[i + 1 :].lstrip()
+        elif line.startswith("*"):
+            selector = "*"
             line = line[1:].lstrip()
-            if line.startswith('('):
-                i = line.find(')')
-                selector += apply_map(line[:i+1].rstrip())
-                line = line[i+1:].lstrip()
+            if line.startswith("("):
+                i = line.find(")")
+                selector += apply_map(line[: i + 1].rstrip())
+                line = line[i + 1 :].lstrip()
             else:
-                m = re.match(r'\d+(_\w+|)|[*]',line)
+                m = re.match(r"\d+(_\w+|)|[*]", line)
                 if not m:
                     self.isvalid = False
                     return
                 i = m.end()
                 selector += line[:i].rstrip()
                 line = line[i:].lstrip()
         else:
-            selector = ''
+            selector = ""
 
         fm = Function.match(line)
         if fm:
-            l2 = line[:fm.end()]
-            m2 = re.match(r'.*?\b(?P<name>\w+)\Z',l2)
+            l2 = line[: fm.end()]
+            m2 = re.match(r".*?\b(?P<name>\w+)\Z", l2)
             if not m2:
                 self.isvalid = False
                 return
-            fname = m2.group('name')
-            fitem = item.copy(clsname+selector+' :: '+fname,
-                              apply_map=True)
+            fname = m2.group("name")
+            fitem = item.copy(clsname + selector + " :: " + fname, apply_map=True)
             self.parent.put_item(fitem)
             item.clone(line)
             self.isvalid = False
             return
 
-        if line.startswith(','):
+        if line.startswith(","):
             line = line[1:].lstrip()
 
         self.raw_selector = selector
         if isinstance(self, Character):
             self.selector = self._parse_char_selector(selector)
         else:
             self.selector = self._parse_kind_selector(selector)
 
-        i = line.find('::')
-        if i==-1:
+        i = line.find("::")
+        if i == -1:
             self.attrspec = []
             self.entity_decls = split_comma(line, self.item)
         else:
             self.attrspec = split_comma(line[:i].rstrip(), self.item)
-            self.entity_decls = split_comma(line[i+2:].lstrip(), self.item)
+            self.entity_decls = split_comma(line[i + 2 :].lstrip(), self.item)
         for entity in self.entity_decls:
             if not is_entity_decl(entity):
                 self.isvalid = False
                 return
 
-        if isinstance(self.parent, Function) \
-               and self.parent.name in self.entity_decls:
-            assert self.parent.typedecl is None,repr(self.parent.typedecl)
+        if isinstance(self.parent, Function) and self.parent.name in self.entity_decls:
+            assert self.parent.typedecl is None, repr(self.parent.typedecl)
             self.parent.typedecl = self
             self.ignore = True
         if isinstance(self, Type):
             self.name = self.selector[1].lower()
-            assert is_name(self.name),repr(self.name)
+            assert is_name(self.name), repr(self.name)
         else:
             self.name = clsname
         return
 
     def _parse_kind_selector(self, selector):
         if not selector:
-            return '',''
-        length,kind = '',''
-        if selector.startswith('*'):
+            return "", ""
+        length, kind = "", ""
+        if selector.startswith("*"):
             length = selector[1:].lstrip()
         else:
-            assert selector[0]+selector[-1]=='()',repr(selector)
+            assert selector[0] + selector[-1] == "()", repr(selector)
             l = selector[1:-1].strip()
-            if l.lower().startswith('kind'):
+            if l.lower().startswith("kind"):
                 l = l[4:].lstrip()
-                if l[0]+l[-1]=='()':
-                    kind = 'kind'+l
+                if l[0] + l[-1] == "()":
+                    kind = "kind" + l
                 else:
-                    assert l.startswith('='),repr(l)
+                    assert l.startswith("="), repr(l)
                     kind = l[1:].lstrip()
             else:
                 kind = l
-        return length,kind
+        return length, kind
 
     def _split_char_selector(self, line):
         """line=``[key=]value`` -> key, value.
         If line does not have name part then return None, value.
         """
-        for name in ['len', 'kind']:
-            if line[:len(name)].lower()==name:
-                value_part = line[len(name):].lstrip()
-                if value_part.startswith('='):
+        for name in ["len", "kind"]:
+            if line[: len(name)].lower() == name:
+                value_part = line[len(name) :].lstrip()
+                if value_part.startswith("="):
                     return name, value_part[1:].lstrip()
         return None, line
 
     def _parse_char_selector(self, selector):
         if not selector:
-            return '',''
-        if selector.startswith('*'):
+            return "", ""
+        if selector.startswith("*"):
             l = selector[1:].lstrip()
-            if l.startswith('('):
-                if l.endswith(','): l = l[:-1].rstrip()
-                assert l.endswith(')'),repr(l)
+            if l.startswith("("):
+                if l.endswith(","):
+                    l = l[:-1].rstrip()
+                assert l.endswith(")"), repr(l)
                 l = l[1:-1].strip()
-                if l.lower().startswith('len'):
+                if l.lower().startswith("len"):
                     l = l[3:].lstrip()[1:].lstrip()
-            kind=''
+            kind = ""
         else:
-            assert selector[0]+selector[-1]=='()',repr(selector)
+            assert selector[0] + selector[-1] == "()", repr(selector)
             l = split_comma(selector[1:-1].strip(), self.item)
-            if len(l)==1:
+            if len(l) == 1:
                 l = l[0]
                 key, value = self._split_char_selector(l)
-                if key=='len':
-                    kind, l = '', value
-                elif key=='kind':
-                    kind, l = value, ''
+                if key == "len":
+                    kind, l = "", value
+                elif key == "kind":
+                    kind, l = value, ""
                 else:
-                    kind = ''
+                    kind = ""
             else:
-                assert len(l)==2,repr(l)
+                assert len(l) == 2, repr(l)
                 key0, value0 = self._split_char_selector(l[0])
                 key1, value1 = self._split_char_selector(l[1])
-                if key0=='len':
-                    assert key1 in [None, 'kind'],repr(key1)
-                    l,kind = value0, value1
-                elif key0=='kind':
-                    assert key1=='len',repr(key1)
-                    l,kind = value1, value0
+                if key0 == "len":
+                    assert key1 in [None, "kind"], repr(key1)
+                    l, kind = value0, value1
+                elif key0 == "kind":
+                    assert key1 == "len", repr(key1)
+                    l, kind = value1, value0
                 else:
-                    assert key0 is None,repr(key0)
-                    assert key1 in [None,'kind'],repr(key1)
+                    assert key0 is None, repr(key0)
+                    assert key1 in [None, "kind"], repr(key1)
                     l, kind = value0, value1
-        return l,kind
+        return l, kind
 
     def tostr(self):
-        ''' Create a text representation of this object and return it '''
+        """Create a text representation of this object and return it"""
         clsname = self.__class__.__name__.upper()
-        text = ''
+        text = ""
         length, kind = self.selector
         if isinstance(self, Character):
             if length and kind:
-                text += '(LEN=%s, KIND=%s)' % (length, kind)
+                text += "(LEN=%s, KIND=%s)" % (length, kind)
             elif length:
-                text += '(LEN=%s)' % (length)
+                text += "(LEN=%s)" % (length)
             elif kind:
-                text += '(KIND=%s)' % (kind)
+                text += "(KIND=%s)" % (kind)
         elif isinstance(self, Type):
-            text += '(%s)' % (kind)
+            text += "(%s)" % (kind)
         elif isinstance(self, Class):
             if kind:
                 # For a class declaration, 'kind' is actually the class
                 # that the variable is an instance of. Therefore there
                 # is no "(KIND=xxx)", just (xxx).
                 text += "({0})".format(kind)
         else:
             if length:
-                text += '*%s' % (length)
+                text += "*%s" % (length)
             if kind:
-                text += '(KIND=%s)' % (kind)
+                text += "(KIND=%s)" % (kind)
 
         return clsname + text
 
-    def tofortran(self,isfix=None):
+    def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         s = self.tostr()
         if self.attrspec:
-            s += ', ' + ', '.join(self.attrspec)
+            s += ", " + ", ".join(self.attrspec)
         # If we were to change fparser so that it always produces the
         # '::' separator then we'd simply comment-out the if below.
-        if self.attrspec or '=' in str(self.entity_decls):
-            s += ' ::'
+        if self.attrspec or "=" in str(self.entity_decls):
+            s += " ::"
         if self.entity_decls:
-            s += ' ' + ', '.join(self.entity_decls)
+            s += " " + ", ".join(self.entity_decls)
         return tab + s
 
     def __str__(self):
         return self.tofortran()
 
     def __eq__(self, other):
         if self.__class__ is not other.__class__:
             return False
-        return self.selector==other.selector
+        return self.selector == other.selector
 
     def astypedecl(self):
         if self.entity_decls or self.attrspec:
             return self.__class__(self.parent, self.item.copy(self.tostr()))
         return self
 
     def analyze(self):
         if not self.entity_decls:
             return
         variables = self.parent.a.variables
         typedecl = self.astypedecl()
         attrspec = self.attrspec[:]
-        access_spec_lst = [a for a in attrspec if a.lower() in ['private','public']]
+        access_spec_lst = [a for a in attrspec if a.lower() in ["private", "public"]]
         if access_spec_lst:
             access_spec = access_spec_lst[0]
             attrspec.remove(access_spec)
         else:
             access_spec = None
         for item in self.entity_decls:
             name, array_spec, char_length, value = self._parse_entity(item)
@@ -378,255 +417,296 @@
             var.set_type(typedecl)
             var.update(self.attrspec)
             if array_spec:
                 var.set_bounds(array_spec)
             if value:
                 var.set_init(value)
             if access_spec is not None:
-                l = getattr(self.parent.a,access_spec.lower() + '_id_list')
+                l = getattr(self.parent.a, access_spec.lower() + "_id_list")
                 l.append(name)
             var.analyze()
         return
 
     def _parse_entity(self, line):
         m = name_re(line)
-        assert m,repr((line,self.item,self.__class__.__name__))
-        name = line[:m.end()]
-        line = line[m.end():].lstrip()
+        assert m, repr((line, self.item, self.__class__.__name__))
+        name = line[: m.end()]
+        line = line[m.end() :].lstrip()
         array_spec = None
         char_length = None
         value = None
         if line:
             item = self.item.copy(line)
             line = item.get_line()
-            if line.startswith('('):
-                i = line.find(')')
-                assert i!=-1,repr(line)
+            if line.startswith("("):
+                i = line.find(")")
+                assert i != -1, repr(line)
                 array_spec = parse_array_spec(line[1:i].strip(), item)
-                line = line[i+1:].lstrip()
+                line = line[i + 1 :].lstrip()
 
-            if line.startswith('*'):
-                i = line.find('=')
-                if i==-1:
+            if line.startswith("*"):
+                i = line.find("=")
+                if i == -1:
                     char_length = item.apply_map(line[1:].lstrip())
-                    line = ''
+                    line = ""
                 else:
                     char_length = item.apply_map(line[1:i].strip())
                     line = line[i:]
-            if line.startswith('='):
+            if line.startswith("="):
                 value = item.apply_map(line[1:].lstrip())
         return name, array_spec, char_length, value
 
     def get_zero_value(self):
         raise NotImplementedError(repr(self.__class__.__name__))
 
     def assign_expression(self, name, value):
-        return '%s = %s' % (name, value)
+        return "%s = %s" % (name, value)
 
     def get_kind(self):
         return self.selector[1] or self.default_kind
 
     def get_length(self):
         return self.selector[0] or 1
 
     def get_byte_size(self):
         length, kind = self.selector
-        if length: return int(length)
-        if kind: return int(kind)
+        if length:
+            return int(length)
+        if kind:
+            return int(kind)
         return self.default_kind
 
-    def is_intrinsic(self): return not isinstance(self,(Type,Class))
-    def is_derived(self): return isinstance(self,Type)
+    def is_intrinsic(self):
+        return not isinstance(self, (Type, Class))
 
-    def is_numeric(self): return isinstance(self,(Integer,Real, DoublePrecision,Complex,DoubleComplex,Byte))
-    def is_nonnumeric(self): return isinstance(self,(Character,Logical))
+    def is_derived(self):
+        return isinstance(self, Type)
+
+    def is_numeric(self):
+        return isinstance(
+            self, (Integer, Real, DoublePrecision, Complex, DoubleComplex, Byte)
+        )
+
+    def is_nonnumeric(self):
+        return isinstance(self, (Character, Logical))
 
 
 class Integer(TypeDeclarationStatement):
-    match = re.compile(r'integer\b',re.I).match
+    match = re.compile(r"integer\b", re.I).match
     default_kind = 4
 
     def get_zero_value(self):
         kind = self.get_kind()
-        if kind==self.default_kind: return '0'
-        return '0_%s' % (kind)
+        if kind == self.default_kind:
+            return "0"
+        return "0_%s" % (kind)
+
 
 class Real(TypeDeclarationStatement):
-    match = re.compile(r'real\b',re.I).match
+    match = re.compile(r"real\b", re.I).match
     default_kind = 4
 
     def get_zero_value(self):
         kind = self.get_kind()
-        if kind==self.default_kind: return '0.0'
-        return '0_%s' % (kind)
+        if kind == self.default_kind:
+            return "0.0"
+        return "0_%s" % (kind)
+
 
 class DoublePrecision(TypeDeclarationStatement):
-    match = re.compile(r'double\s*precision\b',re.I).match
+    match = re.compile(r"double\s*precision\b", re.I).match
     default_kind = 8
 
     def get_byte_size(self):
         return self.default_kind
 
     def get_zero_value(self):
-        return '0.0D0'
+        return "0.0D0"
+
 
 class Complex(TypeDeclarationStatement):
-    match = re.compile(r'complex\b',re.I).match
+    match = re.compile(r"complex\b", re.I).match
     default_kind = 4
 
     def get_byte_size(self):
         length, kind = self.selector
-        if length: return int(length)
-        if kind: return 2*int(kind)
-        return 2*self.default_kind
+        if length:
+            return int(length)
+        if kind:
+            return 2 * int(kind)
+        return 2 * self.default_kind
 
     def get_zero_value(self):
         kind = self.get_kind()
-        if kind==self.default_kind: return '(0.0, 0.0)'
-        return '(0.0_%s, 0.0_%s)' % (kind, kind)
+        if kind == self.default_kind:
+            return "(0.0, 0.0)"
+        return "(0.0_%s, 0.0_%s)" % (kind, kind)
 
     def get_part_typedecl(self):
-        bz = self.get_byte_size()/2
-        return Real(self.parent, self.item.copy('REAL*%s' % (bz)))
+        bz = self.get_byte_size() / 2
+        return Real(self.parent, self.item.copy("REAL*%s" % (bz)))
+
 
 class DoubleComplex(TypeDeclarationStatement):
     # not in standard
-    match = re.compile(r'double\s*complex\b',re.I).match
+    match = re.compile(r"double\s*complex\b", re.I).match
     default_kind = 8
 
     def get_byte_size(self):
-        return 2*self.default_kind
+        return 2 * self.default_kind
 
     def get_zero_value(self):
-        return '(0.0D0,0.0D0)'
+        return "(0.0D0,0.0D0)"
+
 
 class Logical(TypeDeclarationStatement):
-    match = re.compile(r'logical\b',re.I).match
+    match = re.compile(r"logical\b", re.I).match
     default_kind = 4
 
     def get_zero_value(self):
         return ".FALSE."
 
+
 class Character(TypeDeclarationStatement):
-    match = re.compile(r'character\b',re.I).match
+    match = re.compile(r"character\b", re.I).match
     default_kind = 1
 
     def get_zero_value(self):
         return "''"
 
+
 class Byte(TypeDeclarationStatement):
     # not in standard
-    match = re.compile(r'byte\b',re.I).match
+    match = re.compile(r"byte\b", re.I).match
     default_kind = 1
 
     def get_zero_value(self):
-        return '0'
+        return "0"
+
 
 class Type(TypeDeclarationStatement):
-    match = re.compile(r'type\s*\(', re.I).match
+    match = re.compile(r"type\s*\(", re.I).match
 
     def get_zero_value(self):
         type_decl = self.get_type_decl(self.name)
         component_names = type_decl.a.component_names
         components = type_decl.a.components
         l = []
         for name in component_names:
             var = components[name]
             l.append(var.typedecl.get_zero_value())
-        return '%s(%s)' % (type_decl.name, ', '.join(l))
+        return "%s(%s)" % (type_decl.name, ", ".join(l))
 
     def get_kind(self):
         # See 4.5.2, page 48
         raise NotImplementedError(repr(self.__class__.__name__))
 
+
 TypeStmt = Type
 
+
 class Class(TypeDeclarationStatement):
-    match = re.compile(r'class\s*\(', re.I).match
+    match = re.compile(r"class\s*\(", re.I).match
+
 
 class Implicit(Statement):
     """
-    IMPLICIT <implicit-spec-list>
-    IMPLICIT NONE
-    <implicit-spec> = <declaration-type-spec> ( <letter-spec-list> )
-    <letter-spec> = <letter> [ - <letter> ]
+    Class capturing various forms of IMPLICIT statement.
+
+    ::
+
+        IMPLICIT <implicit-spec-list>
+        IMPLICIT NONE
+        <implicit-spec> = <declaration-type-spec> ( <letter-spec-list> )
+        <letter-spec> = <letter> [ - <letter> ]
+
     """
-    match = re.compile(r'implicit\b',re.I).match
+
+    match = re.compile(r"implicit\b", re.I).match
 
     letters = string.ascii_lowercase
 
     def process_item(self):
         line = self.item.get_line()[8:].lstrip()
-        if line.lower()=='none':
+        if line.lower() == "none":
             self.items = []
             return
         items = []
         for item in split_comma(line, self.item):
-            i = item.find('(')
-            assert i!=-1 and item.endswith(')'),repr(item)
+            i = item.find("(")
+            assert i != -1 and item.endswith(")"), repr(item)
             specs = []
-            for spec in split_comma(item[i+1:-1].strip(), self.item):
-                if '-' in spec:
-                    s,e = spec.lower().split('-')
+            for spec in split_comma(item[i + 1 : -1].strip(), self.item):
+                if "-" in spec:
+                    s, e = spec.lower().split("-")
                     s = s.strip()
                     e = e.strip()
-                    assert s in self.letters and e in self.letters,repr((s,e))
+                    assert s in self.letters and e in self.letters, repr((s, e))
                 else:
                     e = s = spec.lower().strip()
-                    assert s in self.letters,repr((s,e))
-                specs.append((s,e))
+                    assert s in self.letters, repr((s, e))
+                specs.append((s, e))
             tspec = item[:i].rstrip()
             stmt = None
             for cls in declaration_type_spec:
                 if cls.match(tspec):
                     stmt = cls(self, self.item.copy(tspec))
                     if stmt.isvalid:
                         break
-            assert stmt is not None,repr((item,line))
-            items.append((stmt,specs))
+            assert stmt is not None, repr((item, line))
+            items.append((stmt, specs))
         self.items = items
         return
 
     def tofortran(self, isfix=None):
         tab = self.get_indent_tab(isfix=isfix)
         if not self.items:
-            return tab + 'IMPLICIT NONE'
+            return tab + "IMPLICIT NONE"
         l = []
-        for stmt,specs in self.items:
+        for stmt, specs in self.items:
             l1 = []
-            for s,e in specs:
-                if s==e:
+            for s, e in specs:
+                if s == e:
                     l1.append(s)
                 else:
-                    l1.append(s + '-' + e)
-            l.append('%s ( %s )' % (stmt.tostr(), ', '.join(l1)))
-        return tab + 'IMPLICIT ' + ', '.join(l)
+                    l1.append(s + "-" + e)
+            l.append("%s ( %s )" % (stmt.tostr(), ", ".join(l1)))
+        return tab + "IMPLICIT " + ", ".join(l)
 
     def analyze(self):
-        '''
+        """
         Analyze the Implicit statments constructed by the parser and
         set-up the associated implicit_rules belonging to the parent
         of this object in the AST.
-        '''
+        """
         implicit_rules = self.parent.a.implicit_rules
         if not self.items:
             if implicit_rules:
-                self.warning('overriding previously set implicit rule mapping'\
-                      ' %r.' % (implicit_rules))
+                self.warning(
+                    "overriding previously set implicit rule mapping"
+                    " %r." % (implicit_rules)
+                )
             self.parent.a.implicit_rules = None
             return
         if implicit_rules is None:
-            self.warning('overriding previously set IMPLICIT NONE')
+            self.warning("overriding previously set IMPLICIT NONE")
             self.parent.a.implicit_rules = implicit_rules = {}
         for stmt, specs in self.items:
             for start, end in specs:
                 start_idx = string.ascii_lowercase.index(start.lower())
                 end_idx = string.ascii_lowercase.index(end.lower())
-                for lchar in string.ascii_lowercase[start_idx:end_idx+1]:
+                for lchar in string.ascii_lowercase[start_idx : end_idx + 1]:
                     implicit_rules[lchar] = stmt
         return
 
-intrinsic_type_spec = [ \
-    Integer , Real,
-    DoublePrecision, Complex, DoubleComplex, Character, Logical, Byte
-    ]
-declaration_type_spec = intrinsic_type_spec + [ TypeStmt, Class ]
+
+intrinsic_type_spec = [
+    Integer,
+    Real,
+    DoublePrecision,
+    Complex,
+    DoubleComplex,
+    Character,
+    Logical,
+    Byte,
+]
+declaration_type_spec = intrinsic_type_spec + [TypeStmt, Class]
```

### Comparing `fparser-0.0.9/src/fparser/scripts/fparser2.py` & `fparser-0.1.0/src/fparser/scripts/fparser2.py`

 * *Files 6% similar despite different names*

```diff
@@ -60,77 +60,66 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-''' Example script to parse a Fortran program using fparser '''
-from __future__ import print_function
+""" Example script to parse a Fortran program using fparser """
+
 import logging
+import sys
 from fparser.scripts.script_options import set_fparser_options
 
 logging.basicConfig()
 
 try:
     from iocbio.optparse_gui import OptionParser
 except ImportError:
     from optparse import OptionParser
 
 
 def runner(_, options, args):
-    '''
+    """
     Function to read, parse and output Fortran source code.
 
     :param options: object constructed by OptionParser with cmd-line flags.
     :param args: list of Fortran files to parse.
     :type args: list of str
 
-    '''
-    import six
+    """
     from fparser.two.parser import ParserFactory
     from fparser.two.Fortran2003 import FortranSyntaxError, InternalError
     from fparser.common.readfortran import FortranFileReader
+
     if not args:
-        print("Error: No fortran files specified")
+        print("Error: No fortran files specified", file=sys.stderr)
         raise SystemExit(1)
     for filename in args:
+        print("File: '{0}'".format(filename), file=sys.stderr)
         try:
-            reader = FortranFileReader(filename,
-                                       ignore_comments=False)
+            reader = FortranFileReader(filename, ignore_comments=False)
         except IOError as error:
-            print(error)
-            return
-        if options.mode != 'auto':
-            reader.format.from_mode(options.mode)
+            print(error, file=sys.stderr)
+            continue
         try:
-            f2003_parser = ParserFactory().create()
-            program = f2003_parser(reader)
+            fparser = ParserFactory().create(std=options.std)
+            program = fparser(reader)
             if options.task == "show":
-                print(six.text_type(program))
+                print(str(program))
             if options.task == "repr":
                 print(repr(program))
         except FortranSyntaxError as msg:
-            print("Syntax error: {0}".format(six.text_type(msg)))
-            try:
-                # protect the access to fifo_item[-1] in case the fifo
-                # buffer is empty
-                print('parsing %r failed at %s' % (filename,
-                                                   reader.fifo_item[-1]))
-                print('started at %s' % (reader.fifo_item[0]))
-            except IndexError:
-                pass
-            raise SystemExit(1)
+            print(f"Syntax error: {msg}", file=sys.stderr)
         except InternalError as msg:
-            print("Internal error in fparser: {0}".format(six.text_type(msg)))
-            raise SystemExit(1)
+            print(f"Internal error in fparser: {msg}", file=sys.stderr)
 
 
 def main():
-    ''' Check arguments before parsing code '''
+    """Check arguments before parsing code"""
     parser = OptionParser()
     set_fparser_options(parser)
     options, args = parser.parse_args()
     runner(parser, options, args)
 
 
 if __name__ == "__main__":
```

### Comparing `fparser-0.0.9/src/fparser/scripts/parse.py` & `fparser-0.1.0/src/fparser/scripts/parse.py`

 * *Files 6% similar despite different names*

```diff
@@ -59,15 +59,14 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-from __future__ import print_function
 import logging
 from fparser.scripts.script_options import set_parse_options
 import fparser.common.sourceinfo
 
 logging.basicConfig()
 
 # START UPDATE SYS.PATH ###
@@ -77,35 +76,35 @@
 except ImportError:
     from optparse import OptionParser
 
 
 def runner(parser, options, args):
     from fparser.common.readfortran import FortranFileReader
     from fparser.one.parsefortran import FortranParser
+
     for filename in args:
         reader = FortranFileReader(filename)
-        if options.mode != 'auto':
-            mode = fparser.common.sourceinfo\
-                   .FortranFormat.from_mode(options.mode)
+        if options.mode != "auto":
+            mode = fparser.common.sourceinfo.FortranFormat.from_mode(options.mode)
             reader.format.set_mode(mode)
         parser = FortranParser(reader)
         parser.parse()
         parser.analyze()
-        if options.task == 'show':
+        if options.task == "show":
             print(parser.block.torepr(4))
-        elif options.task == 'none':
+        elif options.task == "none":
             pass
         else:
             raise NotImplementedError(repr(options.task))
 
 
 def main():
     parser = OptionParser()
     set_parse_options(parser)
-    if hasattr(parser, 'runner'):
+    if hasattr(parser, "runner"):
         parser.runner = runner
     options, args = parser.parse_args()
     runner(parser, options, args)
     return
 
 
 if __name__ == "__main__":
```

### Comparing `fparser-0.0.9/src/fparser/scripts/read.py` & `fparser-0.1.0/src/fparser/scripts/read.py`

 * *Files 2% similar despite different names*

```diff
@@ -60,61 +60,62 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-'''Python script with command line options which calls the Fortran
+"""Python script with command line options which calls the Fortran
 File Reader with the supplied filename(s) and outputs the reader's
 representation of the code(s).
 
-'''
-from __future__ import print_function
+"""
 import sys
 import logging
 from fparser.scripts.script_options import set_read_options
 
 logging.basicConfig()
 
 try:
     from iocbio.optparse_gui import OptionParser
 except ImportError:
     from optparse import OptionParser
 
 
 def runner(_, options, args):
-    '''Call the Fortran File reader for each filename in args and print
+    """Call the Fortran File reader for each filename in args and print
     out its content.
 
     :param options: command line argument information from the options \
     parser
     :type options: :py:class:`optparse.Values`
     :param args: a list of Fortran filepaths
     :type args: list of str
 
     :raises NotImplementedError: if the task option is not set to \
     "show".
 
-    '''
+    """
     from fparser.common.readfortran import FortranFileReader
+
     for filename in args:
         reader = FortranFileReader(filename)
-        if options.task == 'show':
+        if options.task == "show":
             for item in reader:
                 print(item)
                 sys.stdout.flush()
         else:
             raise NotImplementedError(
                 "The task option '{0}' is invalid. Currently only "
-                "'show' is supported.".format(repr(options.task)))
+                "'show' is supported.".format(repr(options.task))
+            )
 
 
 def main():
-    '''Check input options then call the runner function.'''
+    """Check input options then call the runner function."""
     parser = OptionParser()
     set_read_options(parser)
     options, args = parser.parse_args()
     runner(parser, options, args)
 
 
 if __name__ == "__main__":
```

### Comparing `fparser-0.0.9/src/fparser/scripts/script_options.py` & `fparser-0.1.0/src/fparser/tests/test_comment.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -58,71 +59,114 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-__all__ = ['set_read_options', 'set_parse_options',
-           'get_fortran_code_group']
-from optparse import OptionGroup, NO_DEFAULT
-
-def set_read_options(parser):
-    parser.set_usage('''\
-%prog [options] <Fortran files>
-
-Description:
-  %prog reads Fortran codes.''')
-    parser.add_option('--task',
-                      default = 'show',
-                      choices = ['show'],
-                      help = 'Specify reading task. Default: %default.'
-                      )
-    parser.add_option_group(get_fortran_code_group(parser))
-
-def set_parse_options(parser):
-    parser.set_usage('''\
-%prog [options] <Fortran files>
-
-Description:
-  %prog parses Fortran codes.''')
-    parser.add_option('--task',
-                      default = 'show',
-                      choices = ['show', 'none'],
-                      help = 'Specify parsing result task. Default: %default.'
-                      )
-    parser.add_option_group(get_fortran_code_group(parser))
-
-def set_fparser_options(parser):
-    ''' Command line options used by the fparser2 script.
-
-    :param parser: The OptionParser object.
-    :type parser: :py:class:`optparse.OptionParser`
-
-    '''
-
-    parser.set_usage('''\
-%prog [options] <Fortran files>
-
-Description:
-  %prog parses Fortran code.''')
-    parser.add_option('--task',
-                      default='show',
-                      choices=['show', 'repr', 'none'],
-                      help='Specify parsing result task. Default: %default.'
-                      )
-    parser.add_option('--std',
-                      default = 'f2003',
-                      choices = ['f2003', 'f2008'],
-                      help = 'Specify the Fortran standard to use. Default: %default.'
-                      )
-    parser.add_option_group(get_fortran_code_group(parser))
-    
-def get_fortran_code_group(parser):
-    group = OptionGroup (parser, 'Fortran code options',
-                         description = 'Specify information about Fortran codes.')
-    group.add_option('--mode',
-                      default = 'auto',
-                      choices = ['auto', 'free', 'fix', 'f77', 'pyf'],
-                      help = 'Specify Fortran code mode. Default: %default.'
-                      )
-    return group
+from fparser.api import parse
+
+
+def test_comment_lines():
+    source_str = """\
+  !comment line 1
+
+!comment line 2
+module foo
+!comment line 3
+subroutine f
+!comment line 4
+end subroutine f !comment line 5
+end module foo
+    """
+    tree = parse(source_str, isfree=True, isstrict=False, ignore_comments=False)
+    expected = """
+!BEGINSOURCE <cStringIO.StringI object at 0x1518de0> mode=free90
+  !comment line 1
+
+  !comment line 2
+  MODULE foo
+    !comment line 3
+    SUBROUTINE f()
+      !comment line 4
+    END SUBROUTINE f
+    !comment line 5
+  END MODULE foo
+"""
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
+
+    expected = """
+C      BEGINSOURCE <cStringIO.StringI object at 0x1630de0> mode=free90
+C       comment line 1
+
+C       comment line 2
+        MODULE foo
+C         comment line 3
+          SUBROUTINE f()
+C           comment line 4
+          END SUBROUTINE f
+C         comment line 5
+        END MODULE foo
+"""
+    assert tree.asfix().strip().split("\n")[1:] == expected.strip().split("\n")[1:]
+
+
+def test_labels():
+    source_str = """\
+subroutine foo
+  real a
+! Valid code:
+100 a = 3
+  l: do
+  end do l
+200 &! haa
+   a=4
+300 l1: do
+  end do l1
+end subroutine foo
+"""
+    tree = parse(source_str, isfree=True, isstrict=False, ignore_comments=False)
+    expected = """
+!BEGINSOURCE <cStringIO.StringI object at 0x2952e70> mode=free90
+  SUBROUTINE foo()
+    REAL a
+    ! Valid code:
+100 a = 3
+    l: DO
+    END DO l
+200 a = 4
+    ! haa
+300 l1: DO
+    END DO l1
+  END SUBROUTINE foo
+"""
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
+
+    source_str = """\
+      subroutine foo
+      real a
+      ! Valid code:
+  100 a = 3
+      l: do
+      end do l
+  200 ! haa
+     &a=4
+  300 l1: do
+      end do l1
+      end subroutine foo
+"""
+    tree = parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+!      BEGINSOURCE <cStringIO.StringI object at 0x1d3b390> mode=fix90
+        SUBROUTINE foo()
+          REAL a
+          ! Valid code:
+ 100      a = 3
+          l: DO
+          END DO l
+ 200      a = 4
+          ! haa
+ 300      l1: DO
+          END DO l1
+        END SUBROUTINE foo
+"""
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_api.py` & `fparser-0.1.0/src/fparser/tests/test_api.py`

 * *Files 13% similar despite different names*

```diff
@@ -66,68 +66,69 @@
 """
 Test parsing of whole fortran files; 'blackbox' tests here.
 """
 
 from os.path import join, dirname
 from fparser import api
 
-SOURCE_STR = '''\
+SOURCE_STR = """\
     ! before foo
     subroutine foo
     integer i, r
     do i = 1,100
       r = r + 1
     end do
     ! after end do
     end subroutine foo
-    '''
+    """
 
 
 def test_use_module():
-    '''
+    """
     Test that we parse a function that uses a module when we supply the
     latter via the `source_only` argument.
-    '''
+    """
     cwd = dirname(__file__)
-    sources = [join(cwd, 'modfile.f95'), join(cwd, 'funcfile.f95')]
+    sources = [join(cwd, "modfile.f95"), join(cwd, "funcfile.f95")]
     file_to_parse = sources[1]
-    _ = api.parse(file_to_parse, isfree=True, isstrict=False,
-                  source_only=sources)
+    _ = api.parse(file_to_parse, isfree=True, isstrict=False, source_only=sources)
 
 
 def test_dimension_attr():
-    '''
+    """
     Tests for parsing the `dimension` attribute of variable declarations.
-    '''
-    source_str = ("    subroutine foo\n"
-                  "    integer, dimension( -10 : 10, -   2147483648 : "
-                  "2147483648) :: a( -2 : 2, 1000000 : 1000001 )\n"
-                  "    real, dimension(-20:20, 100:113, -  512  : 713) :: b\n"
-                  "    end\n")
+    """
+    source_str = (
+        "    subroutine foo\n"
+        "    integer, dimension( -10 : 10, -   2147483648 : "
+        "2147483648) :: a( -2 : 2, 1000000 : 1000001 )\n"
+        "    real, dimension(-20:20, 100:113, -  512  : 713) :: b\n"
+        "    end\n"
+    )
     tree = api.parse(source_str, isfree=True, isstrict=False)
-    subr = tree.a.external_subprogram['foo']
-    avar = subr.a.variables['a']
+    subr = tree.a.external_subprogram["foo"]
+    avar = subr.a.variables["a"]
 
-    assert avar.dimension == [('-10', '10'), ('-   2147483648', '2147483648')]
-    assert avar.bounds == [('-2', '2'), ('1000000', '1000001')]
-    assert avar.shape == ['5', '2']
+    assert avar.dimension == [("-10", "10"), ("-   2147483648", "2147483648")]
+    assert avar.bounds == [("-2", "2"), ("1000000", "1000001")]
+    assert avar.shape == ["5", "2"]
 
-    bvar = subr.a.variables['b']
+    bvar = subr.a.variables["b"]
 
-    assert bvar.dimension == [('-20', '20'), ('100', '113'), ('-  512', '713')]
-    assert bvar.shape == ['41', '14', '1226']
+    assert bvar.dimension == [("-20", "20"), ("100", "113"), ("-  512", "713")]
+    assert bvar.shape == ["41", "14", "1226"]
 
 
 def test_provides():
-    '''
+    """
     Tests for non-Fortran (f2py markup) module_provides and use_provides
     key words. This is a legacy feature that is due to fparser's origins
     in the f2py project (https://docs.scipy.org/doc/numpy/f2py/).
-    '''
-    source_str = '''
+    """
+    source_str = """
     module mod1
     implicit none
     integer, parameter :: GP = 6
     integer :: a,b,c,d,e
     ! module_provides = {GP,a,b,c,d,e}
     ! use_provides = {}
     end module mod1
@@ -172,48 +173,55 @@
     module mod6
     use mod5, qgp => lgp
     implicit none
     ! module_provides = {}
     ! use_provides = {FP, dummy, a2, b2, qgp, a, b, e}
     end module mod6
 
-      '''
+      """
 
     tree = api.parse(source_str, isfree=True, isstrict=False)
-    mod5 = tree.a.module['mod5']
-    mod6 = tree.a.module['mod6']
-    assert list(mod5.a.module_provides.keys()).sort() == ['fp', 'dummy'].sort()
-    assert list(mod5.a.use_provides.keys()).sort() == \
-        ['a', 'b', 'e', 'a2', 'b2', 'lgp'].sort()
+    mod5 = tree.a.module["mod5"]
+    mod6 = tree.a.module["mod6"]
+    assert list(mod5.a.module_provides.keys()).sort() == ["fp", "dummy"].sort()
+    assert (
+        list(mod5.a.use_provides.keys()).sort()
+        == ["a", "b", "e", "a2", "b2", "lgp"].sort()
+    )
     assert list(mod6.a.module_provides.keys()) == []
-    assert list(mod6.a.use_provides.keys()).sort() == \
-        ['fp', 'dummy', 'b', 'e', 'qgp', 'a2', 'a', 'b2'].sort()
-    assert mod6.a.use_provides['qgp'].name == 'gp'
+    assert (
+        list(mod6.a.use_provides.keys()).sort()
+        == ["fp", "dummy", "b", "e", "qgp", "a2", "a", "b2"].sort()
+    )
+    assert mod6.a.use_provides["qgp"].name == "gp"
 
 
 def test_walk():
-    '''
+    """
     Test the walk() method of the api module.
-    '''
-    tree = api.parse(SOURCE_STR, isfree=True, isstrict=False,
-                     ignore_comments=False)
+    """
+    tree = api.parse(SOURCE_STR, isfree=True, isstrict=False, ignore_comments=False)
     for stmt, depth in api.walk(tree, 1):
         print(depth, stmt.item)
 
 
 def test_caching():
-    ''' Tests relating to enabling/disabling of parser cache. '''
-    tree1 = api.parse(SOURCE_STR, isfree=True, isstrict=False,
-                      ignore_comments=False)
+    """Tests relating to enabling/disabling of parser cache."""
+    tree1 = api.parse(SOURCE_STR, isfree=True, isstrict=False, ignore_comments=False)
     # If we keep the cache from the last call to parse then we
     # should get the same object back
-    tree2 = api.parse(SOURCE_STR, isfree=True, isstrict=False,
-                      ignore_comments=False, clear_cache=False)
+    tree2 = api.parse(
+        SOURCE_STR,
+        isfree=True,
+        isstrict=False,
+        ignore_comments=False,
+        clear_cache=False,
+    )
     assert tree1 is tree2
     # Now wipe the cache and check that we get a new object
-    tree2 = api.parse(SOURCE_STR, isfree=True, isstrict=False,
-                      ignore_comments=False, clear_cache=True)
+    tree2 = api.parse(
+        SOURCE_STR, isfree=True, isstrict=False, ignore_comments=False, clear_cache=True
+    )
     assert tree1 is not tree2
     # Check that wiping the cache is the default behaviour
-    tree3 = api.parse(SOURCE_STR, isfree=True, isstrict=False,
-                      ignore_comments=False)
+    tree3 = api.parse(SOURCE_STR, isfree=True, isstrict=False, ignore_comments=False)
     assert tree3 is not tree2
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_blank_lines.py` & `fparser-0.1.0/src/fparser/tests/test_blank_lines.py`

 * *Files 3% similar despite different names*

```diff
@@ -60,16 +60,17 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
+    source_str = """\
       subroutine bl(a,
      &b,
 
      &c)
       integer a, b, c
 
       a = b + c
@@ -87,21 +88,22 @@
 
 c a third annoying comment
      &e)
 
       a = b + c + d + e
 
       end subroutine blc
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=True,
-                     analyze=False, ignore_comments=True)
-    print(tree)
-    assert str(tree).strip().split('\n')[1:] == '''
+"""
+    tree = api.parse(
+        source_str, isfree=False, isstrict=True, analyze=False, ignore_comments=True
+    )
+    expected = """
       !      BEGINSOURCE <cStringIO.StringI object at 0x3723710> mode=f77
         SUBROUTINE bl(a, b, c)
           INTEGER a, b, c
           a = b + c
         END SUBROUTINE bl
         SUBROUTINE blc(a, b, c, d, e)
           a = b + c + d + e
         END SUBROUTINE blc
-    '''.strip().split('\n')[1:]
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_comment.py` & `fparser-0.1.0/src/fparser/tests/test_issue8.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,9 +1,8 @@
-# Modified work Copyright (c) 2017-2018 Science and Technology
-# Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -59,112 +58,134 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-from fparser.api import parse
+from fparser import api
 
-def test_comment_lines():
-    source_str = '''\
-  !comment line 1
-
-!comment line 2
-module foo
-!comment line 3
-subroutine f
-!comment line 4
-end subroutine f !comment line 5
-end module foo
-    '''
-    tree = parse(source_str, isfree=True, isstrict=False,
-                 ignore_comments=False)
-
-    assert str(tree).strip().split('\n')[1:] == '''
-!BEGINSOURCE <cStringIO.StringI object at 0x1518de0> mode=free90
-  !comment line 1
-
-  !comment line 2
-  MODULE foo
-    !comment line 3
-    SUBROUTINE f()
-      !comment line 4
-    END SUBROUTINE f
-    !comment line 5
-  END MODULE foo
-'''.strip().split('\n')[1:]
-
-    assert tree.asfix().strip().split('\n')[1:]=='''
-C      BEGINSOURCE <cStringIO.StringI object at 0x1630de0> mode=free90
-C       comment line 1
-
-C       comment line 2
-        MODULE foo
-C         comment line 3
-          SUBROUTINE f()
-C           comment line 4
-          END SUBROUTINE f
-C         comment line 5
-        END MODULE foo
-'''.strip().split('\n')[1:]
-
-def test_labels():
-    source_str = '''\
-subroutine foo
-  real a
-! Valid code:
-100 a = 3
-  l: do
-  end do l
-200 &! haa
-   a=4
-300 l1: do
-  end do l1
-end subroutine foo
-'''
-    tree = parse(source_str, isfree=True, isstrict=False,
-                 ignore_comments=False)
-    assert str(tree).strip().split('\n')[1:]=='''
-!BEGINSOURCE <cStringIO.StringI object at 0x2952e70> mode=free90
-  SUBROUTINE foo()
-    REAL a
-    ! Valid code:
-100 a = 3
-    l: DO
-    END DO l
-200 a = 4
-    ! haa
-300 l1: DO
-    END DO l1
-  END SUBROUTINE foo
-'''.strip().split('\n')[1:]
-
-    source_str = '''\
-      subroutine foo
-      real a
-      ! Valid code:
-  100 a = 3
-      l: do
-      end do l
-  200 ! haa
-     &a=4
-  300 l1: do
-      end do l1
-      end subroutine foo
-'''
-    tree = parse(source_str, isfree=False, isstrict=False,
-                 ignore_comments=False)
-    assert str(tree).strip().split('\n')[1:]=='''
-!      BEGINSOURCE <cStringIO.StringI object at 0x1d3b390> mode=fix90
-        SUBROUTINE foo()
-          REAL a
-          ! Valid code:
- 100      a = 3
-          l: DO
-          END DO l
- 200      a = 4
-          ! haa
- 300      l1: DO
-          END DO l1
-        END SUBROUTINE foo
-'''.strip().split('\n')[1:]
+
+def test_reproduce_issue():
+    source_str = """\
+      subroutine gwinput_v2x(ifi,konf,ncore)
+      integer :: ifi, !File handle. Write
+     &  konf(0:lmxamx,nclass),! Principle
+                              ! For examp
+                              ! Core orbi
+                              !   1, 2,..
+                              !   2, 3,..
+                              !   3, 4,..
+                              !
+     &  ncore(nclass)   ! ncore = \sum_l 
+                        ! Number of diffe
+      end
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0x1e52ea0> mode=fix90
+        SUBROUTINE gwinput_v2x(ifi, konf, ncore)
+          INTEGER ifi, konf(0:lmxamx,nclass), ncore(nclass)
+          !File handle. Write
+          ! Principle
+          ! For examp
+          ! Core orbi
+          !   1, 2,..
+          !   2, 3,..
+          !   3, 4,..
+          !
+          ! ncore = \sum_l
+          ! Number of diffe
+        END SUBROUTINE gwinput_v2x
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
+
+
+def test_Issue_r25_1():
+    source_str = """
+      subroutine bndfp()
+      logical:: mlog
+c test abb
+c
+#1232       
+!
+
+c
+cabi
+      real(8):: abc,a(5),
+     &  abcx  !hhhh1
+      abc=3   !hhhh2
+      do i=1,5
+         a(i)=i
+      enddo
+!
+
+!
+      end
+    """
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0xb52b40> mode=fix90
+
+        SUBROUTINE bndfp()
+          LOGICAL mlog
+          ! test abb
+          !
+          !1232
+          !
+
+          !
+          !abi
+          REAL(KIND=8) abc, a(5), abcx
+          !hhhh1
+          abc = 3
+          !hhhh2
+          DO  i=1,5
+            a(i) = i
+          END DO 
+          !
+
+          !
+        END SUBROUTINE bndfp
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
+
+
+def test_Issue_r25_1():
+    source_str = """
+      subroutine rsedit()
+        print 311
+  311   format(/
+     .  t4,'read [fn]',t15,
+
+     .  t14,'  Third argument = flip: exchange n+, n- ')
+      end
+
+    """
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0x121bab0> mode=fix90
+
+        SUBROUTINE rsedit()
+          PRINT 311
+ 311      FORMAT (/  t4, 'read [fn]', t15, t14, '  Third argument = flip: exchange n+, n- ')
+
+        END SUBROUTINE rsedit
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
+
+
+def test_comment_4():
+    source_str = """
+      subroutine m_struc_def()
+ !abc test
+      end
+    """
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0x121aa80> mode=fix90
+
+        SUBROUTINE m_struc_def()
+          !abc test
+        END SUBROUTINE m_struc_def
+"""
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_f90comment_f77source.py` & `fparser-0.1.0/src/fparser/tests/test_issue9.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,20 +60,33 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
-      subroutine foobar()
-!#here's a f90 comment starting at 0
-      end
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=True,
-            analyze=False)
-    assert str(tree).strip().split('\n')[1:] == '''
-      !      BEGINSOURCE <cStringIO.StringI object at 0x3721710> mode=f77
-        SUBROUTINE foobar()
-        END SUBROUTINE foobar
-        '''.strip().split('\n')[1:]
+    source_str = """\
+      module m_rdctrl
+
+      contains
+      
+      subroutine readctrl(prgn,vstrn,vn)
+
+      end subroutine readctrl
+      end module
+      
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0x2405ea0> mode=fix90
+        MODULE m_rdctrl
+
+          CONTAINS
+
+          SUBROUTINE readctrl(prgn, vstrn, vn)
+
+          END SUBROUTINE readctrl
+        END MODULE m_rdctrl
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_functional.py` & `fparser-0.1.0/src/fparser/tests/test_functional.py`

 * *Files 8% similar despite different names*

```diff
@@ -28,33 +28,33 @@
 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-''' Module containing functional tests - i.e. tests of specific functionality
-    within the context of parsing a piece of compilable Fortran '''
+""" Module containing functional tests - i.e. tests of specific functionality
+    within the context of parsing a piece of compilable Fortran """
 
 
 def test_procedure_interface():
-    ''' Test that parser copes with a procedure declaration in
-    a subroutine '''
+    """Test that parser copes with a procedure declaration in
+    a subroutine"""
     from fparser import api
-    source_str = '''  subroutine proc_interface_test()
+
+    source_str = """  subroutine proc_interface_test()
     use field_mod,                   only: field_type, write_interface
     use fs_continuity_mod,           only: W3
     use io_mod,                      only: write_field
     implicit none
     type(field_type)                      :: divergence
     procedure (write_interface), pointer  :: tmp_ptr
 
     divergence = field_type( vector_space = &
                     function_space_collection%get_fs(0, 0, W3) )
     tmp_ptr => write_field
     call divergence%set_write_field_behaviour(write_field)
   end subroutine proc_interface_test
-'''
-    tree = api.parse(source_str, isfree=True, isstrict=False,
-                     ignore_comments=False)
+"""
+    tree = api.parse(source_str, isfree=True, isstrict=False, ignore_comments=False)
     gen_code = str(tree)
     assert "PROCEDURE (write_interface) , POINTER :: tmp_ptr" in gen_code
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue10.py` & `fparser-0.1.0/src/fparser/tests/test_f90comment_f77source.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,23 +60,21 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
-      subroutine foo
-      do 10
- 10   continue
-      end subroutine
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=False,
-                     ignore_comments=False)
-    assert str(tree).strip().split('\n')[1:]=='''
-      !      BEGINSOURCE <cStringIO.StringI object at 0x1733ea0> mode=fix90
-        SUBROUTINE foo()
-          DO 10
- 10       CONTINUE
-        END SUBROUTINE foo
-    '''.strip().split('\n')[1:]
+    source_str = """\
+      subroutine foobar()
+!#here's a f90 comment starting at 0
+      end
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=True, analyze=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0x3721710> mode=f77
+        SUBROUTINE foobar()
+        END SUBROUTINE foobar
+        """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue11.py` & `fparser-0.1.0/src/fparser/tests/test_issue11.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -61,19 +61,22 @@
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 import pytest
 from fparser import api
 
-@pytest.mark.xfail(reason="Fails in fparser1 as the reader now passes "
-                   "include onto the parser if the include is not found")
+
+@pytest.mark.xfail(
+    reason="Fails in fparser1 as the reader now passes "
+    "include onto the parser if the include is not found"
+)
 def test_reproduce_issue():
-    source_str = '''\
+    source_str = """\
       subroutine bndfp()
         include "events.ins"
       end
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=False,
-                     ignore_comments=False)
-    assert str(tree).strip().split('\n')[1:]=='''
-    '''.strip().split('\n')[1:]
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue23.py` & `fparser-0.1.0/src/fparser/tests/test_issue23.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,32 +60,34 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue_1():
-    source_str = '''\
+    source_str = """\
       subroutine bndfp(ax,i)
       logical:: ax
       if(ax) i=1
       end
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=False,
-                     ignore_comments=False)
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
     ifstmt = tree.content[0].content[1]
-    assert str(ifstmt).strip()=='''
-    IF (ax) i = 1'''.strip()
+    expected = """
+    IF (ax) i = 1"""
+    assert str(ifstmt).strip() == expected.strip()
+
 
 def test_reproduce_issue_2():
-    source_str = '''\
+    source_str = """\
       subroutine bndfp(ax,i)
       logical:: ax
       if(ax) call bb(a,b)
       end
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=False,
-                     ignore_comments=False)
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
     ifstmt = tree.content[0].content[1]
-    assert str(ifstmt).strip()=='''
-    IF (ax) CALL bb(a, b)'''.strip()
+    expected = """
+    IF (ax) CALL bb(a, b)"""
+    assert str(ifstmt).strip() == expected.strip()
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue25.py` & `fparser-0.1.0/src/fparser/tests/test_issue25.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,16 +60,17 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
+    source_str = """\
 MODULE testa
 
 CONTAINS
 
 SUBROUTINE f(arga)
 INTEGER :: arga
 
@@ -78,19 +79,18 @@
 SUBROUTINE subf(argx)
 INTEGER :: argx
 END SUBROUTINE subf
 
 END SUBROUTINE f
 
 END MODULE testa
-'''
-    tree = api.parse(source_str, isfree=True, isstrict=False,
-                     ignore_comments=False)
+"""
+    tree = api.parse(source_str, isfree=True, isstrict=False, ignore_comments=False)
     r = str(tree).strip()
-    assert r.split('\n')[1:]=='''
+    expected = """
 ...!BEGINSOURCE <cStringIO.StringI object at 0x139f8a0> mode=free
   MODULE testa
 
     CONTAINS
 
     SUBROUTINE f(arga)
       INTEGER arga
@@ -100,8 +100,9 @@
       SUBROUTINE subf(argx)
         INTEGER argx
       END SUBROUTINE subf
 
     END SUBROUTINE f
 
   END MODULE testa
-    '''.strip().split('\n')[1:],repr(r)
+    """
+    assert r.split("\n")[1:] == expected.strip().split("\n")[1:], repr(r)
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue26.py` & `fparser-0.1.0/src/fparser/tests/test_issue26.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,16 +60,17 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
+    source_str = """\
 MODULE testa
 
 TYPE t
    INTEGER :: x
 END TYPE
 
 CONTAINS
@@ -79,19 +80,18 @@
 TYPE(t), DIMENSION(2) :: v
 
 v(1)%x = 23
 v  (2) % x = 42
 
 END SUBROUTINE f
 END MODULE testa
-'''
-    tree = api.parse(source_str, isfree=True, isstrict=False,
-                     ignore_comments=False)
-    r = str(tree).strip()
-    assert r.split('\n')[1:]=='''
+"""
+    tree = api.parse(source_str, isfree=True, isstrict=False, ignore_comments=False)
+    result = str(tree).strip()
+    expected = """
 !BEGINSOURCE <cStringIO.StringI object at 0x2a1ee70> mode=free
   MODULE testa
 
     TYPE t
       INTEGER x
     END TYPE t
 
@@ -103,8 +103,9 @@
 
       v(1)%x = 23
       v(2)%x = 42
 
     END SUBROUTINE f
   END MODULE testa
 
-    '''.strip().split('\n')[1:],repr(r)
+    """
+    assert result.split("\n")[1:] == expected.strip().split("\n")[1:], repr(result)
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue33.py` & `fparser-0.1.0/src/fparser/tests/test_issue33.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,30 +60,31 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
+    source_str = """\
 module foo
 
 interface assignment(=)
     module procedure baa
 end interface assignment(=)
   
 end module foo
-'''
-    tree = api.parse(source_str, isfree=True, isstrict=False,
-                     ignore_comments=False)
-    r = str(tree).strip()
-    assert r.split('\n')[1:]=='''
+"""
+    tree = api.parse(source_str, isfree=True, isstrict=False, ignore_comments=False)
+    result = str(tree).strip()
+    expected = """
 ...!BEGINSOURCE <cStringIO.StringI object at 0x302c1e0> mode=free
   MODULE foo
 
     INTERFACE assignment(=)
       MODULE PROCEDURE baa
     END INTERFACE assignment(=)
 
   END MODULE foo
-    '''.strip().split('\n')[1:],repr(r)
+    """
+    assert result.split("\n")[1:] == expected.strip().split("\n")[1:], repr(result)
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue4.py` & `fparser-0.1.0/src/fparser/tests/test_issue4.py`

 * *Files 14% similar despite different names*

```diff
@@ -60,100 +60,105 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue_private():
-    source_str = '''
+    source_str = """
     module m
     contains
     subroutine a
     end subroutine a
     end module m
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
 
+
 def test_private_subroutine():
-    source_str = '''
+    source_str = """
     module m
     public
     private a
     contains
     subroutine a
     end subroutine a
     subroutine b
     end subroutine b
     end module m
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     a = tree.content[0].content[3]
     b = tree.content[0].content[4]
 
     assert not a.is_public()
     assert a.is_private()
 
     assert b.is_public()
     assert not b.is_private()
 
+
 def test_related_issue_type():
-    source_str = '''
+    source_str = """
     module m
     type private :: a
     end type a
     type public :: b
     end type b
     type :: c
     end type c
     end module m
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
-    a,b,c = tree.content[0].content[:3]
+    a, b, c = tree.content[0].content[:3]
     assert a.is_private()
     assert not a.is_public()
 
     assert not b.is_private()
     assert b.is_public()
 
     assert not c.is_private()
     assert c.is_public()
 
+
 def test_private_type():
-    source_str = '''
+    source_str = """
     module m
     private
     public b
     type :: a
     end type a
     type :: b
     end type b
     type public :: c
     end type c
     end module m
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
-    a,b,c = tree.content[0].content[2:5]
+    a, b, c = tree.content[0].content[2:5]
     assert a.is_private()
     assert not a.is_public()
     assert not b.is_private()
     assert b.is_public()
     assert not c.is_private()
     assert c.is_public()
 
+
 def test_reproduce_issue_len():
-    source_str = '''
+    source_str = """
     subroutine foo(a)
     character(lenmax) a
     character(lenmax, kind=4) b
     character(len=lenmax, kind=4) c
     character(kind=4, len=lenmax) d
     character(lenmax, 4) e
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
-    a, b, c, d, e=tree.content[0].content[:5]
-    assert a.selector==('lenmax','')
-    assert b.selector==('lenmax','4')
-    assert c.selector==('lenmax','4')
-    assert d.selector==('lenmax','4')
-    assert e.selector==('lenmax','4')
+    a, b, c, d, e = tree.content[0].content[:5]
+    assert a.selector == ("lenmax", "")
+    assert b.selector == ("lenmax", "4")
+    assert c.selector == ("lenmax", "4")
+    assert d.selector == ("lenmax", "4")
+    assert e.selector == ("lenmax", "4")
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue5.py` & `fparser-0.1.0/src/fparser/tests/test_issue5.py`

 * *Files 8% similar despite different names*

```diff
@@ -59,41 +59,43 @@
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''
+    source_str = """
     subroutine foo
     implicit none
     character a*8
     real*4 r
     character*2 b*4
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     foo = tree.content[0]
-    a = foo.get_variable('a')
-    b = foo.get_variable('b')
-    r = foo.get_variable('r')
-    assert a.typedecl.__class__.__name__=='Character'
-    assert a.length == '8',repr(a.length)
-    assert a.name =='a'
-    assert a.typedecl.selector==('','')
-    assert r.typedecl.__class__.__name__=='Real'
-    assert r.typedecl.selector==('4','')
+    a = foo.get_variable("a")
+    b = foo.get_variable("b")
+    r = foo.get_variable("r")
+    assert a.typedecl.__class__.__name__ == "Character"
+    assert a.length == "8", repr(a.length)
+    assert a.name == "a"
+    assert a.typedecl.selector == ("", "")
+    assert r.typedecl.__class__.__name__ == "Real"
+    assert r.typedecl.selector == ("4", "")
+
+    assert b.typedecl.__class__.__name__ == "Character"
+    assert b.length == "4", repr(a.length)
+    assert b.name == "b"
+    assert b.typedecl.selector == ("2", "")
 
-    assert b.typedecl.__class__.__name__=='Character'
-    assert b.length == '4',repr(a.length)
-    assert b.name =='b'
-    assert b.typedecl.selector==('2','')
 
 def test_recursive():
-    source_str = '''
+    source_str = """
     recursive subroutine foo
     end subroutine foo
-    '''
+    """
     tree = api.parse(source_str, isfree=True, isstrict=False)
     foo = tree.content[0]
     assert foo.is_recursive()
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue7.py` & `fparser-0.1.0/src/fparser/tests/test_issue7.py`

 * *Files 16% similar despite different names*

```diff
@@ -60,162 +60,172 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
+
 def test_reproduce_issue():
-    source_str = '''\
+    source_str = """\
       subroutine bndfp()
       use m_struc_def
 C-
 C 
 C
 C
 C
 C
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    s, u, c, e = tree[:3]+tree[-1:]
-    assert s.span==(1,1),repr(s.span)
-    assert u.span==(2,2),repr(u.span)
-    assert c.span==(3,3),repr(c.span)
-    assert e.span==(9,9),repr(e.span)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    s, u, c, e = tree[:3] + tree[-1:]
+    assert s.span == (1, 1), repr(s.span)
+    assert u.span == (2, 2), repr(u.span)
+    assert c.span == (3, 3), repr(c.span)
+    assert e.span == (9, 9), repr(e.span)
 
 
 def test_reproduce_issue_fix77():
-    source_str = '''\
+    source_str = """\
       subroutine foo()
       real a
 c
 c
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=True,
-                          ignore_comments=False)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=True, ignore_comments=False
+    )
     tree = list(tree)
-    foo, a, comment, end = tree[:3]+tree[-1:]
+    foo, a, comment, end = tree[:3] + tree[-1:]
     assert foo.span == (1, 1)
     assert a.span == (2, 4), repr(a)
     assert comment.span == (5, 5), repr(comment.span)
     assert end.span == (5, 5), repr(end.span)
 
 
 def test_reproduce_issue_fix90():
-    source_str = '''\
+    source_str = """\
       subroutine foo()
       real a
 c 1
 c 2
       end
-'''
+"""
     tree = api.get_reader(source_str, isfree=False, isstrict=False)
     tree = list(tree)
-    foo, a, comment,end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert a.span==(2,2),repr(a.span)
-    assert end.span==(5,5),repr(end.span)
+    foo, a, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert a.span == (2, 2), repr(a.span)
+    assert end.span == (5, 5), repr(end.span)
 
-    source_str = '''\
+    source_str = """\
       subroutine foo()
       real a
 c-
 c
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    foo, a, comment,end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert a.span==(2,2),repr(a.span)
-    assert end.span==(5,5),repr(end.span)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    foo, a, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert a.span == (2, 2), repr(a.span)
+    assert end.span == (5, 5), repr(end.span)
 
-    source_str = '''\
+    source_str = """\
       subroutine foo()
       real a
 c
 c
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    foo, a, comment, end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert a.span==(2,2),repr(a.span)
-    assert comment.span == (3,3)
-    assert end.span==(5,5),repr(end.span)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    foo, a, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert a.span == (2, 2), repr(a.span)
+    assert comment.span == (3, 3)
+    assert end.span == (5, 5), repr(end.span)
+
 
 def test_comment_cont_fix90():
-    source_str = '''\
+    source_str = """\
           subroutine foo()
       real
 c 1
      & a
 c 2
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    foo, a, comment, end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert a.span==(2,4),repr(a.span)
-    assert comment.span==(3,3),repr(comment.span)
-    assert end.span==(6,6)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    foo, a, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert a.span == (2, 4), repr(a.span)
+    assert comment.span == (3, 3), repr(comment.span)
+    assert end.span == (6, 6)
 
-    source_str = '''\
+    source_str = """\
           subroutine foo()
       real
 c
      & a
 c 2
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    foo, a, comment, end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert a.span==(2,4),repr(a.span)
-    assert comment.span==(3,3),repr(comment.span)
-    assert end.span==(6,6)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    foo, a, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert a.span == (2, 4), repr(a.span)
+    assert comment.span == (3, 3), repr(comment.span)
+    assert end.span == (6, 6)
 
-    source_str = '''\
+    source_str = """\
           subroutine foo()
       real
 c 1
      & a
 c
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    foo, a, comment, end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert a.span==(2,4),repr(a.span)
-    assert comment.span==(3,3),repr(comment.span)
-    assert end.span==(6,6)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    foo, a, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert a.span == (2, 4), repr(a.span)
+    assert comment.span == (3, 3), repr(comment.span)
+    assert end.span == (6, 6)
 
-    source_str = '''\
+    source_str = """\
           subroutine foo()
       real
 c 1
      & a
 c 2
      &,b
       end
-'''
-    tree = api.get_reader(source_str, isfree=False, isstrict=False,
-                          ignore_comments=False)
-    tree = list(tree)
-    foo, ab, comment, end = tree[:3]+tree[-1:]
-    assert foo.span==(1,1)
-    assert ab.span==(2,6),repr(a.span)
-    assert comment.span==(3,3),repr(comment.span)
-    assert end.span==(7,7)
+"""
+    tree = api.get_reader(
+        source_str, isfree=False, isstrict=False, ignore_comments=False
+    )
+    tree = list(tree)
+    foo, ab, comment, end = tree[:3] + tree[-1:]
+    assert foo.span == (1, 1)
+    assert ab.span == (2, 6), repr(a.span)
+    assert comment.span == (3, 3), repr(comment.span)
+    assert end.span == (7, 7)
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_issue9.py` & `fparser-0.1.0/src/fparser/tests/test_issue10.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -60,32 +60,24 @@
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 from fparser import api
 
-def test_reproduce_issue():
-    source_str = '''\
-      module m_rdctrl
 
-      contains
-      
-      subroutine readctrl(prgn,vstrn,vn)
-
-      end subroutine readctrl
-      end module
-      
-'''
-    tree = api.parse(source_str, isfree=False, isstrict=False,
-                     ignore_comments=False)
-    assert str(tree).strip().split('\n')[1:]=='''
-      !      BEGINSOURCE <cStringIO.StringI object at 0x2405ea0> mode=fix90
-        MODULE m_rdctrl
-
-          CONTAINS
-
-          SUBROUTINE readctrl(prgn, vstrn, vn)
-
-          END SUBROUTINE readctrl
-        END MODULE m_rdctrl
-    '''.strip().split('\n')[1:]
+def test_reproduce_issue():
+    source_str = """\
+      subroutine foo
+      do 10
+ 10   continue
+      end subroutine
+"""
+    tree = api.parse(source_str, isfree=False, isstrict=False, ignore_comments=False)
+    expected = """
+      !      BEGINSOURCE <cStringIO.StringI object at 0x1733ea0> mode=fix90
+        SUBROUTINE foo()
+          DO 10
+ 10       CONTINUE
+        END SUBROUTINE foo
+    """
+    assert str(tree).strip().split("\n")[1:] == expected.strip().split("\n")[1:]
```

### Comparing `fparser-0.0.9/src/fparser/tests/test_mod_private.py` & `fparser-0.1.0/src/fparser/tests/test_mod_private.py`

 * *Files 4% similar despite different names*

```diff
@@ -59,40 +59,42 @@
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 from fparser import api
 
+
 def test_default_private():
-    src = '''\
+    src = """\
 module mod1
 private
 integer :: i
 contains
 subroutine s1
 end subroutine
 end module mod1
-'''
+"""
     mod1 = api.parse(src, isfree=True, isstrict=False).content[0]
     assert mod1.get_provides() == {}, repr(mod1.get_provides())
-    assert list(mod1.a.variables.keys()) == ['i']
-    assert list(mod1.a.module_subprogram.keys()) == ['s1']
+    assert list(mod1.a.variables.keys()) == ["i"]
+    assert list(mod1.a.module_subprogram.keys()) == ["s1"]
+
 
 def test_access_spec():
-    src = '''\
+    src = """\
 module mod1
 private
 integer, public :: i
 integer :: j, k
 public :: j, s1
 contains
 subroutine s1
 end subroutine
 subroutine s2
 end subroutine
 end module mod1
-'''
+"""
     mod1 = api.parse(src, isfree=True, isstrict=False).content[0]
-    assert sorted(mod1.get_provides().keys()) == sorted(['i', 'j', 's1'])
-    assert sorted(mod1.a.variables.keys()) == sorted(['i', 'j', 'k'])
-    assert sorted(mod1.a.module_subprogram.keys()) == sorted(['s2', 's1'])
+    assert sorted(mod1.get_provides().keys()) == sorted(["i", "j", "s1"])
+    assert sorted(mod1.a.variables.keys()) == sorted(["i", "j", "k"])
+    assert sorted(mod1.a.module_subprogram.keys()) == sorted(["s2", "s1"])
```

### Comparing `fparser-0.0.9/src/fparser/two/Fortran2003.py` & `fparser-0.1.0/src/fparser/two/Fortran2003.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 
-# Modified work Copyright (c) 2017-2019 Science and Technology
+# Modified work Copyright (c) 2017-2022 Science and Technology
 # Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
@@ -66,26 +66,51 @@
 # DAMAGE.
 
 """Fortran 2003 Syntax Rules.
 """
 # Original author: Pearu Peterson <pearu@cens.ioc.ee>
 # First version created: Oct 2006
 
+import inspect
 import re
-import logging
+import sys
+
 from fparser.common.splitline import string_replace_map
 from fparser.two import pattern_tools as pattern
 from fparser.common.readfortran import FortranReaderBase
-
-from fparser.two.utils import Base, BlockBase, StringBase, WORDClsBase, \
-    NumberBase, STRINGBase, BracketBase, StmtBase, EndStmtBase, \
-    BinaryOpBase, Type_Declaration_StmtBase, CALLBase, CallBase, \
-    KeywordValueBase, SeparatorBase, SequenceBase, UnaryOpBase
-from fparser.two.utils import NoMatchError, FortranSyntaxError, \
-    InternalSyntaxError, InternalError, show_result
+from fparser.two.symbol_table import SYMBOL_TABLES
+from fparser.two.utils import (
+    Base,
+    BlockBase,
+    StringBase,
+    WORDClsBase,
+    NumberBase,
+    STRINGBase,
+    BracketBase,
+    StmtBase,
+    EndStmtBase,
+    BinaryOpBase,
+    Type_Declaration_StmtBase,
+    CALLBase,
+    CallBase,
+    KeywordValueBase,
+    ScopingRegionMixin,
+    SeparatorBase,
+    SequenceBase,
+    UnaryOpBase,
+    walk,
+    DynamicImport,
+)
+from fparser.two.utils import (
+    NoMatchError,
+    FortranSyntaxError,
+    InternalSyntaxError,
+    InternalError,
+    show_result,
+)
 
 #
 # SECTION  1
 #
 
 # R101: <xyz-list> = <xyz> [ , <xyz> ]...
 # R102: <xyz-name> = <name>
@@ -93,29 +118,31 @@
 
 #
 # SECTION  2
 #
 
 
 class Comment(Base):
-    '''
-    Represents a Fortran Comment
-    '''
+    """
+    Represents a Fortran Comment.
+    """
+
     subclass_names = []
 
     @show_result
     def __new__(cls, string, parent_cls=None):
         """
         Create a new Comment instance.
 
-        :param type cls: the class of object to create
-        :param string: (source of) Fortran string to parse
+        :param type cls: the class of object to create.
+        :param string: (source of) Fortran string to parse.
         :type string: str or :py:class:`FortranReaderBase`
-        :param parent_cls: the parent class of this object
+        :param parent_cls: the parent class of this object.
         :type parent_cls: :py:type:`type`
+
         """
         from fparser.common import readfortran
 
         if isinstance(string, readfortran.Comment):
             # We were after a comment and we got a comment. Construct
             # one manually to avoid recursively calling this __new__
             # method again...
@@ -135,85 +162,110 @@
                 reader.put_item(item)
                 return
         else:
             # We didn't get a comment
             return
 
     def init(self, comment):
-        '''
+        """
         Initialise this Comment
 
         :param  comment: The comment object produced by the reader
         :type comment: :py:class:`readfortran.Comment`
-        '''
+        """
         self.items = [comment.comment]
         self.item = comment
 
     def tostr(self):
-        '''
+        """
         :returns: this comment as a string.
-        :rtype: :py:class:`six.text_type`
-        '''
-        import six
-        return six.text_type(self.items[0])
+        :rtype: :py:class:`str`
+        """
+        return str(self.items[0])
 
     def restore_reader(self, reader):
-        '''
+        """
         Undo the read of this comment by putting its content back
         into the reader (which has a FIFO buffer)
 
         :param reader: the reader instance to return the comment to
         :type reader: :py:class:`fparser.readfortran.FortranReaderBase`
-        '''
+        """
         reader.put_item(self.item)
 
 
-def add_comments_includes(content, reader):
-    '''Creates comment and/or include objects and adds them to the content
-    list. Comment and/or include objects are added until a line that
-    is not a comment or include is found.
+def match_comment_or_include(reader):
+    """Creates a comment or include object from the current line.
 
-    :param content: a `list` of matched objects. Any matched comments \
-                    or includes in this routine are added to this list.
-    :param reader: the fortran file reader containing the line(s) \
+    :param reader: the fortran file reader containing the line \
                    of code that we are trying to match
     :type reader: :py:class:`fparser.common.readfortran.FortranFileReader` \
                   or \
                   :py:class:`fparser.common.readfortran.FortranStringReader`
 
-    '''
+    :return: a comment or include object if found, otherwise `None`.
+    :rtype: :py:class:`fparser.two.Fortran2003.Comment` or \
+            :py:class:`fparser.two.Fortran2003.Include_Stmt`
+
+    """
     obj = Comment(reader)
     obj = Include_Stmt(reader) if not obj else obj
+    return obj
+
+
+def add_comments_includes_directives(content, reader):
+    """Creates comment, include, and/or cpp directive objects and adds them to
+    the content list. Comment, include, and/or directive objects are added
+    until a line that is not a comment, include, or directive is found.
+
+    :param content: a `list` of matched objects. Any matched comments, \
+                    includes, or directives in this routine are added to \
+                    this list.
+    :type content: :obj:`list`
+    :param reader: the fortran file reader containing the line(s) \
+                   of code that we are trying to match
+    :type reader: :py:class:`fparser.common.readfortran.FortranFileReader` \
+                  or \
+                  :py:class:`fparser.common.readfortran.FortranStringReader`
+
+    """
+    from fparser.two.C99Preprocessor import match_cpp_directive
+
+    obj = match_comment_or_include(reader)
+    obj = match_cpp_directive(reader) if not obj else obj
     while obj:
         content.append(obj)
-        obj = Comment(reader)
-        obj = Include_Stmt(reader) if not obj else obj
+        obj = match_comment_or_include(reader)
+        obj = match_cpp_directive(reader) if not obj else obj
 
 
 class Program(BlockBase):  # R201
-    '''
-    Fortran 2003 rule R201
-    program is program-unit
-               [ program-unit ] ...
+    """
+    Fortran 2003 rule R201::
+
+        program is program-unit
+                   [ program-unit ] ...
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Program_Unit']
+    use_names = ["Program_Unit"]
 
     @show_result
     def __new__(cls, string):
-        '''Wrapper around base class __new__ to catch an internal NoMatchError
+        """Wrapper around base class __new__ to catch an internal NoMatchError
         exception and raise it as an external FortranSyntaxError exception.
 
         :param type cls: the class of object to create
         :param string: (source of) Fortran string to parse
         :type string: :py:class:`FortranReaderBase`
         :raises FortranSyntaxError: if the code is not valid Fortran
 
-        '''
+        """
+        # pylint: disable=unused-argument
         try:
             return Base.__new__(cls, string)
         except NoMatchError:
             # At the moment there is no useful information provided by
             # NoMatchError so we pass on an empty string.
             raise FortranSyntaxError(string, "")
         except InternalSyntaxError as excinfo:
@@ -222,675 +274,850 @@
             # object. This is then re-raised here as a
             # FortranSyntaxError, adding the reader object (which
             # provides line number information).
             raise FortranSyntaxError(string, excinfo)
 
     @staticmethod
     def match(reader):
-        '''Implements the matching for a Program. Whilst the rule looks like
+        """Implements the matching for a Program. Whilst the rule looks like
         it could make use of BlockBase, the parser must not match if an
         optional program_unit has a syntax error, which the BlockBase
         match implementation does not do.
 
         :param reader: the fortran file reader containing the line(s)
                        of code that we are trying to match
         :type reader: :py:class:`fparser.common.readfortran.FortranFileReader`
                       or
                       :py:class:`fparser.common.readfortran.FortranStringReader`
         :return: `tuple` containing a single `list` which contains
                  instance of the classes that have matched if there is
                  a match or `None` if there is no match
 
-        '''
+        """
         content = []
-        add_comments_includes(content, reader)
+        add_comments_includes_directives(content, reader)
+        comments = content != []
         try:
             while True:
                 obj = Program_Unit(reader)
                 content.append(obj)
-                add_comments_includes(content, reader)
+                add_comments_includes_directives(content, reader)
                 # cause a StopIteration exception if there are no more lines
                 next_line = reader.next()
                 # put the line back in the case where there are more lines
                 reader.put_item(next_line)
         except NoMatchError:
             # Found a syntax error for this rule. Now look to match
             # (via Main_Program0) with a program containing no program
             # statement as this is optional in Fortran.
             #
-            return BlockBase.match(Main_Program0, [], None, reader)
+            result = BlockBase.match(Main_Program0, [], None, reader)
+            if not result and comments:
+                # This program only contains comments.
+                return (content,)
+            else:
+                return result
         except StopIteration:
             # Reader has no more lines.
             pass
-        return content,
+        return (content,)
 
 
 class Include_Filename(StringBase):  # pylint: disable=invalid-name
 
-    '''Implements the matching of a filename from an include statement.'''
+    """Implements the matching of a filename from an include statement."""
+
     # There are no other classes. This is a simple string match.
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''Match the string with the regular expression file_name in the
+        """Match the string with the regular expression file_name in the
         pattern_tools file. The only content that is not accepted is
         an empty string or white space at the start or end of the
         string.
 
         :param str string: the string to match with the pattern rule.
         :return: a tuple of size 1 containing a string with the \
         matched name if there is a match, or None if there is not.
         :rtype: (str) or NoneType
 
-        '''
+        """
         return StringBase.match(pattern.file_name, string)
 
 
 class Include_Stmt(Base):  # pylint: disable=invalid-name
 
-    '''Implements the matching of a Fortran include statement. There is no
+    """Implements the matching of a Fortran include statement. There is no
     rule for this as the compiler is expected to inline any content
     from an include statement when one is found. However, for a parser
     it can make sense to represent an include statement in a parse
-    tree.
+    tree::
 
-    include-stmt is INCLUDE ['filename' or "filename"]
+        include-stmt is INCLUDE ['filename' or "filename"]
+
+    """
 
-    '''
-    use_names = ['Include_Filename']
+    use_names = ["Include_Filename"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for an include statement.
+        """Implements the matching for an include statement.
 
-        :param str string: the string to match with as an include \
-        statement.
+        :param str string: the string to match with as an include statement.
         :returns: a tuple of size 1 containing an Include_Filename \
         object with the matched filename if there is a match, or None \
         if there is not.
         :rtype: (:py:class:`fparser.two.Fortran2003.Include_Filename`) \
         or NoneType
 
-        '''
+        """
         if not string:
             return None
+
         line = string.strip()
-        if line[:7].upper() != 'INCLUDE':
+        if line[:7].upper() != "INCLUDE":
             # The line does not start with the include token and/or the line
             # is too short.
             return None
         rhs = line[7:].strip()
-        if not rhs:
-            # There is no content after the include token
-            return None
-        if len(rhs) < 3:
-            # The content after the include token is too short to be
-            # valid (it must at least contain quotes and one
-            # character.
-            return None
-        if not ((rhs[0] == "'" and rhs[-1] == "'") or
-                (rhs[0] == '"' and rhs[-1] == '"')):
+        if rhs is None or len(rhs) < 3:
+            # Either we didn't find any includes or the content after
+            # the include token is too short to be valid (it must at
+            # least contain quotes and one character.
+            return None
+        if not (
+            (rhs[0] == "'" and rhs[-1] == "'") or (rhs[0] == '"' and rhs[-1] == '"')
+        ):
             # The filename should be surrounded by single or double
             # quotes but this is not the case.
             return None
         # Remove the quotes.
         file_name = rhs[1:-1]
         # Pass the potential filename to the relevant class.
         name = Include_Filename(file_name)
         if not name:
             raise InternalError(
-                "Fotran2003.py:Include_Stmt:match Include_Filename should "
-                "never return None or an empty name")
+                "Fortran2003.py:Include_Stmt:match Include_Filename should "
+                "never return None or an empty name"
+            )
         return (name,)
 
     def tostr(self):
-        '''
+        """
         :return: this include_stmt as a string
         :rtype: str
-        '''
+        """
 
-        return ("INCLUDE '{0}'".format(self.items[0]))
+        return "INCLUDE '{0}'".format(self.items[0])
 
 
 class Program_Unit(Base):  # R202
     """
-:F03R:`202`::
-    <program-unit> = <main-program>
-                     | <external-subprogram>
-                     | <module>
-                     | <block-data>
+    Fortran 2003 Rule R202::
+
+        <program-unit> = <main-program>
+                         | <external-subprogram>
+                         | <module>
+                         | <block-data>
     """
-    subclass_names = ['Comment', 'Main_Program', 'External_Subprogram',
-                      'Module', 'Block_Data']
+
+    subclass_names = [
+        "Comment",
+        "Main_Program",
+        "External_Subprogram",
+        "Module",
+        "Block_Data",
+    ]
 
 
 class External_Subprogram(Base):  # R203
     """
-:F03R:`203`::
-    <external-subprogram> = <function-subprogram>
-                            | <subroutine-subprogram>
+    Fortran2003 Rule R203::
+
+        <external-subprogram> = <function-subprogram>
+                                | <subroutine-subprogram>
     """
-    subclass_names = ['Comment', 'Function_Subprogram',
-                      'Subroutine_Subprogram']
+
+    subclass_names = ["Comment", "Function_Subprogram", "Subroutine_Subprogram"]
 
 
 class Specification_Part(BlockBase):  # R204
     """
-:F03R:`204`::
-    <specification-part> = [ <use-stmt> ]...
-                             [ <import-stmt> ]...
-                             [ <implicit-part> ]
-                             [ <declaration-construct> ]...
+    Fortran2003 Rule R204::
+
+        <specification-part> = [ <use-stmt> ]...
+                                 [ <import-stmt> ]...
+                                 [ <implicit-part> ]
+                                 [ <declaration-construct> ]...
     """
+
     subclass_names = []
-    use_names = ['Use_Stmt', 'Import_Stmt', 'Implicit_Part',
-                 'Declaration_Construct']
+    use_names = ["Use_Stmt", "Import_Stmt", "Implicit_Part", "Declaration_Construct"]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(None, [Use_Stmt, Import_Stmt,
-                                      Implicit_Part, Declaration_Construct],
-                               None, reader)
+        return BlockBase.match(
+            None,
+            [Use_Stmt, Import_Stmt, Implicit_Part, Declaration_Construct],
+            None,
+            reader,
+        )
 
 
 class Implicit_Part(BlockBase):  # R205
     """
-:F03R:`205`::
-    <implicit-part> = [ <implicit-part-stmt> ]...
-                        <implicit-stmt>
+    Fortran2003 Rule R205::
+
+        <implicit-part> = [ <implicit-part-stmt> ]...
+                            <implicit-stmt>
     """
+
     subclass_names = []
-    use_names = ['Implicit_Part_Stmt', 'Implicit_Stmt']
+    use_names = ["Implicit_Part_Stmt", "Implicit_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(None, [Implicit_Part_Stmt], None, reader)
 
 
 class Implicit_Part_Stmt(Base):  # R206
     """
-:F03R:`206`::
-    <implicit-part-stmt> = <implicit-stmt>
-                           | <parameter-stmt>
-                           | <format-stmt>
-                           | <entry-stmt>
+    Fortran2003 Rule R206::
+
+        <implicit-part-stmt> = <implicit-stmt>
+                               | <parameter-stmt>
+                               | <format-stmt>
+                               | <entry-stmt>
     """
-    subclass_names = ['Comment', 'Implicit_Stmt', 'Parameter_Stmt',
-                      'Format_Stmt', 'Entry_Stmt']
+
+    subclass_names = [
+        "Comment",
+        "Implicit_Stmt",
+        "Parameter_Stmt",
+        "Format_Stmt",
+        "Entry_Stmt",
+    ]
 
 
 class Declaration_Construct(Base):  # R207
-    '''Fortran 2003 rule R207
+    """
+    Fortran 2003 rule R207::
 
-    declaration-construct is derived-type-def
-                           or entry-stmt
-                           or enum-def
-                           or format-stmt
-                           or interface-block
-                           or parameter-stmt
-                           or procedure-declaration-stmt
-                           or specification-stmt
-                           or type-declaration-stmt
-                           or stmt-function-stmt
+        declaration-construct is derived-type-def
+                               or entry-stmt
+                               or enum-def
+                               or format-stmt
+                               or interface-block
+                               or parameter-stmt
+                               or procedure-declaration-stmt
+                               or specification-stmt
+                               or type-declaration-stmt
+                               or stmt-function-stmt
 
     Note, stmt-function-stmt is not currently matched.
 
-    '''
+    """
+
     # Commented out Stmt_Function_Stmt as it can falsely match an
     # access to an array or function. Reintroducing statement
     # functions is captured in issue #202.
 
     #                   'Type_Declaration_Stmt', 'Stmt_Function_Stmt']
-    subclass_names = ['Derived_Type_Def', 'Entry_Stmt', 'Enum_Def',
-                      'Format_Stmt', 'Interface_Block', 'Parameter_Stmt',
-                      'Procedure_Declaration_Stmt', 'Specification_Stmt',
-                      'Type_Declaration_Stmt']
+    subclass_names = [
+        "Derived_Type_Def",
+        "Entry_Stmt",
+        "Enum_Def",
+        "Format_Stmt",
+        "Interface_Block",
+        "Parameter_Stmt",
+        "Procedure_Declaration_Stmt",
+        "Specification_Stmt",
+        "Type_Declaration_Stmt",
+    ]
 
 
 class Execution_Part(BlockBase):  # R208
-    """:F03R:`208`::
+    """Fortran2003 Rule R208::
+
     <execution-part> = <executable-construct>
                        | [ <execution-part-construct> ]...
 
     <execution-part> shall not contain <end-function-stmt>,
     <end-program-stmt>, <end-subroutine-stmt>
 
     """
+
     subclass_names = []
-    use_names = ['Executable_Construct_C201', 'Execution_Part_Construct_C201']
+    use_names = ["Executable_Construct_C201", "Execution_Part_Construct_C201"]
 
+    @staticmethod
     def match(string):
-        return BlockBase.match(Executable_Construct_C201,
-                               [Execution_Part_Construct_C201],
-                               None, string)
-    match = staticmethod(match)
+        return BlockBase.match(
+            Executable_Construct_C201, [Execution_Part_Construct_C201], None, string
+        )
 
 
 class Execution_Part_Construct(Base):  # R209
     """
-    <execution-part-construct> = <executable-construct>
-                                 | <format-stmt>
-                                 | <entry-stmt>
-                                 | <data-stmt>
+    ::
+
+        <execution-part-construct> = <executable-construct>
+                                     | <format-stmt>
+                                     | <entry-stmt>
+                                     | <data-stmt>
+
     """
-    subclass_names = ['Comment', 'Executable_Construct', 'Format_Stmt',
-                      'Entry_Stmt', 'Data_Stmt']
+
+    subclass_names = [
+        "Comment",
+        "Executable_Construct",
+        "Format_Stmt",
+        "Entry_Stmt",
+        "Data_Stmt",
+    ]
 
 
 class Execution_Part_Construct_C201(Base):
-    subclass_names = ['Comment', 'Executable_Construct_C201', 'Format_Stmt',
-                      'Entry_Stmt', 'Data_Stmt']
+    subclass_names = [
+        "Comment",
+        "Executable_Construct_C201",
+        "Format_Stmt",
+        "Entry_Stmt",
+        "Data_Stmt",
+    ]
 
 
 class Internal_Subprogram_Part(BlockBase):  # R210
     """
-    <internal-subprogram-part> = <contains-stmt>
-                                   <internal-subprogram>
-                                   [ <internal-subprogram> ]...
+    ::
+
+        <internal-subprogram-part> = <contains-stmt>
+                                       <internal-subprogram>
+                                       [ <internal-subprogram> ]...
+
     """
+
     subclass_names = []
-    use_names = ['Contains_Stmt', 'Internal_Subprogram']
+    use_names = ["Contains_Stmt", "Internal_Subprogram"]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Contains_Stmt, [Internal_Subprogram],
-                               None, reader)
+        return BlockBase.match(Contains_Stmt, [Internal_Subprogram], None, reader)
 
 
 class Internal_Subprogram(Base):  # R211
     """
-    <internal-subprogram> = <function-subprogram>
-                            | <subroutine-subprogram>
+    ::
+
+        <internal-subprogram> = <function-subprogram>
+                                | <subroutine-subprogram>
+
     """
-    subclass_names = ['Function_Subprogram', 'Subroutine_Subprogram']
+
+    subclass_names = ["Function_Subprogram", "Subroutine_Subprogram"]
 
 
 class Specification_Stmt(Base):  # R212
     """
-    <specification-stmt> = <access-stmt>
-                           | <allocatable-stmt>
-                           | <asynchronous-stmt>
-                           | <bind-stmt>
-                           | <common-stmt>
-                           | <data-stmt>
-                           | <dimension-stmt>
-                           | <equivalence-stmt>
-                           | <external-stmt>
-                           | <intent-stmt>
-                           | <intrinsic-stmt>
-                           | <namelist-stmt>
-                           | <optional-stmt>
-                           | <pointer-stmt>
-                           | <protected-stmt>
-                           | <save-stmt>
-                           | <target-stmt>
-                           | <volatile-stmt>
-                           | <value-stmt>
+    ::
+
+        <specification-stmt> = <access-stmt>
+                               | <allocatable-stmt>
+                               | <asynchronous-stmt>
+                               | <bind-stmt>
+                               | <common-stmt>
+                               | <data-stmt>
+                               | <dimension-stmt>
+                               | <equivalence-stmt>
+                               | <external-stmt>
+                               | <intent-stmt>
+                               | <intrinsic-stmt>
+                               | <namelist-stmt>
+                               | <optional-stmt>
+                               | <pointer-stmt>
+                               | <protected-stmt>
+                               | <save-stmt>
+                               | <target-stmt>
+                               | <volatile-stmt>
+                               | <value-stmt>
+
     """
+
     subclass_names = [
-        'Access_Stmt', 'Allocatable_Stmt', 'Asynchronous_Stmt', 'Bind_Stmt',
-        'Comment', 'Common_Stmt', 'Data_Stmt', 'Dimension_Stmt',
-        'Equivalence_Stmt',
-        'External_Stmt', 'Intent_Stmt', 'Intrinsic_Stmt', 'Namelist_Stmt',
-        'Optional_Stmt', 'Pointer_Stmt', 'Cray_Pointer_Stmt',
-        'Protected_Stmt', 'Save_Stmt', 'Target_Stmt', 'Volatile_Stmt',
-        'Value_Stmt']
+        "Access_Stmt",
+        "Allocatable_Stmt",
+        "Asynchronous_Stmt",
+        "Bind_Stmt",
+        "Comment",
+        "Common_Stmt",
+        "Data_Stmt",
+        "Dimension_Stmt",
+        "Equivalence_Stmt",
+        "External_Stmt",
+        "Intent_Stmt",
+        "Intrinsic_Stmt",
+        "Namelist_Stmt",
+        "Optional_Stmt",
+        "Pointer_Stmt",
+        "Cray_Pointer_Stmt",
+        "Protected_Stmt",
+        "Save_Stmt",
+        "Target_Stmt",
+        "Volatile_Stmt",
+        "Value_Stmt",
+    ]
 
 
 class Executable_Construct(Base):  # R213
     # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R213
-    executable-construct is action-stmt
-                         or associate-construct
-                         or case-construct
-                         or do-construct
-                         or forall-construct
-                         or if-construct
-                         or select-type-construct
-                         or where-construct
+    """
+    Fortran 2003 rule R213::
+
+        executable-construct is action-stmt
+                             or associate-construct
+                             or case-construct
+                             or do-construct
+                             or forall-construct
+                             or if-construct
+                             or select-type-construct
+                             or where-construct
 
-    '''
+    """
     subclass_names = [
-        'Action_Stmt', 'Associate_Construct', 'Case_Construct',
-        'Do_Construct', 'Forall_Construct', 'If_Construct',
-        'Select_Type_Construct', 'Where_Construct']
+        "Action_Stmt",
+        "Associate_Construct",
+        "Case_Construct",
+        "Do_Construct",
+        "Forall_Construct",
+        "If_Construct",
+        "Select_Type_Construct",
+        "Where_Construct",
+    ]
 
 
 class Executable_Construct_C201(Base):
     subclass_names = Executable_Construct.subclass_names[:]
-    subclass_names[subclass_names.index('Action_Stmt')] = 'Action_Stmt_C201'
+    subclass_names[subclass_names.index("Action_Stmt")] = "Action_Stmt_C201"
 
 
 class Action_Stmt(Base):  # R214
     """
-    <action-stmt> = <allocate-stmt>
-                    | <assignment-stmt>
-                    | <backspace-stmt>
-                    | <call-stmt>
-                    | <close-stmt>
-                    | <continue-stmt>
-                    | <cycle-stmt>
-                    | <deallocate-stmt>
-                    | <endfile-stmt>
-                    | <end-function-stmt>
-                    | <end-program-stmt>
-                    | <end-subroutine-stmt>
-                    | <exit-stmt>
-                    | <flush-stmt>
-                    | <forall-stmt>
-                    | <goto-stmt>
-                    | <if-stmt>
-                    | <inquire-stmt>
-                    | <nullify-stmt>
-                    | <open-stmt>
-                    | <pointer-assignment-stmt>
-                    | <print-stmt>
-                    | <read-stmt>
-                    | <return-stmt>
-                    | <rewind-stmt>
-                    | <stop-stmt>
-                    | <wait-stmt>
-                    | <where-stmt>
-                    | <write-stmt>
-                    | <arithmetic-if-stmt>
-                    | <computed-goto-stmt>
-    """
-    subclass_names = ['Allocate_Stmt', 'Assignment_Stmt', 'Backspace_Stmt',
-                      'Call_Stmt', 'Close_Stmt', 'Comment', 'Continue_Stmt',
-                      'Cycle_Stmt', 'Deallocate_Stmt', 'Endfile_Stmt',
-                      'End_Function_Stmt', 'End_Subroutine_Stmt', 'Exit_Stmt',
-                      'Flush_Stmt', 'Forall_Stmt', 'Goto_Stmt', 'If_Stmt',
-                      'Inquire_Stmt', 'Nullify_Stmt', 'Open_Stmt',
-                      'Pointer_Assignment_Stmt', 'Print_Stmt', 'Read_Stmt',
-                      'Return_Stmt', 'Rewind_Stmt', 'Stop_Stmt', 'Wait_Stmt',
-                      'Where_Stmt', 'Write_Stmt', 'Arithmetic_If_Stmt',
-                      'Computed_Goto_Stmt']
+    ::
+
+        <action-stmt> = <allocate-stmt>
+                        | <assignment-stmt>
+                        | <backspace-stmt>
+                        | <call-stmt>
+                        | <close-stmt>
+                        | <continue-stmt>
+                        | <cycle-stmt>
+                        | <deallocate-stmt>
+                        | <endfile-stmt>
+                        | <end-function-stmt>
+                        | <end-program-stmt>
+                        | <end-subroutine-stmt>
+                        | <exit-stmt>
+                        | <flush-stmt>
+                        | <forall-stmt>
+                        | <goto-stmt>
+                        | <if-stmt>
+                        | <inquire-stmt>
+                        | <nullify-stmt>
+                        | <open-stmt>
+                        | <pointer-assignment-stmt>
+                        | <print-stmt>
+                        | <read-stmt>
+                        | <return-stmt>
+                        | <rewind-stmt>
+                        | <stop-stmt>
+                        | <wait-stmt>
+                        | <where-stmt>
+                        | <write-stmt>
+                        | <arithmetic-if-stmt>
+                        | <computed-goto-stmt>
+
+    """
+
+    subclass_names = [
+        "Allocate_Stmt",
+        "Assignment_Stmt",
+        "Backspace_Stmt",
+        "Call_Stmt",
+        "Close_Stmt",
+        "Comment",
+        "Continue_Stmt",
+        "Cycle_Stmt",
+        "Deallocate_Stmt",
+        "Endfile_Stmt",
+        "End_Function_Stmt",
+        "End_Subroutine_Stmt",
+        "Exit_Stmt",
+        "Flush_Stmt",
+        "Forall_Stmt",
+        "Goto_Stmt",
+        "If_Stmt",
+        "Inquire_Stmt",
+        "Nullify_Stmt",
+        "Open_Stmt",
+        "Pointer_Assignment_Stmt",
+        "Print_Stmt",
+        "Read_Stmt",
+        "Return_Stmt",
+        "Rewind_Stmt",
+        "Stop_Stmt",
+        "Wait_Stmt",
+        "Where_Stmt",
+        "Write_Stmt",
+        "Arithmetic_If_Stmt",
+        "Computed_Goto_Stmt",
+    ]
 
 
 class Action_Stmt_C201(Base):
     """
-    <action-stmt-c201> = <action-stmt>
+    ::
+
+        <action-stmt-c201> = <action-stmt>
+
     C201 is applied.
+
     """
+
     subclass_names = Action_Stmt.subclass_names[:]
-    subclass_names.remove('End_Function_Stmt')
-    subclass_names.remove('End_Subroutine_Stmt')
+    subclass_names.remove("End_Function_Stmt")
+    subclass_names.remove("End_Subroutine_Stmt")
     # subclass_names.remove('End_Program_Stmt')
 
 
 class Action_Stmt_C802(Base):
     """
-    <action-stmt-c802> = <action-stmt>
+    ::
+
+        <action-stmt-c802> = <action-stmt>
+
     C802 is applied.
+
     """
+
     subclass_names = Action_Stmt.subclass_names[:]
-    subclass_names.remove('End_Function_Stmt')
-    subclass_names.remove('End_Subroutine_Stmt')
-    subclass_names.remove('If_Stmt')
+    subclass_names.remove("End_Function_Stmt")
+    subclass_names.remove("End_Subroutine_Stmt")
+    subclass_names.remove("If_Stmt")
 
 
 class Action_Stmt_C824(Base):
     """
-    <action-stmt-c824> = <action-stmt>
+    ::
+
+        <action-stmt-c824> = <action-stmt>
+
     C824 is applied.
     """
+
     subclass_names = Action_Stmt.subclass_names[:]
-    subclass_names.remove('End_Function_Stmt')
-    subclass_names.remove('End_Subroutine_Stmt')
-    subclass_names.remove('Continue_Stmt')
-    subclass_names.remove('Goto_Stmt')
-    subclass_names.remove('Return_Stmt')
-    subclass_names.remove('Stop_Stmt')
-    subclass_names.remove('Exit_Stmt')
-    subclass_names.remove('Cycle_Stmt')
-    subclass_names.remove('Arithmetic_If_Stmt')
+    subclass_names.remove("End_Function_Stmt")
+    subclass_names.remove("End_Subroutine_Stmt")
+    subclass_names.remove("Continue_Stmt")
+    subclass_names.remove("Goto_Stmt")
+    subclass_names.remove("Return_Stmt")
+    subclass_names.remove("Stop_Stmt")
+    subclass_names.remove("Exit_Stmt")
+    subclass_names.remove("Cycle_Stmt")
+    subclass_names.remove("Arithmetic_If_Stmt")
 
 
 class Keyword(Base):  # R215
     """
-    <keyword> = <name>
+    ::
+
+        <keyword> = <name>
+
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
+
 
 #
 # SECTION  3
 #
 
 # R301: <character> = <alphanumeric-character> | <special-character>
 # R302: <alphanumeric-character> = <letter> | <digit> | <underscore>
 # R303: <underscore> = _
 
 
 class Name(StringBase):  # R304
-    '''
-    Fortran 2003 rule R304
-    name is letter [ alphanumeric_character ]...
+    """
+    Fortran 2003 rule R304::
+
+        name is letter [ alphanumeric_character ]...
+
+    """
 
-    '''
     # There are no other classes. This is a simple string match.
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''Match the string with the regular expression abs_name in the
+        """Match the string with the regular expression abs_name in the
         pattern_tools file.
 
         :param str string: the string to match with the pattern rule.
         :return: a tuple of size 1 containing a string with the \
         matched name if there is a match, or None if there is not.
         :rtype: (str) or None
 
-        '''
+        """
         return StringBase.match(pattern.abs_name, string.strip())
 
 
 class Constant(Base):  # R305
     """
-    <constant> = <literal-constant>
-                 | <named-constant>
+    ::
+
+        <constant> = <literal-constant>
+                     | <named-constant>
     """
-    subclass_names = ['Literal_Constant', 'Named_Constant']
+
+    subclass_names = ["Literal_Constant", "Named_Constant"]
 
 
 class Literal_Constant(Base):  # R306
     """
-    <literal-constant> = <int-literal-constant>
-                         | <real-literal-constant>
-                         | <complex-literal-constant>
-                         | <logical-literal-constant>
-                         | <char-literal-constant>
-                         | <boz-literal-constant>
+    ::
+
+        <literal-constant> = <int-literal-constant>
+                             | <real-literal-constant>
+                             | <complex-literal-constant>
+                             | <logical-literal-constant>
+                             | <char-literal-constant>
+                             | <boz-literal-constant>
     """
+
     subclass_names = [
-        'Int_Literal_Constant', 'Real_Literal_Constant',
-        'Complex_Literal_Constant', 'Logical_Literal_Constant',
-        'Char_Literal_Constant', 'Boz_Literal_Constant']
+        "Int_Literal_Constant",
+        "Real_Literal_Constant",
+        "Complex_Literal_Constant",
+        "Logical_Literal_Constant",
+        "Char_Literal_Constant",
+        "Boz_Literal_Constant",
+    ]
 
 
 class Named_Constant(Base):  # R307
     """
-    <named-constant> = <name>
+    ::
+        <named-constant> = <name>
+
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Int_Constant(Base):  # R308
     """
-    <int-constant> = <constant>
+    ::
+
+        <int-constant> = <constant>
     """
-    subclass_names = ['Constant']
+
+    subclass_names = ["Constant"]
 
 
 class Char_Constant(Base):  # R309
     """
-    <char-constant> = <constant>
+    ::
+
+        <char-constant> = <constant>
     """
-    subclass_names = ['Constant']
+
+    subclass_names = ["Constant"]
+
 
 # R310: <intrinsic-operator> = <power-op> | <mult-op> | <add-op> |
 # <concat-op> | <rel-op> | <not-op> | <and-op> | <or-op> | <equiv-op>
 # Rule 310 is defined in pattern_tools.py. As it is only used by Rule
 # 312 it does not need to be defined explicitly as a class. Note, it
 # could be created as a class if it were useful for code
 # manipulation. We could additionally create each of the operators
 # themselves as classes.
 
 
 class Defined_Operator(Base):  # pylint: disable=invalid-name
-    '''Fortran 2003 rule R311
-    R311 defined-operator is defined-unary-op
+    """
+    Fortran 2003 rule R311::
+
+        defined-operator is defined-unary-op
                           or defined-binary-op
                           or extended-intrinsic-op
 
     Note, defined-operator is defined in pattern_tools.py so could be
     called directly via a stringbase match. However, the defined unary
     and binary op rules have constraints which would not be checked if
     we did this.
 
     Note, whilst we subclass for both Defined Unary and Binary ops,
     the match is the same so we will only ever match with the first
     (so the second is not really necessary here). This is OK from a
     parsing point of view as they both return a Defined_Op class, so
     are identical from the parsers point of view.
 
-    '''
-    subclass_names = ['Defined_Unary_Op', 'Defined_Binary_Op',
-                      'Extended_Intrinsic_Op']
+    """
+
+    subclass_names = ["Defined_Unary_Op", "Defined_Binary_Op", "Extended_Intrinsic_Op"]
 
 
 class Extended_Intrinsic_Op(StringBase):  # pylint: disable=invalid-name
-    '''Fortran 2003 rule R312
-    R312 extended-intrinsic-op is intrinsic-operator
+    """
+    Fortran 2003 rule R312::
+
+        extended-intrinsic-op is intrinsic-operator
 
     Note, extended-intrinsic-op is only ever used by R311 and is
     defined in pattern_tools.py so could be matched directly in the
     Defined_Operator class (by changing it to STRINGBase and moving
     the match in this class into the Defined_Operator class). This
     would mean that this class would not be required. However, the
     parse tree would then not have the concept of an
     Extended_Intrinsic_Op which might be useful for code manipulation
     tools.
 
-    '''
+    """
+
     @staticmethod
     def match(string):
-        '''Implements the matching for the extended-intrinsic-op
+        """Implements the matching for the extended-intrinsic-op
         rule. Matches the string with the regular expression
         extended_intrinsic_operator in the pattern_tools file.
 
         :param str string: the string to match with the pattern rule.
         :return: a tuple of size 1 containing a string with the \
         matched name if there is a match, or None if there is not.
         :rtype: (str) or None
 
-        '''
+        """
         return StringBase.match(pattern.extended_intrinsic_operator, string)
 
 
 class Label(StringBase):  # R313
     """
-::
-    <label> = <digit> [ <digit> [ <digit> [ <digit> [ <digit> ] ] ] ]
+    ::
+
+        <label> = <digit> [ <digit> [ <digit> [ <digit> [ <digit> ] ] ] ]
 
-Attributes
-----------
-string : str
+    Has attributes::
+
+        string : str
     """
+
     subclass_names = []
 
     @staticmethod
     def match(string):
         return StringBase.match(pattern.abs_label, string)
 
     def __int__(self):
         return int(self.string)
 
+
 #
 # SECTION  4
 #
 
 
 class Type_Spec(Base):  # R401
     """
-    <type-spec> = <intrinsic-type-spec>
-                  | <derived-type-spec>
+    ::
+        <type-spec> = <intrinsic-type-spec>
+                      | <derived-type-spec>
     """
-    subclass_names = ['Intrinsic_Type_Spec', 'Derived_Type_Spec']
+
+    subclass_names = ["Intrinsic_Type_Spec", "Derived_Type_Spec"]
 
 
 class Type_Param_Value(StringBase):  # R402
     """
-    <type-param-value> = <scalar-int-expr>
-                       | *
-                       | :
+    Fortran 2003 Rule 402::
+
+        <type-param-value> = <scalar-int-expr>
+                           | *
+                           | :
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
     use_names = []
 
+    @staticmethod
     def match(string):
-        return StringBase.match(['*', ':'], string)
-    match = staticmethod(match)
+        return StringBase.match(["*", ":"], string)
 
 
 class Intrinsic_Type_Spec(WORDClsBase):  # R403
     """
-    <intrinsic-type-spec> = INTEGER [ <kind-selector> ]
-                            | REAL [ <kind-selector> ]
-                            | DOUBLE COMPLEX
-                            | COMPLEX [ <kind-selector> ]
-                            | CHARACTER [ <char-selector> ]
-                            | LOGICAL [ <kind-selector> ]
-    Extensions:
-                            | DOUBLE PRECISION
-                            | BYTE
-    """
-    subclass_names = []
-    use_names = ['Kind_Selector', 'Char_Selector']
-
-    def match(string):
-        for w, cls in [('INTEGER', Kind_Selector),
-                       ('REAL', Kind_Selector),
-                       ('COMPLEX', Kind_Selector),
-                       ('LOGICAL', Kind_Selector),
-                       ('CHARACTER', Char_Selector),
-                       (pattern.abs_double_complex_name, None),
-                       (pattern.abs_double_precision_name, None),
-                       ('BYTE', None)]:
+    ::
+
+        <intrinsic-type-spec> = INTEGER [ <kind-selector> ]
+                                | REAL [ <kind-selector> ]
+                                | DOUBLE COMPLEX
+                                | COMPLEX [ <kind-selector> ]
+                                | CHARACTER [ <char-selector> ]
+                                | LOGICAL [ <kind-selector> ]
+        Extensions:
+                                | DOUBLE PRECISION
+                                | BYTE
+    """
+
+    subclass_names = []
+    use_names = ["Kind_Selector", "Char_Selector"]
+
+    @staticmethod
+    def match(string):
+        for w, cls in [
+            ("INTEGER", Kind_Selector),
+            ("REAL", Kind_Selector),
+            ("COMPLEX", Kind_Selector),
+            ("LOGICAL", Kind_Selector),
+            ("CHARACTER", Char_Selector),
+            (pattern.abs_double_complex_name, None),
+            (pattern.abs_double_precision_name, None),
+            ("BYTE", None),
+        ]:
             try:
                 obj = WORDClsBase.match(w, cls, string)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return
-    match = staticmethod(match)
+        return None
 
 
 class Kind_Selector(Base):  # R404
-    '''
-    Fortran 2003 rule R404
-    kind-selector is ( [ KIND = ] scalar-int-initialization-expr )
-    A non-standard extension is also supported here:
-                      | * char-length
+    """
+    Fortran 2003 rule R404::
+
+        kind-selector is ( [ KIND = ] scalar-int-initialization-expr )
 
-    There is an associated constraint that we can't enforce in fparser:
+        A non-standard extension is also supported here:
+                          | * char-length
 
-    'C404 (R404) The value of scalar-int-initialization-expr shall be
-    nonnegative and shall specify a representation method that
-    exists on the processor.'
+    There is an associated constraint that we can't enforce in fparser::
+
+        C404 (R404) The value of scalar-int-initialization-expr shall be
+        nonnegative and shall specify a representation method that
+        exists on the processor.
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Char_Length', 'Scalar_Int_Initialization_Expr']
+    use_names = ["Char_Length", "Scalar_Int_Initialization_Expr"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Kind_Selector.
+        """Implements the matching for a Kind_Selector.
 
         :param str string: a string containing the code to match
         :return: `None` if there is no match, otherwise a `tuple` of \
         size 3 containing a '(', a single `list` which contains an \
         instance of classes that have matched and a ')', or a `tuple` \
         of size 2 containing a '*' and an instance of classes that \
         have matched.
@@ -906,1113 +1133,1376 @@
         string is at least 2 characters long and the logic in this \
         routine relies on this. The reason there is a minimum of two \
         is that the pattern '*n' where 'n' is a number is the smallest \
         valid pattern. The other valid pattern must have at least a \
         name with one character surrounded by brackets e.g. '(x)' so \
         should be at least 3 characters long.
 
-        '''
+        """
         if string is None:
             raise InternalError(
-                "String argument in class Kind_Selector method match() "
-                "is None.")
+                "String argument in class Kind_Selector method match() " "is None."
+            )
         if len(string) <= 1:
             raise InternalError(
                 "String argument '{0}' in class Kind_Selector method "
-                "match() is too short to be valid.".format(string))
+                "match() is too short to be valid.".format(string)
+            )
 
         # remove any leading or trailing white space
         string = string.strip()
 
-        if string[0]+string[-1] != '()':
+        if string[0] + string[-1] != "()":
             # must be the '*n' extension
-            if not string.startswith('*'):
+            if not string.startswith("*"):
                 return None
-            return '*', Char_Length(string[1:].lstrip())
+            return "*", Char_Length(string[1:].lstrip())
         # remove left and right brackets and subsequently any leading
         # or trailing spaces
         string = string[1:-1].strip()
         # check for optional 'kind='
         if len(string) > 5:
             # string is long enough to potentially contain 'kind=...'
-            if string[:4].upper() == 'KIND' and string[4:].lstrip()[0] == "=":
+            if string[:4].upper() == "KIND" and string[4:].lstrip()[0] == "=":
                 # found 'kind=' so strip it out, including any leading spaces
                 string = string[4:].lstrip()[1:].lstrip()
-        return '(', Scalar_Int_Initialization_Expr(string), ')'
+        return "(", Scalar_Int_Initialization_Expr(string), ")"
 
     def tostr(self):
-        '''
+        """
         :return: this kind_selector as a string
         :rtype: str
-        '''
+        """
         if len(self.items) == 2:
             result = "{0[0]}{0[1]}".format(self.items)
         elif len(self.items) == 3:
             result = "{0[0]}KIND = {0[1]}{0[2]}".format(self.items)
         else:
             raise InternalError(
                 "Class Kind_Selector method tostr() has '{0}' items, "
-                "but expecting 2 or 3.".format(len(self.items)))
+                "but expecting 2 or 3.".format(len(self.items))
+            )
         return result
 
 
 class Signed_Int_Literal_Constant(NumberBase):  # R405
     """
-    <signed-int-literal-constant> = [ <sign> ] <int-literal-constant>
+    ::
+        <signed-int-literal-constant> = [ <sign> ] <int-literal-constant>
+
     """
+
     # never used because sign is included in pattern
-    subclass_names = ['Int_Literal_Constant']
+    subclass_names = ["Int_Literal_Constant"]
 
+    @staticmethod
     def match(string):
-        return NumberBase.match(
-            pattern.abs_signed_int_literal_constant_named, string)
-    match = staticmethod(match)
+        return NumberBase.match(pattern.abs_signed_int_literal_constant_named, string)
 
 
 class Int_Literal_Constant(NumberBase):  # R406
     """
-    <int-literal-constant> = <digit-string> [ _ <kind-param> ]
+    ::
+        <int-literal-constant> = <digit-string> [ _ <kind-param> ]
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return NumberBase.match(
-            pattern.abs_int_literal_constant_named, string)
-    match = staticmethod(match)
+        return NumberBase.match(pattern.abs_int_literal_constant_named, string)
 
 
 class Digit_String(NumberBase):
     """
-    <digit-string> = <digit> [ <digit> ]...
+    ::
+
+        <digit-string> = <digit> [ <digit> ]...
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
         return NumberBase.match(pattern.abs_digit_string_named, string)
-    match = staticmethod(match)
+
 
 # R407: <kind-param> = <digit-string> | <scalar-int-constant-name>
 # R408: <signed-digit-string> = [ <sign> ] <digit-string>
 # R409: <digit-string> = <digit> [ <digit> ]...
 # R410: <sign> = + | -
 
 
 class Boz_Literal_Constant(Base):  # R411
     """
-    <boz-literal-constant> = <binary-constant>
-                             | <octal-constant>
-                             | <hex-constant>
+    ::
+
+        <boz-literal-constant> = <binary-constant>
+                                 | <octal-constant>
+                                 | <hex-constant>
     """
-    subclass_names = ['Binary_Constant', 'Octal_Constant', 'Hex_Constant']
+
+    subclass_names = ["Binary_Constant", "Octal_Constant", "Hex_Constant"]
 
 
 class Binary_Constant(STRINGBase):  # R412
     """
-    <binary-constant> = B ' <digit> [ <digit> ]... '
-                        | B \" <digit> [ <digit> ]... \"
+    ::
+
+        <binary-constant> = B ' <digit> [ <digit> ]... '
+                            | B \" <digit> [ <digit> ]... \"
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
         return STRINGBase.match(pattern.abs_binary_constant, string)
-    match = staticmethod(match)
 
 
 class Octal_Constant(STRINGBase):  # R413
     """
-    <octal-constant> = O ' <digit> [ <digit> ]... '
-                       | O \" <digit> [ <digit> ]... \"
+    ::
+
+        <octal-constant> = O ' <digit> [ <digit> ]... '
+                           | O \" <digit> [ <digit> ]... \"
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
         return STRINGBase.match(pattern.abs_octal_constant, string)
-    match = staticmethod(match)
 
 
 class Hex_Constant(STRINGBase):  # R414
     """
-    <hex-constant> = Z ' <digit> [ <digit> ]... '
-                     | Z \" <digit> [ <digit> ]... \"
+    ::
+
+        <hex-constant> = Z ' <digit> [ <digit> ]... '
+                         | Z \" <digit> [ <digit> ]... \"
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
         return STRINGBase.match(pattern.abs_hex_constant, string)
-    match = staticmethod(match)
+
 
 # R415: <hex-digit> = <digit> | A | B | C | D | E | F
 
 
 class Signed_Real_Literal_Constant(NumberBase):  # R416
     """
-    <signed-real-literal-constant> = [ <sign> ] <real-literal-constant>
+    ::
+
+        <signed-real-literal-constant> = [ <sign> ] <real-literal-constant>
     """
-    subclass_names = ['Real_Literal_Constant']  # never used
 
+    subclass_names = ["Real_Literal_Constant"]  # never used
+
+    @staticmethod
     def match(string):
-        return NumberBase.match(
-            pattern.abs_signed_real_literal_constant_named, string)
-    match = staticmethod(match)
+        return NumberBase.match(pattern.abs_signed_real_literal_constant_named, string)
 
 
 class Real_Literal_Constant(NumberBase):  # R417
-    """
-    """
+    """ """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return NumberBase.match(
-            pattern.abs_real_literal_constant_named, string)
-    match = staticmethod(match)
+        return NumberBase.match(pattern.abs_real_literal_constant_named, string)
+
 
 # R418: <significand> = <digit-string> . [ <digit-string> ]  | . <digit-string>
 # R419: <exponent-letter> = E | D
 # R420: <exponent> = <signed-digit-string>
 
 
 class Complex_Literal_Constant(Base):  # R421
     """
-    <complex-literal-constant> = ( <real-part>, <imag-part> )
+    ::
+
+        <complex-literal-constant> = ( <real-part>, <imag-part> )
     """
+
     subclass_names = []
-    use_names = ['Real_Part', 'Imag_Part']
+    use_names = ["Real_Part", "Imag_Part"]
 
+    @staticmethod
     def match(string):
-        if not string or string[0]+string[-1] != '()':
+        if not string or string[0] + string[-1] != "()":
             return
         if not pattern.abs_complex_literal_constant.match(string):
             return
-        r, i = string[1:-1].split(',')
+        r, i = string[1:-1].split(",")
         return Real_Part(r.strip()), Imag_Part(i.strip())
-    match = staticmethod(match)
 
     def tostr(self):
-        return '(%s, %s)' % tuple(self.items)
+        return "(%s, %s)" % tuple(self.items)
 
 
 class Real_Part(Base):  # R422
     """
-    <real-part> = <signed-int-literal-constant>
-                  | <signed-real-literal-constant>
-                  | <named-constant>
-    """
-    subclass_names = ['Signed_Int_Literal_Constant',
-                      'Signed_Real_Literal_Constant',
-                      'Named_Constant']
+    ::
+
+        <real-part> = <signed-int-literal-constant>
+                      | <signed-real-literal-constant>
+                      | <named-constant>
+    """
+
+    subclass_names = [
+        "Signed_Int_Literal_Constant",
+        "Signed_Real_Literal_Constant",
+        "Named_Constant",
+    ]
 
 
 class Imag_Part(Base):  # R423
     """
-    <imag-part> = <real-part>
+    ::
+
+        <imag-part> = <real-part>
+
     """
-    subclass_names = ['Signed_Int_Literal_Constant',
-                      'Signed_Real_Literal_Constant',
-                      'Named_Constant']
+
+    subclass_names = [
+        "Signed_Int_Literal_Constant",
+        "Signed_Real_Literal_Constant",
+        "Named_Constant",
+    ]
 
 
 class Char_Selector(Base):  # R424
     """
-    <char-selector> = <length-selector>
-                      | ( LEN = <type-param-value> ,
-                         KIND = <scalar-int-initialization-expr> )
-                      | ( <type-param-value> ,
-                         [ KIND = ] <scalar-int-initialization-expr> )
-                      | ( KIND = <scalar-int-initialization-expr>
-                        [ , LEN = <type-param-value> ] )
+    ::
+
+        <char-selector> = <length-selector>
+                          | ( LEN = <type-param-value> ,
+                             KIND = <scalar-int-initialization-expr> )
+                          | ( <type-param-value> ,
+                             [ KIND = ] <scalar-int-initialization-expr> )
+                          | ( KIND = <scalar-int-initialization-expr>
+                            [ , LEN = <type-param-value> ] )
+
     """
-    subclass_names = ['Length_Selector']
-    use_names = ['Type_Param_Value', 'Scalar_Int_Initialization_Expr']
 
+    subclass_names = ["Length_Selector"]
+    use_names = ["Type_Param_Value", "Scalar_Int_Initialization_Expr"]
+
+    @staticmethod
     def match(string):
-        if string[0] + string[-1] != '()':
+        if string[0] + string[-1] != "()":
             return
         line, repmap = string_replace_map(string[1:-1].strip())
-        if line[:3].upper() == 'LEN' and line[3:].lstrip().startswith('='):
+        if line[:3].upper() == "LEN" and line[3:].lstrip().startswith("="):
             line = line[3:].lstrip()
             line = line[1:].lstrip()
-            i = line.find(',')
+            i = line.find(",")
             if i == -1:
                 return
             v = line[:i].rstrip()
-            line = line[i+1:].lstrip()
-            if line[:4].upper() != 'KIND':
+            line = line[i + 1 :].lstrip()
+            if line[:4].upper() != "KIND":
                 return
             line = line[4:].lstrip()
-            if not line.startswith('='):
+            if not line.startswith("="):
                 return
             line = line[1:].lstrip()
             v = repmap(v)
             line = repmap(line)
             return Type_Param_Value(v), Scalar_Int_Initialization_Expr(line)
-        elif line[:4].upper() == 'KIND' and line[4:].lstrip().startswith('='):
+        elif line[:4].upper() == "KIND" and line[4:].lstrip().startswith("="):
             line = line[4:].lstrip()
             line = line[1:].lstrip()
-            i = line.find(',')
+            i = line.find(",")
             if i == -1:
                 return None, Scalar_Int_Initialization_Expr(line)
-            v = line[i+1:].lstrip()
+            v = line[i + 1 :].lstrip()
             line = line[:i].rstrip()
-            if v[:3].upper() != 'LEN':
+            if v[:3].upper() != "LEN":
                 return
             v = v[3:].lstrip()
-            if not v.startswith('='):
+            if not v.startswith("="):
                 return
             v = v[1:].lstrip()
             return Type_Param_Value(v), Scalar_Int_Initialization_Expr(line)
         else:
-            i = line.find(',')
+            i = line.find(",")
             if i == -1:
                 return
             v = line[:i].rstrip()
-            line = line[i+1:].lstrip()
-            if line[:4].upper() == 'KIND' and \
-               line[4:].lstrip().startswith('='):
+            line = line[i + 1 :].lstrip()
+            if line[:4].upper() == "KIND" and line[4:].lstrip().startswith("="):
                 line = line[4:].lstrip()
                 line = line[1:].lstrip()
             return Type_Param_Value(v), Scalar_Int_Initialization_Expr(line)
-        return
-    match = staticmethod(match)
+        return None
 
     def tostr(self):
         if self.items[0] is None:
-            return '(KIND = %s)' % (self.items[1])
-        return '(LEN = %s, KIND = %s)' % (self.items[0], self.items[1])
+            return "(KIND = %s)" % (self.items[1])
+        return "(LEN = %s, KIND = %s)" % (self.items[0], self.items[1])
 
 
 class Length_Selector(Base):  # R425
     """
-    <length -selector> = ( [ LEN = ] <type-param-value> )
-                        | * <char-length> [ , ]
+    ::
+
+        <length -selector> = ( [ LEN = ] <type-param-value> )
+                            | * <char-length> [ , ]
     """
+
     subclass_names = []
-    use_names = ['Type_Param_Value', 'Char_Length']
+    use_names = ["Type_Param_Value", "Char_Length"]
 
+    @staticmethod
     def match(string):
-        if string[0]+string[-1] == '()':
+        if string[0] + string[-1] == "()":
             line = string[1:-1].strip()
-            if line[:3].upper() == 'LEN' and line[3:].lstrip().startswith('='):
+            if line[:3].upper() == "LEN" and line[3:].lstrip().startswith("="):
                 line = line[3:].lstrip()
                 line = line[1:].lstrip()
-            return '(', Type_Param_Value(line), ')'
-        if not string.startswith('*'):
+            return "(", Type_Param_Value(line), ")"
+        if not string.startswith("*"):
             return
         line = string[1:].lstrip()
-        if string[-1] == ',':
+        if string[-1] == ",":
             line = line[:-1].rstrip()
-        return '*', Char_Length(line)
-    match = staticmethod(match)
+        return "*", Char_Length(line)
 
     def tostr(self):
         if len(self.items) == 2:
-            return '%s%s' % tuple(self.items)
-        return '%sLEN = %s%s' % tuple(self.items)
+            return "%s%s" % tuple(self.items)
+        return "%sLEN = %s%s" % tuple(self.items)
 
 
 class Char_Length(BracketBase):  # R426
     """
-    <char-length> = ( <type-param-value> )
-                    | <scalar-int-literal-constant>
+    ::
+
+        <char-length> = ( <type-param-value> )
+                        | <scalar-int-literal-constant>
     """
-    subclass_names = ['Scalar_Int_Literal_Constant']
-    use_names = ['Type_Param_Value']
 
-    def match(string): return BracketBase.match('()', Type_Param_Value, string)
-    match = staticmethod(match)
+    subclass_names = ["Scalar_Int_Literal_Constant"]
+    use_names = ["Type_Param_Value"]
+
+    @staticmethod
+    def match(string):
+        return BracketBase.match("()", Type_Param_Value, string)
 
 
 class Char_Literal_Constant(Base):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R427
+    """
+    Fortran 2003 rule R427::
+
+        char-literal-constant is [ kind-param _ ] ' rep-char '
+                              or [ kind-param _ ] " rep-char "
+    """
 
-    char-literal-constant is [ kind-param _ ] ' rep-char '
-                          or [ kind-param _ ] " rep-char "
-    '''
     subclass_names = []
     rep = pattern.char_literal_constant
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Char_Literal_Constant. For example
+        """
+        Implements the matching for a Char_Literal_Constant. For example::
 
-        "hello"
-        'hello'
-        nondefaultcharset_"nondefaultchars"
+            "hello"
+            'hello'
+            nondefaultcharset_"nondefaultchars"
 
         There is an associated constraint C422: "The value of
         kind-param shall specify a representation method that exists
         on the processor." However, this cannot be validated by
         fparser so no checks are performed.
 
         :param str string: a string containing the code to match.
+
         :return: `None` if there is no match, otherwise a `tuple` of
                  size 2 containing the character constant and the kind
                  value as strings.
         :rtype: `NoneType` or (`str`, `NoneType`) or (`str`, `str`)
 
-        '''
+        """
         if not string:
             return None
         strip_string = string.strip()
         if not strip_string:
             # the string is empty or only contains blank space
             return None
-        if strip_string[-1] not in '"\'':
+        if strip_string[-1] not in "\"'":
             return None
         if strip_string[-1] == '"':
-            abs_a_n_char_literal_constant_named = \
-                    pattern.abs_a_n_char_literal_constant_named2
+            abs_a_n_char_literal_constant_named = (
+                pattern.abs_a_n_char_literal_constant_named2
+            )
         else:
-            abs_a_n_char_literal_constant_named = \
-                    pattern.abs_a_n_char_literal_constant_named1
+            abs_a_n_char_literal_constant_named = (
+                pattern.abs_a_n_char_literal_constant_named1
+            )
         line, repmap = string_replace_map(strip_string)
         match = abs_a_n_char_literal_constant_named.match(line)
         if not match:
             return None
-        kind_param = match.group('kind_param')
-        line = match.group('value')
+        kind_param = match.group("kind_param")
+        line = match.group("value")
         line = repmap(line)
         return line, kind_param
 
     def tostr(self):
-        '''
+        """
         :return: this Char_Literal_Constant as a string.
         :rtype: str
+
         :raises InternalError: if the internal items list variable is \
-        not the expected size.
+                not the expected size.
         :raises InternalError: if the first element of the internal \
-        items list is None or is an empty string.
-
-        '''
+                items list is None or is an empty string.
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Class Char_Literal_Constant method tostr() has '{0}' items, "
-                "but expecting 2.".format(len(self.items)))
+                "but expecting 2.".format(len(self.items))
+            )
         if not self.items[0]:
             # items[0] is the value of the constant so is required. It
             # also can't be empty as it needs to include the
             # surrounding quotes to be valid
             raise InternalError(
                 "Class Char_Literal_Constant method tostr(). 'Items' entry 0 "
-                "should not be empty")
+                "should not be empty"
+            )
+        char_str = str(self.items[0])
         if not self.items[1]:
-            # Character literal has no kind specifier.
-            return str(self.items[0])
-        return "{0}_{1}".format(self.items[1], self.items[0])
+            return char_str
+        # The character constant has a kind specifier
+        kind_str = str(self.items[1])
+        return f"{kind_str}_{char_str}"
 
 
 class Logical_Literal_Constant(NumberBase):  # R428
     """
-    <logical-literal-constant> = .TRUE. [ _ <kind-param> ]
-                                 | .FALSE. [ _ <kind-param> ]
+    ::
+
+        <logical-literal-constant> = .TRUE. [ _ <kind-param> ]
+                                     | .FALSE. [ _ <kind-param> ]
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return NumberBase.match(pattern.abs_logical_literal_constant_named,
-                                string)
-    match = staticmethod(match)
+        return NumberBase.match(pattern.abs_logical_literal_constant_named, string)
 
 
 class Derived_Type_Def(BlockBase):  # R429
     """
-    <derived-type-def> = <derived-type-stmt>
-                           [ <type-param-def-stmt> ]...
-                           [ <private-or-sequence> ]...
-                           [ <component-part> ]
-                           [ <type-bound-procedure-part> ]
-                           <end-type-stmt>
+    ::
+
+        <derived-type-def> = <derived-type-stmt>
+                               [ <type-param-def-stmt> ]...
+                               [ <private-or-sequence> ]...
+                               [ <component-part> ]
+                               [ <type-bound-procedure-part> ]
+                               <end-type-stmt>
     """
+
     subclass_names = []
-    use_names = ['Derived_Type_Stmt', 'Type_Param_Def_Stmt',
-                 'Private_Or_Sequence', 'Component_Part',
-                 'Type_Bound_Procedure_Part', 'End_Type_Stmt']
+    use_names = [
+        "Derived_Type_Stmt",
+        "Type_Param_Def_Stmt",
+        "Private_Or_Sequence",
+        "Component_Part",
+        "Type_Bound_Procedure_Part",
+        "End_Type_Stmt",
+    ]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Derived_Type_Stmt,
-                               [Type_Param_Def_Stmt, Private_Or_Sequence,
-                                Component_Part, Type_Bound_Procedure_Part],
-                               End_Type_Stmt, reader,
-                               match_names=True  # C431
-                               )
+        return BlockBase.match(
+            Derived_Type_Stmt,
+            [
+                Type_Param_Def_Stmt,
+                Private_Or_Sequence,
+                Component_Part,
+                Type_Bound_Procedure_Part,
+            ],
+            End_Type_Stmt,
+            reader,
+            match_names=True,  # C431
+        )
 
 
 class Derived_Type_Stmt(StmtBase):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R430
+    """
+    Fortran 2003 rule R430::
 
-    derived-type-stmt is TYPE [ [ , type-attr-spec-list ] :: ]
-                         type-name [ ( type-param-name-list ) ]
+        derived-type-stmt is TYPE [ [ , type-attr-spec-list ] :: ]
+                             type-name [ ( type-param-name-list ) ]
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Type_Attr_Spec_List', 'Type_Name', 'Type_Param_Name_List']
+    use_names = ["Type_Attr_Spec_List", "Type_Name", "Type_Param_Name_List"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Derived Type Statement.
+        """Implements the matching for a Derived Type Statement.
 
         :param str string: a string containing the code to match
         :return: `None` if there is no match, otherwise a `tuple` of \
                  size 3 containing an `Attribute_Spec_List` (or `None` if \
                  there isn't one), the name of the type (in a `Name` \
                  class) and a `Parameter_Name_List` (or `None` is there \
                  isn't one).
         :rtype: ( `Type_Attr_Spec_List` or `None`, `Name`, \
                   `Type_Param_Name_List` or `None` ) or `None`
 
-        '''
+        """
         string_strip = string.strip()
-        if string_strip[:4].upper() != 'TYPE':
+        if string_strip[:4].upper() != "TYPE":
             return None
         line = string_strip[4:].lstrip()
-        position = line.find('::')
+        position = line.find("::")
         attr_specs = None
         if position != -1:
-            if line.startswith(','):
+            if line.startswith(","):
                 lstrip = line[1:position].strip()
                 if not lstrip:
                     # There is no content after the "," and before the
                     # "::"
                     return None
                 attr_specs = Type_Attr_Spec_List(lstrip)
             elif line[:position].strip():
                 # There is invalid content between and 'TYPE' and '::'
                 return None
-            line = line[position+2:].lstrip()
+            line = line[position + 2 :].lstrip()
         match = pattern.name.match(line)
         if not match:
             # There is no content after the "TYPE" or the "::"
             return None
         name = Type_Name(match.group())
-        line = line[match.end():].lstrip()
+        line = line[match.end() :].lstrip()
         if not line:
             return attr_specs, name, None
-        if line[0] + line[-1] != '()':
+        if line[0] + line[-1] != "()":
             return None
         return attr_specs, name, Type_Param_Name_List(line[1:-1].strip())
 
     def tostr(self):
-        '''
+        """
         :return: this derived type statement as a string
         :rtype: str
         :raises InternalError: if items array is not the expected size
         :raises InternalError: if items array[1] has no content
 
-        '''
+        """
         if len(self.items) != 3:
             raise InternalError(
                 "Derived_Type_Stmt.tostr(). 'items' should be of size 3 but "
-                "found '{0}'.".format(len(self.items)))
+                "found '{0}'.".format(len(self.items))
+            )
         if not self.items[1]:
             raise InternalError(
                 "Derived_Type_Stmt.tostr(). 'items[1]' should be a Name "
-                "instance containing the derived type name but it is empty")
-        string = 'TYPE'
+                "instance containing the derived type name but it is empty"
+            )
+        string = "TYPE"
         if self.items[0]:
             string += ", {0} :: {1}".format(self.items[0], self.items[1])
         else:
             string += " :: {0}".format(self.items[1])
         if self.items[2]:
             string += "({0})".format(self.items[2])
         return string
 
     def get_start_name(self):
-        '''
+        """
         :return: this derived type statement's name as a string
         :rtype: str
 
-        '''
+        """
         return self.items[1].string
 
 
 class Type_Name(Name):  # C424
     """
-    <type-name> = <name>
-    <type-name> shall not be DOUBLEPRECISION or the name of intrinsic type
+    ::
+
+        <type-name> = <name>
+        <type-name> shall not be DOUBLEPRECISION or the name of intrinsic type
+
     """
+
     subclass_names = []
     use_names = []
 
+    @staticmethod
     def match(string):
         if pattern.abs_intrinsic_type_name.match(string):
             return
         return Name.match(string)
-    match = staticmethod(match)
 
 
 class Type_Attr_Spec(Base):  # R431
     """
-    <type-attr-spec> = <access-spec>
-                       | EXTENDS ( <parent-type-name> )
-                       | ABSTRACT
-                       | BIND (C)
+    ::
+
+        <type-attr-spec> = <access-spec>
+                           | EXTENDS ( <parent-type-name> )
+                           | ABSTRACT
+                           | BIND (C)
+
     """
-    subclass_names = ['Access_Spec', 'Language_Binding_Spec'][:-1]
-    use_names = ['Parent_Type_Name']
+
+    subclass_names = ["Access_Spec", "Language_Binding_Spec"][:-1]
+    use_names = ["Parent_Type_Name"]
 
     @staticmethod
     def match(string):
-        if len(string) == 8 and string.upper() == 'ABSTRACT':
-            return 'ABSTRACT', None
-        if string[:4].upper() == 'BIND':
+        if len(string) == 8 and string.upper() == "ABSTRACT":
+            return "ABSTRACT", None
+        if string[:4].upper() == "BIND":
             line = string[4:].lstrip()
-            if not line or line[0]+line[-1] != '()':
+            if not line or line[0] + line[-1] != "()":
                 return
             line = line[1:-1].strip()
-            if line.upper() == 'C':
-                return 'BIND', 'C'
-        elif string[:7].upper() == 'EXTENDS':
+            if line.upper() == "C":
+                return "BIND", "C"
+        elif string[:7].upper() == "EXTENDS":
             line = string[7:].lstrip()
-            if not line or line[0]+line[-1] != '()':
+            if not line or line[0] + line[-1] != "()":
                 return
-            return 'EXTENDS', Parent_Type_Name(line[1:-1].strip())
+            return "EXTENDS", Parent_Type_Name(line[1:-1].strip())
 
     def tostr(self):
         if self.items[1] is None:
-            return '%s' % (self.items[0])
-        return '%s(%s)' % (self.items)
+            return "%s" % (self.items[0])
+        return "%s(%s)" % (self.items)
 
 
 class Private_Or_Sequence(Base):  # R432
     """
-    <private-or-sequence> = <private-components-stmt>
-                            | <sequence-stmt>
+    ::
+
+        <private-or-sequence> = <private-components-stmt>
+                                | <sequence-stmt>
+
     """
-    subclass_names = ['Private_Components_Stmt', 'Sequence_Stmt']
+
+    subclass_names = ["Private_Components_Stmt", "Sequence_Stmt"]
 
 
 class End_Type_Stmt(EndStmtBase):  # R433
     """
-    <end-type-stmt> = END TYPE [ <type-name> ]
+    ::
+
+        <end-type-stmt> = END TYPE [ <type-name> ]
+
     """
+
     subclass_names = []
-    use_names = ['Type_Name']
+    use_names = ["Type_Name"]
 
     @staticmethod
     def match(string):
-        return EndStmtBase.match('TYPE', Type_Name, string,
-                                 require_stmt_type=True)
+        return EndStmtBase.match("TYPE", Type_Name, string, require_stmt_type=True)
 
 
 class Sequence_Stmt(STRINGBase):  # R434
     """
-    <sequence-stmt> = SEQUENCE
+    ::
+
+        <sequence-stmt> = SEQUENCE
+
     """
+
     subclass_names = []
 
     @staticmethod
     def match(string):
-        return STRINGBase.match('SEQUENCE', string)
+        return STRINGBase.match("SEQUENCE", string)
 
 
 class Type_Param_Def_Stmt(StmtBase):  # R435
     """
-    <type-param-def-stmt> = INTEGER [ <kind-selector> ] ,
-        <type-param-attr-spec> :: <type-param-decl-list>
+    ::
+
+        <type-param-def-stmt> = INTEGER [ <kind-selector> ] ,
+            <type-param-attr-spec> :: <type-param-decl-list>
+
     """
+
     subclass_names = []
-    use_names = ['Kind_Selector', 'Type_Param_Attr_Spec',
-                 'Type_Param_Decl_List']
+    use_names = ["Kind_Selector", "Type_Param_Attr_Spec", "Type_Param_Decl_List"]
 
+    @staticmethod
     def match(string):
-        if string[:7].upper() != 'INTEGER':
+        if string[:7].upper() != "INTEGER":
             return
         line, repmap = string_replace_map(string[7:].lstrip())
         if not line:
             return
-        i = line.find(',')
+        i = line.find(",")
         if i == -1:
             return
         kind_selector = repmap(line[:i].rstrip()) or None
-        line = repmap(line[i+1:].lstrip())
-        i = line.find('::')
+        line = repmap(line[i + 1 :].lstrip())
+        i = line.find("::")
         if i == -1:
             return
         l1 = line[:i].rstrip()
-        l2 = line[i+2:].lstrip()
+        l2 = line[i + 2 :].lstrip()
         if not l1 or not l2:
             return
         if kind_selector:
             kind_selector = Kind_Selector(kind_selector)
-        return kind_selector, Type_Param_Attr_Spec(l1), \
-            Type_Param_Decl_List(l2)
-    match = staticmethod(match)
+        return kind_selector, Type_Param_Attr_Spec(l1), Type_Param_Decl_List(l2)
 
     def tostr(self):
-        s = 'INTEGER'
+        s = "INTEGER"
         if self.items[0] is not None:
-            s += '%s, %s :: %s' % tuple(self.items)
+            s += "%s, %s :: %s" % tuple(self.items)
         else:
-            s += ', %s :: %s' % tuple(self.items[1:])
+            s += ", %s :: %s" % tuple(self.items[1:])
         return s
 
 
 class Type_Param_Decl(BinaryOpBase):  # R436
     """
-    <type-param-decl> = <type-param-name>
-        [ = <scalar-int-initialization-expr> ]
+    ::
+        <type-param-decl> = <type-param-name>
+            [ = <scalar-int-initialization-expr> ]
+
     """
-    subclass_names = ['Type_Param_Name']
-    use_names = ['Scalar_Int_Initialization_Expr']
 
+    subclass_names = ["Type_Param_Name"]
+    use_names = ["Scalar_Int_Initialization_Expr"]
+
+    @staticmethod
     def match(string):
-        if '=' not in string:
+        if "=" not in string:
             return
-        lhs, rhs = string.split('=', 1)
+        lhs, rhs = string.split("=", 1)
         lhs = lhs.rstrip()
         rhs = rhs.lstrip()
         if not lhs or not rhs:
             return
-        return Type_Param_Name(lhs), '=', Scalar_Int_Initialization_Expr(rhs)
-    match = staticmethod(match)
+        return Type_Param_Name(lhs), "=", Scalar_Int_Initialization_Expr(rhs)
 
 
 class Type_Param_Attr_Spec(STRINGBase):  # R437
     """
-    <type-param-attr-spec> = KIND
-                             | LEN
+    ::
+
+        <type-param-attr-spec> = KIND
+                                 | LEN
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['KIND', 'LEN'], string)
-    match = staticmethod(match)
+        return STRINGBase.match(["KIND", "LEN"], string)
 
 
 class Component_Part(BlockBase):  # R438
     """
-    <component-part> = [ <component-def-stmt> ]...
+    ::
+
+        <component-part> is [ <component-def-stmt> ]...
+
     """
+
     subclass_names = []
-    use_names = ['Component_Def_Stmt']
+    use_names = ["Component_Def_Stmt"]
 
+    @staticmethod
     def match(reader):
         content = []
         while 1:
             try:
                 obj = Component_Def_Stmt(reader)
             except NoMatchError:
                 obj = None
             if obj is None:
                 break
             content.append(obj)
         if content:
-            return content,
-        return
-    match = staticmethod(match)
+            return (content,)
+        return None
+
+    def tofortran(self, tab="", isfix=None):
+        """
+        Converts this node (and all children) into Fortran.
 
-    def tofortran(self, tab='', isfix=None):
+        :param str tab: white space to prefix to output.
+        :param bool isfix: whether or not to generate fixed-format output.
+
+        :returns: Fortran code.
+        :rtype: str
+
+        """
         mylist = []
         for item in self.content:
             mylist.append(item.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(mylist)
+        return "\n".join(mylist)
 
 
 class Component_Def_Stmt(Base):  # R439
     """
-    <component-def-stmt> = <data-component-def-stmt>
-                           | <proc-component-def-stmt>
+    ::
+
+        <component-def-stmt> is <data-component-def-stmt>
+                             or <proc-component-def-stmt>
+
     """
-    subclass_names = ['Data_Component_Def_Stmt', 'Proc_Component_Def_Stmt']
+
+    subclass_names = ["Data_Component_Def_Stmt", "Proc_Component_Def_Stmt"]
 
 
 class Data_Component_Def_Stmt(Type_Declaration_StmtBase):  # R440
     """
-    <data-component-def-stmt> = <declaration-type-spec> [
-        [ , <component-attr-spec-list> ] :: ] <component-decl-list>
+    Fortran 2003 rule 440::
+
+        <data-component-def-stmt> is <declaration-type-spec> [
+                 [ , <component-attr-spec-list> ] :: ] <component-decl-list>
+
+    Associated constraints are::
+
+        C436 (R440)  No component-attr-spec shall appear more than once in a given
+             component-def-stmt.
+        C437 (R440)  A component declared with the CLASS keyword shall have the
+             ALLOCATABLE or POINTER attribute.
+        C438 (R440)  If the POINTER attribute is not specified for a component,
+             the declaration-type-spec in the component-def-stmt shall be CLASS(*)
+             or shall specify an intrinsic type or a previously defined derived
+             type.
+        C439 (R440)  If the POINTER attribute is specified for a component, the
+             declaration-type-spec in the component-def-stmt shall be CLASS(*) or
+             shall specify an intrinsic type or any accessible derived type
+             including the type being defined.
+        C440 (R440)  If the POINTER or ALLOCATABLE attribute is specified, each
+             component-array-spec shall be a deferred-shape-spec-list.
+        C441 (R440)  If neither the POINTER attribute nor the ALLOCATABLE
+             attribute is specified, each component-array-spec shall be an
+             explicit-shape-spec-list.
+        C443 (R440)  A component shall not have both the ALLOCATABLE and the
+             POINTER attribute.
+        C446 (R440)  If component-initialization appears, a double-colon separator
+             shall appear before the component-decl-list.
+        C447 (R440)  If => appears in component-initialization, POINTER shall
+             appear in the component-attr-spec-list. If = appears in
+             component-initialization, POINTER or ALLOCATABLE shall not appear in
+             the component-attr-spec-list.
+
+    C436-C441, C443, C446-C447 are currently not checked - issue #258.
+
     """
+
     subclass_names = []
-    use_names = ['Declaration_Type_Spec', 'Component_Attr_Spec_List',
-                 'Component_Decl_List']
+    use_names = [
+        "Declaration_Type_Spec",
+        "Component_Attr_Spec_List",
+        "Component_Decl_List",
+    ]
 
     @staticmethod
     def match(string):
         return Type_Declaration_StmtBase.match(
-            Declaration_Type_Spec, Component_Attr_Spec_List,
-            Component_Decl_List, string)
+            Declaration_Type_Spec, Component_Attr_Spec_List, Component_Decl_List, string
+        )
 
 
 class Dimension_Component_Attr_Spec(CALLBase):
     """
-    <dimension-component-attr-spec> = DIMENSION ( <component-array-spec> )
+    ::
+
+        <dimension-component-attr-spec> = DIMENSION ( <component-array-spec> )
+
     """
+
     subclass_names = []
-    use_names = ['Component_Array_Spec']
+    use_names = ["Component_Array_Spec"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match('DIMENSION', Component_Array_Spec, string)
-    match = staticmethod(match)
+        return CALLBase.match("DIMENSION", Component_Array_Spec, string)
 
 
 class Component_Attr_Spec(STRINGBase):  # R441
     """
-    <component-attr-spec> = POINTER
-                            | DIMENSION ( <component-array-spec> )
-                            | ALLOCATABLE
-                            | <access-spec>
+    ::
+
+        <component-attr-spec> = POINTER
+                                | DIMENSION ( <component-array-spec> )
+                                | ALLOCATABLE
+                                | <access-spec>
+
     """
-    subclass_names = ['Access_Spec', 'Dimension_Component_Attr_Spec']
+
+    subclass_names = ["Access_Spec", "Dimension_Component_Attr_Spec"]
     use_names = []
+    attributes = ["POINTER", "ALLOCATABLE"]
 
-    @staticmethod
-    def match(string):
-        return STRINGBase.match(['POINTER', 'ALLOCATABLE'], string)
+    @classmethod
+    def match(cls, string):
+        """Implements the matching for component attribute specifications.
+
+        Note that this is implemented as a `classmethod` (not a
+        `staticmethod`), using attribute keywords from the list provided
+        as a class property. This allows expanding this list for
+        Fortran 2008 without having to reimplement the matching.
+
+        :param str string: the string to match as an attribute.
+
+        :return: None if there is no match, otherwise a 1-tuple \
+            containing the matched attribute string.
+        :rtype: NoneType or (str,)
+
+        """
+        return STRINGBase.match(cls.attributes, string)
 
 
 class Component_Decl(Base):  # R442
     """
-    <component-decl> = <component-name> [ ( <component-array-spec> ) ]
-        [ * <char-length> ] [ <component-initialization> ]
+    ::
+
+        <component-decl> = <component-name> [ ( <component-array-spec> ) ]
+            [ * <char-length> ] [ <component-initialization> ]
+
     """
+
     subclass_names = []
-    use_names = ['Component_Name', 'Component_Array_Spec',
-                 'Char_Length', 'Component_Initialization']
+    use_names = [
+        "Component_Name",
+        "Component_Array_Spec",
+        "Char_Length",
+        "Component_Initialization",
+    ]
 
+    @staticmethod
     def match(string):
         m = pattern.name.match(string)
         if m is None:
             return
         name = Component_Name(m.group())
-        newline = string[m.end():].lstrip()
+        newline = string[m.end() :].lstrip()
         if not newline:
             return name, None, None, None
         array_spec = None
         char_length = None
         init = None
-        if newline.startswith('('):
+        if newline.startswith("("):
             line, repmap = string_replace_map(newline)
-            i = line.find(')')
+            i = line.find(")")
             if i == -1:
                 return
             array_spec = Component_Array_Spec(repmap(line[1:i].strip()))
-            newline = repmap(line[i+1:].lstrip())
-        if newline.startswith('*'):
+            newline = repmap(line[i + 1 :].lstrip())
+        if newline.startswith("*"):
             line, repmap = string_replace_map(newline)
-            i = line.find('=')
+            i = line.find("=")
             if i != -1:
                 char_length = repmap(line[1:i].strip())
                 newline = repmap(newline[i:].lstrip())
             else:
                 char_length = repmap(newline[1:].strip())
-                newline = ''
+                newline = ""
             char_length = Char_Length(char_length)
-        if newline.startswith('='):
+        if newline.startswith("="):
             init = Component_Initialization(newline)
         else:
-            assert newline == '', repr(newline)
+            assert newline == "", repr(newline)
         return name, array_spec, char_length, init
-    match = staticmethod(match)
 
     def tostr(self):
         s = str(self.items[0])
         if self.items[1] is not None:
-            s += '(' + str(self.items[1]) + ')'
+            s += "(" + str(self.items[1]) + ")"
         if self.items[2] is not None:
-            s += '*' + str(self.items[2])
+            s += "*" + str(self.items[2])
         if self.items[3] is not None:
-            s += ' ' + str(self.items[3])
+            s += " " + str(self.items[3])
         return s
 
 
 class Component_Array_Spec(Base):  # R443
     """
-    <component-array-spec> = <explicit-shape-spec-list>
-                             | <deferred-shape-spec-list>
+    ::
+
+        <component-array-spec> = <explicit-shape-spec-list>
+                                 | <deferred-shape-spec-list>
+
     """
-    subclass_names = ['Explicit_Shape_Spec_List', 'Deferred_Shape_Spec_List']
+
+    subclass_names = ["Explicit_Shape_Spec_List", "Deferred_Shape_Spec_List"]
 
 
 class Component_Initialization(Base):  # R444
     """
-    <component-initialization> =  = <initialization-expr>
-                                 | => <null-init>
+    ::
+
+        <component-initialization> =  = <initialization-expr>
+                                     | => <null-init>
+
     """
+
     subclass_names = []
-    use_names = ['Initialization_Expr', 'Null_Init']
+    use_names = ["Initialization_Expr", "Null_Init"]
 
+    @staticmethod
     def match(string):
-        if string.startswith('=>'):
-            return '=>', Null_Init(string[2:].lstrip())
-        if string.startswith('='):
-            return '=', Initialization_Expr(string[1:].lstrip())
-        return
-    match = staticmethod(match)
+        if string.startswith("=>"):
+            return "=>", Null_Init(string[2:].lstrip())
+        if string.startswith("="):
+            return "=", Initialization_Expr(string[1:].lstrip())
+        return None
 
     def tostr(self):
-        return '%s %s' % tuple(self.items)
+        return "%s %s" % tuple(self.items)
 
 
 class Proc_Component_Def_Stmt(StmtBase):  # R445
     """
-    <proc-component-def-stmt> = PROCEDURE ( [ <proc-interface> ] )
-        , <proc-component-attr-spec-list> :: <proc-decl-list>
+    ::
+
+        <proc-component-def-stmt> is PROCEDURE ( [ <proc-interface> ] )
+            , <proc-component-attr-spec-list> :: <proc-decl-list>
+
+    where::
+
+        proc-component-attr-spec is POINTER
+                                 or PASS [ (arg-name) ]
+                                 or NOPASS
+                                 or access-spec
+
+    The standard specifies the following constraints::
+
+        C448 The same proc-component-attr-spec shall not appear more than once
+             in a given proc-component-def-stmt. Not checked by fparser - #232.
+
+        C449 POINTER shall appear in each proc-component-attr-spec-list.
+
+        C450 If the procedure pointer component has an implicit interface or
+             has no arguments, NOPASS shall be specified. Not checked by
+             fparser - #232.
+
+        C451 If PASS (arg-name) appears, the interface shall have a dummy argument
+             named arg-name. Not checked by fparser - #232.
+
+        C452 PASS and NOPASS shall not both appear in the same
+             proc-component-attr-spec-list. Not checked by fparser - #232.
+
     """
+
     subclass_names = []
-    use_names = ['Proc_Interface', 'Proc_Component_Attr_Spec_List',
-                 'Proc_Decl_List']
+    use_names = ["Proc_Interface", "Proc_Component_Attr_Spec_List", "Proc_Decl_List"]
 
     @staticmethod
     def match(string):
-        if string[:9].upper() != 'PROCEDURE':
-            return
+        """
+        Attempts to match the supplied string with the pattern for a
+        declaration of a procedure part of a component.
+
+        :param str string: the string to test for a match.
+
+        :returns: None (if no match) or a tuple consisting of the procedure \
+                  interface, the list of attributes and a list of procedure \
+                  names or None.
+        :rtype: NoneType or \
+           (:py:class:`fparser.two.Fortran2003.Proc_Interface`, \
+            :py:class:`fparser.two.Fortran2003.Proc_Component_Attr_Spec_List`,\
+            :py:class:`fparser.two.Fortran2003.Proc_Decl_List`)
+        """
+        if string[:9].upper() != "PROCEDURE":
+            return None
         line, repmap = string_replace_map(string[9:].lstrip())
-        if not line.startswith('('):
-            return
-        i = line.find(')')
-        if i == -1:
-            return
-        p = repmap(line[:i+1])[1:-1].strip() or None
-        if p:
-            p = Proc_Interface(p)
-        line = line[i+1:].lstrip()
-        if not line.startswith(','):
-            return
+        if not line.startswith("("):
+            return None
+        idx = line.find(")")
+        if idx == -1:
+            return None
+        pinterface = repmap(line[: idx + 1])[1:-1].strip() or None
+        if pinterface:
+            pinterface = Proc_Interface(pinterface)
+        line = line[idx + 1 :].lstrip()
+        if not line.startswith(","):
+            return None
         line = line[1:].strip()
-        i = line.find('::')
-        if i == -1:
-            return
-        return p, Proc_Component_Attr_Spec_List(
-            repmap(line[:i].rstrip())), Proc_Decl_List(
-                repmap(line[i+2:].lstrip()))
+        idx = line.find("::")
+        if idx == -1:
+            return None
+        attr_spec_list = Proc_Component_Attr_Spec_List(repmap(line[:idx].rstrip()))
+        # C449 POINTER must be present in the attribute list
+        if Proc_Component_Attr_Spec("POINTER") not in attr_spec_list.items:
+            return None
+        return (
+            pinterface,
+            attr_spec_list,
+            Proc_Decl_List(repmap(line[idx + 2 :].lstrip())),
+        )
 
     def tostr(self):
         if self.items[0] is not None:
-            return 'PROCEDURE(%s), %s :: %s' % (self.items)
-        return 'PROCEDURE(), %s :: %s' % (self.items[1:])
+            return "PROCEDURE(%s), %s :: %s" % (self.items)
+        return "PROCEDURE(), %s :: %s" % (self.items[1:])
 
 
 class Proc_Component_PASS_Arg_Name(CALLBase):
     """
-    <proc-component-PASS-arg-name> = PASS ( <arg-name> )
+    ::
+
+        <proc-component-PASS-arg-name> = PASS ( <arg-name> )
+
     """
+
     subclass_names = []
-    use_names = ['Arg_Name']
+    use_names = ["Arg_Name"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match('PASS', Arg_Name, string)
-    match = staticmethod(match)
+        return CALLBase.match("PASS", Arg_Name, string)
 
 
 class Proc_Component_Attr_Spec(STRINGBase):  # R446
     """
-    <proc-component-attr-spec> = POINTER
-                                 | PASS [ ( <arg-name> ) ]
-                                 | NOPASS
-                                 | <access-spec>
+    ::
+
+        <proc-component-attr-spec> = POINTER
+                                     | PASS [ ( <arg-name> ) ]
+                                     | NOPASS
+                                     | <access-spec>
+
     """
-    subclass_names = ['Access_Spec', 'Proc_Component_PASS_Arg_Name']
 
+    subclass_names = ["Access_Spec", "Proc_Component_PASS_Arg_Name"]
+
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['POINTER', 'PASS', 'NOPASS'],
-                                string.upper())
-    match = staticmethod(match)
+        return STRINGBase.match(["POINTER", "PASS", "NOPASS"], string.upper())
 
 
 class Private_Components_Stmt(STRINGBase):  # pylint: disable=invalid-name
-    '''
-    :F03R:`447`::
+    """
+    Fortran2003 Rule R447::
 
-    Fortran 2003 rule R447
-    that specifies support for private components statement
-    within a derived type.
+        <private-components-stmt> = PRIVATE
+
+    Specifies support for private components statement within a derived type.
+
+    """
 
-    <private-components-stmt> = PRIVATE
-    '''
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: keyword  "PRIVATE" or None if no match is found
         :rtype: str or None
-        '''
-        return StringBase.match('PRIVATE', string.upper())
+        """
+        return StringBase.match("PRIVATE", string.upper())
 
 
 class Type_Bound_Procedure_Part(BlockBase):  # pylint: disable=invalid-name
-    '''
-    :F03R:`448`::
+    """
+    Fortran 2003 rule R448.
+
+    Specifies the type-bound procedure part of a derived type::
 
-    Fortran 2003 rule R448
-    that specifies the type-bound procedure part of a derived type.
+        type-bound-procedure-part is contains-stmt
+                                          [ binding-private-stmt ]
+                                          proc-binding-stmt
+                                          [ proc-binding-stmt ]...
+
+    """
 
-    <type-bound-procedure-part> = <contains-stmt>
-                                      [ <binding-private-stmt> ]
-                                      <proc-binding-stmt>
-                                      [ <proc-binding-stmt> ]...
-    '''
     subclass_names = []
-    use_names = ['Contains_Stmt', 'Binding_Private_Stmt', 'Proc_Binding_Stmt']
+    use_names = ["Contains_Stmt", "Binding_Private_Stmt", "Proc_Binding_Stmt"]
 
     @staticmethod
     def match(reader):
-        '''
+        """
         :param reader: the Fortran reader containing the line(s) of code \
         that we are trying to match
         :type reader: :py:class:`fparser.common.readfortran.FortranReaderBase`
+
         :return: code block containing instances of the classes that match \
                  the syntax of the type-bound procedure part of a derived type.
         :rtype: ([`Contains_Stmt`, `Specific_Binding`, `str`, `Name`, \
                   `Name`]) or `None`
-        '''
-        return BlockBase.match(Contains_Stmt,
-                               [Binding_Private_Stmt, Proc_Binding_Stmt],
-                               None, reader)
+        """
+        return BlockBase.match(
+            Contains_Stmt, [Binding_Private_Stmt, Proc_Binding_Stmt], None, reader
+        )
 
 
-class Binding_Private_Stmt(StmtBase,
-                           STRINGBase):  # pylint: disable=invalid-name
-    '''
-    :F03R:`449`::
+class Binding_Private_Stmt(StmtBase, STRINGBase):  # pylint: disable=invalid-name
+    """
+    Fortran2003 Rule R449::
+
+        <binding-private-stmt> = PRIVATE
 
-    Fortran 2003 rule R449
-    for binding private statement within the type-bound procedure
+    For binding private statement within the type-bound procedure
     part of a derived type.
 
-    <binding-private-stmt> = PRIVATE
-    '''
+    """
+
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
+
         :return: keyword  "PRIVATE" or None if no match is found
         :rtype: str or None
-        '''
-        return StringBase.match('PRIVATE', string.upper())
+        """
+        return StringBase.match("PRIVATE", string.upper())
 
 
 class Proc_Binding_Stmt(Base):  # pylint: disable=invalid-name
-    '''
-    :F03R:`450`::
+    """
+    Fortran2003 Rule R450::
 
-    Fortran 2003 rule R450
-    that specifies procedure binding for the type-bound procedures
+        <proc-binding-stmt> = <specific-binding>
+                              | <generic-binding>
+                              | <final-binding>
+
+    Specifies the procedure binding for the type-bound procedures
     within a derived type.
 
-    <proc-binding-stmt> = <specific-binding>
-                          | <generic-binding>
-                          | <final-binding>
-    '''
-    subclass_names = ['Specific_Binding', 'Generic_Binding', 'Final_Binding']
+    """
+
+    subclass_names = ["Specific_Binding", "Generic_Binding", "Final_Binding"]
 
 
 class Specific_Binding(StmtBase):  # pylint: disable=invalid-name
-    ''':F03R:`451`::
+    """Fortran2003 Rule R451::
+
+        <specific-binding> = PROCEDURE [ ( <interface-name> ) ] [
+            [ , <binding-attr-list> ] :: ] <binding-name> [ => <procedure-name> ]
 
-    Fortran 2003 rule R451
-    that specifies syntax of specific binding for a type-bound
+    Specifies the syntax of specific binding for a type-bound
     procedure within a derived type.
 
-    <specific-binding> = PROCEDURE [ ( <interface-name> ) ] [
-        [ , <binding-attr-list> ] :: ] <binding-name> [ => <procedure-name> ]
+    The following are associated constraints::
 
-    The following are associated constraints:
+        C456 (R451) If => procedure-name appears, the double-colon
+        separator shall appear.
 
-    "C456 (R451) If => procedure-name appears, the double-colon
-    separator shall appear."
+        C457 (R451) If => procedure-name appears, interface-name shall not
+        appear.
 
-    "C457 (R451) If => procedure-name appears, interface-name shall not
-    appear."
+        C458 (R451) The procedure-name shall be the name of an accessible
+        module procedure or an external procedure that has an explicit
+        interface. Note, this is not checked by fparser.
 
-    "C458 (R451) The procedure-name shall be the name of an accessible
-    module procedure or an external procedure that has an explicit
-    interface." Note, this is not checked by fparser.
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Interface_Name', 'Binding_Attr_List',
-                 'Binding_Name', 'Procedure_Name']
+    use_names = [
+        "Interface_Name",
+        "Binding_Attr_List",
+        "Binding_Name",
+        "Procedure_Name",
+    ]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: 5-tuple containing strings and instances of the classes
                  describing a specific type-bound procedure (optional
                  interface name, optional binding attribute list,
                  optional double colon delimiter, mandatory binding
                  name and optional procedure name)
         :rtype: 5-tuple of objects (1 mandatory and 4 optional)
-        '''
+        """
         # Remove any leading, trailing spaces.
         string_strip = string.strip()
-        if string_strip[:9].upper() != 'PROCEDURE':
+        if string_strip[:9].upper() != "PROCEDURE":
             # There is no 'PROCEDURE' statement.
             return None
         if len(string_strip) < 11:
             # Line is too short to be valid
             return None
         # Remember whether there was a space after the keyword
         space_after = False
         if string_strip[9] == " ":
             space_after = True
         line = string_strip[9:].lstrip()
         # Find optional interface name if it exists.
         iname = None
-        if line.startswith('('):
-            index = line.find(')')
+        if line.startswith("("):
+            index = line.find(")")
             if index == -1:
                 # Left brace has no corresponding right brace
                 return None
             iname = Interface_Name(line[1:index].strip())
-            line = line[index+1:].lstrip()
+            line = line[index + 1 :].lstrip()
         # Look for optional double colon and binding attribute list.
         dcolon = None
         mylist = None
-        index = line.find('::')
+        index = line.find("::")
         if index != -1:
-            dcolon = '::'
-            if line.startswith(','):
+            dcolon = "::"
+            if line.startswith(","):
                 mylist = Binding_Attr_List(line[1:index].strip())
             elif line[:index].strip():
                 # There is content between procedure (with optional
                 # interface) and :: that does not start with a ','
                 # which is a syntax error.
                 return None
-            line = line[index+2:].lstrip()
+            line = line[index + 2 :].lstrip()
         if not iname and not dcolon:
             # there is no interface name or double colon between the
             # keyword and the binding name. Therefore we expect a
             # space between the two.
             if not space_after:
                 # No space was found so return to indicate an
                 # error.
                 return None
         # Find optional procedure name.
-        index = line.find('=>')
+        index = line.find("=>")
         pname = None
         if index != -1:
-            pname = Procedure_Name(line[index+2:].lstrip())
+            pname = Procedure_Name(line[index + 2 :].lstrip())
             line = line[:index].rstrip()
             if not dcolon:
                 # Constraint C456 requires '::' if there is a
                 # procedure-name.
                 return None
         if iname and pname:
             # Constraint C457 disallows interface-name if there is a
             # procedure-name.
             return None
         # Return class arguments.
         return iname, mylist, dcolon, Binding_Name(line), pname
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of a specific type-bound procedure
         :rtype: `str`
 
-        '''
+        """
         if len(self.items) != 5:
             raise InternalError(
                 "Class Specific_Binding method tostr() has '{0}' items, "
-                "but expecting 5.".format(len(self.items)))
+                "but expecting 5.".format(len(self.items))
+            )
 
         stmt = "PROCEDURE"
         # Add optional interface name
         if self.items[0]:
             stmt += "({0})".format(self.items[0])
         # Add optional double colon and binding attribute list
         # (if the list is present)
@@ -2026,5446 +2516,7220 @@
         if self.items[4]:
             stmt += " => {0}".format(self.items[4])
         return stmt
 
 
 class Binding_PASS_Arg_Name(CALLBase):
     # pylint: disable=invalid-name
-    '''
-    :F03R:`453_help`::
+    """
+    Fortran 2003 helper rule (for R453)::
+
+        <binding-PASS-arg-name> = PASS ( <arg-name> )
 
-    Fortran 2003 helper rule (for R453)
-    that specifies syntax of passed-object dummy argument for a
+    Specifies the syntax of passed-object dummy argument for a
     specific type-bound procedure.
 
-    <binding-PASS-arg-name> = PASS ( <arg-name> )
-    '''
+    """
     subclass_names = []
-    use_names = ['Arg_Name']
+    use_names = ["Arg_Name"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: keyword  "PASS" with the name of a passed-object
                  dummy argument or nothing if no match is found
         :rtype: str
-        '''
-        return CALLBase.match('PASS', Arg_Name, string)
+        """
+        return CALLBase.match("PASS", Arg_Name, string)
 
 
 class Generic_Binding(StmtBase):
     # pylint: disable=invalid-name
-    '''
-    :F03R:`452`::
+    """
+    Fortran2003 Rule R452::
 
-    Fortran 2003 rule R452
-    that specifies syntax of generic binding for a type-bound
+        <generic-binding> = GENERIC [ , <access-spec> ] ::
+            <generic-spec> => <binding-name-list>
+
+    Specifies the syntax of generic binding for a type-bound
     procedure within a derived type.
 
-    <generic-binding> = GENERIC [ , <access-spec> ] ::
-        <generic-spec> => <binding-name-list>
-    '''
+    """
     subclass_names = []
-    use_names = ['Access_Spec', 'Generic_Spec', 'Binding_Name_List']
+    use_names = ["Access_Spec", "Generic_Spec", "Binding_Name_List"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: 3-tuple containing strings and instances of the
                  classes describing a generic type-bound procedure
                  (optional access specifier, mandatory generic
                  identifier and mandatory binding name list)
         :rtype: 3-tuple of objects (2 mandatory and 1 optional)
-        '''
+        """
         # Incorrect 'GENERIC' statement
-        if string[:7].upper() != 'GENERIC':
+        if string[:7].upper() != "GENERIC":
             return
         line = string[7:].lstrip()
-        i = line.find('::')
+        i = line.find("::")
         # No mandatory double colon
         if i == -1:
             return
         aspec = None
         # Return optional access specifier (PRIVATE or PUBLIC)
-        if line.startswith(','):
+        if line.startswith(","):
             aspec = Access_Spec(line[1:i].strip())
-        line = line[i+2:].lstrip()
-        i = line.find('=>')
+        line = line[i + 2 :].lstrip()
+        i = line.find("=>")
         if i == -1:
             return
         # Return mandatory Generic_Spec and Binding_Name_List
-        return aspec, Generic_Spec(line[:i].rstrip()), \
-            Binding_Name_List(line[i+3:].lstrip())
+        return (
+            aspec,
+            Generic_Spec(line[:i].rstrip()),
+            Binding_Name_List(line[i + 3 :].lstrip()),
+        )
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of a "GENERIC" type-bound procedure
         :rtype: str
-        '''
+        """
         if self.items[0] is None:
-            return 'GENERIC :: %s => %s' % (self.items[1:])
-        return 'GENERIC, %s :: %s => %s' % (self.items)
+            return "GENERIC :: %s => %s" % (self.items[1:])
+        return "GENERIC, %s :: %s => %s" % (self.items)
 
 
 class Binding_Attr(STRINGBase):  # pylint: disable=invalid-name
 
-    '''
-    :F03R:`453`::
+    """
+    Fortran2003 Rule R453::
+
+        <binding-attr> = PASS [ ( <arg-name> ) ]
+                         | NOPASS
+                         | NON_OVERRIDABLE
+                         | DEFERRED
+                         | <access-spec>
 
-    Fortran 2003 rule R453
-    that specifies syntax of allowed binding attributes for a
+    Specifies syntax of allowed binding attributes for a
     specific type-bound procedure binding.
 
-    <binding-attr> = PASS [ ( <arg-name> ) ]
-                     | NOPASS
-                     | NON_OVERRIDABLE
-                     | DEFERRED
-                     | <access-spec>
-    '''
-    subclass_names = ['Access_Spec', 'Binding_PASS_Arg_Name']
+    """
+
+    subclass_names = ["Access_Spec", "Binding_PASS_Arg_Name"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :return: keywords for allowed binding attributes or
                  nothing if no match is found
         :rtype: str
-        '''
-        return STRINGBase.match(['PASS', 'NOPASS',
-                                 'NON_OVERRIDABLE', 'DEFERRED'], string)
+        """
+        return STRINGBase.match(
+            ["PASS", "NOPASS", "NON_OVERRIDABLE", "DEFERRED"], string
+        )
 
 
 class Final_Binding(StmtBase, WORDClsBase):  # pylint: disable=invalid-name
 
-    '''
-    :F03R:`454`::
+    """
+    Fortran2003 Rule R454::
+
+        <final-binding> = FINAL [ :: ] <final-subroutine-name-list>
 
-    Fortran 2003 rule R454
-    that specifies syntax of final binding for a type-bound
+    Specifies the syntax of final binding for a type-bound
     procedure within a derived type.
 
-    <final-binding> = FINAL [ :: ] <final-subroutine-name-list>
-    '''
+    """
+
     subclass_names = []
-    use_names = ['Final_Subroutine_Name_List']
+    use_names = ["Final_Subroutine_Name_List"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :return: keyword  "FINAL" with the list of "FINAL" type-bound
                  procedures or nothing if no match is found
         :rtype: str
-        '''
+        """
         return WORDClsBase.match(
-            'FINAL', Final_Subroutine_Name_List, string, check_colons=True,
-            require_cls=True)
+            "FINAL", Final_Subroutine_Name_List, string, colons=True, require_cls=True
+        )
 
     # String representation with optional double colons included
     tostr = WORDClsBase.tostr_a
 
 
 class Derived_Type_Spec(CallBase):  # R455
     """
-    <derived-type-spec> = <type-name> [ ( <type-param-spec-list> ) ]
+    ::
+
+        <derived-type-spec> = <type-name> [ ( <type-param-spec-list> ) ]
+
     """
-    subclass_names = ['Type_Name']
-    use_names = ['Type_Param_Spec_List']
 
+    subclass_names = ["Type_Name"]
+    use_names = ["Type_Param_Spec_List"]
+
+    @staticmethod
     def match(string):
         return CallBase.match(Type_Name, Type_Param_Spec_List, string)
-    match = staticmethod(match)
 
 
 class Type_Param_Spec(KeywordValueBase):  # R456
     """
-    <type-param-spec> = [ <keyword> = ] <type-param-value>
-    """
-    subclass_names = ['Type_Param_Value']
-    use_names = ['Keyword']
+    ::
 
-    def match(string):
-        return KeywordValueBase.match(Keyword, Type_Param_Value, string)
-    match = staticmethod(match)
+        <type-param-spec> = [ <keyword> = ] <type-param-value>
 
-
-class Structure_Constructor_2(KeywordValueBase):  # R457.b
-    """
-    <structure-constructor-2> = [ <keyword> = ] <component-data-source>
     """
-    subclass_names = ['Component_Data_Source']
-    use_names = ['Keyword']
 
+    subclass_names = ["Type_Param_Value"]
+    use_names = ["Keyword"]
+
+    @staticmethod
     def match(string):
-        return KeywordValueBase.match(Keyword, Component_Data_Source, string)
-    match = staticmethod(match)
+        return KeywordValueBase.match(Keyword, Type_Param_Value, string)
 
 
 class Structure_Constructor(CallBase):  # R457
     """
-    <structure-constructor> = <derived-type-spec> ( [ <component-spec-list> ] )
-                            | <structure-constructor-2>
+    ::
+
+        <structure-constructor> = <derived-type-spec> ( [ <component-spec-list> ] )
+
     """
-    subclass_names = ['Structure_Constructor_2']
-    use_names = ['Derived_Type_Spec', 'Component_Spec_List']
 
+    subclass_names = []
+    use_names = ["Derived_Type_Spec", "Component_Spec_List"]
+
+    @staticmethod
     def match(string):
         return CallBase.match(Derived_Type_Spec, Component_Spec_List, string)
-    match = staticmethod(match)
 
 
 class Component_Spec(KeywordValueBase):  # R458
     """
-    <component-spec> = [ <keyword> = ] <component-data-source>
+    ::
+
+        <component-spec> = [ <keyword> = ] <component-data-source>
+
     """
-    subclass_names = ['Component_Data_Source']
-    use_names = ['Keyword']
 
+    subclass_names = ["Component_Data_Source"]
+    use_names = ["Keyword"]
+
+    @staticmethod
     def match(string):
         return KeywordValueBase.match(Keyword, Component_Data_Source, string)
-    match = staticmethod(match)
 
 
 class Component_Data_Source(Base):  # R459
     """
-    <component-data-source> = <expr>
-                              | <data-target>
-                              | <proc-target>
+    ::
+
+        <component-data-source> = <expr>
+                                  | <data-target>
+                                  | <proc-target>
+
     """
-    subclass_names = ['Proc_Target', 'Data_Target', 'Expr']
+
+    subclass_names = ["Proc_Target", "Data_Target", "Expr"]
 
 
 class Enum_Def(BlockBase):  # R460
     """
-    <enum-def> = <enum-def-stmt>
-                     <enumerator-def-stmt>
-                     [ <enumerator-def-stmt> ]...
-                     <end-enum-stmt>
+    ::
+
+        <enum-def> = <enum-def-stmt>
+                         <enumerator-def-stmt>
+                         [ <enumerator-def-stmt> ]...
+                         <end-enum-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Enum_Def_Stmt', 'Enumerator_Def_Stmt', 'End_Enum_Stmt']
+    use_names = ["Enum_Def_Stmt", "Enumerator_Def_Stmt", "End_Enum_Stmt"]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Enum_Def_Stmt, [Enumerator_Def_Stmt],
-                               End_Enum_Stmt, reader)
+        return BlockBase.match(
+            Enum_Def_Stmt, [Enumerator_Def_Stmt], End_Enum_Stmt, reader
+        )
 
 
 class Enum_Def_Stmt(StmtBase):  # R461
     """
-    <enum-def-stmt> = ENUM, BIND(C)
+    ::
+
+        <enum-def-stmt> = ENUM, BIND(C)
+
     """
+
     subclass_names = []
     use_names = []
 
     @staticmethod
     def match(string):
-        if string.upper().replace(' ', '') != 'ENUM,BIND(C)':
+        if string.upper().replace(" ", "") != "ENUM,BIND(C)":
             return
-        return 'ENUM, BIND(C)',
+        return ("ENUM, BIND(C)",)
 
     def tostr(self):
-        return '%s' % (self.items[0])
+        return "%s" % (self.items[0])
 
 
 class Enumerator_Def_Stmt(StmtBase, WORDClsBase):  # R462
     """
-    <enumerator-def-stmt> = ENUMERATOR [ :: ] <enumerator-list>
+    ::
+
+        <enumerator-def-stmt> = ENUMERATOR [ :: ] <enumerator-list>
+
     """
+
     subclass_names = []
-    use_names = ['Enumerator_List']
+    use_names = ["Enumerator_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'ENUMERATOR', Enumerator_List, string,
-            check_colons=True, require_cls=True)
-    match = staticmethod(match)
+            "ENUMERATOR", Enumerator_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Enumerator(BinaryOpBase):  # R463
     """
-    <enumerator> = <named-constant> [ = <scalar-int-initialization-expr> ]
+    ::
+
+        <enumerator> = <named-constant> [ = <scalar-int-initialization-expr> ]
+
     """
-    subclass_names = ['Named_Constant']
-    use_names = ['Scalar_Int_Initialization_Expr']
 
+    subclass_names = ["Named_Constant"]
+    use_names = ["Scalar_Int_Initialization_Expr"]
+
+    @staticmethod
     def match(string):
-        if '=' not in string:
+        if "=" not in string:
             return
-        lhs, rhs = string.split('=', 1)
-        return Named_Constant(
-            lhs.rstrip()), '=', Scalar_Int_Initialization_Expr(rhs.lstrip())
-    match = staticmethod(match)
+        lhs, rhs = string.split("=", 1)
+        return (
+            Named_Constant(lhs.rstrip()),
+            "=",
+            Scalar_Int_Initialization_Expr(rhs.lstrip()),
+        )
 
 
 class End_Enum_Stmt(EndStmtBase):  # R464
     """
-    <end-enum-stmt> = END ENUM
+    ::
+
+        <end-enum-stmt> = END ENUM
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return EndStmtBase.match('ENUM', None, string, require_stmt_type=True)
-    match = staticmethod(match)
+        return EndStmtBase.match("ENUM", None, string, require_stmt_type=True)
 
 
 class Array_Constructor(BracketBase):  # R465
     """
-    <array-constructor> = (/ <ac-spec> /)
-                          | <left-square-bracket> <ac-spec>
-                            <right-square-bracket>
+    ::
+
+        <array-constructor> = (/ <ac-spec> /)
+                              | <left-square-bracket> <ac-spec>
+                                <right-square-bracket>
 
     """
+
     subclass_names = []
-    use_names = ['Ac_Spec']
+    use_names = ["Ac_Spec"]
 
+    @staticmethod
     def match(string):
         try:
-            obj = BracketBase.match('(//)', Ac_Spec, string)
+            obj = BracketBase.match("(//)", Ac_Spec, string)
         except NoMatchError:
             obj = None
         if obj is None:
-            obj = BracketBase.match('[]', Ac_Spec, string)
+            obj = BracketBase.match("[]", Ac_Spec, string)
         return obj
-    match = staticmethod(match)
 
 
 class Ac_Spec(Base):  # R466
     """
-    <ac-spec> = <type-spec> ::
-                | [ <type-spec> :: ] <ac-value-list>
+    ::
+
+        <ac-spec> = <type-spec> ::
+                    | [ <type-spec> :: ] <ac-value-list>
+
     """
-    subclass_names = ['Ac_Value_List']
-    use_names = ['Type_Spec']
 
+    subclass_names = ["Ac_Value_List"]
+    use_names = ["Type_Spec"]
+
+    @staticmethod
     def match(string):
-        if string.endswith('::'):
+        if string.endswith("::"):
             return Type_Spec(string[:-2].rstrip()), None
         line, repmap = string_replace_map(string)
-        i = line.find('::')
+        i = line.find("::")
         if i == -1:
             return
         ts = line[:i].rstrip()
-        line = line[i+2:].lstrip()
+        line = line[i + 2 :].lstrip()
         ts = repmap(ts)
         line = repmap(line)
         return Type_Spec(ts), Ac_Value_List(line)
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[0] is None:
             return str(self.items[1])
         if self.items[1] is None:
-            return str(self.items[0]) + ' ::'
-        return '%s :: %s' % self.items
+            return str(self.items[0]) + " ::"
+        return "%s :: %s" % self.items
+
 
 # R467: <left-square-bracket> = [
 # R468: <right-square-bracket> = ]
 
 
 class Ac_Value(Base):  # R469
     """
-    <ac-value> = <expr>
-                 | <ac-implied-do>
+    ::
+
+        <ac-value> = <expr>
+                     | <ac-implied-do>
+
     """
-    subclass_names = ['Ac_Implied_Do', 'Expr']
 
+    subclass_names = ["Ac_Implied_Do", "Expr"]
 
-class Ac_Implied_Do(Base):  # R470
+
+class Ac_Implied_Do(Base):
     """
-    <ac-implied-do> = ( <ac-value-list> , <ac-implied-do-control> )
+    Fortran2003 rule R470.
+    Describes the form of implicit do loop used within an array constructor::
+
+        ac-implied-do is ( ac-value-list , ac-implied-do-control )
+
+    Subject to the following constraint::
+
+        C497 (R470) The ac-do-variable of an ac-implied-do that is in another
+              ac-implied-do shall not appear as the ac-do-variable of the
+              containing ac-implied-do.
+
+    C497 is currently not checked - issue #257.
+
     """
+
     subclass_names = []
-    use_names = ['Ac_Value_List', 'Ac_Implied_Do_Control']
+    use_names = ["Ac_Value_List", "Ac_Implied_Do_Control"]
 
+    @staticmethod
     def match(string):
-        if string[0] + string[-1] != '()':
+        if string[0] + string[-1] != "()":
             return
         line, repmap = string_replace_map(string[1:-1].strip())
-        i = line.rfind('=')
+        i = line.rfind("=")
         if i == -1:
             return
-        j = line[:i].rfind(',')
+        j = line[:i].rfind(",")
         assert j != -1
         s1 = repmap(line[:j].rstrip())
-        s2 = repmap(line[j+1:].lstrip())
+        s2 = repmap(line[j + 1 :].lstrip())
         return Ac_Value_List(s1), Ac_Implied_Do_Control(s2)
-    match = staticmethod(match)
 
     def tostr(self):
-        return '(%s, %s)' % tuple(self.items)
+        return "(%s, %s)" % tuple(self.items)
 
 
-class Ac_Implied_Do_Control(Base):  # R471
+class Ac_Implied_Do_Control(Base):
     """
-    <ac-implied-do-control> = <ac-do-variable> = <scalar-int-expr> ,
-        <scalar-int-expr> [ , <scalar-int-expr> ]
+    Fortran2003 rule R471.
+    Specifies the syntax for the control of an implicit loop within an
+    array constructor::
+
+        ac-implied-do-control is ac-do-variable = scalar-int-expr,
+                                        scalar-int-expr [ , scalar-int-expr ]
+
+    where (R472) ac-do-variable is scalar-int-variable
+
     """
+
     subclass_names = []
-    use_names = ['Ac_Do_Variable', 'Scalar_Int_Expr']
+    use_names = ["Ac_Do_Variable", "Scalar_Int_Expr"]
 
+    @staticmethod
     def match(string):
-        i = string.find('=')
-        if i == -1:
-            return
-        s1 = string[:i].rstrip()
-        line, repmap = string_replace_map(string[i+1:].lstrip())
-        t = line.split(',')
-        if not (2 <= len(t) <= 3):
-            return
-        t = [Scalar_Int_Expr(s.strip()) for s in t]
-        return Ac_Do_Variable(s1), t
-    match = staticmethod(match)
+        """ Attempts to match the supplied string with the pattern for
+        implied-do control.
+
+        :param str string: the string to test for a match.
+
+        :returns: None if there is no match or a 2-tuple containing the \
+                  do-variable name and the list of integer expressions (for \
+                  start, stop [, step]).
+        :rtype: NoneType or \
+                (:py:class:`fparser.two.Fortran2003.Ac_Do_Variable`, list)
+        """
+        idx = string.find("=")
+        if idx == -1:
+            return None
+        do_var = string[:idx].rstrip()
+        line, repmap = string_replace_map(string[idx + 1 :].lstrip())
+        int_exprns = line.split(",")
+        if not (2 <= len(int_exprns) <= 3):
+            return None
+        exprn_list = [Scalar_Int_Expr(repmap(s.strip())) for s in int_exprns]
+        return Ac_Do_Variable(do_var), exprn_list
 
     def tostr(self):
-        return '%s = %s' % (self.items[0], ', '.join(map(str, self.items[1])))
+        return "%s = %s" % (self.items[0], ", ".join(map(str, self.items[1])))
 
 
-class Ac_Do_Variable(Base):  # R472
+class Ac_Do_Variable(Base):
     """
-    <ac-do-variable> = <scalar-int-variable>
-    <ac-do-variable> shall be a named variable
+    Fortran2003 rule R472.
+    Specifies the permitted form of an implicit do-loop variable within an
+    array constructor::
+
+        ac-do-variable is scalar-int-variable
+        ac-do-variable shall be a named variable
+
+    Subject to the following constraint::
+
+        C493 (R472) ac-do-variable shall be a named variable.
+
+    C493 is currently not checked - issue #257.
+
     """
-    subclass_names = ['Scalar_Int_Variable']
+
+    subclass_names = ["Scalar_Int_Variable"]
+
 
 #
 # SECTION  5
 #
 
 
 class Type_Declaration_Stmt(Type_Declaration_StmtBase):  # R501
     """
-    <type-declaration-stmt> = <declaration-type-spec> [
-        [ , <attr-spec> ]... :: ] <entity-decl-list>
-    """
-    subclass_names = []
-    use_names = ['Declaration_Type_Spec', 'Attr_Spec_List', 'Entity_Decl_List']
+    Fortran 2003 rule 501::
+
+        type-declaration-stmt is declaration-type-spec [
+            [ , attr-spec ]... :: ] entity-decl-list
+
+    Associated constraints are::
+
+        C507 (R501)  The same attr-spec shall not appear more than once in a given
+             type-declaration-stmt.
+        C509 (R501)  An entity declared with the CLASS keyword shall be a dummy
+             argument or have the ALLOCATABLE or POINTER attribute.
+        C510 (R501)  An array that has the POINTER or ALLOCATABLE attribute shall
+             be specified with an array-spec that is a deferred-shape-spec-list.
+        C511 (R501)  An array-spec for an object-name that is a function result
+             that does not have the ALLOCATABLE or POINTER attribute shall be an
+             explicit-shape-spec-list.
+        C512 (R501)  If the POINTER attribute is specified, the ALLOCATABLE,
+             TARGET, EXTERNAL, or INTRINSIC attribute shall not be specified.
+        C513 (R501)  If the TARGET attribute is specified, the POINTER, EXTERNAL,
+             INTRINSIC, or PARAMETER attribute shall not be specified.
+        C514 (R501)  The PARAMETER attribute shall not be specified for a dummy
+             argument, a pointer, an allocatable entity, a function, or an object
+             in a common block.
+        C515 (R501)  The INTENT, VALUE, and OPTIONAL attributes may be specified
+             only for dummy arguments.
+        C516 (R501)  The INTENT attribute shall not be specified for a dummy
+             procedure without the POINTER attribute.
+        C517 (R501)  The SAVE attribute shall not be specified for an object that
+             is in a common block, a dummy argument, a procedure, a function
+             result, an automatic data object, or an object with the PARAMETER
+             attribute.
+        C519 (R501)  An entity in an entity-decl-list shall not have the EXTERNAL
+             or INTRINSIC attribute specified unless it is a function.
+        C522 (R501)  The initialization shall appear if the statement contains a
+             PARAMETER attribute.
+        C523 (R501)  If initialization appears, a double-colon separator shall
+             appear before the entity-decl-list.
+        C526 (R501)  If the VOLATILE attribute is specified, the PARAMETER,
+             INTRINSIC, EXTERNAL, or INTENT(IN) attribute shall not be specified.
+        C527 (R501)  If the VALUE attribute is specified, the PARAMETER, EXTERNAL,
+             POINTER, ALLOCATABLE, DIMENSION, VOLATILE, INTENT(INOUT), or
+             INTENT(OUT) attribute shall not be specified.
+        C528 (R501)  If the VALUE attribute is specified, the length type
+             parameter values shall be omitted or specified by initialization
+             expressions.
+        C529 (R501)  The VALUE attribute shall not be specified for a dummy
+             procedure.
+        C530 (R501)  The ALLOCATABLE, POINTER, or OPTIONAL attribute shall not be
+             specified for adummy argument of a procedure that has
+             aproc-language-binding-spec.
+        C532 (R501)  If a language-binding-spec is specified, the entity declared
+             shall be an interoperable variable.
+        C533 (R501)  If a language-binding-spec with a NAME= specifier appears,
+             the entity-decl-list shall consist of a single entity-decl.
+        C534 (R503)  The PROTECTED attribute is permitted only in the
+             specification part of a module.
+        C535 (R501)  The PROTECTED attribute is permitted only for a procedure
+             pointer or named variable that is not in a common block.
+        C536 (R501)  If the PROTECTED attribute is specified, the EXTERNAL,
+             INTRINSIC, or PARAMETER attribute shall not be specified.
+
+    C507, C509-C517, C519, C522-C523, C526-C530, C532-C533, C535-C536 are
+    currently not checked - issue #259.
+
+    """
+
+    subclass_names = []
+    use_names = ["Declaration_Type_Spec", "Attr_Spec_List", "Entity_Decl_List"]
+
+    @staticmethod
+    def get_attr_spec_list_cls():
+        """Return the type used to match the attr-spec-list
+
+        This method allows to overwrite the type used in :py:meth:`match`
+        in derived classes
+        (e.g., :py:class:`fparser.two.Fortran2008.Type_Declaration_Stmt`).
+
+        This cannot be implemented as an attribute because the relevant type
+        :class:`Attr_Spec_List` is auto-generated at the end of the file
+        using the :attr:`use_names` property of the class.
+
+        """
+        return Attr_Spec_List
 
     @staticmethod
-    def match(string):
-        return Type_Declaration_StmtBase.match(
-            Declaration_Type_Spec, Attr_Spec_List, Entity_Decl_List, string)
+    def add_to_symbol_table(result):
+        """Capture the declared symbols in the symbol table of the current
+        scoping region
+
+        :param result: the declared type, attributes and entities or None
+        :type result: `NoneType` or \
+                (Declaration_Type_Spec, Attr_Spec_List or NoneType, \
+                 Entity_Decl_List)
+        """
+        if result:
+            # We matched a declaration - capture the declared symbols in the
+            # symbol table of the current scoping region.
+            table = SYMBOL_TABLES.current_scope
+
+            if table and isinstance(result[0], Intrinsic_Type_Spec):
+                # We have a definition of symbol(s) of intrinsic type
+                decl_list = walk(result, Entity_Decl)
+                for decl in decl_list:
+                    # TODO #201 use an enumeration to specify the primitive
+                    # type rather than a string.
+                    table.add_data_symbol(decl.items[0].string, str(result[0]))
+            # TODO #201 support symbols that are not of intrinsic type.
+
+    @classmethod
+    def match(cls, string):
+        """
+        Attempts to match the supplied string as a type declaration. If the
+        match is successful the declared symbols are added to the symbol table
+        of the current scope (if there is one).
+
+        Note that this is implemented as a class method to allow parameterizing
+        the type used to match attr-spec-list via :py:meth:`get_attr_spec_list_cls`.
+
+        :param str string: the string to match.
+
+        :returns: 3-tuple containing the matched declaration.
+        :rtype: (Declaration_Type_Spec, Attr_Spec_List or NoneType, \
+                 Entity_Decl_List)
+
+        """
+        result = Type_Declaration_StmtBase.match(
+            Declaration_Type_Spec,
+            cls.get_attr_spec_list_cls(),
+            Entity_Decl_List,
+            string,
+        )
+        cls.add_to_symbol_table(result)
+        return result
 
     @staticmethod
     def match2(string):
         line, repmap = string_replace_map(string)
-        i = line.find('::')
+        i = line.find("::")
         if i != -1:
-            j = line[:i].find(',')
+            j = line[:i].find(",")
             if j != -1:
                 i = j
         else:
-            if line[:6].upper() == 'DOUBLE':
-                m = re.search(r'\s[a-z_]', line[6:].lstrip(), re.I)
+            if line[:6].upper() == "DOUBLE":
+                m = re.search(r"\s[a-z_]", line[6:].lstrip(), re.I)
                 if m is None:
                     return
                 i = m.start() + len(line) - len(line[6:].lstrip())
             else:
-                m = re.search(r'\s[a-z_]', line, re.I)
+                m = re.search(r"\s[a-z_]", line, re.I)
                 if m is None:
                     return
                 i = m.start()
         type_spec = Declaration_Type_Spec(repmap(line[:i].rstrip()))
         if type_spec is None:
             return
         line = line[i:].lstrip()
-        if line.startswith(','):
-            i = line.find('::')
+        if line.startswith(","):
+            i = line.find("::")
             if i == -1:
                 return
             attr_specs = Attr_Spec_List(repmap(line[1:i].strip()))
             if attr_specs is None:
                 return
             line = line[i:]
         else:
             attr_specs = None
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         entity_decls = Entity_Decl_List(repmap(line))
         if entity_decls is None:
             return
         return type_spec, attr_specs, entity_decls
 
     def tostr(self):
         if self.items[1] is None:
-            return '%s :: %s' % (self.items[0], self.items[2])
+            return "%s :: %s" % (self.items[0], self.items[2])
         else:
-            return '%s, %s :: %s' % self.items
+            return "%s, %s :: %s" % self.items
 
 
 class Declaration_Type_Spec(Base):  # R502
     """
-    <declaration-type-spec> = <intrinsic-type-spec>
-                              | TYPE ( <derived-type-spec> )
-                              | CLASS ( <derived-type-spec> )
-                              | CLASS ( * )
+    ::
+
+        <declaration-type-spec> = <intrinsic-type-spec>
+                                  | TYPE ( <derived-type-spec> )
+                                  | CLASS ( <derived-type-spec> )
+                                  | CLASS ( * )
+
     """
-    subclass_names = ['Intrinsic_Type_Spec']
-    use_names = ['Derived_Type_Spec']
+
+    subclass_names = ["Intrinsic_Type_Spec"]
+    use_names = ["Derived_Type_Spec"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching of a declaration type specification.
+        """Implements the matching of a declaration type specification.
 
         :param str string: the reader or string to match as a \
         declaration type specification.
 
         :return: A tuple of size 2 containing a string with the value \
         'TYPE' or 'CLASS' and a 'Derived_Type_Spec' instance if there \
         is a match or None if not.
-        :rtype: (str, \
-        py:class:`fparser.two.Fortran2003.Derived_Type_Spec`,) or \
-        NoneType
+        :rtype: Optional[Tuple[Str, \
+            py:class:`fparser.two.Fortran2003.Derived_Type_Spec`]
 
-        '''
+        """
         if not string:
             return None
-        if string[-1] != ')':
+        if string[-1] != ")":
             return None
         start = string[:4].upper()
-        if start == 'TYPE':
+        if start == "TYPE":
             line = string[4:].lstrip()
-            if not line.startswith('('):
+            if not line.startswith("("):
                 return None
-            return 'TYPE', Derived_Type_Spec(line[1:-1].strip())
+            return "TYPE", Derived_Type_Spec(line[1:-1].strip())
         start = string[:5].upper()
-        if start == 'CLASS':
+        if start == "CLASS":
             line = string[5:].lstrip()
-            if not line.startswith('('):
+            if not line.startswith("("):
                 return None
             line = line[1:-1].strip()
-            if line == '*':
-                return 'CLASS', '*'
-            return 'CLASS', Derived_Type_Spec(line)
+            if line == "*":
+                return "CLASS", "*"
+            return "CLASS", Derived_Type_Spec(line)
         return None
 
     def tostr(self):
-        return '%s(%s)' % self.items
+        return "%s(%s)" % self.items
 
 
 class Dimension_Attr_Spec(CALLBase):  # R503.d
     """
-    <dimension-attr-spec> = DIMENSION ( <array-spec> )
+    ::
+
+        <dimension-attr-spec> = DIMENSION ( <array-spec> )
+
     """
+
     subclass_names = []
-    use_names = ['Array_Spec']
+    use_names = ["Array_Spec"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match('DIMENSION', Array_Spec, string)
-    match = staticmethod(match)
+        return CALLBase.match("DIMENSION", Array_Spec, string)
 
 
 class Intent_Attr_Spec(CALLBase):  # R503.f
     """
-    <intent-attr-spec> = INTENT ( <intent-spec> )
+    ::
+
+        <intent-attr-spec> = INTENT ( <intent-spec> )
+
     """
+
     subclass_names = []
-    use_names = ['Intent_Spec']
+    use_names = ["Intent_Spec"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match('INTENT', Intent_Spec, string)
-    match = staticmethod(match)
+        return CALLBase.match("INTENT", Intent_Spec, string)
 
 
 class Attr_Spec(STRINGBase):  # R503
     """
-    <attr-spec> = <access-spec>
-                  | ALLOCATABLE
-                  | ASYNCHRONOUS
-                  | DIMENSION ( <array-spec> )
-                  | EXTERNAL
-                  | INTENT ( <intent-spec> )
-                  | INTRINSIC
-                  | <language-binding-spec>
-                  | OPTIONAL
-                  | PARAMETER
-                  | POINTER
-                  | PROTECTED
-                  | SAVE
-                  | TARGET
-                  | VALUE
-                  | VOLATILE
+    ::
+
+        <attr-spec> = <access-spec>
+                      | ALLOCATABLE
+                      | ASYNCHRONOUS
+                      | DIMENSION ( <array-spec> )
+                      | EXTERNAL
+                      | INTENT ( <intent-spec> )
+                      | INTRINSIC
+                      | <language-binding-spec>
+                      | OPTIONAL
+                      | PARAMETER
+                      | POINTER
+                      | PROTECTED
+                      | SAVE
+                      | TARGET
+                      | VALUE
+                      | VOLATILE
+
     """
-    subclass_names = ['Access_Spec', 'Language_Binding_Spec',
-                      'Dimension_Attr_Spec', 'Intent_Attr_Spec']
+
+    subclass_names = [
+        "Access_Spec",
+        "Language_Binding_Spec",
+        "Dimension_Attr_Spec",
+        "Intent_Attr_Spec",
+    ]
     use_names = []
 
+    @staticmethod
     def match(string):
         return STRINGBase.match(pattern.abs_attr_spec, string)
-    match = staticmethod(match)
 
 
 class Entity_Decl(Base):  # R504
     """
-    <entity-decl> = <object-name> [ ( <array-spec> ) ]
-        [ * <char-length> ] [ <initialization> ]
-                    | <function-name> [ * <char-length> ]
+    ::
+
+        <entity-decl> = <object-name> [ ( <array-spec> ) ]
+            [ * <char-length> ] [ <initialization> ]
+                        | <function-name> [ * <char-length> ]
+
     """
+
     subclass_names = []
-    use_names = ['Object_Name', 'Array_Spec', 'Char_Length',
-                 'Initialization', 'Function_Name']
+    use_names = [
+        "Object_Name",
+        "Array_Spec",
+        "Char_Length",
+        "Initialization",
+        "Function_Name",
+    ]
 
+    @staticmethod
     def match(string, target=False):
         m = pattern.name.match(string)
         if m is None:
             return
         name = Name(m.group())
-        newline = string[m.end():].lstrip()
+        newline = string[m.end() :].lstrip()
         if not newline:
             return name, None, None, None
         array_spec = None
         char_length = None
         init = None
-        if newline.startswith('('):
+        if newline.startswith("("):
             line, repmap = string_replace_map(newline)
-            i = line.find(')')
+            i = line.find(")")
             if i == -1:
                 return
             array_spec = Array_Spec(repmap(line[1:i].strip()))
-            newline = repmap(line[i+1:].lstrip())
+            newline = repmap(line[i + 1 :].lstrip())
         if target:
             if newline:
                 return
             return name, array_spec, None, None
-        if newline.startswith('*'):
+        if newline.startswith("*"):
             line, repmap = string_replace_map(newline)
-            i = line.find('=')
+            i = line.find("=")
             if i != -1:
                 char_length = repmap(line[1:i].strip())
                 newline = repmap(newline[i:].lstrip())
             else:
                 char_length = repmap(newline[1:].strip())
-                newline = ''
+                newline = ""
             char_length = Char_Length(char_length)
-        if newline.startswith('='):
+        if newline.startswith("="):
             init = Initialization(newline)
         elif newline:
             return
         else:
-            assert newline == '', repr((newline, string))
+            assert newline == "", repr((newline, string))
         return name, array_spec, char_length, init
-    match = staticmethod(match)
 
     def tostr(self):
         s = str(self.items[0])
         if self.items[1] is not None:
-            s += '(' + str(self.items[1]) + ')'
+            s += "(" + str(self.items[1]) + ")"
         if self.items[2] is not None:
-            s += '*' + str(self.items[2])
+            s += "*" + str(self.items[2])
         if self.items[3] is not None:
-            s += ' ' + str(self.items[3])
+            s += " " + str(self.items[3])
         return s
 
+    def get_name(self):
+        """Provides the entity name as an instance of the :py:class:`Name` class.
+
+        :rtype: :py:class:`Name`
+        """
+        return self.items[0]
+
 
 class Object_Name(Base):  # R505
     """
-    <object-name> = <name>
+    ::
+
+        <object-name> = <name>
+
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Initialization(Base):  # R506
     """
-    <initialization> =  = <initialization-expr>
-                       | => <null-init>
+    ::
+
+        <initialization> =  = <initialization-expr>
+                           | => <null-init>
+
     """
+
     subclass_names = []
-    use_names = ['Initialization_Expr', 'Null_Init']
+    use_names = ["Initialization_Expr", "Null_Init"]
 
+    @staticmethod
     def match(string):
-        if string.startswith('=>'):
-            return '=>', Null_Init(string[2:].lstrip())
-        if string.startswith('='):
-            return '=', Initialization_Expr(string[1:].lstrip())
-        return
-    match = staticmethod(match)
+        if string.startswith("=>"):
+            return "=>", Null_Init(string[2:].lstrip())
+        if string.startswith("="):
+            return "=", Initialization_Expr(string[1:].lstrip())
+        return None
 
     def tostr(self):
-        return '%s %s' % self.items
+        return "%s %s" % self.items
 
 
 class Null_Init(STRINGBase):  # R507
     """
-    <null-init> = <function-reference>
+    ::
+
+        null-init is function-reference
+
+    where::
+
+        function-reference shall be a reference to the NULL
+                           intrinsic function with no arguments.
 
-    <function-reference> shall be a reference to the NULL
-        intrinsic function with no arguments.
     """
-    subclass_names = ['Function_Reference']
 
+    subclass_names = ["Function_Reference"]
+
+    @staticmethod
     def match(string):
-        return STRINGBase.match('NULL', string)
-    match = staticmethod(match)
+        return STRINGBase.match("NULL", string)
 
 
 class Access_Spec(STRINGBase):  # R508
     """
-:F03R:`508`::
-    <access-spec> = PUBLIC
-                    | PRIVATE
+    Fortran2003 Rule R508::
+
+        <access-spec> = PUBLIC
+                        | PRIVATE
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['PUBLIC', 'PRIVATE'], string)
-    match = staticmethod(match)
+        return STRINGBase.match(["PUBLIC", "PRIVATE"], string)
 
 
 class Language_Binding_Spec(Base):  # R509
     """
-:F03R:`509`::
-    <language-binding-spec> = BIND ( C [ ,
-        NAME = <scalar-char-initialization-expr> ] )
+    Fortran2003 Rule R509::
+
+        <language-binding-spec> = BIND ( C [ ,
+            NAME = <scalar-char-initialization-expr> ] )
+
     """
+
     subclass_names = []
-    use_names = ['Scalar_Char_Initialization_Expr']
+    use_names = ["Scalar_Char_Initialization_Expr"]
 
+    @staticmethod
     def match(string):
         start = string[:4].upper()
-        if start != 'BIND':
+        if start != "BIND":
             return
         line = string[4:].lstrip()
-        if not line or line[0] + line[-1] != '()':
+        if not line or line[0] + line[-1] != "()":
             return
         line = line[1:-1].strip()
         if not line:
             return
         start = line[0].upper()
-        if start != 'C':
+        if start != "C":
             return
         line = line[1:].lstrip()
         if not line:
-            return None,
-        if not line.startswith(','):
+            return (None,)
+        if not line.startswith(","):
             return
         line = line[1:].lstrip()
         start = line[:4].upper()
-        if start != 'NAME':
+        if start != "NAME":
             return
         line = line[4:].lstrip()
-        if not line.startswith('='):
+        if not line.startswith("="):
             return
-        return Scalar_Char_Initialization_Expr(line[1:].lstrip()),
-    match = staticmethod(match)
+        return (Scalar_Char_Initialization_Expr(line[1:].lstrip()),)
 
     def tostr(self):
         if self.items[0] is None:
-            return 'BIND(C)'
-        return 'BIND(C, NAME = %s)' % (self.items[0])
+            return "BIND(C)"
+        return "BIND(C, NAME = %s)" % (self.items[0])
 
 
 class Array_Spec(Base):  # R510
     """
-:F03R:`510`::
-    <array-spec> = <explicit-shape-spec-list>
-                   | <assumed-shape-spec-list>
-                   | <deferred-shape-spec-list>
-                   | <assumed-size-spec>
-    """
-    subclass_names = ['Assumed_Size_Spec', 'Explicit_Shape_Spec_List',
-                      'Assumed_Shape_Spec_List',
-                      'Deferred_Shape_Spec_List']
+    Fortran2003 Rule R510::
+
+        <array-spec> = <explicit-shape-spec-list>
+                       | <assumed-shape-spec-list>
+                       | <deferred-shape-spec-list>
+                       | <assumed-size-spec>
+
+    """
+
+    subclass_names = [
+        "Assumed_Size_Spec",
+        "Explicit_Shape_Spec_List",
+        "Assumed_Shape_Spec_List",
+        "Deferred_Shape_Spec_List",
+    ]
 
 
 class Explicit_Shape_Spec(SeparatorBase):  # R511
     """
-    <explicit-shape-spec> = [ <lower-bound> : ] <upper-bound>
+    ::
+
+        <explicit-shape-spec> = [ <lower-bound> : ] <upper-bound>
+
     """
+
     subclass_names = []
-    use_names = ['Lower_Bound', 'Upper_Bound']
+    use_names = ["Lower_Bound", "Upper_Bound"]
 
+    @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        if ':' not in line:
+        if ":" not in line:
             return None, Upper_Bound(string)
-        lower, upper = line.split(':', 1)
+        lower, upper = line.split(":", 1)
         lower = lower.rstrip()
         upper = upper.lstrip()
         if not upper:
             return
         if not lower:
             return
         return Lower_Bound(repmap(lower)), Upper_Bound(repmap(upper))
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[0] is None:
             return str(self.items[1])
         return SeparatorBase.tostr(self)
 
 
 class Lower_Bound(Base):  # R512
     """
-    <lower-bound> = <specification-expr>
+    ::
+
+        <lower-bound> = <specification-expr>
+
     """
-    subclass_names = ['Specification_Expr']
+
+    subclass_names = ["Specification_Expr"]
 
 
 class Upper_Bound(Base):  # R513
     """
-    <upper-bound> = <specification-expr>
+    ::
+
+        <upper-bound> = <specification-expr>
+
     """
-    subclass_names = ['Specification_Expr']
+
+    subclass_names = ["Specification_Expr"]
 
 
 class Assumed_Shape_Spec(SeparatorBase):  # R514
     """
-:F03R:`514`::
-    <assumed-shape-spec> = [ <lower-bound> ] :
+    Fortran2003 Rule R514::
+
+        <assumed-shape-spec> = [ <lower-bound> ] :
+
     """
+
     subclass_names = []
-    use_names = ['Lower_Bound']
+    use_names = ["Lower_Bound"]
 
+    @staticmethod
     def match(string):
         return SeparatorBase.match(Lower_Bound, None, string)
-    match = staticmethod(match)
 
 
 class Deferred_Shape_Spec(SeparatorBase):  # R515
     """
-:F03R:`515`::
-    <deferred_shape_spec> = :
+    Fortran2003 Rule R515::
+
+        <deferred_shape_spec> = :
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        if string == ':':
+        if string == ":":
             return None, None
-        return
-    match = staticmethod(match)
+        return None
 
 
 class Assumed_Size_Spec(Base):  # R516
     """
-:F03R:`516`::
-    <assumed-size-spec> = [ <explicit-shape-spec-list> , ]
-        [ <lower-bound> : ] *
+    Fortran2003 Rule R516::
+
+        <assumed-size-spec> = [ <explicit-shape-spec-list> , ]
+            [ <lower-bound> : ] *
+
     """
+
     subclass_names = []
-    use_names = ['Explicit_Shape_Spec_List', 'Lower_Bound']
+    use_names = ["Explicit_Shape_Spec_List", "Lower_Bound"]
 
+    @staticmethod
     def match(string):
-        if not string.endswith('*'):
+        if not string.endswith("*"):
             return
         line = string[:-1].rstrip()
         if not line:
             return None, None
-        if line.endswith(':'):
+        if line.endswith(":"):
             line, repmap = string_replace_map(line[:-1].rstrip())
-            i = line.rfind(',')
+            i = line.rfind(",")
             if i == -1:
                 return None, Lower_Bound(repmap(line))
-            return Explicit_Shape_Spec_List(
-                repmap(line[:i].rstrip())), \
-                Lower_Bound(repmap(line[i+1:].lstrip()))
-        if not line.endswith(','):
+            return (
+                Explicit_Shape_Spec_List(repmap(line[:i].rstrip())),
+                Lower_Bound(repmap(line[i + 1 :].lstrip())),
+            )
+        if not line.endswith(","):
             return
         line = line[:-1].rstrip()
         return Explicit_Shape_Spec_List(line), None
-    match = staticmethod(match)
 
     def tostr(self):
-        s = ''
+        s = ""
         if self.items[0] is not None:
-            s += str(self.items[0]) + ', '
+            s += str(self.items[0]) + ", "
         if self.items[1] is not None:
-            s += str(self.items[1]) + ' : '
-        s += '*'
+            s += str(self.items[1]) + " : "
+        s += "*"
         return s
 
 
 class Intent_Spec(STRINGBase):  # R517
     """
-    <intent-spec> = IN
-                    | OUT
-                    | INOUT
+    ::
+
+        <intent-spec> = IN
+                        | OUT
+                        | INOUT
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
         return STRINGBase.match(pattern.abs_intent_spec, string)
-    match = staticmethod(match)
 
 
 class Access_Stmt(StmtBase, WORDClsBase):  # R518
     """
-:F03R:`518`::
-    <access-stmt> = <access-spec> [ [ :: ] <access-id-list> ]
+    Fortran2003 Rule R518::
+
+        <access-stmt> = <access-spec> [ [ :: ] <access-id-list> ]
+
     """
+
     subclass_names = []
-    use_names = ['Access_Spec', 'Access_Id_List']
+    use_names = ["Access_Spec", "Access_Id_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            ['PUBLIC', 'PRIVATE'],
-            Access_Id_List, string, check_colons=True,
-            require_cls=False)
-    match = staticmethod(match)
+            ["PUBLIC", "PRIVATE"],
+            Access_Id_List,
+            string,
+            colons=True,
+            require_cls=False,
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Access_Id(Base):  # R519
     """
-:F03R:`519`::
-    <access-id> = <use-name>
-                  | <generic-spec>
+    Fortran2003 Rule R519::
+
+        <access-id> = <use-name>
+                      | <generic-spec>
+
     """
-    subclass_names = ['Use_Name', 'Generic_Spec']
+
+    subclass_names = ["Use_Name", "Generic_Spec"]
 
 
 class Object_Name_Deferred_Shape_Spec_List_Item(CallBase):
     """
-    <..> =  <object-name> [ ( <deferred-shape-spec-list> ) ]
+    ::
+
+        <..> =  <object-name> [ ( <deferred-shape-spec-list> ) ]
+
     """
-    subclass_names = ['Object_Name']
-    use_names = ['Deferred_Shape_Spec_List']
 
+    subclass_names = ["Object_Name"]
+    use_names = ["Deferred_Shape_Spec_List"]
+
+    @staticmethod
     def match(string):
         return CallBase.match(
-            Object_Name, Deferred_Shape_Spec_List, string,
-            require_rhs=True)
-    match = staticmethod(match)
+            Object_Name, Deferred_Shape_Spec_List, string, require_rhs=True
+        )
 
 
 class Allocatable_Stmt(StmtBase, WORDClsBase):  # R520
     """
-:F03R:`520`::
-    <allocateble-stmt> = ALLOCATABLE [ :: ] <object-name> [
-        ( <deferred-shape-spec-list> ) ] [ , <object-name>
-        [ ( <deferred-shape-spec-list> ) ] ]...
+    Fortran2003 Rule R520::
+
+        <allocateble-stmt> = ALLOCATABLE [ :: ] <object-name> [
+            ( <deferred-shape-spec-list> ) ] [ , <object-name>
+            [ ( <deferred-shape-spec-list> ) ] ]...
+
     """
+
     subclass_names = []
-    use_names = ['Object_Name_Deferred_Shape_Spec_List_Item_List']
+    use_names = ["Object_Name_Deferred_Shape_Spec_List_Item_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'ALLOCATABLE', Object_Name_Deferred_Shape_Spec_List_Item_List,
-            string, check_colons=True, require_cls=True)
-    match = staticmethod(match)
+            "ALLOCATABLE",
+            Object_Name_Deferred_Shape_Spec_List_Item_List,
+            string,
+            colons=True,
+            require_cls=True,
+        )
 
 
 class Asynchronous_Stmt(StmtBase, WORDClsBase):  # R521
     """
-:F03R:`521`::
-    <asynchronous-stmt> = ASYNCHRONOUS [ :: ] <object-name-list>
+    Fortran2003 Rule R521::
+
+        <asynchronous-stmt> = ASYNCHRONOUS [ :: ] <object-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Object_Name_List']
+    use_names = ["Object_Name_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'ASYNCHRONOUS', Object_Name_List, string, check_colons=True,
-            require_cls=True)
-    match = staticmethod(match)
+            "ASYNCHRONOUS", Object_Name_List, string, colons=True, require_cls=True
+        )
 
 
 class Bind_Stmt(StmtBase):  # R522
     """
-:F03R:`522`::
-    <bind-stmt> = <language-binding-spec> [ :: ] <bind-entity-list>
+    Fortran2003 Rule R522::
+
+        <bind-stmt> = <language-binding-spec> [ :: ] <bind-entity-list>
+
     """
+
     subclass_names = []
-    use_names = ['Language_Binding_Spec', 'Bind_Entity_List']
+    use_names = ["Language_Binding_Spec", "Bind_Entity_List"]
 
+    @staticmethod
     def match(string):
-        i = string.find('::')
+        i = string.find("::")
         if i == -1:
-            i = string.find(')')
+            i = string.find(")")
             if i == -1:
                 return
-            lhs, rhs = string[:i], string[i+1:]
+            lhs, rhs = string[:i], string[i + 1 :]
         else:
-            lhs, rhs = string.split('::', 1)
+            lhs, rhs = string.split("::", 1)
         lhs = lhs.rstrip()
         rhs = rhs.lstrip()
         if not lhs or not rhs:
             return
         return Language_Binding_Spec(lhs), Bind_Entity_List(rhs)
-    match = staticmethod(match)
 
     def tostr(self):
-        return '%s :: %s' % self.items
+        return "%s :: %s" % self.items
 
 
 class Bind_Entity(BracketBase):  # R523
     """
-    <bind-entity> = <entity-name>
-                    | / <common-block-name> /
+    ::
+
+        <bind-entity> = <entity-name>
+                        | / <common-block-name> /
+
     """
-    subclass_names = ['Entity_Name']
-    use_names = ['Common_Block_Name']
 
+    subclass_names = ["Entity_Name"]
+    use_names = ["Common_Block_Name"]
+
+    @staticmethod
     def match(string):
-        return BracketBase.match('//', Common_Block_Name, string)
-    match = staticmethod(match)
+        return BracketBase.match("//", Common_Block_Name, string)
 
 
 class Data_Stmt(StmtBase):  # R524
     """
-:F03R:524::
-    <data-stmt> = DATA <data-stmt-set> [ [ , ] <data-stmt-set> ]...
+    Fortran 2003 Rule R524::
+
+        <data-stmt> = DATA <data-stmt-set> [ [ , ] <data-stmt-set> ]...
+
     """
+
     subclass_names = []
-    use_names = ['Data_Stmt_Set']
+    use_names = ["Data_Stmt_Set"]
 
     @staticmethod
     def match(string):
-        if string[:4].upper() != 'DATA':
+        if string[:4].upper() != "DATA":
             return
         line, repmap = string_replace_map(string[4:].lstrip())
-        i = line.find('/')
+        i = line.find("/")
         if i == -1:
             return
-        i = line.find('/', i + 1)
+        i = line.find("/", i + 1)
         if i == -1:
             return
-        items = [Data_Stmt_Set(repmap(line[:i+1]))]
-        line = line[i+1:].lstrip()
+        items = [Data_Stmt_Set(repmap(line[: i + 1]))]
+        line = line[i + 1 :].lstrip()
         while line:
-            if line.startswith(','):
+            if line.startswith(","):
                 line = line[1:].lstrip()
-            i = line.find('/')
+            i = line.find("/")
             if i == -1:
                 return
-            i = line.find('/', i + 1)
+            i = line.find("/", i + 1)
             if i == -1:
                 return
-            items.append(Data_Stmt_Set(repmap(line[:i+1])))
-            line = line[i+1:].lstrip()
+            items.append(Data_Stmt_Set(repmap(line[: i + 1])))
+            line = line[i + 1 :].lstrip()
         return tuple(items)
 
     def tostr(self):
-        return 'DATA ' + ', '.join(map(str, self.items))
+        return "DATA " + ", ".join(map(str, self.items))
 
 
 class Data_Stmt_Set(Base):  # R525
     """
-:F03R:525::
-    <data-stmt-set> = <data-stmt-object-list> / <data-stmt-value-list> /
+    Fortran2003 Rule R525::
+
+        <data-stmt-set> = <data-stmt-object-list> / <data-stmt-value-list> /
+
     """
+
     subclass_names = []
-    use_names = ['Data_Stmt_Object_List', 'Data_Stmt_Value_List']
+    use_names = ["Data_Stmt_Object_List", "Data_Stmt_Value_List"]
 
     @staticmethod
     def match(string):
-        if not string.endswith('/'):
+        if not string.endswith("/"):
             return
         line, repmap = string_replace_map(string)
-        i = line.find('/')
+        i = line.find("/")
         if i == -1:
             return
-        data_stmt_object_list = Data_Stmt_Object_List(
-            repmap(line[:i].rstrip()))
-        data_stmt_value_list = Data_Stmt_Value_List(
-            repmap(line[i+1:-1].strip()))
+        data_stmt_object_list = Data_Stmt_Object_List(repmap(line[:i].rstrip()))
+        data_stmt_value_list = Data_Stmt_Value_List(repmap(line[i + 1 : -1].strip()))
         return data_stmt_object_list, data_stmt_value_list
 
     data_stmt_object_list = property(lambda self: self.items[0])
     data_stmt_value_list = property(lambda self: self.items[1])
 
     def tostr(self):
-        return '%s / %s /' % tuple(self.items)
+        return "%s / %s /" % tuple(self.items)
 
 
 class Data_Stmt_Object(Base):  # R526
     """
-:F03R:526::
-    <data-stmt-object> = <variable>
-                         | <data-implied-do>
+    Fortran 2003 Rule R526::
+
+        <data-stmt-object> = <variable>
+                             | <data-implied-do>
+
     """
-    subclass_names = ['Variable', 'Data_Implied_Do']
+
+    subclass_names = ["Variable", "Data_Implied_Do"]
 
 
 class Data_Implied_Do(Base):  # R527
     """
-:F03R:527::
-    <data-implied-do> = ( <data-i-do-object-list> ,
-        <data-i-do-variable> = <scalar-int-expr > ,
-        <scalar-int-expr> [ , <scalar-int-expr> ] )
+    Fortran 2003 Rule R527::
+
+        <data-implied-do> = ( <data-i-do-object-list> ,
+            <data-i-do-variable> = <scalar-int-expr > ,
+            <scalar-int-expr> [ , <scalar-int-expr> ] )
+
     """
+
     subclass_names = []
-    use_names = ['Data_I_Do_Object_List', 'Data_I_Do_Variable',
-                 'Scalar_Int_Expr']
+    use_names = ["Data_I_Do_Object_List", "Data_I_Do_Variable", "Scalar_Int_Expr"]
 
     @staticmethod
     def match(string):
-        if not (string.startswith('(') and string.endswith(')')):
+        if not (string.startswith("(") and string.endswith(")")):
             return
         line, repmap = string_replace_map(string[1:-1].strip())
-        s = line.split('=', 1)
+        s = line.split("=", 1)
         if len(s) != 2:
             return
         lhs = s[0].rstrip()
         rhs = s[1].lstrip()
-        s1 = lhs.rsplit(',', 1)
+        s1 = lhs.rsplit(",", 1)
         if len(s1) != 2:
             return
-        s2 = rhs.split(',')
+        s2 = rhs.split(",")
         if len(s2) not in [2, 3]:
             return
         data_i_do_object_list = Data_I_Do_Object_List(repmap(s1[0].rstrip()))
         data_i_do_variable = Data_I_Do_Variable(repmap(s1[1].lstrip()))
         scalar_int_expr1 = Scalar_Int_Expr(repmap(s2[0].rstrip()))
         scalar_int_expr2 = Scalar_Int_Expr(repmap(s2[1].strip()))
         if len(s2) == 3:
             scalar_int_expr3 = Scalar_Int_Expr(repmap(s2[2].lstrip()))
         else:
             scalar_int_expr3 = None
-        return data_i_do_object_list, data_i_do_variable, \
-            scalar_int_expr1, scalar_int_expr2, scalar_int_expr3
+        return (
+            data_i_do_object_list,
+            data_i_do_variable,
+            scalar_int_expr1,
+            scalar_int_expr2,
+            scalar_int_expr3,
+        )
 
     data_i_do_object_list = property(lambda self: self.items[0])
     data_i_do_variable = property(lambda self: self.items[1])
     scalar_int_expr1 = property(lambda self: self.items[2])
     scalar_int_expr2 = property(lambda self: self.items[3])
     scalar_int_expr3 = property(lambda self: self.items[4])
 
     def tostr(self):
-        tmp = '%s, %s = %s, %s' % tuple(self.items[:4])
+        tmp = "%s, %s = %s, %s" % tuple(self.items[:4])
         if self.items[4] is not None:
-            tmp += ', %s' % (self.items[4])
-        return '(' + tmp + ')'
+            tmp += ", %s" % (self.items[4])
+        return "(" + tmp + ")"
 
 
 class Data_I_Do_Object(Base):  # R528
     """
-    <data-i-do-object> = <array-element>
-                         | <scalar-structure-component>
-                         | <data-implied-do>
+    ::
+
+        <data-i-do-object> = <array-element>
+                             | <scalar-structure-component>
+                             | <data-implied-do>
+
     """
-    subclass_names = ['Array_Element', 'Scalar_Structure_Component',
-                      'Data_Implied_Do']
+
+    subclass_names = ["Array_Element", "Scalar_Structure_Component", "Data_Implied_Do"]
 
 
 class Data_I_Do_Variable(Base):  # R529
     """
-    <data-i-do-variable> = <scalar-int-variable>
+    ::
+
+        <data-i-do-variable> = <scalar-int-variable>
+
     """
-    subclass_names = ['Scalar_Int_Variable']
+
+    subclass_names = ["Scalar_Int_Variable"]
 
 
 class Data_Stmt_Value(Base):  # R530
     """
-    <data-stmt-value> = [ <data-stmt-repeat> * ] <data-stmt-constant>
+    ::
+
+        <data-stmt-value> = [ <data-stmt-repeat> * ] <data-stmt-constant>
+
     """
-    subclass_names = ['Data_Stmt_Constant']
-    use_names = ['Data_Stmt_Repeat']
 
+    subclass_names = ["Data_Stmt_Constant"]
+    use_names = ["Data_Stmt_Repeat"]
+
+    @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        s = line.split('*', 1)
+        s = line.split("*", 1)
         if len(s) != 2:
             return
         lhs = repmap(s[0].rstrip())
         rhs = repmap(s[1].lstrip())
         if not lhs or not rhs:
             return
         return Data_Stmt_Repeat(lhs), Data_Stmt_Constant(rhs)
-    match = staticmethod(match)
 
     def tostr(self):
-        return '%s * %s' % self.items
+        return "%s * %s" % self.items
 
 
 class Data_Stmt_Repeat(Base):  # R531
     """
-    <data-stmt-repeat> = <scalar-int-constant>
-                         | <scalar-int-constant-subobject>
+    ::
+
+        <data-stmt-repeat> = <scalar-int-constant>
+                             | <scalar-int-constant-subobject>
+
     """
-    subclass_names = ['Scalar_Int_Constant', 'Scalar_Int_Constant_Subobject']
+
+    subclass_names = ["Scalar_Int_Constant", "Scalar_Int_Constant_Subobject"]
 
 
 class Data_Stmt_Constant(Base):  # R532
     """
-    <data-stmt-constant> = <scalar-constant>
-                           | <scalar-constant-subobject>
-                           | <signed-int-literal-constant>
-                           | <signed-real-literal-constant>
-                           | <null-init>
-                           | <structure-constructor>
-    """
-    subclass_names = ['Scalar_Constant', 'Scalar_Constant_Subobject',
-                      'Signed_Int_Literal_Constant',
-                      'Signed_Real_Literal_Constant',
-                      'Null_Init', 'Structure_Constructor']
+    Fortran 2003 Rule R532::
+
+        <data-stmt-constant> = <scalar-constant>
+                               | <scalar-constant-subobject>
+                               | <signed-int-literal-constant>
+                               | <signed-real-literal-constant>
+                               | <null-init>
+                               | <structure-constructor>
+
+    """
+
+    subclass_names = [
+        "Scalar_Constant",
+        "Scalar_Constant_Subobject",
+        "Signed_Int_Literal_Constant",
+        "Signed_Real_Literal_Constant",
+        "Null_Init",
+        "Structure_Constructor",
+    ]
 
 
 class Int_Constant_Subobject(Base):  # R533
     """
-    <int-constant-subobject> = <constant-subobject>
+    Fortran 2003 Rule R533::
+
+        <int-constant-subobject> = <constant-subobject>
+
     """
-    subclass_names = ['Constant_Subobject']
+
+    subclass_names = ["Constant_Subobject"]
 
 
 class Constant_Subobject(Base):  # R534
     """
-    <constant-subobject> = <designator>
+    Fortran 2003 Rule R534::
+
+        <constant-subobject> = <designator>
+
     """
-    subclass_names = ['Designator']
+
+    subclass_names = ["Designator"]
 
 
 class Dimension_Stmt(StmtBase):  # R535
     """
-    <dimension-stmt> = DIMENSION [ :: ] <array-name> ( <array-spec> )
-        [ , <array-name> ( <array-spec> ) ]...
+    Fortran 2003 Rule R535::
+
+        <dimension-stmt> = DIMENSION [ :: ] <array-name> ( <array-spec> )
+            [ , <array-name> ( <array-spec> ) ]...
+
     """
+
     subclass_names = []
-    use_names = ['Array_Name', 'Array_Spec']
+    use_names = ["Array_Name", "Array_Spec"]
 
+    @staticmethod
     def match(string):
-        if string[:9].upper() != 'DIMENSION':
+        if string[:9].upper() != "DIMENSION":
             return
         line, repmap = string_replace_map(string[9:].lstrip())
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         decls = []
-        for s in line.split(','):
+        for s in line.split(","):
             s = s.strip()
-            if not s.endswith(')'):
+            if not s.endswith(")"):
                 return
-            i = s.find('(')
+            i = s.find("(")
             if i == -1:
                 return
-            decls.append((Array_Name(repmap(s[:i].rstrip())),
-                          Array_Spec(repmap(s[i+1:-1].strip()))))
+            decls.append(
+                (
+                    Array_Name(repmap(s[:i].rstrip())),
+                    Array_Spec(repmap(s[i + 1 : -1].strip())),
+                )
+            )
         if not decls:
             return
-        return decls,
-    match = staticmethod(match)
+        return (decls,)
 
     def tostr(self):
-        return 'DIMENSION :: ' + ', '.join(['%s(%s)'
-                                            % ns for ns in self.items[0]])
+        return "DIMENSION :: " + ", ".join(["%s(%s)" % ns for ns in self.items[0]])
 
 
 class Intent_Stmt(StmtBase):  # R536
     """
-    <intent-stmt> = INTENT ( <intent-spec> ) [ :: ] <dummy-arg-name-list>
+    ::
+
+        <intent-stmt> = INTENT ( <intent-spec> ) [ :: ] <dummy-arg-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Intent_Spec', 'Dummy_Arg_Name_List']
+    use_names = ["Intent_Spec", "Dummy_Arg_Name_List"]
 
+    @staticmethod
     def match(string):
-        if string[:6].upper() != 'INTENT':
+        if string[:6].upper() != "INTENT":
             return
         line = string[6:].lstrip()
-        if not line or not line.startswith('('):
+        if not line or not line.startswith("("):
             return
-        i = line.rfind(')')
+        i = line.rfind(")")
         if i == -1:
             return
         spec = line[1:i].strip()
         if not spec:
             return
-        line = line[i+1:].lstrip()
-        if line.startswith('::'):
+        line = line[i + 1 :].lstrip()
+        if line.startswith("::"):
             line = line[2:].lstrip()
         if not line:
             return
         return Intent_Spec(spec), Dummy_Arg_Name_List(line)
-    match = staticmethod(match)
 
     def tostr(self):
-        return 'INTENT(%s) :: %s' % self.items
+        return "INTENT(%s) :: %s" % self.items
 
 
 class Optional_Stmt(StmtBase, WORDClsBase):  # R537
     """
-    <optional-stmt> = OPTIONAL [ :: ] <dummy-arg-name-list>
+    ::
+
+        <optional-stmt> = OPTIONAL [ :: ] <dummy-arg-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Dummy_Arg_Name_List']
+    use_names = ["Dummy_Arg_Name_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'OPTIONAL', Dummy_Arg_Name_List, string, check_colons=True,
-            require_cls=True)
-    match = staticmethod(match)
+            "OPTIONAL", Dummy_Arg_Name_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Parameter_Stmt(StmtBase, CALLBase):  # R538
     """
-    <parameter-stmt> = PARAMETER ( <named-constant-def-list> )
+    ::
+
+        <parameter-stmt> = PARAMETER ( <named-constant-def-list> )
+
     """
+
     subclass_names = []
-    use_names = ['Named_Constant_Def_List']
+    use_names = ["Named_Constant_Def_List"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match('PARAMETER', Named_Constant_Def_List,
-                              string, require_rhs=True)
-    match = staticmethod(match)
+        return CALLBase.match(
+            "PARAMETER", Named_Constant_Def_List, string, require_rhs=True
+        )
 
 
 class Named_Constant_Def(KeywordValueBase):  # R539
     """
-    <named-constant-def> = <named-constant> = <initialization-expr>
+    ::
+
+        <named-constant-def> = <named-constant> = <initialization-expr>
+
     """
+
     subclass_names = []
-    use_names = ['Named_Constant', 'Initialization_Expr']
+    use_names = ["Named_Constant", "Initialization_Expr"]
 
+    @staticmethod
     def match(string):
-        return KeywordValueBase.match(Named_Constant, Initialization_Expr,
-                                      string)
-    match = staticmethod(match)
+        return KeywordValueBase.match(Named_Constant, Initialization_Expr, string)
 
 
 class Cray_Pointer_Stmt(StmtBase, WORDClsBase):  # pylint: disable=invalid-name
-    '''
-    cray-pointer-stmt is POINTER cray-pointer-decl-list
-    '''
+    """
+    ::
+
+        cray-pointer-stmt is POINTER cray-pointer-decl-list
+
+    """
+
     subclass_names = []
-    use_names = ['Cray_Pointer_Decl_List']
+    use_names = ["Cray_Pointer_Decl_List"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Cray-pointer statement.
+        """Implements the matching for a Cray-pointer statement.
 
         :param string: the reader or string to match as a Cray-pointer \
-        statement.
+                       statement.
         :type string: \
         :py:class:`fparser.common.readfortran.FortranReaderBase` or \
         `str`
         :return: a tuple of size 2 containing a string with the name \
         "POINTER" and a cray-pointer-decl-list, if there is a match, \
         or `None` if there is not.
         :rtype: (str, Cray_Pointer_Decl_List) or None
 
-        '''
+        """
         from fparser.two.utils import EXTENSIONS
-        if 'cray-pointer' not in EXTENSIONS:
+
+        if "cray-pointer" not in EXTENSIONS:
             return None
-        return WORDClsBase.match('POINTER', Cray_Pointer_Decl_List, string,
-                                 require_cls=True)
+        return WORDClsBase.match(
+            "POINTER", Cray_Pointer_Decl_List, string, require_cls=True
+        )
 
 
 class Cray_Pointer_Decl(Base):  # pylint: disable=invalid-name
-    '''
-    cray-pointer-decl is ( cray-pointer-name, cray-pointee-decl )
-    '''
-    use_names = ['Cray_Pointer_Name', 'Cray_Pointee_Name', 'Cray_Pointee_Decl']
+    """
+    ::
+
+        cray-pointer-decl is ( cray-pointer-name, cray-pointee-decl )
+
+    """
+
+    use_names = ["Cray_Pointer_Name", "Cray_Pointee_Name", "Cray_Pointee_Decl"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Cray-pointer declaration.
+        """Implements the matching for a Cray-pointer declaration.
 
         :param str string: the string to match as a Cray-pointer \
         declaration.
         :return: None if there is no match, otherwise a tuple of size \
         2 containing the name of the pointer as the first argument and \
         either the name of the pointee as the second argument or a \
         Cray-pointee declaration.
         :rtype: None, (Name, Name) or (Name, Cray_Pointee_Decl)
 
-        '''
+        """
         if not string:
             return None
         strip_string = string.strip()
         if not strip_string:
             return None
         if not strip_string[0] == "(":
             return None
         if not strip_string[-1] == ")":
             return None
         strip_string_nobr = strip_string[1:-1].strip()
         line, repmap = string_replace_map(strip_string_nobr)
-        split_list = line.split(',')
+        split_list = line.split(",")
         if len(split_list) != 2:
             return None
         pointer_name = repmap(split_list[0]).strip()
         pointee_str = repmap(split_list[1]).strip()
         if pointee_str[-1] == ")":
-            return Cray_Pointer_Name(pointer_name), \
-                Cray_Pointee_Decl(pointee_str)
+            return Cray_Pointer_Name(pointer_name), Cray_Pointee_Decl(pointee_str)
         return Cray_Pointer_Name(pointer_name), Cray_Pointee_Name(pointee_str)
 
     def tostr(self):
-        '''
+        """
         :return: this Cray-pointee declaration as a string
         :rtype: str
+
         :raises InternalError: if the internal items list variable is \
         not the expected size.
         :raises InternalError: if the first element of the internal \
         items list is None or is empty.
         :raises InternalError: if the second element of the internal \
         items list is None or is empty.
-        '''
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Cray_Pointer_Decl.tostr(). 'Items' should be of size 2 but "
-                "found '{0}'.".format(len(self.items)))
+                "found '{0}'.".format(len(self.items))
+            )
         if not self.items[0]:
-            raise InternalError("Cray_Pointer_Decl_Stmt.tostr(). 'Items' "
-                                "entry 0 should be a pointer name but it is "
-                                "empty")
+            raise InternalError(
+                "Cray_Pointer_Decl_Stmt.tostr(). 'Items' "
+                "entry 0 should be a pointer name but it is "
+                "empty"
+            )
         if not self.items[1]:
-            raise InternalError("Cray_Pointer_Decl_Stmt.tostr(). 'Items' "
-                                "entry 1 should be a pointee name or pointee "
-                                "declaration but it is empty")
+            raise InternalError(
+                "Cray_Pointer_Decl_Stmt.tostr(). 'Items' "
+                "entry 1 should be a pointee name or pointee "
+                "declaration but it is empty"
+            )
         return "({0}, {1})".format(self.items[0], self.items[1])
 
 
 class Cray_Pointee_Decl(CallBase):  # pylint: disable=invalid-name
-    '''
-    cray-pointee-decl is cray-pointee-name ( cray-pointee-array-spec )
+    """
+    ::
+
+        cray-pointee-decl is cray-pointee-name ( cray-pointee-array-spec )
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Cray_Pointee_Name', 'Cray_Pointee_Array_Spec']
+    use_names = ["Cray_Pointee_Name", "Cray_Pointee_Array_Spec"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Cray-pointee declaration.
+        """Implements the matching for a Cray-pointee declaration.
 
         :param str string: the string to match as a Cray-pointee \
         declaration.
         :return: None if there is no match, otherwise a tuple of size \
         2 containing the name of the pointee as the first argument and \
         a Cray-pointee array spec as the second argument.
         :rtype: None or (Name, Cray_Pointee_Array_Spec)
 
-        '''
+        """
         return CallBase.match(
-            Cray_Pointee_Name, Cray_Pointee_Array_Spec, string,
-            require_rhs=True)
+            Cray_Pointee_Name, Cray_Pointee_Array_Spec, string, require_rhs=True
+        )
 
 
 class Cray_Pointee_Array_Spec(Base):  # pylint: disable=invalid-name
-    '''cray-pointee-array-spec is explicit-shape-spec-list
-                            or assumed-size-spec
+    """
+    ::
+
+        cray-pointee-array-spec is explicit-shape-spec-list
+                                or assumed-size-spec
 
     The above two forms of declaration are the only ones allowed
     according to
-    http://pubs.cray.com/content/S-3901/8.6/
-    cray-fortran-reference-manual-s-3901-86/types) or
-    https://docs.oracle.com/cd/E19957-01/805-4941/z40000a54ba7/index.html
+    `<http://pubs.cray.com/content/S-3901/8.6/
+    cray-fortran-reference-manual-s-3901-86/types>`_ or
+    `<https://docs.oracle.com/cd/E19957-01/805-4941/z40000a54ba7/index.html>`_
 
-    '''
-    subclass_names = ['Assumed_Size_Spec', 'Explicit_Shape_Spec_List']
+    """
+
+    subclass_names = ["Assumed_Size_Spec", "Explicit_Shape_Spec_List"]
 
 
 class Pointer_Stmt(StmtBase, WORDClsBase):  # R540
     """
-    <pointer-stmt> = POINTER [ :: ] <pointer-decl-list>
+    ::
+
+        <pointer-stmt> = POINTER [ :: ] <pointer-decl-list>
+
     """
+
     subclass_names = []
-    use_names = ['Pointer_Decl_List']
+    use_names = ["Pointer_Decl_List"]
 
+    @staticmethod
     def match(string):
-        return WORDClsBase.match('POINTER', Pointer_Decl_List, string,
-                                 check_colons=True, require_cls=True)
-    match = staticmethod(match)
+        return WORDClsBase.match(
+            "POINTER", Pointer_Decl_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Pointer_Decl(CallBase):  # R541
     """
-    <pointer-decl> = <object-name> [ ( <deferred-shape-spec-list> ) ]
-                     | <proc-entity-name>
+    ::
+
+        <pointer-decl> = <object-name> [ ( <deferred-shape-spec-list> ) ]
+                         | <proc-entity-name>
+
     """
-    subclass_names = ['Proc_Entity_Name', 'Object_Name']
-    use_names = ['Deferred_Shape_Spec_List']
 
+    subclass_names = ["Proc_Entity_Name", "Object_Name"]
+    use_names = ["Deferred_Shape_Spec_List"]
+
+    @staticmethod
     def match(string):
-        return CallBase.match(Object_Name, Deferred_Shape_Spec_List,
-                              string, require_rhs=True)
-    match = staticmethod(match)
+        return CallBase.match(
+            Object_Name, Deferred_Shape_Spec_List, string, require_rhs=True
+        )
 
 
 class Protected_Stmt(StmtBase, WORDClsBase):  # R542
     """
-    <protected-stmt> = PROTECTED [ :: ] <entity-name-list>
+    ::
+
+        <protected-stmt> = PROTECTED [ :: ] <entity-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Entity_Name_List']
+    use_names = ["Entity_Name_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'PROTECTED', Entity_Name_List, string, check_colons=True,
-            require_cls=True)
-    match = staticmethod(match)
+            "PROTECTED", Entity_Name_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Save_Stmt(StmtBase, WORDClsBase):  # R543
     """
-    <save-stmt> = SAVE [ [ :: ] <saved-entity-list> ]
+    ::
+
+        <save-stmt> = SAVE [ [ :: ] <saved-entity-list> ]
+
     """
+
     subclass_names = []
-    use_names = ['Saved_Entity_List']
+    use_names = ["Saved_Entity_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'SAVE', Saved_Entity_List, string, check_colons=True,
-            require_cls=False)
-    match = staticmethod(match)
+            "SAVE", Saved_Entity_List, string, colons=True, require_cls=False
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Saved_Entity(BracketBase):  # R544
     """
-    <saved-entity> = <object-name>
-                     | <proc-pointer-name>
-                     | / <common-block-name> /
+    ::
+
+        <saved-entity> = <object-name>
+                         | <proc-pointer-name>
+                         | / <common-block-name> /
+
     """
-    subclass_names = ['Object_Name', 'Proc_Pointer_Name']
-    use_names = ['Common_Block_Name']
 
+    subclass_names = ["Object_Name", "Proc_Pointer_Name"]
+    use_names = ["Common_Block_Name"]
+
+    @staticmethod
     def match(string):
-        return BracketBase.match('//', Common_Block_Name, string)
-    match = staticmethod(match)
+        return BracketBase.match("//", Common_Block_Name, string)
 
 
 class Proc_Pointer_Name(Base):  # R545
     """
-    <proc-pointer-name> = <name>
+    ::
+
+        <proc-pointer-name> = <name>
+
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Target_Entity_Decl(Entity_Decl):
     """
-    <target-entity-decl> = <object-name> [ ( <array-spec> ) ]
+    ::
+
+        <target-entity-decl> = <object-name> [ ( <array-spec> ) ]
+
     """
+
     subclass_names = []
-    use_names = ['Object_Name', 'Array_Spec']
+    use_names = ["Object_Name", "Array_Spec"]
 
     @staticmethod
     def match(string):
         return Entity_Decl.match(string, target=True)
 
 
 class Target_Stmt(StmtBase):  # R546
     """
-    <target-stmt> = TARGET [ :: ] <target-entity-decl-list>
+    ::
+
+        <target-stmt> = TARGET [ :: ] <target-entity-decl-list>
+
     """
+
     subclass_names = []
-    use_names = ['Target_Entity_Decl_List']
+    use_names = ["Target_Entity_Decl_List"]
 
     @staticmethod
     def match(string):
-        if string[:6].upper() != 'TARGET':
+        if string[:6].upper() != "TARGET":
             return
         line = string[6:].lstrip()
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
-        return Target_Entity_Decl_List(line),
+        return (Target_Entity_Decl_List(line),)
 
     def tostr(self):
-        return 'TARGET :: %s' % (self.items[0])
+        return "TARGET :: %s" % (self.items[0])
 
 
 class Value_Stmt(StmtBase, WORDClsBase):  # R547
     """
-    <value-stmt> = VALUE [ :: ] <dummy-arg-name-list>
+    ::
+
+        <value-stmt> = VALUE [ :: ] <dummy-arg-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Dummy_Arg_Name_List']
+    use_names = ["Dummy_Arg_Name_List"]
 
     @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'VALUE', Dummy_Arg_Name_List, string, check_colons=True,
-            require_cls=True)
+            "VALUE", Dummy_Arg_Name_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Volatile_Stmt(StmtBase, WORDClsBase):  # R548
     """
-    <volatile-stmt> = VOLATILE [ :: ] <object-name-list>
+    ::
+
+        <volatile-stmt> = VOLATILE [ :: ] <object-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Object_Name_List']
+    use_names = ["Object_Name_List"]
 
     @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'VOLATILE', Object_Name_List, string, check_colons=True,
-            require_cls=True)
+            "VOLATILE", Object_Name_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Implicit_Stmt(StmtBase):  # R549
     """
-::
-    <implicit-stmt> = IMPLICIT <implicit-spec-list>
-                      | IMPLICIT NONE
+    ::
+
+        <implicit-stmt> = IMPLICIT <implicit-spec-list>
+                          | IMPLICIT NONE
+
+    Has attributes::
+
+        items : ({'NONE', Implicit_Spec_List},)
 
-Attributes
-----------
-items : ({'NONE', Implicit_Spec_List},)
     """
+
     subclass_names = []
-    use_names = ['Implicit_Spec_List']
+    use_names = ["Implicit_Spec_List"]
 
     @staticmethod
     def match(string):
-        if string[:8].upper() != 'IMPLICIT':
+        if string[:8].upper() != "IMPLICIT":
             return
         line = string[8:].lstrip()
-        if len(line) == 4 and line.upper() == 'NONE':
-            return 'NONE',
-        return Implicit_Spec_List(line),
-        for w, cls in [(pattern.abs_implicit_none, None),
-                       ('IMPLICIT', Implicit_Spec_List)]:
+        if len(line) == 4 and line.upper() == "NONE":
+            return ("NONE",)
+        return (Implicit_Spec_List(line),)
+        for w, cls in [
+            (pattern.abs_implicit_none, None),
+            ("IMPLICIT", Implicit_Spec_List),
+        ]:
             try:
                 obj = WORDClsBase.match(w, cls, string)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return
+        return None
 
     def tostr(self):
-        return 'IMPLICIT %s' % (self.items[0])
+        return "IMPLICIT %s" % (self.items[0])
 
 
 class Implicit_Spec(CallBase):  # R550
     """
-    <implicit-spec> = <declaration-type-spec> ( <letter-spec-list> )
+    ::
+
+        <implicit-spec> = <declaration-type-spec> ( <letter-spec-list> )
+
     """
+
     subclass_names = []
-    use_names = ['Declaration_Type_Spec', 'Letter_Spec_List']
+    use_names = ["Declaration_Type_Spec", "Letter_Spec_List"]
 
+    @staticmethod
     def match(string):
-        if not string.endswith(')'):
+        if not string.endswith(")"):
             return
-        i = string.rfind('(')
+        i = string.rfind("(")
         if i == -1:
             return
         s1 = string[:i].rstrip()
-        s2 = string[i+1:-1].strip()
+        s2 = string[i + 1 : -1].strip()
         if not s1 or not s2:
             return
         return Declaration_Type_Spec(s1), Letter_Spec_List(s2)
-    match = staticmethod(match)
 
 
 class Letter_Spec(Base):  # R551
     """
-    <letter-spec> = <letter> [ - <letter> ]
+    ::
+
+        <letter-spec> = <letter> [ - <letter> ]
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
         if len(string) == 1:
             lhs = string.upper()
-            if 'A' <= lhs <= 'Z':
+            if "A" <= lhs <= "Z":
                 return lhs, None
             return
-        if '-' not in string:
+        if "-" not in string:
             return
-        lhs, rhs = string.split('-', 1)
+        lhs, rhs = string.split("-", 1)
         lhs = lhs.strip().upper()
         rhs = rhs.strip().upper()
         if not len(lhs) == len(rhs) == 1:
             return
-        if not ('A' <= lhs <= rhs <= 'Z'):
+        if not ("A" <= lhs <= rhs <= "Z"):
             return
         return lhs, rhs
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[1] is None:
             return str(self.items[0])
-        return '%s - %s' % tuple(self.items)
+        return "%s - %s" % tuple(self.items)
 
 
 class Namelist_Stmt(StmtBase):  # R552
     """
-::
-    <namelist-stmt> = NAMELIST / <namelist-group-name> /
-        <namelist-group-object-list> [ [ , ] / <namelist-group-name> /
-        <namelist-group-object-list> ]...
+    ::
+
+        <namelist-stmt> = NAMELIST / <namelist-group-name> /
+            <namelist-group-object-list> [ [ , ] / <namelist-group-name> /
+            <namelist-group-object-list> ]...
+
+    Attributes::
+
+        items : (Namelist_Group_Name, Namelist_Group_Object_List)-tuple
 
-Attributes
-----------
-items : (Namelist_Group_Name, Namelist_Group_Object_List)-tuple
     """
+
     subclass_names = []
-    use_names = ['Namelist_Group_Name', 'Namelist_Group_Object_List']
+    use_names = ["Namelist_Group_Name", "Namelist_Group_Object_List"]
 
     @staticmethod
     def match(string):
-        if string[:8].upper() != 'NAMELIST':
+        if string[:8].upper() != "NAMELIST":
             return
         line = string[8:].lstrip()
-        parts = line.split('/')
+        parts = line.split("/")
         items = []
         fst = parts.pop(0)
         assert not fst, repr((fst, parts))
         while len(parts) >= 2:
             name, lst = parts[:2]
             del parts[:2]
             name = name.strip()
             lst = lst.strip()
-            if lst.endswith(','):
+            if lst.endswith(","):
                 lst = lst[:-1].rstrip()
-            items.append(
-                (Namelist_Group_Name(name), Namelist_Group_Object_List(lst)))
+            items.append((Namelist_Group_Name(name), Namelist_Group_Object_List(lst)))
         assert not parts, repr(parts)
         return tuple(items)
 
     def tostr(self):
-        return 'NAMELIST ' + ', '.join('/%s/ %s' % (name_lst)
-                                       for name_lst in self.items)
+        return "NAMELIST " + ", ".join(
+            "/%s/ %s" % (name_lst) for name_lst in self.items
+        )
 
 
 class Namelist_Group_Object(Base):  # R553
     """
-    <namelist-group-object> = <variable-name>
+    ::
+
+        <namelist-group-object> = <variable-name>
+
     """
-    subclass_names = ['Variable_Name']
+
+    subclass_names = ["Variable_Name"]
 
 
 class Equivalence_Stmt(StmtBase, WORDClsBase):  # R554
     """
-    <equivalence-stmt> = EQUIVALENCE <equivalence-set-list>
+    ::
+
+        <equivalence-stmt> = EQUIVALENCE <equivalence-set-list>
+
     """
+
     subclass_names = []
-    use_names = ['Equivalence_Set_List']
+    use_names = ["Equivalence_Set_List"]
 
+    @staticmethod
     def match(string):
-        return WORDClsBase.match('EQUIVALENCE', Equivalence_Set_List, string)
-    match = staticmethod(match)
+        return WORDClsBase.match("EQUIVALENCE", Equivalence_Set_List, string)
 
 
 class Equivalence_Set(Base):  # R555
     """
-    <equivalence-set> = ( <equivalence-object> , <equivalence-object-list> )
+    ::
+
+        <equivalence-set> = ( <equivalence-object> , <equivalence-object-list> )
+
     """
+
     subclass_names = []
-    use_names = ['Equivalence_Object', 'Equivalence_Object_List']
+    use_names = ["Equivalence_Object", "Equivalence_Object_List"]
 
+    @staticmethod
     def match(string):
-        if not string or string[0] + string[-1] != '()':
+        if not string or string[0] + string[-1] != "()":
             return
         line = string[1:-1].strip()
         if not line:
             return
         tmp = Equivalence_Object_List(line)
         obj = tmp.items[0]
         tmp.items = tmp.items[1:]
         if not tmp.items:
             return
         return obj, tmp
-    match = staticmethod(match)
 
     def tostr(self):
-        return '(%s, %s)' % tuple(self.items)
+        return "(%s, %s)" % tuple(self.items)
 
 
 class Equivalence_Object(Base):  # R556
     """
-    <equivalence-object> = <variable-name>
-                           | <array-element>
-                           | <substring>
+    ::
+
+        <equivalence-object> = <variable-name>
+                               | <array-element>
+                               | <substring>
+
     """
-    subclass_names = ['Variable_Name', 'Array_Element', 'Substring']
+
+    subclass_names = ["Variable_Name", "Array_Element", "Substring"]
 
 
 class Common_Stmt(StmtBase):  # R557
     """
-    <common-stmt> = COMMON [ / [ <common-block-name> ] / ]
-        <common-block-object-list> [ [ , ] / [ <common-block-name> ]
-        / <common-block-object-list> ]...
+    ::
+
+        <common-stmt> = COMMON [ / [ <common-block-name> ] / ]
+            <common-block-object-list> [ [ , ] / [ <common-block-name> ]
+            / <common-block-object-list> ]...
     """
+
     subclass_names = []
-    use_names = ['Common_Block_Name', 'Common_Block_Object_List']
+    use_names = ["Common_Block_Name", "Common_Block_Object_List"]
 
+    @staticmethod
     def match(string):
-        if string[:6].upper() != 'COMMON':
+        if string[:6].upper() != "COMMON":
             return
         line = string[6:]
-        if not line or 'A' <= line[0].upper() <= 'Z' or line[0] == '_':
+        if not line or "A" <= line[0].upper() <= "Z" or line[0] == "_":
             return
         line, repmap = string_replace_map(line.lstrip())
         items = []
-        if line.startswith('/'):
-            i = line.find('/', 1)
+        if line.startswith("/"):
+            i = line.find("/", 1)
             if i == -1:
                 return
             name = line[1:i].strip() or None
             if name is not None:
                 name = Common_Block_Name(name)
-            line = line[i+1:].lstrip()
-            i = line.find('/')
+            line = line[i + 1 :].lstrip()
+            i = line.find("/")
             if i == -1:
                 lst = Common_Block_Object_List(repmap(line))
-                line = ''
+                line = ""
             else:
                 tmp = line[:i].rstrip()
-                if tmp.endswith(','):
+                if tmp.endswith(","):
                     tmp = tmp[:-1].rstrip()
                 if not tmp:
                     return
                 lst = Common_Block_Object_List(repmap(tmp))
                 line = line[i:].lstrip()
         else:
             name = None
-            i = line.find('/')
+            i = line.find("/")
             if i == -1:
                 lst = Common_Block_Object_List(repmap(line))
-                line = ''
+                line = ""
             else:
                 tmp = line[:i].rstrip()
-                if tmp.endswith(','):
+                if tmp.endswith(","):
                     tmp = tmp[:-1].rstrip()
                 if not tmp:
                     return
                 lst = Common_Block_Object_List(repmap(tmp))
                 line = line[i:].lstrip()
         items.append((name, lst))
         while line:
-            if line.startswith(','):
+            if line.startswith(","):
                 line = line[1:].lstrip()
-            if not line.startswith('/'):
+            if not line.startswith("/"):
                 return
-            i = line.find('/', 1)
+            i = line.find("/", 1)
             name = line[1:i].strip() or None
             if name is not None:
                 name = Common_Block_Name(name)
-            line = line[i+1:].lstrip()
-            i = line.find('/')
+            line = line[i + 1 :].lstrip()
+            i = line.find("/")
             if i == -1:
                 lst = Common_Block_Object_List(repmap(line))
-                line = ''
+                line = ""
             else:
                 tmp = line[:i].rstrip()
-                if tmp.endswith(','):
+                if tmp.endswith(","):
                     tmp = tmp[:-1].rstrip()
                 if not tmp:
                     return
                 lst = Common_Block_Object_List(repmap(tmp))
                 line = line[i:].lstrip()
             items.append((name, lst))
-        return items,
-    match = staticmethod(match)
+        return (items,)
 
     def tostr(self):
-        s = 'COMMON'
-        for (name, lst) in self.items[0]:
+        s = "COMMON"
+        for name, lst in self.items[0]:
             if name is not None:
-                s += ' /%s/ %s' % (name, lst)
+                s += " /%s/ %s" % (name, lst)
             else:
-                s += ' // %s' % (lst)
+                s += " // %s" % (lst)
         return s
 
 
 class Common_Block_Object(CallBase):  # R558
     """
-    <common-block-object> = <variable-name> [ ( <explicit-shape-spec-list> ) ]
-                            | <proc-pointer-name>
+    ::
+
+        <common-block-object> = <variable-name> [ ( <explicit-shape-spec-list> ) ]
+                                | <proc-pointer-name>
+
     """
-    subclass_names = ['Proc_Pointer_Name', 'Variable_Name']
-    use_names = ['Variable_Name', 'Explicit_Shape_Spec_List']
 
+    subclass_names = ["Proc_Pointer_Name", "Variable_Name"]
+    use_names = ["Variable_Name", "Explicit_Shape_Spec_List"]
+
+    @staticmethod
     def match(string):
         return CallBase.match(
-            Variable_Name, Explicit_Shape_Spec_List, string,
-            require_rhs=True)
-    match = staticmethod(match)
+            Variable_Name, Explicit_Shape_Spec_List, string, require_rhs=True
+        )
+
 
 #
 # SECTION  6
 #
 
 
 class Variable(Base):  # R601
     """
-    <variable> = <designator>
+    ::
+
+        <variable> = <designator>
+
     """
-    subclass_names = ['Designator']
+
+    subclass_names = ["Designator"]
 
 
 class Variable_Name(Base):  # R602
     """
-    <variable-name> = <name>
+    ::
+
+        <variable-name> = <name>
+
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Designator(Base):  # R603
     """
-    <designator> = <object-name>
-                   | <array-element>
-                   | <array-section>
-                   | <structure-component>
-                   | <substring>
-    <substring-range> = [ <scalar-int-expr> ] : [ <scalar-int-expr> ]
-    <structure-component> = <data-ref>
-    """
-    subclass_names = ['Object_Name', 'Array_Section', 'Array_Element',
-                      'Structure_Component', 'Substring'
-                      ]
+    Fortran 2003 rule R603::
+
+        designator is object-name
+                   or array-element
+                   or array-section
+                   or structure-component
+                   or substring
+
+    """
+
+    # At the moment some array section text, and all structure
+    # component and substring text will match the array-element
+    # rule. This is because the associated rule constraints
+    # (e.g. C617, C618 and C619) and specification text (see note 6.6)
+    # are not currently enforced. Note, these constraints can not be
+    # enforced until issue #201 has been addressed.
+    subclass_names = [
+        "Object_Name",
+        "Array_Element",
+        "Array_Section",
+        "Structure_Component",
+        "Substring",
+    ]
 
 
 class Logical_Variable(Base):  # R604
     """
-    <logical-variable> = <variable>
+    ::
+
+        <logical-variable> = <variable>
+
     """
-    subclass_names = ['Variable']
+
+    subclass_names = ["Variable"]
 
 
 class Default_Logical_Variable(Base):  # R605
     """
-    <default-logical-variable> = <variable>
+    ::
+
+        <default-logical-variable> = <variable>
+
     """
-    subclass_names = ['Variable']
+
+    subclass_names = ["Variable"]
 
 
 class Char_Variable(Base):  # R606
     """
-    <char-variable> = <variable>
+    ::
+
+        <char-variable> = <variable>
+
     """
-    subclass_names = ['Variable']
+
+    subclass_names = ["Variable"]
 
 
 class Default_Char_Variable(Base):  # R607
     """
-    <default-char-variable> = <variable>
+    ::
+
+        <default-char-variable> = <variable>
+
     """
-    subclass_names = ['Variable']
+
+    subclass_names = ["Variable"]
 
 
 class Int_Variable(Base):  # R608
     """
-    <int-variable> = <variable>
+    ::
+
+        <int-variable> = <variable>
+
     """
-    subclass_names = ['Variable']
+
+    subclass_names = ["Variable"]
 
 
 class Substring(CallBase):  # R609
     """
-    <substring> = <parent-string> ( <substring-range> )
+    ::
+
+        <substring> = <parent-string> ( <substring-range> )
+
     """
+
     subclass_names = []
-    use_names = ['Parent_String', 'Substring_Range']
+    use_names = ["Parent_String", "Substring_Range"]
 
+    @staticmethod
     def match(string):
-        return CallBase.match(
-            Parent_String, Substring_Range, string, require_rhs=True)
-    match = staticmethod(match)
+        return CallBase.match(Parent_String, Substring_Range, string, require_rhs=True)
 
 
 class Parent_String(Base):  # R610
     """
-    <parent-string> = <scalar-variable-name>
-                      | <array-element>
-                      | <scalar-structure-component>
-                      | <scalar-constant>
+    ::
+
+        <parent-string> = <scalar-variable-name>
+                          | <array-element>
+                          | <scalar-structure-component>
+                          | <scalar-constant>
+
     """
-    subclass_names = ['Scalar_Variable_Name', 'Array_Element',
-                      'Scalar_Structure_Component', 'Scalar_Constant']
+
+    subclass_names = [
+        "Scalar_Variable_Name",
+        "Array_Element",
+        "Scalar_Structure_Component",
+        "Scalar_Constant",
+    ]
 
 
 class Substring_Range(SeparatorBase):  # R611
     """
-    <substring-range> = [ <scalar-int-expr> ] : [ <scalar-int-expr> ]
+    ::
+
+        <substring-range> = [ <scalar-int-expr> ] : [ <scalar-int-expr> ]
+
     """
+
     subclass_names = []
-    use_names = ['Scalar_Int_Expr']
+    use_names = ["Scalar_Int_Expr"]
 
     @staticmethod
     def match(string):
         return SeparatorBase.match(Scalar_Int_Expr, Scalar_Int_Expr, string)
 
 
 class Data_Ref(SequenceBase):
-    '''
-    Fortran 2003 Rule R612
+    """
+    Fortran 2003 Rule R612::
 
-    data-ref is part-ref [ % part-ref ] ...
+        data-ref is part-ref [ % part-ref ] ...
 
     If there is only one part-ref then return a 'Part_Ref' object (or
     another object from a matching sub-rule). If there is more than
     one part-ref then return a 'Data_Ref' object containing the
     part-ref's.
 
-    '''
-    subclass_names = ['Part_Ref']
+    """
+
+    subclass_names = ["Part_Ref"]
     use_names = []
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a data-reference. This defines a series
+        """Implements the matching for a data-reference. This defines a series
         of dereferences e.g. a%b%c.
 
         If there is more than one part-ref then return a 'Data_Ref'
         object containing the part-ref's, otherwise return 'None'. A
         single 'part-ref' is purposely not matched here.
 
         :param str string: Fortran code to check for a match
 
         :return: `None` if there is no match, or a tuple containing \
                  the matched operator as a string and another tuple \
                  containing the matched subclasses.
 
         :rtype: NoneType or (str, (obj, obj, ...))
 
-        '''
+        """
         # Use SequenceBase as normal, then force no match when there is
         # only one entry in the sequence.
-        result = SequenceBase.match(r'%', Part_Ref, string)
+        result = SequenceBase.match(r"%", Part_Ref, string)
         entries = result[1]
         if len(entries) > 1:
             # There is more than one part-ref so return a Data_Ref
             # object containing the part-refs.
             return result
         # There is only one part-ref so return None to indicate there
         # is no match and allow the subclass_names Part_Ref class to
         # match instead.
         return None
 
 
 class Part_Ref(CallBase):  # R613
     """
-    <part-ref> = <part-name> [ ( <section-subscript-list> ) ]
+    ::
+
+        <part-ref> = <part-name> [ ( <section-subscript-list> ) ]
+
     """
-    subclass_names = ['Part_Name']
-    use_names = ['Section_Subscript_List']
 
+    subclass_names = ["Part_Name"]
+    use_names = ["Section_Subscript_List"]
+
+    @staticmethod
     def match(string):
         return CallBase.match(
-            Part_Name, Section_Subscript_List, string, require_rhs=True)
-    match = staticmethod(match)
+            Part_Name, Section_Subscript_List, string, require_rhs=True
+        )
 
 
 class Structure_Component(Base):  # R614
     """
-    <structure-component> = <data-ref>
+    ::
+
+        <structure-component> = <data-ref>
+
     """
-    subclass_names = ['Data_Ref']
+
+    subclass_names = ["Data_Ref"]
 
 
 class Type_Param_Inquiry(BinaryOpBase):  # R615
     """
-    <type-param-inquiry> = <designator> % <type-param-name>
+    ::
+
+        <type-param-inquiry> = <designator> % <type-param-name>
+
     """
+
     subclass_names = []
-    use_names = ['Designator', 'Type_Param_Name']
+    use_names = ["Designator", "Type_Param_Name"]
 
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Designator, pattern.percent_op.named(), Type_Param_Name, string)
-    match = staticmethod(match)
+            Designator, pattern.percent_op.named(), Type_Param_Name, string
+        )
 
 
 class Array_Element(Base):  # R616
     """
-    <array-element> = <data-ref>
+    ::
+
+        <array-element> = <data-ref>
+
     """
-    subclass_names = ['Data_Ref']
+
+    subclass_names = ["Data_Ref"]
 
 
 class Array_Section(CallBase):  # R617
     """
-    <array-section> = <data-ref> [ ( <substring-range> ) ]
+    ::
+
+        <array-section> = <data-ref> [ ( <substring-range> ) ]
+
     """
-    subclass_names = ['Data_Ref']
-    use_names = ['Substring_Range']
 
+    subclass_names = ["Data_Ref"]
+    use_names = ["Substring_Range"]
+
+    @staticmethod
     def match(string):
-        return CallBase.match(
-            Data_Ref, Substring_Range, string, require_rhs=True)
-    match = staticmethod(match)
+        return CallBase.match(Data_Ref, Substring_Range, string, require_rhs=True)
 
 
 class Subscript(Base):  # R618
     """
-    <subscript> = <scalar-int-expr>
+    ::
+
+        <subscript> = <scalar-int-expr>
+
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
 
 
 class Section_Subscript(Base):  # R619
     """
-    <section-subscript> = <subscript>
-                          | <subscript-triplet>
-                          | <vector-subscript>
+    ::
+
+        <section-subscript> = <subscript>
+                              | <subscript-triplet>
+                              | <vector-subscript>
+
     """
-    subclass_names = ['Subscript_Triplet', 'Vector_Subscript', 'Subscript']
+
+    subclass_names = ["Subscript_Triplet", "Vector_Subscript", "Subscript"]
 
 
 class Subscript_Triplet(Base):  # R620
     """
-    <subscript-triplet> = [ <subscript> ] : [ <subscript> ] [ : <stride> ]
+    ::
+
+        <subscript-triplet> = [ <subscript> ] : [ <subscript> ] [ : <stride> ]
+
     """
+
     subclass_names = []
-    use_names = ['Subscript', 'Stride']
+    use_names = ["Subscript", "Stride"]
 
+    @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        t = line.split(':')
+        t = line.split(":")
         if len(t) <= 1 or len(t) > 3:
             return
         lhs_obj, rhs_obj, stride_obj = None, None, None
         if len(t) == 2:
             lhs, rhs = t[0].rstrip(), t[1].lstrip()
         else:
             lhs, rhs, stride = t[0].rstrip(), t[1].strip(), t[2].lstrip()
             if stride:
                 stride_obj = Stride(repmap(stride))
         if lhs:
             lhs_obj = Subscript(repmap(lhs))
         if rhs:
             rhs_obj = Subscript(repmap(rhs))
         return lhs_obj, rhs_obj, stride_obj
-    match = staticmethod(match)
 
     def tostr(self):
-        s = ''
+        s = ""
         if self.items[0] is not None:
-            s += str(self.items[0]) + ' :'
+            s += str(self.items[0]) + " :"
         else:
-            s += ':'
+            s += ":"
         if self.items[1] is not None:
-            s += ' ' + str(self.items[1])
+            s += " " + str(self.items[1])
         if self.items[2] is not None:
-            s += ' : ' + str(self.items[2])
+            s += " : " + str(self.items[2])
         return s
 
 
 class Stride(Base):  # R621
     """
-    <stride> = <scalar-int-expr>
+    ::
+
+        <stride> = <scalar-int-expr>
+
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
 
 
 class Vector_Subscript(Base):  # R622
     """
-    <vector-subscript> = <int-expr>
+    ::
+
+        <vector-subscript> = <int-expr>
+
     """
-    subclass_names = ['Int_Expr']
+
+    subclass_names = ["Int_Expr"]
 
 
 class Allocate_Stmt(StmtBase):  # R623
     """
-    <allocate-stmt> = ALLOCATE ( [ <type-spec> :: ] <allocation-list>
-        [ , <alloc-opt-list> ] )
+    Fortran2003 rule R623::
+
+        allocate-stmt is ALLOCATE ( [ type-spec :: ] allocation-list
+                                    [, alloc-opt-list ] )
+
+    Subject to the following constraints\:
+
+    C622 (R629) Each allocate-object shall be a nonprocedure pointer or an
+                 allocatable variable.
+    C623 (R623) If any allocate-object in the statement has a deferred type
+                parameter, either type-spec or SOURCE= shall appear.
+    C624 (R623) If a type-spec appears, it shall specify a type with which
+                each allocate-object is type compatible.
+    C625 (R623) If any allocate-object is unlimited polymorphic, either
+                type-spec or SOURCE= shall appear.
+    C626 (R623) A type-param-value in a type-spec shall be an asterisk if and
+                only if each allocate-object is a dummy argument for which the
+                corresponding type parameter is assumed.
+    C627 (R623) If a type-spec appears, the kind type parameter values of each
+                allocate-object shall be the same as the corresponding type
+                parameter values of the type-spec.
+    C628 (R628) An allocate-shape-spec-list shall appear if and only if the
+                allocate-object is an array.
+    C629 (R628) The number of allocate-shape-specs in an
+                allocate-shape-spec-list shall be the same as the rank of the
+                allocate-object.
+    C630 (R624) No alloc-opt shall appear more than once in a given
+                alloc-opt-list.
+    C631 (R623) If SOURCE= appears, type-spec shall not appear and
+                allocation-list shall contain only one allocate-object, which
+                shall be type compatible (5.1.1.2) with source-expr.
+    C632 (R623) The source-expr shall be a scalar or have the same rank as
+                allocate-object.
+    C633 (R623) Corresponding kind type parameters of allocate-object and
+                source-expr shall have the same values.
+
+    None of these constraints are currently applied - issue #355.
+
     """
+
     subclass_names = []
-    use_names = ['Type_Spec', 'Allocation_List', 'Alloc_Opt_List']
+    use_names = ["Type_Spec", "Allocation_List", "Alloc_Opt_List"]
 
-    @staticmethod
-    def match(string):
-        if string[:8].upper() != 'ALLOCATE':
-            return
+    @classmethod
+    def match(cls, string):
+        """
+        Attempts to match the supplied string as an Allocate_Stmt.
+
+        :param str string: the string to attempt to match.
+
+        :returns: A 2-tuple giving the Type_Spec and Allocation_List if the \
+            match is successful, None otherwise.
+        :rtype: Optional[ \
+            Tuple[Optional[:py:class:`fparser.two.Fortran2003.Type_Spec`], \
+                  :py:class:`fparser.two.Fortran2003.Allocation_List`]]
+        """
+        if string[:8].upper() != "ALLOCATE":
+            return None
         line = string[8:].lstrip()
-        if not line or line[0] != '(' or line[-1] != ')':
-            return
+        if not line or line[0] != "(" or line[-1] != ")":
+            return None
         line, repmap = string_replace_map(line[1:-1].strip())
-        i = line.find('::')
+        idx = line.find("::")
         spec = None
-        if i != -1:
-            spec = Type_Spec(repmap(line[:i].rstrip()))
-            line = line[i+2:].lstrip()
-        i = line.find('=')
+        if idx != -1:
+            spec = Type_Spec(repmap(line[:idx].rstrip()))
+            line = line[idx + 2 :].lstrip()
+        idx = line.find("=")
         opts = None
-        if i != -1:
-            j = line[:i].rfind(',')
-            assert j != -1, repr((i, j, line))
-            opts = Alloc_Opt_List(repmap(line[j+1:].lstrip()))
-            line = line[:j].rstrip()
+        if idx != -1:
+            jdx = line[:idx].rfind(",")
+            if jdx == -1:
+                # There must be at least one positional argument before any
+                # named arguments.
+                return None
+            # Use the class 'alloc_opt_list' property to ensure we use the
+            # correct class depending on whether 'cls' is associated with
+            # Fortran2003 or Fortran2008.
+            opts = cls.alloc_opt_list()(repmap(line[jdx + 1 :].lstrip()))
+            line = line[:jdx].rstrip()
         return spec, Allocation_List(repmap(line)), opts
 
+    @classmethod
+    def alloc_opt_list(cls):
+        """
+        :returns: the Fortran2003 flavour of Alloc_Opt_List.
+        :rtype: type
+        """
+        return Alloc_Opt_List
+
     def tostr(self):
         spec, lst, opts = self.items
         if spec is not None:
             if opts is not None:
-                return 'ALLOCATE(%s::%s, %s)' % (spec, lst, opts)
+                return "ALLOCATE(%s::%s, %s)" % (spec, lst, opts)
             else:
-                return 'ALLOCATE(%s::%s)' % (spec, lst)
+                return "ALLOCATE(%s::%s)" % (spec, lst)
         elif opts is not None:
-            return 'ALLOCATE(%s, %s)' % (lst, opts)
+            return "ALLOCATE(%s, %s)" % (lst, opts)
         else:
-            return 'ALLOCATE(%s)' % (lst)
+            return "ALLOCATE(%s)" % (lst)
 
 
-class Alloc_Opt(KeywordValueBase):  # R624
+class Stat_Variable(Base):  # R625
     """
-    <alloc-opt> = STAT = <stat-variable>
-                  | ERRMSG = <errmsg-variable>
-                  | SOURCE = <source-expr>
+    ::
+
+        <stat-variable> = <scalar-int-variable>
+
     """
-    subclass_names = []
-    use_names = ['Stat_Variable', 'Errmsg_Variable', 'Source_Expr']
 
-    def match(string):
-        for (k, v) in [('STAT', Stat_Variable),
-                       ('ERRMSG', Errmsg_Variable),
-                       ('SOURCE', Source_Expr)]:
-            try:
-                obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
-            except NoMatchError:
-                obj = None
-            if obj is not None:
-                return obj
-        return
-    match = staticmethod(match)
+    subclass_names = ["Scalar_Int_Variable"]
 
 
-class Stat_Variable(Base):  # R625
+class Errmsg_Variable(Base):  # R626
     """
-    <stat-variable> = <scalar-int-variable>
+    ::
+
+        <errmsg-variable> = <scalar-default-char-variable>
+
     """
-    subclass_names = ['Scalar_Int_Variable']
 
+    subclass_names = ["Scalar_Default_Char_Variable"]
 
-class Errmsg_Variable(Base):  # R626
+
+class Source_Expr(Base):  # R627
     """
-    <errmsg-variable> = <scalar-default-char-variable>
+    ::
+
+        <source-expr> = <expr>
+
     """
-    subclass_names = ['Scalar_Default_Char_Variable']
 
+    subclass_names = ["Expr"]
 
-class Source_Expr(Base):  # R627
+
+class Alloc_Opt(KeywordValueBase):  # R624
     """
-    <source-expr> = <expr>
+    ::
+
+        <alloc-opt> = STAT = <stat-variable>
+                      | ERRMSG = <errmsg-variable>
+                      | SOURCE = <source-expr>
+
     """
-    subclass_names = ['Expr']
+
+    subclass_names = []
+    use_names = ["Stat_Variable", "Errmsg_Variable", "Source_Expr"]
+    #: The keywords tested for in the match() method.
+    _keyword_pairs = [
+        ("STAT", Stat_Variable),
+        ("ERRMSG", Errmsg_Variable),
+        ("SOURCE", Source_Expr),
+    ]
+
+    @classmethod
+    def match(cls, string):
+        for k, v in cls._keyword_pairs:
+            obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
+            if obj is not None:
+                return obj
+        return None
 
 
 class Allocation(CallBase):  # R628
     """
-    <allocation> = <allocate-object> [ ( <allocate-shape-spec-list> ) ]
-                 | <variable-name>
+    ::
+
+        <allocation> = <allocate-object> [ ( <allocate-shape-spec-list> ) ]
+                     | <variable-name>
+
     """
-    subclass_names = ['Variable_Name', 'Allocate_Object']
-    use_names = ['Allocate_Shape_Spec_List']
 
+    subclass_names = ["Variable_Name", "Allocate_Object"]
+    use_names = ["Allocate_Shape_Spec_List"]
+
+    @staticmethod
     def match(string):
         return CallBase.match(
-            Allocate_Object, Allocate_Shape_Spec_List, string,
-            require_rhs=True)
-    match = staticmethod(match)
+            Allocate_Object, Allocate_Shape_Spec_List, string, require_rhs=True
+        )
 
 
 class Allocate_Object(Base):  # R629
     """
-    <allocate-object> = <variable-name>
-                        | <structure-component>
+    ::
+
+        <allocate-object> = <variable-name>
+                            | <structure-component>
+
     """
-    subclass_names = ['Variable_Name', 'Structure_Component']
+
+    subclass_names = ["Variable_Name", "Structure_Component"]
 
 
 class Allocate_Shape_Spec(SeparatorBase):  # R630
     """
-    <allocate-shape-spec> = [ <lower-bound-expr> : ] <upper-bound-expr>
+    ::
+
+        <allocate-shape-spec> = [ <lower-bound-expr> : ] <upper-bound-expr>
+
     """
+
     subclass_names = []
-    use_names = ['Lower_Bound_Expr', 'Upper_Bound_Expr']
+    use_names = ["Lower_Bound_Expr", "Upper_Bound_Expr"]
 
+    @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        if ':' not in line:
+        if ":" not in line:
             return None, Upper_Bound_Expr(string)
-        lower, upper = line.split(':', 1)
+        lower, upper = line.split(":", 1)
         lower = lower.rstrip()
         upper = upper.lstrip()
         if not upper:
             return
         if not lower:
             return
         return Lower_Bound_Expr(repmap(lower)), Upper_Bound_Expr(repmap(upper))
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[0] is None:
             return str(self.items[1])
         return SeparatorBase.tostr(self)
 
 
 class Lower_Bound_Expr(Base):  # R631
     """
-    <lower-bound-expr> = <scalar-int-expr>
+    ::
+
+        <lower-bound-expr> = <scalar-int-expr>
+
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
 
 
 class Upper_Bound_Expr(Base):  # R632
     """
-    <upper-bound-expr> = <scalar-int-expr>
+    ::
+
+        <upper-bound-expr> = <scalar-int-expr>
+
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
 
 
 class Nullify_Stmt(StmtBase, CALLBase):  # R633
     """
-    <nullify-stmt> = NULLIFY ( <pointer-object-list> )
+    ::
+
+        <nullify-stmt> = NULLIFY ( <pointer-object-list> )
+
     """
+
     subclass_names = []
-    use_names = ['Pointer_Object_List']
+    use_names = ["Pointer_Object_List"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match(
-            'NULLIFY', Pointer_Object_List, string, require_rhs=True)
-    match = staticmethod(match)
+        return CALLBase.match("NULLIFY", Pointer_Object_List, string, require_rhs=True)
 
 
 class Pointer_Object(Base):  # R634
     """
-    <pointer-object> = <variable-name>
-                       | <structure-component>
-                       | <proc-pointer-name>
+    ::
+
+        <pointer-object> = <variable-name>
+                           | <structure-component>
+                           | <proc-pointer-name>
+
     """
-    subclass_names = ['Variable_Name', 'Structure_Component',
-                      'Proc_Pointer_Name']
+
+    subclass_names = ["Variable_Name", "Structure_Component", "Proc_Pointer_Name"]
 
 
 class Deallocate_Stmt(StmtBase):  # R635
     """
-    <deallocate-stmt> = DEALLOCATE ( <allocate-object-list> [
-        , <dealloc-opt-list> ] )
+    ::
+
+        <deallocate-stmt> = DEALLOCATE ( <allocate-object-list> [
+            , <dealloc-opt-list> ] )
+
     """
+
     subclass_names = []
-    use_names = ['Allocate_Object_List', 'Dealloc_Opt_List']
+    use_names = ["Allocate_Object_List", "Dealloc_Opt_List"]
 
     @staticmethod
     def match(string):
-        if string[:10].upper() != 'DEALLOCATE':
+        if string[:10].upper() != "DEALLOCATE":
             return
         line = string[10:].lstrip()
-        if not line or line[0] != '(' or line[-1] != ')':
+        if not line or line[0] != "(" or line[-1] != ")":
             return
         line, repmap = string_replace_map(line[1:-1].strip())
-        i = line.find('=')
+        i = line.find("=")
         opts = None
         if i != -1:
-            j = line[:i].rfind(',')
+            j = line[:i].rfind(",")
             assert j != -1, repr((i, j, line))
-            opts = Dealloc_Opt_List(repmap(line[j+1:].lstrip()))
+            opts = Dealloc_Opt_List(repmap(line[j + 1 :].lstrip()))
             line = line[:j].rstrip()
         return Allocate_Object_List(repmap(line)), opts
 
     def tostr(self):
         if self.items[1] is not None:
-            return 'DEALLOCATE(%s, %s)' % (self.items)
-        return 'DEALLOCATE(%s)' % (self.items[0])
+            return "DEALLOCATE(%s, %s)" % (self.items)
+        return "DEALLOCATE(%s)" % (self.items[0])
 
 
 class Dealloc_Opt(KeywordValueBase):  # R636
     """
-    <dealloc-opt> = STAT = <stat-variable>
-                    | ERRMSG = <errmsg-variable>
+    ::
+
+        <dealloc-opt> = STAT = <stat-variable>
+                        | ERRMSG = <errmsg-variable>
+
     """
+
     subclass_names = []
-    use_names = ['Stat_Variable', 'Errmsg_Variable']
+    use_names = ["Stat_Variable", "Errmsg_Variable"]
 
+    @staticmethod
     def match(string):
-        for (k, v) in [('STAT', Stat_Variable),
-                       ('ERRMSG', Errmsg_Variable),
-                       ]:
+        for k, v in [("STAT", Stat_Variable), ("ERRMSG", Errmsg_Variable)]:
             try:
                 obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return
-    match = staticmethod(match)
+        return None
 
 
 class Scalar_Char_Initialization_Expr(Base):
-    subclass_names = ['Char_Initialization_Expr']
+    subclass_names = ["Char_Initialization_Expr"]
+
 
 #
 # SECTION  7
 #
 
 
 class Primary(Base):  # R701
-    '''Fortran 2003 rule R701
+    """
+    Fortran 2003 rule R701::
 
-    primary is intrinsic_function_reference
-            or constant
-            or designator
-            or array-constructor
-            or structure-constructor
-            or function-reference
-            or type-param-inquiry
-            or type-param-name
-            or ( expr )
+        primary is intrinsic_function_reference
+                or constant
+                or designator
+                or array-constructor
+                or structure-constructor
+                or function-reference
+                or type-param-inquiry
+                or type-param-name
+                or ( expr )
 
     `intrinsic_function_reference` is not part of rule R701 but is
     required for fparser to recognise intrinsic functions. This is
     placed before array-constructor in the `subclass_names` list so
     that an intrinsic is not (incorrectly) matched as an array (as
     class `Base` matches rules in list order).
 
-    '''
+    Note, ( expr ) is implemented in the Parenthesis subclass.
+
+    """
+
     subclass_names = [
-        'Intrinsic_Function_Reference',
-        'Constant', 'Designator', 'Array_Constructor',
-        'Structure_Constructor', 'Function_Reference',
-        'Type_Param_Inquiry', 'Type_Param_Name', 'Parenthesis',
+        "Intrinsic_Function_Reference",
+        "Constant",
+        "Designator",
+        "Array_Constructor",
+        "Structure_Constructor",
+        "Function_Reference",
+        "Type_Param_Inquiry",
+        "Type_Param_Name",
+        "Parenthesis",
     ]
 
 
-class Parenthesis(BracketBase):  # R701.h
+class Parenthesis(BracketBase):
     """
-    <parenthesis> = ( <expr> )
+    Part of Fortran 2003 rule R701::
+
+        parenthesis = ( expr )
+
     """
+
     subclass_names = []
-    use_names = ['Expr']
+    use_names = ["Expr"]
 
+    @staticmethod
     def match(string):
-        return BracketBase.match('()', Expr, string)
-    match = staticmethod(match)
+        """Implements the matching of round brackets surrounding an expression
+        which is specified as one of the matches in R701.
+
+        :param str string: Fortran code to check for a match.
+
+        :returns: `None` if there is no match, or a 3-tuple containing \
+            the left bracket, the matched expression and the right \
+            bracket.
+        :rtype: NoneType or (str, subclass of \
+            :py:class:`fparser.two.utils.Base`, str)
+
+        """
+        return BracketBase.match("()", Expr, string)
 
 
 class Level_1_Expr(UnaryOpBase):  # R702
     """
-    <level-1-expr> = [ <defined-unary-op> ] <primary>
-    <defined-unary-op> = . <letter> [ <letter> ]... .
+    ::
+
+        <level-1-expr> = [ <defined-unary-op> ] <primary>
+        <defined-unary-op> = . <letter> [ <letter> ]... .
+
     """
-    subclass_names = ['Primary']
+
+    subclass_names = ["Primary"]
     use_names = []
 
+    @staticmethod
     def match(string):
-        return UnaryOpBase.match(
-            pattern.defined_unary_op.named(), Primary, string)
+        return UnaryOpBase.match(pattern.defined_unary_op.named(), Primary, string)
+
     # exclude_op_pattern = pattern.non_defined_binary_op)
-    match = staticmethod(match)
 
 
-class Defined_Unary_Op(STRINGBase):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R703
+class Defined_Unary_Op(Base):  # pylint: disable=invalid-name
+    """
+    Fortran 2003 rule R703::
 
-    defined-unary-op is . letter [ letter ]... .
+        defined-unary-op is . letter [ letter ]... .
 
     C704 (R703) A defined-unary-op shall not contain more than 63
     letters and shall not be the same as any intrinsic-operator or
     logical-literal-constant.
 
     Implemented in Defined_Op class.
 
-    '''
-    subclass_names = ['Defined_Op']
+    """
+
+    subclass_names = ["Defined_Op"]
 
 
 class Defined_Op(STRINGBase):  # pylint: disable=invalid-name
-    '''
+    """
     Utility class that Implements the functionality of rules R703 and
-    R723 (as the rules are the same)
+    R723 (as the rules are the same)::
 
-    defined-op is . letter [ letter ]... .
+        defined-op is . letter [ letter ]... .
 
     C704 (R723) A defined-binary-op shall not contain more than 63
     letters and shall not be the same as any intrinsic-operator or
     logical-literal-constant.
 
     C704 (R703) A defined-unary-op shall not contain more than 63
     letters and shall not be the same as any intrinsic-operator or
     logical-literal-constant.
 
-    '''
+    """
+
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a (user) Defined Unary or Binary
+        """Implements the matching for a (user) Defined Unary or Binary
         Operator.
 
         :param str string: Fortran code to check for a match
         :return: `None` if there is no match, or a tuple containing \
                  the matched operator as a string
         :rtype: None or (str)
 
-        '''
+        """
         strip_string = string.strip()
         if len(strip_string) > 65:
             # C704. Must be 63 letters or fewer (Test for >65 due
             # to the two dots).
             return None
         if pattern.non_defined_binary_op.match(strip_string):
             # C704. Must not match with an intrinsic-operator or
             # logical-literal-constant
             return None
         return STRINGBase.match(pattern.abs_defined_op, strip_string)
 
 
 class Mult_Operand(BinaryOpBase):  # R704
     """
-    <mult-operand> = <level-1-expr> [ <power-op> <mult-operand> ]
-    <power-op> = **
+    ::
+
+        <mult-operand> = <level-1-expr> [ <power-op> <mult-operand> ]
+        <power-op> = **
+
     """
-    subclass_names = ['Level_1_Expr']
-    use_names = ['Mult_Operand']
 
+    subclass_names = ["Level_1_Expr"]
+    use_names = ["Mult_Operand"]
+
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Level_1_Expr, pattern.power_op.named(), Mult_Operand,
-            string, right=False)
-    match = staticmethod(match)
+            Level_1_Expr, pattern.power_op.named(), Mult_Operand, string, right=False
+        )
 
 
-class Add_Operand(BinaryOpBase):  # R705
+class Add_Operand(BinaryOpBase):  # pylint: disable=invalid-name
     """
-    <add-operand> = [ <add-operand> <mult-op> ] <mult-operand>
-    <mult-op>  = *
-                 | /
+    Fortran 2003 rule R705::
+
+        add-operand is [ add-operand mult-op ] mult-operand
+
+    Rule R705 is implemented in two parts, the first with the optional
+    part included (in the match method for this class) and the second
+    without the optional part (specified in subclass_names).
+
+    Note rule R708 (mult-op is * or /) is implemented directly here as
+    the mult_op pattern.
+
+    There is potential to accidentally match a sign in an exponent as the
+    plus/minus sign in a level-2-expr. If this were to happen then it is
+    possible to end up matching a * or / (a level 1 expression) before
+    matching a valid + or - which would normally result in no match
+    overall as * or / are matched after + or -. This situation is
+    avoided by tokenising the string before performing the match so
+    that any numerical constants involving exponents are replaced by
+    simple symbols. (The tokenisation is performed by
+    `fparser.common.splitline.string_replace_map`.)
+
     """
-    subclass_names = ['Mult_Operand']
-    use_names = ['Add_Operand', 'Mult_Operand']
 
+    subclass_names = ["Mult_Operand"]
+    use_names = ["Mult_Operand"]
+
+    @staticmethod
     def match(string):
+        """Implement the matching for the add-operand rule. Makes use of the
+        pre-defined mult_op pattern and the BinaryOpBase baseclass.
+
+        :param str string: the string to match.
+
+        :returns: a tuple of size 3 containing an fparser2 class \
+            instance matching a level-2-expr expression, a string \
+            containing the matched operator and an fparser2 class \
+            instance matching a mult-operand if there is a match, or \
+            None if there is not.
+        :rtype: (subclass of :py:class:`fparser.two.utils.Base`, str, \
+            subclass of :py:class:`fparser.two.utils.Base`) or NoneType
+
+        """
         return BinaryOpBase.match(
-            Add_Operand, pattern.mult_op.named(), Mult_Operand, string)
-    match = staticmethod(match)
+            Add_Operand, pattern.mult_op.named(), Mult_Operand, string
+        )
 
 
 class Level_2_Expr(BinaryOpBase):  # R706
     """
-    <level-2-expr> = [ [ <level-2-expr> ] <add-op> ] <add-operand>
-    <level-2-expr> = [ <level-2-expr> <add-op> ] <add-operand>
-                     | <level-2-unary-expr>
-    <add-op>   = +
-                 | -
+    ::
+
+        <level-2-expr> = [ [ <level-2-expr> ] <add-op> ] <add-operand>
+        <level-2-expr> = [ <level-2-expr> <add-op> ] <add-operand>
+                         | <level-2-unary-expr>
+        <add-op>   = +
+                     | -
+
     """
-    subclass_names = ['Level_2_Unary_Expr']
-    use_names = ['Level_2_Expr']
 
+    subclass_names = ["Level_2_Unary_Expr"]
+    use_names = ["Level_2_Expr"]
+
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Level_2_Expr, pattern.add_op.named(), Add_Operand,
-            string, is_add=True)
-    match = staticmethod(match)
+            Level_2_Expr, pattern.add_op.named(), Add_Operand, string
+        )
 
 
 class Level_2_Unary_Expr(UnaryOpBase):  # R706.c
     """
-    <level-2-unary-expr> = [ <add-op> ] <add-operand>
+    ::
+
+        <level-2-unary-expr> = [ <add-op> ] <add-operand>
+
     """
-    subclass_names = ['Add_Operand']
+
+    subclass_names = ["Add_Operand"]
     use_names = []
 
+    @staticmethod
     def match(string):
-        return UnaryOpBase.match(
-            pattern.add_op.named(), Add_Operand, string)
-    match = staticmethod(match)
-
-# R707: <power-op> = **
-# R708: <mult-op> = * | /
-# R709: <add-op> = + | -
+        return UnaryOpBase.match(pattern.add_op.named(), Add_Operand, string)
+
+
+# R707: power-op is **
+# R708: mult-op is * or /
+# R709: add-op is + or -
 
 
 class Level_3_Expr(BinaryOpBase):  # R710
     """
-    <level-3-expr> = [ <level-3-expr> <concat-op> ] <level-2-expr>
-    <concat-op>    = //
+    ::
+
+        <level-3-expr> = [ <level-3-expr> <concat-op> ] <level-2-expr>
+        <concat-op>    = //
+
     """
-    subclass_names = ['Level_2_Expr']
-    use_names = ['Level_3_Expr']
 
+    subclass_names = ["Level_2_Expr"]
+    use_names = ["Level_3_Expr"]
+
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Level_3_Expr, pattern.concat_op.named(),
-            Level_2_Expr, string)
-    match = staticmethod(match)
+            Level_3_Expr, pattern.concat_op.named(), Level_2_Expr, string
+        )
+
 
 # R711: <concat-op> = //
 
 
 class Level_4_Expr(BinaryOpBase):  # R712
     """
-    <level-4-expr> = [ <level-3-expr> <rel-op> ] <level-3-expr>
-    <rel-op> = .EQ. | .NE. | .LT. | .LE. | .GT. | .GE. | == |
-        /= | < | <= | > | >=
+    ::
+
+        <level-4-expr> = [ <level-3-expr> <rel-op> ] <level-3-expr>
+        <rel-op> = .EQ. | .NE. | .LT. | .LE. | .GT. | .GE. | == |
+            /= | < | <= | > | >=
+
     """
-    subclass_names = ['Level_3_Expr']
+
+    subclass_names = ["Level_3_Expr"]
     use_names = []
 
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Level_3_Expr, pattern.rel_op.named(), Level_3_Expr,
-            string)
-    match = staticmethod(match)
+            Level_3_Expr, pattern.rel_op.named(), Level_3_Expr, string
+        )
+
 
 # R713: <rel-op> = .EQ. | .NE. | .LT. | .LE. | .GT. | .GE. |
 # == | /= | < | <= | > | >=
 
 
 class And_Operand(UnaryOpBase):  # R714
     """
-    <and-operand> = [ <not-op> ] <level-4-expr>
-    <not-op> = .NOT.
+    ::
+
+        <and-operand> = [ <not-op> ] <level-4-expr>
+        <not-op> = .NOT.
+
     """
-    subclass_names = ['Level_4_Expr']
+
+    subclass_names = ["Level_4_Expr"]
     use_names = []
 
+    @staticmethod
     def match(string):
-        return UnaryOpBase.match(
-            pattern.not_op.named(), Level_4_Expr, string)
-    match = staticmethod(match)
+        return UnaryOpBase.match(pattern.not_op.named(), Level_4_Expr, string)
 
 
 class Or_Operand(BinaryOpBase):  # R715
     """
-    <or-operand> = [ <or-operand> <and-op> ] <and-operand>
-    <and-op> = .AND.
+    ::
+
+        <or-operand> = [ <or-operand> <and-op> ] <and-operand>
+        <and-op> = .AND.
+
     """
-    subclass_names = ['And_Operand']
-    use_names = ['Or_Operand', 'And_Operand']
+
+    subclass_names = ["And_Operand"]
+    use_names = ["Or_Operand", "And_Operand"]
 
     @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Or_Operand, pattern.and_op.named(), And_Operand, string)
+            Or_Operand, pattern.and_op.named(), And_Operand, string
+        )
 
 
 class Equiv_Operand(BinaryOpBase):  # R716
     """
-    <equiv-operand> = [ <equiv-operand> <or-op> ] <or-operand>
-    <or-op>  = .OR.
+    ::
+
+        <equiv-operand> = [ <equiv-operand> <or-op> ] <or-operand>
+        <or-op>  = .OR.
+
     """
-    subclass_names = ['Or_Operand']
-    use_names = ['Equiv_Operand']
 
+    subclass_names = ["Or_Operand"]
+    use_names = ["Equiv_Operand"]
+
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Equiv_Operand, pattern.or_op.named(), Or_Operand, string)
-    match = staticmethod(match)
+            Equiv_Operand, pattern.or_op.named(), Or_Operand, string
+        )
 
 
 class Level_5_Expr(BinaryOpBase):  # R717
     """
-    <level-5-expr> = [ <level-5-expr> <equiv-op> ] <equiv-operand>
-    <equiv-op> = .EQV.
-               | .NEQV.
+    ::
+
+        <level-5-expr> = [ <level-5-expr> <equiv-op> ] <equiv-operand>
+        <equiv-op> = .EQV.
+                   | .NEQV.
+
     """
-    subclass_names = ['Equiv_Operand']
-    use_names = ['Level_5_Expr']
 
+    subclass_names = ["Equiv_Operand"]
+    use_names = ["Level_5_Expr"]
+
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Level_5_Expr, pattern.equiv_op.named(), Equiv_Operand, string)
-    match = staticmethod(match)
+            Level_5_Expr, pattern.equiv_op.named(), Equiv_Operand, string
+        )
+
 
 # R718: <not-op> = .NOT.
 # R719: <and-op> = .AND.
 # R720: <or-op> = .OR.
 # R721: <equiv-op> = .EQV. | .NEQV.
 
 
 class Expr(BinaryOpBase):  # R722
     """
-    <expr> = [ <expr> <defined-binary-op> ] <level-5-expr>
-    <defined-binary-op> = . <letter> [ <letter> ]... .
+    ::
+
+        <expr> = [ <expr> <defined-binary-op> ] <level-5-expr>
+        <defined-binary-op> = . <letter> [ <letter> ]... .
+
     """
-    subclass_names = ['Level_5_Expr']
-    use_names = ['Expr']
 
+    subclass_names = ["Level_5_Expr"]
+    use_names = ["Expr"]
+
+    @staticmethod
     def match(string):
         return BinaryOpBase.match(
-            Expr, pattern.defined_binary_op.named(), Level_5_Expr,
-            string, exclude_op_pattern=pattern.non_defined_binary_op)
-    match = staticmethod(match)
+            Expr,
+            pattern.defined_binary_op.named(),
+            Level_5_Expr,
+            string,
+            exclude_op_pattern=pattern.non_defined_binary_op,
+        )
 
 
-class Defined_Binary_Op(STRINGBase):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R723
+class Defined_Binary_Op(Base):  # pylint: disable=invalid-name
+    """
+    Fortran 2003 rule R723::
 
-    defined-binary-op is . letter [ letter ]... .
+        defined-binary-op is . letter [ letter ]... .
 
     C704 (R723) A defined-binary-op shall not contain more than 63
     letters and shall not be the same as any intrinsic-operator or
     logical-literal-constant.
 
     Implemented in Defined_Op class.
 
-    '''
-    subclass_names = ['Defined_Op']
+    """
+
+    subclass_names = ["Defined_Op"]
 
 
-class Logical_Expr(Base):  # R724
+class Logical_Expr(Base):  # pylint: disable=invalid-name
     """
-    <logical-expr> = <expr>
+    Fortran 2003 rule R724::
+
+        logical-expr is expr
+
+    C705 logical-expr shall be of type logical.
+
     """
-    subclass_names = ['Expr']
 
+    subclass_names = []
+
+    @staticmethod
+    def match(string):
+        """Implements the matching for a logical expression.
+
+        Note, whilst we exclude Signed_Int_Literal_Constant and
+        Signed_Real_Literal_Constant, it seems that it is not possible
+        to create these from code as a "-" sign is treated as a unary
+        operator.
 
-class Char_Expr(Base):  # R725
+        :param str string: Fortran code to check for a match.
+        :returns: `None` if there is no match, or an fparser2 class \
+                  instance containing the matched expression.
+        :rtype: NoneType or :py:class:`fparser.two.utils.Base`
+
+        """
+        excluded = (
+            Signed_Int_Literal_Constant,
+            Int_Literal_Constant,
+            Binary_Constant,
+            Octal_Constant,
+            Hex_Constant,
+            Signed_Real_Literal_Constant,
+            Real_Literal_Constant,
+            Complex_Literal_Constant,
+            Char_Literal_Constant,
+        )
+        # Attempt to match as a general expression.
+        result = Expr(string)
+        # C705: the match should fail if the result is not a logical
+        # expression. This is difficult to check in general so for the
+        # time being check that, in the case where a literal constant
+        # is returned, this is not of the wrong type.
+        if isinstance(result, excluded):
+            return None
+        return result
+
+
+class Char_Expr(Base):  # pylint: disable=invalid-name
     """
-    <char-expr> = <expr>
+    Fortran 2003 rule R725::
+
+        char-expr is expr
+
+    C706 char-expr shall be of type character.
+
     """
-    subclass_names = ['Expr']
 
+    subclass_names = []
 
-class Default_Char_Expr(Base):  # R726
+    @staticmethod
+    def match(string):
+        """Implements the matching for a character expression.
+
+        :param str string: Fortran code to check for a match.
+        :returns: `None` if there is no match, or an fparser2 class \
+                  instance containing the matched expression.
+        :rtype: NoneType or :py:class:`fparser.two.utils.Base`
+
+        """
+        excluded = (
+            Signed_Int_Literal_Constant,
+            Int_Literal_Constant,
+            Binary_Constant,
+            Octal_Constant,
+            Hex_Constant,
+            Signed_Real_Literal_Constant,
+            Real_Literal_Constant,
+            Complex_Literal_Constant,
+            Logical_Literal_Constant,
+        )
+        # Attempt to match as a general expression.
+        result = Expr(string)
+        # C706: the match should fail if the result is not a character
+        # expression. This is difficult to check in general so for the
+        # time being check that, in the case where a literal constant
+        # is returned, this is not of the wrong type.
+        if isinstance(result, excluded):
+            return None
+        return result
+
+
+class Default_Char_Expr(Base):  # pylint: disable=invalid-name
     """
-    <default-char-expr> = <expr>
+    Fortran 2003 rule R726::
+
+        default-char-expr is expr
+
+    C707 default-char-expr shall be of type default character.
+
     """
-    subclass_names = ['Expr']
+
+    subclass_names = []
+
+    @staticmethod
+    def match(string):
+        """Implements the matching for a default character expression.
+
+        :param str string: Fortran code to check for a match.
+        :returns: `None` if there is no match, or an fparser2 class \
+                  instance containing the matched expression.
+        :rtype: NoneType or :py:class:`fparser.two.utils.Base`
+
+        """
+        excluded = (
+            Signed_Int_Literal_Constant,
+            Int_Literal_Constant,
+            Binary_Constant,
+            Octal_Constant,
+            Hex_Constant,
+            Signed_Real_Literal_Constant,
+            Real_Literal_Constant,
+            Complex_Literal_Constant,
+            Logical_Literal_Constant,
+        )
+        # Attempt to match as a general expression.
+        result = Expr(string)
+        # C707: the match should fail if the result is not a character
+        # expression. This is difficult to check in general so for the
+        # time being check that, in the case where a literal constant
+        # is returned, this is not of the wrong type.
+        if isinstance(result, excluded):
+            return None
+        return result
 
 
-class Int_Expr(Base):  # R727
+class Int_Expr(Base):  # pylint: disable=invalid-name
     """
-    <int-expr> = <expr>
+    Fortran 2003 rule R727::
+
+        int-expr is expr
+
+    C708 int-expr shall be of type integer.
+
     """
-    subclass_names = ['Expr']
 
+    subclass_names = []
 
-class Numeric_Expr(Base):  # R728
+    @staticmethod
+    def match(string):
+        """Implements the matching for an integer expression.
+
+        :param str string: Fortran code to check for a match.
+        :returns: `None` if there is no match, or an fparser2 class \
+                  instance containing the matched expression.
+        :rtype: NoneType or :py:class:`fparser.two.utils.Base`
+
+        """
+        excluded = (
+            Binary_Constant,
+            Octal_Constant,
+            Hex_Constant,
+            Signed_Real_Literal_Constant,
+            Real_Literal_Constant,
+            Complex_Literal_Constant,
+            Char_Literal_Constant,
+            Logical_Literal_Constant,
+        )
+        # Attempt to match as a general expression.
+        result = Expr(string)
+        # C708: the match should fail if the result is not an integer
+        # expression. This is difficult to check in general so for the
+        # time being check that, in the case where a literal constant
+        # is returned, this is not of the wrong type.
+        if isinstance(result, excluded):
+            return None
+        return result
+
+
+class Numeric_Expr(Base):  # pylint: disable=invalid-name
     """
-    <numeric-expr> = <expr>
+    Fortran 2003 rule R728::
+
+        numeric-expr is expr
+
+    C709 numeric-expr shall be of type integer, real or complex.
+
     """
-    subclass_names = ['Expr']
+
+    subclass_names = []
+
+    @staticmethod
+    def match(string):
+        """Implements the matching for a numeric expression.
+
+        :param str string: Fortran code to check for a match.
+        :returns: `None` if there is no match, or an fparser2 class \
+                  instance containing the matched expression.
+        :rtype: NoneType or :py:class:`fparser.two.utils.Base`
+
+        """
+        excluded = (
+            Binary_Constant,
+            Octal_Constant,
+            Hex_Constant,
+            Char_Literal_Constant,
+            Logical_Literal_Constant,
+        )
+        # Attempt to match as a general expression.
+        result = Expr(string)
+        # C709: the match should fail if the result is not an integer,
+        # real or complex expression. This is difficult to check in
+        # general so for the time being check that, in the case where
+        # a literal constant is returned, this is not of the wrong
+        # type.
+        if isinstance(result, excluded):
+            return None
+        return result
 
 
 class Specification_Expr(Base):  # R729
     """
-    <specification-expr> = <scalar-int-expr>
+    ::
+
+        <specification-expr> = <scalar-int-expr>
+
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
 
 
 class Initialization_Expr(Base):  # R730
     """
-    <initialization-expr> = <expr>
+    ::
+
+        <initialization-expr> = <expr>
+
     """
-    subclass_names = ['Expr']
+
+    subclass_names = ["Expr"]
 
 
 class Char_Initialization_Expr(Base):  # R731
     """
-    <char-initialization-expr> = <char-expr>
+    ::
+
+        <char-initialization-expr> = <char-expr>
+
     """
-    subclass_names = ['Char_Expr']
+
+    subclass_names = ["Char_Expr"]
 
 
 class Int_Initialization_Expr(Base):  # R732
     """
-    <int-initialization-expr> = <int-expr>
+    ::
+
+        <int-initialization-expr> = <int-expr>
+
     """
-    subclass_names = ['Int_Expr']
+
+    subclass_names = ["Int_Expr"]
 
 
 class Logical_Initialization_Expr(Base):  # R733
     """
-    <logical-initialization-expr> = <logical-expr>
+    ::
+
+        <logical-initialization-expr> = <logical-expr>
+
     """
-    subclass_names = ['Logical_Expr']
+
+    subclass_names = ["Logical_Expr"]
 
 
 class Assignment_Stmt(StmtBase, BinaryOpBase):  # R734
     """
-    <assignment-stmt> = <variable> = <expr>
+    ::
+
+        <assignment-stmt> = <variable> = <expr>
+
     """
+
     subclass_names = []
-    use_names = ['Variable', 'Expr']
+    use_names = ["Variable", "Expr"]
 
     @staticmethod
     def match(string):
-        return BinaryOpBase.match(Variable, '=', Expr, string, right=False)
+        return BinaryOpBase.match(Variable, "=", Expr, string, right=False)
 
 
 class Pointer_Assignment_Stmt(StmtBase):  # R735
     """
-    <pointer-assignment-stmt> = <data-pointer-object> [
-        ( <bounds-spec-list> ) ] => <data-target>
-        | <data-pointer-object> ( <bounds-remapping-list> ) => <data-target>
-        | <proc-pointer-object> => <proc-target>
+    ::
+
+        <pointer-assignment-stmt> = <data-pointer-object> [
+            ( <bounds-spec-list> ) ] => <data-target>
+            | <data-pointer-object> ( <bounds-remapping-list> ) => <data-target>
+            | <proc-pointer-object> => <proc-target>
+
     """
+
     subclass_names = []
-    use_names = ['Data_Pointer_Object', 'Bounds_Spec_List',
-                 'Data_Target', 'Bounds_Remapping_List',
-                 'Proc_Pointer_Object', 'Proc_Target']
+    use_names = [
+        "Data_Pointer_Object",
+        "Bounds_Spec_List",
+        "Data_Target",
+        "Bounds_Remapping_List",
+        "Proc_Pointer_Object",
+        "Proc_Target",
+    ]
 
     @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        i = line.find('=>')
+        i = line.find("=>")
         if i == -1:
             return
         lhs = line[:i].rstrip()
-        rhs = repmap(line[i+2:].lstrip())
-        if lhs.endswith(')'):
-            i = lhs.rfind('(')
+        rhs = repmap(line[i + 2 :].lstrip())
+        if lhs.endswith(")"):
+            i = lhs.rfind("(")
             if i == -1:
                 return
             o = repmap(lhs[:i].rstrip())
-            tmp = repmap(lhs[i+1:-1].strip())
+            tmp = repmap(lhs[i + 1 : -1].strip())
             try:
-                return Data_Pointer_Object(o), Bounds_Spec_List(tmp), \
-                    Data_Target(rhs)
+                return Data_Pointer_Object(o), Bounds_Spec_List(tmp), Data_Target(rhs)
             except NoMatchError as msg:
-                return Data_Pointer_Object(o), Bounds_Remapping_List(tmp), \
-                    Data_Target(rhs)
+                return (
+                    Data_Pointer_Object(o),
+                    Bounds_Remapping_List(tmp),
+                    Data_Target(rhs),
+                )
         else:
             lhs = repmap(lhs)
         try:
             return Data_Pointer_Object(lhs), None, Data_Target(rhs)
         except NoMatchError as msg:
             return Proc_Pointer_Object(lhs), None, Proc_Target(rhs)
 
     def tostr(self):
         if self.items[1] is None:
-            return '%s => %s' % (self.items[0], self.items[2])
-        return '%s(%s) => %s' % (self.items)
+            return "%s => %s" % (self.items[0], self.items[2])
+        return "%s(%s) => %s" % (self.items)
 
 
 class Data_Pointer_Object(BinaryOpBase):  # R736
     """
-    <data-pointer-object> = <variable-name>
-                            | <variable> % <data-pointer-component-name>
+    ::
+
+        <data-pointer-object> = <variable-name>
+                                | <variable> % <data-pointer-component-name>
+
     """
-    subclass_names = ['Variable_Name']
-    use_names = ['Variable', 'Data_Pointer_Component_Name']
+
+    subclass_names = ["Variable_Name"]
+    use_names = ["Variable", "Data_Pointer_Component_Name"]
 
     @staticmethod
     def match(string):
-        return BinaryOpBase.match(
-            Variable, r'%', Data_Pointer_Component_Name, string)
+        return BinaryOpBase.match(Variable, r"%", Data_Pointer_Component_Name, string)
 
 
 class Bounds_Spec(SeparatorBase):  # R737
     """
-    <bounds-spec> = <lower-bound-expr> :
+    ::
+
+        <bounds-spec> = <lower-bound-expr> :
+
     """
+
     subclass_names = []
-    use_names = ['Lower_Bound_Expr']
+    use_names = ["Lower_Bound_Expr"]
 
+    @staticmethod
     def match(string):
-        return SeparatorBase.match(
-            Lower_Bound_Expr, None, string, require_lhs=True)
-    match = staticmethod(match)
+        return SeparatorBase.match(Lower_Bound_Expr, None, string, require_lhs=True)
 
 
 class Bounds_Remapping(SeparatorBase):  # R738
     """
-    <bounds-remapping> = <lower-bound-expr> : <upper-bound-expr>
+    ::
+
+        <bounds-remapping> = <lower-bound-expr> : <upper-bound-expr>
+
     """
+
     subclass_names = []
-    use_classes = ['Lower_Bound_Expr', 'Upper_Bound_Expr']
+    use_classes = ["Lower_Bound_Expr", "Upper_Bound_Expr"]
 
+    @staticmethod
     def match(string):
         return SeparatorBase.match(
-            Lower_Bound_Expr, Upper_Bound_Expr, string, require_lhs=True,
-            require_rhs=True)
-    match = staticmethod(match)
+            Lower_Bound_Expr,
+            Upper_Bound_Expr,
+            string,
+            require_lhs=True,
+            require_rhs=True,
+        )
 
 
 class Data_Target(Base):  # R739
     """
-    <data-target> = <variable>
-                    | <expr>
+    ::
+
+        <data-target> = <variable>
+                        | <expr>
+
     """
-    subclass_names = ['Variable', 'Expr']
+
+    subclass_names = ["Variable", "Expr"]
 
 
 class Proc_Pointer_Object(Base):  # R740
     """
-    <proc-pointer-object> = <proc-pointer-name>
-                            | <proc-component-ref>
+    ::
+
+        <proc-pointer-object> = <proc-pointer-name>
+                              | <proc-component-ref>
+
     """
-    subclass_names = ['Proc_Pointer_Name', 'Proc_Component_Ref']
+
+    subclass_names = ["Proc_Pointer_Name", "Proc_Component_Ref"]
 
 
 class Proc_Component_Ref(BinaryOpBase):  # R741
     """
-    <proc-component-ref> = <variable> % <procedure-component-name>
+    ::
+
+        <proc-component-ref> = <variable> % <procedure-component-name>
+
     """
+
     subclass_names = []
-    use_names = ['Variable', 'Procedure_Component_Name']
+    use_names = ["Variable", "Procedure_Component_Name"]
 
+    @staticmethod
     def match(string):
-        return BinaryOpBase.match(Variable, r'%', Procedure_Component_Name,
-                                  string)
-    match = staticmethod(match)
+        return BinaryOpBase.match(Variable, r"%", Procedure_Component_Name, string)
 
 
 class Proc_Target(Base):  # R742
     """
-    <proc-target> = <expr>
-                    | <procedure-name>
-                    | <proc-component-ref>
+    ::
+
+        <proc-target> = <expr>
+                        | <procedure-name>
+                        | <proc-component-ref>
+
     """
-    subclass_names = ['Proc_Component_Ref', 'Procedure_Name', 'Expr']
+
+    subclass_names = ["Proc_Component_Ref", "Procedure_Name", "Expr"]
 
 
 class Where_Stmt(StmtBase):  # R743
     """
-    <where-stmt> = WHERE ( <mask-expr> ) <where-assignment-stmt>
+    ::
+
+        <where-stmt> = WHERE ( <mask-expr> ) <where-assignment-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Mask_Expr', 'Where_Assignment_Stmt']
+    use_names = ["Mask_Expr", "Where_Assignment_Stmt"]
 
+    @staticmethod
     def match(string):
-        if string[:5].upper() != 'WHERE':
+        if string[:5].upper() != "WHERE":
             return
         line, repmap = string_replace_map(string[5:].lstrip())
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
-        stmt = repmap(line[i+1:].lstrip())
+        stmt = repmap(line[i + 1 :].lstrip())
         if not stmt:
             return
         expr = repmap(line[1:i].strip())
         if not expr:
             return
         return Mask_Expr(expr), Where_Assignment_Stmt(stmt)
-    match = staticmethod(match)
 
     def tostr(self):
-        return 'WHERE (%s) %s' % tuple(self.items)
+        return "WHERE (%s) %s" % tuple(self.items)
 
 
 class Where_Construct(BlockBase):  # R744
     """
-    <where-construct> = <where-construct-stmt>
-                              [ <where-body-construct> ]...
-                            [ <masked-elsewhere-stmt>
-                              [ <where-body-construct> ]...
-                            ]...
-                            [ <elsewhere-stmt>
-                              [ <where-body-construct> ]... ]
-                            <end-where-stmt>
+    ::
+
+        <where-construct> = <where-construct-stmt>
+                                  [ <where-body-construct> ]...
+                                [ <masked-elsewhere-stmt>
+                                  [ <where-body-construct> ]...
+                                ]...
+                                [ <elsewhere-stmt>
+                                  [ <where-body-construct> ]... ]
+                                <end-where-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Where_Construct_Stmt', 'Where_Body_Construct',
-                 'Masked_Elsewhere_Stmt',
-                 'Elsewhere_Stmt', 'End_Where_Stmt']
+    use_names = [
+        "Where_Construct_Stmt",
+        "Where_Body_Construct",
+        "Masked_Elsewhere_Stmt",
+        "Elsewhere_Stmt",
+        "End_Where_Stmt",
+    ]
 
     @staticmethod
     def match(string):
         return BlockBase.match(
-            Where_Construct_Stmt, [Where_Body_Construct,
-                                   Masked_Elsewhere_Stmt,
-                                   Where_Body_Construct,
-                                   Elsewhere_Stmt,
-                                   Where_Body_Construct, ],
-            End_Where_Stmt, string,
+            Where_Construct_Stmt,
+            [
+                Where_Body_Construct,
+                Masked_Elsewhere_Stmt,
+                Where_Body_Construct,
+                Elsewhere_Stmt,
+                Where_Body_Construct,
+            ],
+            End_Where_Stmt,
+            string,
             match_names=True,  # C730
-            match_name_classes=(Masked_Elsewhere_Stmt, Elsewhere_Stmt,
-                                End_Where_Stmt),  # C730
-            enable_where_construct_hook=True)
+            strict_match_names=True,  # C730
+            match_name_classes=(
+                Masked_Elsewhere_Stmt,
+                Elsewhere_Stmt,
+                End_Where_Stmt,
+            ),  # C730
+            enable_where_construct_hook=True,
+        )
+
+    def tofortran(self, tab="", isfix=None):
+        """
+        Converts this node (and all children) into Fortran.
 
-    def tofortran(self, tab='', isfix=None):
+        :param str tab: white space to prefix to output.
+        :param bool isfix: whether or not to generate fixed-format output.
+
+        :returns: Fortran code.
+        :rtype: str
+
+        """
         tmp = []
         start = self.content[0]
         end = self.content[-1]
         tmp.append(start.tofortran(tab=tab, isfix=isfix))
         for item in self.content[1:-1]:
             if isinstance(item, (Masked_Elsewhere_Stmt, Elsewhere_Stmt)):
                 tmp.append(item.tofortran(tab=tab, isfix=isfix))
             else:
-                tmp.append(item.tofortran(tab=tab+'  ', isfix=isfix))
+                tmp.append(item.tofortran(tab=tab + "  ", isfix=isfix))
         tmp.append(end.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(tmp)
+        return "\n".join(tmp)
 
 
 class Where_Construct_Stmt(StmtBase):  # R745
     """
-    <where-construct-stmt> = [ <where-construct-name> : ] WHERE ( <mask-expr> )
+    ::
+
+        <where-construct-stmt> = [ <where-construct-name> : ] WHERE ( <mask-expr> )
+
     """
+
     subclass_names = []
-    use_names = ['Where_Construct_Name', 'Mask_Expr']
+    use_names = ["Where_Construct_Name", "Mask_Expr"]
 
     @staticmethod
     def match(string):
-        if string[:5].upper() != 'WHERE':
+        if string[:5].upper() != "WHERE":
             return
         line = string[5:].lstrip()
         if not line:
             return
-        if line[0] + line[-1] != '()':
+        if line[0] + line[-1] != "()":
             return
         line = line[1:-1].strip()
         if not line:
             return
-        return Mask_Expr(line),
+        return (Mask_Expr(line),)
 
     def tostr(self):
-        return 'WHERE (%s)' % tuple(self.items)
+        return "WHERE (%s)" % tuple(self.items)
 
     def get_start_name(self):
         return self.item.name
 
 
 class Where_Body_Construct(Base):  # R746
     """
-::
-    <where-body-construct> = <where-assignment-stmt>
-                             | <where-stmt>
-                             | <where-construct>
+    ::
+
+        <where-body-construct> = <where-assignment-stmt>
+                                 | <where-stmt>
+                                 | <where-construct>
+
     """
-    subclass_names = ['Where_Assignment_Stmt', 'Where_Stmt', 'Where_Construct']
+
+    subclass_names = ["Where_Assignment_Stmt", "Where_Stmt", "Where_Construct"]
 
 
 class Where_Assignment_Stmt(Base):  # R747
     """
-::
-    <where-assignment-stmt> = <assignment-stmt>
+    ::
+
+        <where-assignment-stmt> = <assignment-stmt>
+
     """
-    subclass_names = ['Assignment_Stmt']
+
+    subclass_names = ["Assignment_Stmt"]
 
 
 class Mask_Expr(Base):  # R748
     """
     <mask-expr> = <logical-expr>
     """
-    subclass_names = ['Logical_Expr']
+
+    subclass_names = ["Logical_Expr"]
 
 
 class Masked_Elsewhere_Stmt(StmtBase):  # R749
     """
-    <masked-elsewhere-stmt> = ELSEWHERE
-                              ( <mask-expr> ) [ <where-construct-name> ]
+    ::
+
+        <masked-elsewhere-stmt> = ELSEWHERE
+                                  ( <mask-expr> ) [ <where-construct-name> ]
+
     """
+
     import re
+
     subclass_names = []
-    use_names = ['Mask_Expr', 'Where_Construct_Name']
+    use_names = ["Mask_Expr", "Where_Construct_Name"]
 
     @staticmethod
     def match(string):
         if not Elsewhere_Stmt._regex.match(string):
             return
         idx = string.upper().index("WHERE")
-        line = string[idx+5:].lstrip()
+        line = string[idx + 5 :].lstrip()
 
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.rfind(')')
+        i = line.rfind(")")
         if i == -1:
             return
         expr = line[1:i].strip()
         if not expr:
             return
-        line = line[i+1:].rstrip()
+        line = line[i + 1 :].rstrip()
         if line:
             return Mask_Expr(expr), Where_Construct_Name(line)
         return Mask_Expr(expr), None
 
     def tostr(self):
         if self.items[1] is None:
-            return 'ELSEWHERE(%s)' % (self.items[0])
-        return 'ELSEWHERE(%s) %s' % self.items
+            return "ELSEWHERE(%s)" % (self.items[0])
+        return "ELSEWHERE(%s) %s" % self.items
 
     def get_end_name(self):
+        """
+        :return: the name at the END of this block, if it exists
+        :rtype: str or NoneType
+        """
         name = self.items[1]
         if name is not None:
             return name.string
+        return None
 
 
 class Elsewhere_Stmt(StmtBase, WORDClsBase):  # R750
     """
     <elsewhere-stmt> = ELSEWHERE [ <where-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Where_Construct_Name']
-    _regex = re.compile(r'ELSE\s*WHERE', re.I)
+    use_names = ["Where_Construct_Name"]
+    _regex = re.compile(r"ELSE\s*WHERE", re.I)
 
     @staticmethod
     def match(string):
         if not Elsewhere_Stmt._regex.match(string):
             return
         idx = string.upper().index("WHERE")
-        line = string[idx+5:].lstrip()
+        line = string[idx + 5 :].lstrip()
         if line:
             return "ELSEWHERE", Where_Construct_Name(line)
         return "ELSEWHERE", None
 
     def get_end_name(self):
+        """
+        :return: the name at the END of this block, if it exists
+        :rtype: str or NoneType
+        """
         name = self.items[1]
         if name is not None:
             return name.string
+        return None
 
 
 class End_Where_Stmt(EndStmtBase):  # R751
     """
     <end-where-stmt> = END WHERE [ <where-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Where_Construct_Name']
+    use_names = ["Where_Construct_Name"]
 
     @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'WHERE', Where_Construct_Name, string, require_stmt_type=True)
+            "WHERE", Where_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class Forall_Construct(BlockBase):  # R752
     """
-    <forall-construct> = <forall-construct-stmt>
-                             [ <forall-body-construct> ]...
-                             <end-forall-stmt>
+    ::
+
+        <forall-construct> = <forall-construct-stmt>
+                                 [ <forall-body-construct> ]...
+                                 <end-forall-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Forall_Construct_Stmt', 'Forall_Body_Construct',
-                 'End_Forall_Stmt']
+    use_names = ["Forall_Construct_Stmt", "Forall_Body_Construct", "End_Forall_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Forall_Construct_Stmt, [Forall_Body_Construct],
-            End_Forall_Stmt, reader, match_names=True,  # C732
+            Forall_Construct_Stmt,
+            [Forall_Body_Construct],
+            End_Forall_Stmt,
+            reader,
+            match_names=True,  # C732
+            strict_match_names=True,  # C732
         )
 
 
 class Forall_Construct_Stmt(StmtBase, WORDClsBase):  # R753
     """
-    <forall-construct-stmt> = [ <forall-construct-name> : ]
-        FORALL <forall-header>
+    ::
+
+        <forall-construct-stmt> = [ <forall-construct-name> : ]
+            FORALL <forall-header>
+
     """
+
     subclass_names = []
-    use_names = ['Forall_Construct_Name', 'Forall_Header']
+    use_names = ["Forall_Construct_Name", "Forall_Header"]
 
     @staticmethod
     def match(string):
-        return WORDClsBase.match(
-            'FORALL', Forall_Header, string, require_cls=True)
+        return WORDClsBase.match("FORALL", Forall_Header, string, require_cls=True)
 
     def get_start_name(self):
         return self.item.name
 
 
 class Forall_Header(Base):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R754
-    forall-header is ( forall-triplet-spec-list [, scalar-mask-expr ] )
+    """
+    Fortran 2003 rule R754::
+
+        forall-header is ( forall-triplet-spec-list [, scalar-mask-expr ] )
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Forall_Triplet_Spec_List', 'Scalar_Mask_Expr']
+    use_names = ["Forall_Triplet_Spec_List", "Scalar_Mask_Expr"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Forall_Header.
+        """Implements the matching for a Forall_Header.
 
         :param str string: A string containing the code to match.
         :return: `None` if there is no match, otherwise a `tuple` of \
                  size 2 containing a class of type \
                  `Forall_Triplet_Spec_List` and a class of type \
                  `Scalar_Mask_Expr` if there is a scalar mask \
                  expresssion and `None` if not.
         :rtype: (`Forall_Triplet_Spec_List`, `Scalar_Mask_Expr`) or \
                 (`Forall_Triplet_Spec_List`, `None`) or `None`
 
-        '''
+        """
         strip_string = string.strip()
         if not strip_string:
             # Input only contains white space
             return None
-        if strip_string[0] + strip_string[-1] != '()':
+        if strip_string[0] + strip_string[-1] != "()":
             # Input does not start with '(' and end with ')'
             return None
         strip_string_nobr = strip_string[1:-1].strip()
         try:
             # first try to match without a scalar mask expression
             return Forall_Triplet_Spec_List(strip_string_nobr), None
         except NoMatchError:
             # The match failed so try to match with the optional
             # scalar mask expression. Use repmap to remove any
             # unexpected "," e.g. an array access a(i,j), when
             # splitting the string.
             mapped_string, repmap = string_replace_map(strip_string_nobr)
-            split_string = mapped_string.rsplit(',', 1)
+            split_string = mapped_string.rsplit(",", 1)
             if len(split_string) != 2:
                 return None
             left_str = repmap(split_string[0].rstrip())
             right_str = repmap(split_string[1].lstrip())
-            return (Forall_Triplet_Spec_List(left_str),
-                    Scalar_Mask_Expr(right_str))
+            return (Forall_Triplet_Spec_List(left_str), Scalar_Mask_Expr(right_str))
 
     def tostr(self):
-        ''':return: this Forall Header as a string
+        """:return: this Forall Header as a string
         :rtype: str
         :raises InternalError: if the length of the internal items \
         list is not 2.
         :raises InternalError: if the first entry of the internal \
         items list has no content, as a Forall_Triplet_List is \
         expected.
 
-        '''
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Forall_Header.tostr(). 'items' should be of size 2 but "
-                "found '{0}'.".format(len(self.items)))
+                "found '{0}'.".format(len(self.items))
+            )
         if not self.items[0]:
             raise InternalError(
                 "Forall_Header.tostr(). 'items[0]' should be a "
-                "Forall_Triplet_Spec_List instance but it is empty.")
+                "Forall_Triplet_Spec_List instance but it is empty."
+            )
         if not self.items[1]:
             # there is no scalar mask expression
             return "({0})".format(self.items[0])
         return "({0}, {1})".format(self.items[0], self.items[1])
 
 
 class Forall_Triplet_Spec(Base):  # R755
     """
-    <forall-triplet-spec> = <index-name> = <subscript> :
-        <subscript> [ : <stride> ]
+    ::
+
+        <forall-triplet-spec> = <index-name> = <subscript> :
+            <subscript> [ : <stride> ]
+
     """
+
     subclass_names = []
-    use_names = ['Index_Name', 'Subscript', 'Stride']
+    use_names = ["Index_Name", "Subscript", "Stride"]
 
     @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        i = line.find('=')
+        i = line.find("=")
         if i == -1:
             return
         n = Index_Name(repmap(line[:i].rstrip()))
-        line = line[i+1:].lstrip()
-        s = [repmap(s.strip()) for s in line.split(':')]
+        line = line[i + 1 :].lstrip()
+        s = [repmap(s.strip()) for s in line.split(":")]
         if len(s) == 2:
             return n, Subscript(s[0]), Subscript(s[1]), None
         if len(s) == 3:
             return n, Subscript(s[0]), Subscript(s[1]), Stride(s[2])
 
     def tostr(self):
         if self.items[3] is None:
-            return '%s = %s : %s' % (self.items[:3])
-        return '%s = %s : %s : %s' % (self.items)
+            return "%s = %s : %s" % (self.items[:3])
+        return "%s = %s : %s : %s" % (self.items)
 
 
 class Forall_Body_Construct(Base):  # R756
     """
-    <forall-body-construct> = <forall-assignment-stmt>
-                              | <where-stmt>
-                              | <where-construct>
-                              | <forall-construct>
-                              | <forall-stmt>
-    """
-    subclass_names = ['Forall_Assignment_Stmt', 'Where_Stmt',
-                      'Where_Construct', 'Forall_Construct',
-                      'Forall_Stmt']
+    ::
+
+        <forall-body-construct> = <forall-assignment-stmt>
+                                  | <where-stmt>
+                                  | <where-construct>
+                                  | <forall-construct>
+                                  | <forall-stmt>
+
+    """
+
+    subclass_names = [
+        "Forall_Assignment_Stmt",
+        "Where_Stmt",
+        "Where_Construct",
+        "Forall_Construct",
+        "Forall_Stmt",
+    ]
 
 
 class Forall_Assignment_Stmt(Base):  # R757
     """
-    <forall-assignment-stmt> = <assignment-stmt>
-                               | <pointer-assignment-stmt>
+    ::
+
+        <forall-assignment-stmt> = <assignment-stmt>
+                                   | <pointer-assignment-stmt>
+
     """
-    subclass_names = ['Assignment_Stmt', 'Pointer_Assignment_Stmt']
+
+    subclass_names = ["Assignment_Stmt", "Pointer_Assignment_Stmt"]
 
 
 class End_Forall_Stmt(EndStmtBase):  # R758
     """
     <end-forall-stmt> = END FORALL [ <forall-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Forall_Construct_Name']
+    use_names = ["Forall_Construct_Name"]
 
     @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'FORALL', Forall_Construct_Name, string, require_stmt_type=True)
+            "FORALL", Forall_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class Forall_Stmt(StmtBase):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R759
-    forall-stmt is FORALL forall-header forall-assignment-stmt
+    """
+    Fortran 2003 rule R759::
+
+        forall-stmt is FORALL forall-header forall-assignment-stmt
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Forall_Header', 'Forall_Assignment_Stmt']
+    use_names = ["Forall_Header", "Forall_Assignment_Stmt"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a forall statement.
+        """Implements the matching for a forall statement.
 
         :param string: A string or the fortran reader containing the \
                     line of code that we are trying to match.
         :type string: `str` or \
         :py:class:`fparser.common.readfortran.FortranReader`
         :return: `None` if there is no match or a `tuple` of size 2 \
         containing an instance of the Forall_Header class followed by \
         an instance of the Forall_Assignment_Stmt class.
         :rtype: `None` or ( \
         :py:class:`fparser.two.Fortran2003.Forall_Header`, \
         :py:class:`fparser.two.Fortran2003.Forall_Assignment_Stmt`)
 
-        '''
+        """
         strip_string = string.strip()
-        if strip_string[:6].upper() != 'FORALL':
+        if strip_string[:6].upper() != "FORALL":
             return None
         line, repmap = string_replace_map(strip_string[6:].lstrip())
-        if not line.startswith('('):
+        if not line.startswith("("):
             return None
-        index = line.find(')')
+        index = line.find(")")
         if index == -1:
             return None
-        header = repmap(line[:index+1])
+        header = repmap(line[: index + 1])
         # No need to check if header variable is empty as we know it
         # will contain brackets at least
-        line = repmap(line[index+1:].lstrip())
+        line = repmap(line[index + 1 :].lstrip())
         if not line:
             return None
         return Forall_Header(header), Forall_Assignment_Stmt(line)
 
     def tostr(self):
-        '''
+        """
         :return: this forall statement as a string
         :rtype: str
         :raises InternalError: if the internal items list variable is \
         not the expected size.
         :raises InternalError: if the first element of the internal \
         items list is None or is an empty string.
         :raises InternalError: if the second element of the internal \
         items list is None or is an empty string.
-        '''
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Class Forall_Stmt method tostr() has '{0}' items, "
-                "but expecting 2.".format(len(self.items)))
+                "but expecting 2.".format(len(self.items))
+            )
         if not self.items[0]:
             raise InternalError(
                 "Class Forall_Stmt method tostr(). 'Items' entry 0 "
-                "should be a valid Forall_Header.")
+                "should be a valid Forall_Header."
+            )
         if not self.items[1]:
             raise InternalError(
                 "Class Forall_Stmt method tostr(). 'Items' entry 1 should "
-                "be a valid Forall_Assignment_Stmt")
+                "be a valid Forall_Assignment_Stmt"
+            )
         return "FORALL {0} {1}".format(self.items[0], self.items[1])
 
+
 #
 # SECTION  8
 #
 
 
 class Block(BlockBase):  # R801
     """
     <block> = [ <execution-part-construct> ]...
     """
+
     subclass_names = []
-    use_names = ['Execution_Part_Construct']
+    use_names = ["Execution_Part_Construct"]
 
     @staticmethod
     def match(string):
         return BlockBase.match(None, [Execution_Part_Construct], None, string)
 
 
 class If_Construct(BlockBase):  # R802
     """
-    <if-construct> = <if-then-stmt>
-                           <block>
-                         [ <else-if-stmt>
-                           <block>
-                         ]...
-                         [ <else-stmt>
-                           <block>
-                         ]
-                         <end-if-stmt>
+    ::
+
+        <if-construct> = <if-then-stmt>
+                               <block>
+                             [ <else-if-stmt>
+                               <block>
+                             ]...
+                             [ <else-stmt>
+                               <block>
+                             ]
+                             <end-if-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['If_Then_Stmt', 'Block', 'Else_If_Stmt',
-                 'Else_Stmt', 'End_If_Stmt']
+    use_names = [
+        "If_Then_Stmt",
+        "Execution_Part_Construct",
+        "Else_If_Stmt",
+        "Else_Stmt",
+        "End_If_Stmt",
+    ]
 
     @staticmethod
     def match(string):
         return BlockBase.match(
-            If_Then_Stmt, [Execution_Part_Construct,
-                           Else_If_Stmt,
-                           Execution_Part_Construct,
-                           Else_Stmt,
-                           Execution_Part_Construct],
-            End_If_Stmt, string,
+            If_Then_Stmt,
+            [
+                Execution_Part_Construct,
+                Else_If_Stmt,
+                Execution_Part_Construct,
+                Else_Stmt,
+                Execution_Part_Construct,
+            ],
+            End_If_Stmt,
+            string,
             match_names=True,  # C801
+            strict_match_names=True,  # C801
             match_name_classes=(Else_If_Stmt, Else_Stmt, End_If_Stmt),
-            enable_if_construct_hook=True)
+            enable_if_construct_hook=True,
+        )
+
+    def tofortran(self, tab="", isfix=None):
+        """
+        Converts this node (and all children) into Fortran.
 
-    def tofortran(self, tab='', isfix=None):
+        :param str tab: white space to prefix to output.
+        :param bool isfix: whether or not to generate fixed-format output.
+
+        :returns: Fortran code.
+        :rtype: str
+
+        """
         tmp = []
         start = self.content[0]
         end = self.content[-1]
         tmp.append(start.tofortran(tab=tab, isfix=isfix))
         for item in self.content[1:-1]:
             if isinstance(item, (Else_If_Stmt, Else_Stmt)):
                 tmp.append(item.tofortran(tab=tab, isfix=isfix))
             else:
-                tmp.append(item.tofortran(tab=tab+'  ', isfix=isfix))
+                tmp.append(item.tofortran(tab=tab + "  ", isfix=isfix))
         tmp.append(end.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(tmp)
+        return "\n".join(tmp)
 
 
 class If_Then_Stmt(StmtBase):  # R803
     """
-    <if-then-stmt> = [ <if-construct-name> : ]
-        IF ( <scalar-logical-expr> ) THEN
+    ::
+
+        <if-then-stmt> = [ <if-construct-name> : ]
+            IF ( <scalar-logical-expr> ) THEN
+
     """
+
     subclass_names = []
-    use_names = ['If_Construct_Name', 'Scalar_Logical_Expr']
+    use_names = ["If_Construct_Name", "Scalar_Logical_Expr"]
 
     @staticmethod
     def match(string):
-        if string[:2].upper() != 'IF':
+        if string[:2].upper() != "IF":
             return
-        if string[-4:].upper() != 'THEN':
+        if string[-4:].upper() != "THEN":
             return
         line = string[2:-4].strip()
         if not line:
             return
-        if line[0] + line[-1] != '()':
+        if line[0] + line[-1] != "()":
             return
-        return Scalar_Logical_Expr(line[1:-1].strip()),
+        return (Scalar_Logical_Expr(line[1:-1].strip()),)
 
     def tostr(self):
-        return 'IF (%s) THEN' % self.items
+        return "IF (%s) THEN" % self.items
 
     def get_start_name(self):
         return self.item.name
 
 
 class Else_If_Stmt(StmtBase):  # R804
     """
-    <else-if-stmt> = ELSE IF ( <scalar-logical-expr> ) THEN
-        [ <if-construct-name> ]
+    ::
+
+        <else-if-stmt> = ELSE IF ( <scalar-logical-expr> ) THEN
+            [ <if-construct-name> ]
+
     """
+
     subclass_names = []
-    use_names = ['Scalar_Logical_Expr', 'If_Construct_Name']
+    use_names = ["Scalar_Logical_Expr", "If_Construct_Name"]
 
     @staticmethod
     def match(string):
-        if string[:4].upper() != 'ELSE':
+        if string[:4].upper() != "ELSE":
             return
         line = string[4:].lstrip()
-        if line[:2].upper() != 'IF':
+        if line[:2].upper() != "IF":
             return
         line = line[2:].lstrip()
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.rfind(')')
+        i = line.rfind(")")
         if i == -1:
             return
         expr = line[1:i].strip()
-        line = line[i+1:].lstrip()
-        if line[:4].upper() != 'THEN':
+        line = line[i + 1 :].lstrip()
+        if line[:4].upper() != "THEN":
             return
         line = line[4:].lstrip()
         if line:
             return Scalar_Logical_Expr(expr), If_Construct_Name(line)
         return Scalar_Logical_Expr(expr), None
 
     def tostr(self):
         if self.items[1] is None:
-            return 'ELSE IF (%s) THEN' % (self.items[0])
-        return 'ELSE IF (%s) THEN %s' % self.items
+            return "ELSE IF (%s) THEN" % (self.items[0])
+        return "ELSE IF (%s) THEN %s" % self.items
 
     def get_end_name(self):
+        """
+        :return: the name at the END of this block, if it exists
+        :rtype: str or NoneType
+        """
         name = self.items[1]
         if name is not None:
             return name.string
+        return None
 
 
 class Else_Stmt(StmtBase):  # R805
     """
     <else-stmt> = ELSE [ <if-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['If_Construct_Name']
+    use_names = ["If_Construct_Name"]
 
     @staticmethod
     def match(string):
-        if string[:4].upper() != 'ELSE':
+        if string[:4].upper() != "ELSE":
             return
         line = string[4:].lstrip()
         if line:
-            return If_Construct_Name(line),
-        return None,
+            return (If_Construct_Name(line),)
+        return (None,)
 
     def tostr(self):
         if self.items[0] is None:
-            return 'ELSE'
-        return 'ELSE %s' % self.items
+            return "ELSE"
+        return "ELSE %s" % self.items
 
     def get_end_name(self):
+        """
+        :return: the name at the END of this block, if it exists
+        :rtype: str or NoneType
+        """
         name = self.items[0]
         if name is not None:
             return name.string
+        return None
 
 
 class End_If_Stmt(EndStmtBase):  # R806
     """
     <end-if-stmt> = END IF [ <if-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['If_Construct_Name']
+    use_names = ["If_Construct_Name"]
 
     @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'IF', If_Construct_Name, string, require_stmt_type=True)
+            "IF", If_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class If_Stmt(StmtBase):  # R807
     """
-    <if-stmt> = IF ( <scalar-logical-expr> ) <action-stmt>
+    Fortran 2003 rule R807::
+
+        if-stmt is IF ( scalar-logical-expr ) action-stmt
+
+    C802 (R807) The action-stmt in the if-stmt shall not be an if-stmt,
+    end-program-stmt, end-function-stmt, or end-subroutine-stmt.
+
     """
+
     subclass_names = []
-    use_names = ['Scalar_Logical_Expr', 'Action_Stmt_C802']
+    use_names = ["Scalar_Logical_Expr", "Action_Stmt_C802"]
+    action_stmt_cls = Action_Stmt_C802
 
-    @staticmethod
-    def match(string):
-        if string[:2].upper() != 'IF':
+    @classmethod
+    def match(cls, string):
+        """Implements the matching for an if statement that controls a single
+        action statement
+
+        This is implemented as a class method to allow parameterizing the
+        type that is used to match the action-stmt. It is specified by the
+        attribute :py:attr:`action_stmt_cls`, which can be overwritten in
+        derived classes to specify an updated version, so done for example
+        in the Fortran 2008 version :py:class:`fparser.two.Fortran2008.If_Stmt`.
+
+        :param str string: Text that we are trying to match.
+
+        :returns: None if there is no match or, if there is a match, a \
+            2-tuple containing the logical expression as an object matched by \
+            :py:class:`fparser.two.Fortran2003.Scalar_Logical_Expr` and the \
+            action statement as an object matching ``cls.action_stmt_cls``. 
+        :rtype: (:py:class:`fparser.two.Fortran2003.Scalar_Logical_Expr`,
+            :py:class:`fparser.two.Fortran2003.Action_Stmt_C802`) \
+            or NoneType
+
+        """
+        if string[:2].upper() != "IF":
             return
         line, repmap = string_replace_map(string)
         line = line[2:].lstrip()
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         expr = repmap(line[1:i].strip())
-        stmt = repmap(line[i+1:].lstrip())
-        return Scalar_Logical_Expr(expr), Action_Stmt_C802(stmt)
+        stmt = repmap(line[i + 1 :].lstrip())
+        return Scalar_Logical_Expr(expr), cls.action_stmt_cls(stmt)
 
     def tostr(self):
-        return 'IF (%s) %s' % self.items
+        return "IF (%s) %s" % self.items
 
 
 class Case_Construct(BlockBase):  # R808
     """
-    <case-construct> = <select-case-stmt>
-                           [ <case-stmt>
-                             <block> == [<execution-part-construct>]..
-                           ]..
-                           <end-select-stmt>
+    ::
+
+        <case-construct> = <select-case-stmt>
+                               [ <case-stmt>
+                                 <block> == [<execution-part-construct>]..
+                               ]..
+                               <end-select-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Select_Case_Stmt', 'Case_Stmt',
-                 'End_Select_Stmt', 'Execution_Part_Construct']
+    use_names = [
+        "Select_Case_Stmt",
+        "Case_Stmt",
+        "End_Select_Stmt",
+        "Execution_Part_Construct",
+    ]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Select_Case_Stmt, [Case_Stmt,
-                               Execution_Part_Construct,
-                               Case_Stmt],
-            End_Select_Stmt, reader,
+            Select_Case_Stmt,
+            [Case_Stmt, Execution_Part_Construct, Case_Stmt],
+            End_Select_Stmt,
+            reader,
             match_names=True,  # C803
-            enable_case_construct_hook=True  # C803
+            strict_match_names=True,  # C803
+            match_name_classes=(Case_Stmt),
         )
 
-    def tofortran(self, tab='', isfix=None):
+    def tofortran(self, tab="", isfix=None):
+        """
+        Converts this node (and all children) into Fortran.
+
+        :param str tab: white space to prefix to output.
+        :param bool isfix: whether or not to generate fixed-format output.
+
+        :returns: Fortran code.
+        :rtype: str
+
+        """
         tmp = []
         start = self.content[0]
         end = self.content[-1]
         tmp.append(start.tofortran(tab=tab, isfix=isfix))
         for item in self.content[1:-1]:
             if isinstance(item, Case_Stmt):
                 tmp.append(item.tofortran(tab=tab, isfix=isfix))
             else:
-                tmp.append(item.tofortran(tab=tab + '  ', isfix=isfix))
+                tmp.append(item.tofortran(tab=tab + "  ", isfix=isfix))
         tmp.append(end.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(tmp)
+        return "\n".join(tmp)
 
 
 class Select_Case_Stmt(StmtBase, CALLBase):  # R809
     """
-    <select-case-stmt> = [ <case-construct-name> : ]
-        SELECT CASE ( <case-expr> )
+    ::
+
+        <select-case-stmt> = [ <case-construct-name> : ]
+            SELECT CASE ( <case-expr> )
+
     """
+
     subclass_names = []
-    use_names = ['Case_Construct_Name', 'Case_Expr']
+    use_names = ["Case_Construct_Name", "Case_Expr"]
 
     @staticmethod
     def match(string):
-        if string[:6].upper() != 'SELECT':
+        if string[:6].upper() != "SELECT":
             return
         line = string[6:].lstrip()
-        if line[:4].upper() != 'CASE':
+        if line[:4].upper() != "CASE":
             return
         line = line[4:].lstrip()
-        if not line or line[0]+line[-1] != '()':
+        if not line or line[0] + line[-1] != "()":
             return
         line = line[1:-1].strip()
-        return Case_Expr(line),
+        return (Case_Expr(line),)
 
     def tostr(self):
-        return 'SELECT CASE (%s)' % (self.items[0])
+        return "SELECT CASE (%s)" % (self.items[0])
 
     def get_start_name(self):
         return self.item.name
 
 
 class Case_Stmt(StmtBase):  # R810
     """
     <case-stmt> = CASE <case-selector> [ <case-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Case_Selector', 'Case_Construct_Name']
+    use_names = ["Case_Selector", "Case_Construct_Name"]
 
     @staticmethod
     def match(string):
-        if string[:4].upper() != 'CASE':
+        if string[:4].upper() != "CASE":
             return
         line, repmap = string_replace_map(string[4:].lstrip())
-        if line.startswith('('):
-            i = line.find(')')
+        if line.startswith("("):
+            i = line.find(")")
             if i == -1:
                 return
-            n = line[i+1:].lstrip() or None
+            n = line[i + 1 :].lstrip() or None
             if n:
                 n = Case_Construct_Name(repmap(n))
-            return Case_Selector(repmap(line[:i+1].rstrip())), n
-        if line[:7].upper() == 'DEFAULT':
+            return Case_Selector(repmap(line[: i + 1].rstrip())), n
+        if line[:7].upper() == "DEFAULT":
             n = repmap(line[7:].lstrip()) or None
             if n:
                 n = Case_Construct_Name(repmap(n))
             return Case_Selector(line[:7]), n
 
     def tostr(self):
         if self.items[1] is None:
-            return 'CASE %s' % (self.items[0])
-        return 'CASE %s %s' % (self.items)
+            return "CASE %s" % (self.items[0])
+        return "CASE %s %s" % (self.items)
+
+    def get_end_name(self):
+        """
+        :return: the name at the END of this block, if it exists
+        :rtype: str or NoneType
+        """
+        name = self.items[1]
+        if name is not None:
+            return name.string
+        return None
 
 
 class End_Select_Stmt(EndStmtBase):  # R811
     """
     <end-select-stmt> = END SELECT [ <case-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Case_Construct_Name']
+    use_names = ["Case_Construct_Name"]
 
     @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'SELECT', Case_Construct_Name, string, require_stmt_type=True)
+            "SELECT", Case_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class Case_Expr(Base):  # R812
     """
-    <case-expr> = <scalar-int-expr>
-                  | <scalar-char-expr>
-                  | <scalar-logical-expr>
+    ::
+
+        <case-expr> = <scalar-int-expr>
+                      | <scalar-char-expr>
+                      | <scalar-logical-expr>
+
     """
+
     subclass_names = []
-    subclass_names = ['Scalar_Int_Expr', 'Scalar_Char_Expr',
-                      'Scalar_Logical_Expr']
+    subclass_names = ["Scalar_Int_Expr", "Scalar_Char_Expr", "Scalar_Logical_Expr"]
 
 
 class Case_Selector(Base):  # R813
     """
-    <case-selector> = ( <case-value-range-list> )
-                      | DEFAULT
+    ::
+
+        <case-selector> = ( <case-value-range-list> )
+                          | DEFAULT
+
     """
+
     subclass_names = []
-    use_names = ['Case_Value_Range_List']
+    use_names = ["Case_Value_Range_List"]
 
     @staticmethod
     def match(string):
-        if len(string) == 7 and string.upper() == 'DEFAULT':
-            return None,
-        if not (string.startswith('(') and string.endswith(')')):
+        if len(string) == 7 and string.upper() == "DEFAULT":
+            return (None,)
+        if not (string.startswith("(") and string.endswith(")")):
             return
-        return Case_Value_Range_List(string[1:-1].strip()),
+        return (Case_Value_Range_List(string[1:-1].strip()),)
 
     def tostr(self):
         if self.items[0] is None:
-            return 'DEFAULT'
-        return '(%s)' % (self.items[0])
+            return "DEFAULT"
+        return "(%s)" % (self.items[0])
 
 
 class Case_Value_Range(SeparatorBase):  # R814
     """
-    <case-value-range> = <case-value>
-                         | <case-value> :
-                         | : <case-value>
-                         | <case-value> : <case-value>
+    ::
+
+        <case-value-range> = <case-value>
+                             | <case-value> :
+                             | : <case-value>
+                             | <case-value> : <case-value>
+
     """
-    subclass_names = ['Case_Value']
+
+    subclass_names = ["Case_Value"]
 
     @staticmethod
     def match(string):
         return SeparatorBase.match(Case_Value, Case_Value, string)
 
 
 class Case_Value(Base):  # R815
     """
-    <case-value> = <scalar-int-initialization-expr>
-                   | <scalar-char-initialization-expr>
-                   | <scalar-logical-initialization-expr>
-    """
-    subclass_names = ['Scalar_Int_Initialization_Expr',
-                      'Scalar_Char_Initialization_Expr',
-                      'Scalar_Logical_Initialization_Expr']
+    ::
+
+        <case-value> = <scalar-int-initialization-expr>
+                       | <scalar-char-initialization-expr>
+                       | <scalar-logical-initialization-expr>
+
+    """
+
+    subclass_names = [
+        "Scalar_Int_Initialization_Expr",
+        "Scalar_Char_Initialization_Expr",
+        "Scalar_Logical_Initialization_Expr",
+    ]
 
 
 class Associate_Construct(BlockBase):  # R816
     """
-    <associate-construct> = <associate-stmt>
-                                <block> == [ <execution-part-construct> ]...
-                                <end-associate-stmt>
+    ::
+
+        <associate-construct> = <associate-stmt>
+                                    <block> == [ <execution-part-construct> ]...
+                                    <end-associate-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Associate_Stmt', 'Execution_Part_Construct',
-                 'End_Associate_Stmt']
+    use_names = ["Associate_Stmt", "Execution_Part_Construct", "End_Associate_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Associate_Stmt, [Execution_Part_Construct],
-            End_Associate_Stmt, reader,
+            Associate_Stmt,
+            [Execution_Part_Construct],
+            End_Associate_Stmt,
+            reader,
             match_names=True,  # C810
+            strict_match_names=True,  # C810
         )
 
 
 class Associate_Stmt(StmtBase, CALLBase):  # R817
     """
-    <associate-stmt> = [ <associate-construct-name> : ]
-        ASSOCIATE ( <association-list> )
+    ::
+
+        <associate-stmt> = [ <associate-construct-name> : ]
+            ASSOCIATE ( <association-list> )
+
     """
+
     subclass_names = []
-    use_names = ['Associate_Construct_Name', 'Association_List']
+    use_names = ["Associate_Construct_Name", "Association_List"]
 
     @staticmethod
     def match(string):
-        return CALLBase.match('ASSOCIATE', Association_List, string)
+        return CALLBase.match("ASSOCIATE", Association_List, string)
 
     def get_start_name(self):
         return self.item.name
 
 
 class Association(BinaryOpBase):  # R818
     """
     <association> = <associate-name> => <selector>
     """
+
     subclass_names = []
-    use_names = ['Associate_Name', 'Selector']
+    use_names = ["Associate_Name", "Selector"]
 
     @staticmethod
     def match(string):
-        return BinaryOpBase.match(Associate_Name, '=>', Selector, string)
+        return BinaryOpBase.match(Associate_Name, "=>", Selector, string)
 
 
 class Selector(Base):  # R819
     """
-    <selector> = <expr>
-                 | <variable>
+    ::
+
+        <selector> = <expr>
+                     | <variable>
     """
-    subclass_names = ['Expr', 'Variable']
+
+    subclass_names = ["Expr", "Variable"]
 
 
 class End_Associate_Stmt(EndStmtBase):  # R820
     """
     <end-associate-stmt> = END ASSOCIATE [ <associate-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Associate_Construct_Name']
+    use_names = ["Associate_Construct_Name"]
 
     @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'ASSOCIATE', Associate_Construct_Name, string,
-            require_stmt_type=True)
+            "ASSOCIATE", Associate_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class Select_Type_Construct(BlockBase):  # R821
     """
-    <select-type-construct> = <select-type-stmt>
-                                  [ <type-guard-stmt>
-                                    <block> == [<execution-part-construct>]..
-                                  ]...
-                                  <end-select-type-stmt>
+    ::
+
+        <select-type-construct> = <select-type-stmt>
+                                      [ <type-guard-stmt>
+                                        <block> == [<execution-part-construct>]..
+                                      ]...
+                                      <end-select-type-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Select_Type_Stmt', 'Type_Guard_Stmt',
-                 'Execution_Part_Construct', 'End_Select_Type_Stmt']
+    use_names = [
+        "Select_Type_Stmt",
+        "Type_Guard_Stmt",
+        "Execution_Part_Construct",
+        "End_Select_Type_Stmt",
+    ]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Select_Type_Stmt, [Type_Guard_Stmt, Execution_Part_Construct,
-                               Type_Guard_Stmt], End_Select_Type_Stmt, reader,
+            Select_Type_Stmt,
+            [Type_Guard_Stmt, Execution_Part_Construct, Type_Guard_Stmt],
+            End_Select_Type_Stmt,
+            reader,
             match_names=True,  # C819
-            enable_select_type_construct_hook=True)
+            strict_match_names=True,  # C819
+            match_name_classes=(Type_Guard_Stmt),
+        )
 
 
 class Select_Type_Stmt(StmtBase):  # R822
     """
-    <select-type-stmt> = [ <select-construct-name> : ] SELECT TYPE
-        ( [ <associate-name> => ] <selector> )
+    ::
+
+        <select-type-stmt> = [ <select-construct-name> : ] SELECT TYPE
+            ( [ <associate-name> => ] <selector> )
+
     """
+
     subclass_names = []
-    use_names = ['Select_Construct_Name', 'Associate_Name', 'Selector']
+    use_names = ["Select_Construct_Name", "Associate_Name", "Selector"]
 
     @staticmethod
     def match(string):
-        if string[:6].upper() != 'SELECT':
+        if string[:6].upper() != "SELECT":
             return
         line = string[6:].lstrip()
-        if line[:4].upper() != 'TYPE':
+        if line[:4].upper() != "TYPE":
             return
         line = line[4:].lstrip()
-        if not line or line[0]+line[-1] != '()':
+        if not line or line[0] + line[-1] != "()":
             return
         line = line[1:-1].strip()
-        i = line.find('=>')
+        i = line.find("=>")
         if i != -1:
-            return Associate_Name(
-                line[:i].rstrip()), Selector(line[i+2:].lstrip())
+            return Associate_Name(line[:i].rstrip()), Selector(line[i + 2 :].lstrip())
         return None, Selector(line)
 
     def tostr(self):
         if self.items[0] is None:
-            return 'SELECT TYPE(%s)' % (self.items[1])
-        return 'SELECT TYPE(%s=>%s)' % (self.items)
+            return "SELECT TYPE(%s)" % (self.items[1])
+        return "SELECT TYPE(%s=>%s)" % (self.items)
 
     def get_start_name(self):
         return self.item.name
 
 
 class Type_Guard_Stmt(StmtBase):  # R823
     """
-::
-    <type-guard-stmt> = TYPE IS ( <type-spec> ) [ <select-construct-name> ]
-                        | CLASS IS ( <type-spec> ) [ <select-construct-name> ]
-                        | CLASS DEFAULT [ <select-construct-name> ]
+    ::
+
+        <type-guard-stmt> = TYPE IS ( <type-spec> ) [ <select-construct-name> ]
+                            | CLASS IS ( <type-spec> ) [ <select-construct-name> ]
+                            | CLASS DEFAULT [ <select-construct-name> ]
+
+    The `items` attribute for this class will contain::
+
+        ({'TYPE IS', 'CLASS IS', 'CLASS DEFAULT'}, Type_Spec, Select_Construct_Name)
 
-Attributes
-----------
-items : ({'TYPE IS', 'CLASS IS', 'CLASS DEFAULT'}, Type_Spec,
-        Select_Construct_Name)
     """
+
     subclass_names = []
-    use_names = ['Type_Spec', 'Select_Construct_Name']
+    use_names = ["Type_Spec", "Select_Construct_Name"]
 
     @staticmethod
     def match(string):
-        if string[:4].upper() == 'TYPE':
+        if string[:4].upper() == "TYPE":
             line = string[4:].lstrip()
-            if not line[:2].upper() == 'IS':
+            if not line[:2].upper() == "IS":
                 return
             line = line[2:].lstrip()
-            kind = 'TYPE IS'
-        elif string[:5].upper() == 'CLASS':
+            kind = "TYPE IS"
+        elif string[:5].upper() == "CLASS":
             line = string[5:].lstrip()
-            if line[:2].upper() == 'IS':
+            if line[:2].upper() == "IS":
                 line = line[2:].lstrip()
-                kind = 'CLASS IS'
-            elif line[:7].upper() == 'DEFAULT':
+                kind = "CLASS IS"
+            elif line[:7].upper() == "DEFAULT":
                 line = line[7:].lstrip()
                 if line:
                     if isalnum(line[0]):
                         return
-                    return 'CLASS DEFAULT', None, Select_Construct_Name(line)
-                return 'CLASS DEFAULT', None, None
+                    return "CLASS DEFAULT", None, Select_Construct_Name(line)
+                return "CLASS DEFAULT", None, None
             else:
                 return
         else:
             return
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.rfind(')')
+        i = line.rfind(")")
         if i == -1:
             return
         tmp = line[1:i].strip()
         if not tmp:
             return
-        line = line[i+1:].lstrip()
+        line = line[i + 1 :].lstrip()
         if line:
             return kind, Type_Spec(tmp), Select_Construct_Name(line)
         return kind, Type_Spec(tmp), None
 
     def tostr(self):
         s = str(self.items[0])
         if self.items[1] is not None:
-            s += ' (%s)' % (self.items[1])
+            s += " (%s)" % (self.items[1])
         if self.items[2] is not None:
-            s += ' %s' % (self.items[2])
+            s += " %s" % (self.items[2])
         return s
 
+    def get_end_name(self):
+        """
+        :return: the name at the END of this block, if it exists
+        :rtype: str or NoneType
+        """
+        name = self.items[-1]
+        if name is not None:
+            return name.string
+        return None
+
 
 class End_Select_Type_Stmt(EndStmtBase):  # R824
     """
     <end-select-type-stmt> = END SELECT [ <select-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Select_Construct_Name']
+    use_names = ["Select_Construct_Name"]
 
     @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'SELECT', Select_Construct_Name, string, require_stmt_type=True)
+            "SELECT", Select_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class Do_Construct(Base):  # pylint: disable=invalid-name
     """
-    R825
+    R825::
+
+        <do-construct> = <block-do-construct>
+                         | <nonblock-do-construct>
 
-    <do-construct> = <block-do-construct>
-                     | <nonblock-do-construct>
     """
-    subclass_names = ['Block_Do_Construct', 'Nonblock_Do_Construct']
+
+    subclass_names = ["Block_Do_Construct", "Nonblock_Do_Construct"]
 
 
 class Block_Do_Construct(Base):  # pylint: disable=invalid-name
     """
-    R826
+    R826::
+
+        <block-do-construct> = <block-label-do-construct>
+                               | <block-nonlabel-do-construct>
 
-    <block-do-construct> = <block-label-do-construct>
-                           | <block-nonlabel-do-construct>
     """
-    subclass_names = ['Block_Label_Do_Construct',
-                      'Block_Nonlabel_Do_Construct']
+
+    subclass_names = ["Block_Label_Do_Construct", "Block_Nonlabel_Do_Construct"]
 
 
 class Block_Label_Do_Construct(BlockBase):  # pylint: disable=invalid-name
     """
-    R826_1
+    R826_1::
+
+        <block-label-do-construct> = <label-do-stmt>
+                                       [ <execution-part-construct> ]...
+                                       <end-do>
 
-    <block-label-do-construct> = <label-do-stmt>
-                                   [ <execution-part-construct> ]...
-                                   <end-do>
     """
+
     subclass_names = []
-    use_names = ['Label_Do_Stmt', 'Execution_Part_Construct', 'End_Do']
+    use_names = ["Label_Do_Stmt", "Execution_Part_Construct", "End_Do"]
 
     @staticmethod
     def match(reader):
-        '''
+        """
         :param reader: instance of `FortranReaderBase` class
         :type reader: :py:class:`FortranReaderBase`
         :return: code block matching the labeled "DO" construct
         :rtype: string
-        '''
-        return BlockBase.match(Label_Do_Stmt, [Execution_Part_Construct],
-                               End_Do, reader,
-                               match_labels=True,
-                               enable_do_label_construct_hook=True)
-
-    def tofortran(self, tab='', isfix=None):
-        '''
-        :param str tab: tab character or empty string
-        :param bool isfix: whether the reader is in fixed format
-        :return: parsed representation of the labeled "DO" construct
-        :rtype: string
-        '''
+        """
+        return BlockBase.match(
+            Label_Do_Stmt,
+            [Execution_Part_Construct],
+            End_Do,
+            reader,
+            match_labels=True,
+            enable_do_label_construct_hook=True,
+        )
+
+    def tofortran(self, tab="", isfix=None):
+        """
+        :param str tab: tab character or empty string.
+        :param bool isfix: whether the reader is in fixed format.
+
+        :return: parsed representation of the labeled "DO" construct.
+        :rtype: str
+        """
         lblock = []
         start = self.content[0]
         end = self.content[-1]
-        extra_tab = '  '
+        extra_tab = "  "
         lblock.append(start.tofortran(tab=tab, isfix=isfix))
         for item in self.content[1:-1]:
-            lblock.append(item.tofortran(tab=tab+extra_tab, isfix=isfix))
+            lblock.append(item.tofortran(tab=tab + extra_tab, isfix=isfix))
         if len(self.content) > 1:
             lblock.append(end.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(lblock)
+        return "\n".join(lblock)
 
 
 class Block_Nonlabel_Do_Construct(BlockBase):  # pylint: disable=invalid-name
     """
-     R826_2
+    R826_2::
+
+       <block-nonlabel-do-construct> = <nonlabel-do-stmt>
+                                        [ <execution-part-construct> ]...
+                                        <end-do-stmt>
 
-    <block-nonlabel-do-construct> = <nonlabel-do-stmt>
-                                     [ <execution-part-construct> ]...
-                                     <end-do-stmt>
     """
+
     subclass_names = []
-    use_names = ['Nonlabel_Do_Stmt', 'Execution_Part_Construct', 'End_Do_Stmt']
+    use_names = ["Nonlabel_Do_Stmt", "Execution_Part_Construct", "End_Do_Stmt"]
 
     @staticmethod
     def match(reader):
-        '''
+        """
         :param reader: instance of `FortranReaderBase` class
         :type reader: :py:class:`FortranReaderBase`
         :return: code block matching the nonlabeled "DO" construct
         :rtype: string
-        '''
-        return BlockBase.match(Nonlabel_Do_Stmt, [Execution_Part_Construct],
-                               End_Do_Stmt, reader
-                               )
+        """
+        return BlockBase.match(
+            Nonlabel_Do_Stmt,
+            [Execution_Part_Construct],
+            End_Do_Stmt,
+            reader,
+            match_names=True,  # C821
+            strict_match_names=True,  # C821
+        )
 
 
 class Do_Stmt(Base):  # pylint: disable=invalid-name
     """
-    R827
+    R827::
+
+        <do-stmt> = <label-do-stmt>
+                    | <nonlabel-do-stmt>
 
-    <do-stmt> = <label-do-stmt>
-                | <nonlabel-do-stmt>
     """
-    subclass_names = ['Label_Do_Stmt', 'Nonlabel_Do_Stmt']
+
+    subclass_names = ["Label_Do_Stmt", "Nonlabel_Do_Stmt"]
 
 
 class Label_Do_Stmt(StmtBase):  # pylint: disable=invalid-name
     """
-    R828
+    R828::
+
+        <label-do-stmt> = [ <do-construct-name> : ] DO <label> [ <loop-control> ]
 
-    <label-do-stmt> = [ <do-construct-name> : ] DO <label> [ <loop-control> ]
     """
+
     subclass_names = []
-    use_names = ['Do_Construct_Name', 'Label', 'Loop_Control']
+    use_names = ["Do_Construct_Name", "Label", "Loop_Control"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param string: (source of) Fortran string to parse
         :type string: str or :py:class:`FortranReaderBase`
         :return: 3-tuple containing strings and instances of the classes
                  determining labeled "DO" statement (optional statement name,
                  label and loop control expression if present)
         :rtype: 3-tuple of objects
-        '''
+        """
         # do-construct-name is determined by reader
-        if string[:2].upper() != 'DO':
+        if string[:2].upper() != "DO":
             return
         line = string[2:].lstrip()
         mpat = pattern.label.match(line)
         if mpat is None:
             return
         label = mpat.group()
-        line = line[mpat.end():].lstrip()
+        line = line[mpat.end() :].lstrip()
         if line:
             return None, Label(label), Loop_Control(line)
         return None, Label(label), None
 
     def tostr(self):
-        '''
+        """
         :return: string containing Fortran code for the parsed
                  labeled "DO" statement
         :rtype: string
-        '''
+        """
         # pylint: disable=unbalanced-tuple-unpacking
         name, label, loop_control = self.items
         if name is None:
-            dostmt = 'DO %s' % (label)
+            dostmt = "DO %s" % (label)
         else:
-            dostmt = '%s: DO %s' % (label)
+            dostmt = "%s: DO %s" % (label)
         if loop_control is not None:
-            dostmt += ' %s' % (loop_control)
+            dostmt += " %s" % (loop_control)
         return dostmt
 
     def get_start_name(self):
-        '''
+        """
         :return: optional labeled "DO" statement name
         :rtype: string
-        '''
+        """
         return self.item.name
 
     def get_start_label(self):
-        '''
+        """
         :return: label of "DO" statement
         :rtype: string
-        '''
+        """
         return int(self.items[1])
 
     do_construct_name = property(lambda self: self.items[0])
     label = property(lambda self: self.items[1])
     loop_control = property(lambda self: self.items[2])
 
 
 class Nonlabel_Do_Stmt(StmtBase, WORDClsBase):  # pylint: disable=invalid-name
     """
-    R829
+    R829::
+
+        <nonlabel-do-stmt> = [ <do-construct-name> : ] DO [ <loop-control> ]
 
-    <nonlabel-do-stmt> = [ <do-construct-name> : ] DO [ <loop-control> ]
     """
+
     subclass_names = []
-    use_names = ['Do_Construct_Name', 'Loop_Control']
+    use_names = ["Do_Construct_Name", "Loop_Control"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: code line matching the nonlabeled "DO" statement
         :rtype: string
-        '''
-        return WORDClsBase.match('DO', Loop_Control, string)
+        """
+        return WORDClsBase.match("DO", Loop_Control, string)
+
+    def get_start_name(self):
+        """
+        :return: optional labeled "DO" statement name
+        :rtype: string
+        """
+        return self.item.name
 
 
 class Loop_Control(Base):  # pylint: disable=invalid-name
     """
-    R830
+    R830::
+
+        <loop-control> = [ , ] <do-variable> = scalar-int-expr,
+                                               scalar-int-expr
+                                               [ , <scalar-int-expr> ]
+                         | [ , ] WHILE ( <scalar-logical-expr> )
 
-    <loop-control> = [ , ] <do-variable> = scalar-int-expr,
-                                           scalar-int-expr
-                                           [ , <scalar-int-expr> ]
-                     | [ , ] WHILE ( <scalar-logical-expr> )
     """
+
     subclass_names = []
-    use_names = ['Do_Variable', 'Scalar_Int_Expr', 'Scalar_Logical_Expr']
+    use_names = ["Do_Variable", "Scalar_Int_Expr", "Scalar_Logical_Expr"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: 3-tuple containing strings and instances of the classes
                  determining loop control (optional comma delimiter,
                  optional scalar logical expression describing "WHILE"
                  condition or optional counter expression containing loop
                  counter and scalar integer expression)
         :rtype: 3-tuple of objects or nothing for an "infinite loop"
-        '''
+        """
         # pylint: disable=unbalanced-tuple-unpacking
         optional_delim = None
         # Match optional delimiter
-        if string.startswith(','):
+        if string.startswith(","):
             line, repmap = string_replace_map(string[1:].lstrip())
             optional_delim = ", "
         else:
             line, repmap = string_replace_map(string)
         # Match "WHILE" scalar logical expression
-        if line[:5].upper() == 'WHILE' and line[5:].lstrip().startswith('('):
+        if line[:5].upper() == "WHILE" and line[5:].lstrip().startswith("("):
             lbrak = line[5:].lstrip()
-            i = lbrak.find(')')
-            if i != -1 and i == len(lbrak)-1:
-                scalar_logical_expr = \
-                    Scalar_Logical_Expr(repmap(lbrak[1:i].strip()))
+            i = lbrak.find(")")
+            if i != -1 and i == len(lbrak) - 1:
+                scalar_logical_expr = Scalar_Logical_Expr(repmap(lbrak[1:i].strip()))
                 return scalar_logical_expr, None, optional_delim
         # Match counter expression
         # More than one '=' in counter expression
-        if line.count('=') != 1:
+        if line.count("=") != 1:
             return
-        var, rhs = line.split('=')
-        rhs = [s.strip() for s in rhs.lstrip().split(',')]
+        var, rhs = line.split("=")
+        rhs = [s.strip() for s in rhs.lstrip().split(",")]
         # Incorrect number of elements in counter expression
         if not 2 <= len(rhs) <= 3:
             return
-        counter_expr = (Variable(repmap(var.rstrip())),
-                        list(map(Scalar_Int_Expr, list(map(repmap, rhs)))))
+        counter_expr = (
+            Variable(repmap(var.rstrip())),
+            list(map(Scalar_Int_Expr, list(map(repmap, rhs)))),
+        )
         return None, counter_expr, optional_delim
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of loop control construct
         :rtype: string
-        '''
+        """
         # pylint: disable=unbalanced-tuple-unpacking
         scalar_logical_expr, counter_expr, optional_delim = self.items
         # Return loop control construct containing "WHILE" condition and
         # its <scalar-logical-expr>
         if scalar_logical_expr is not None:
-            loopctrl = 'WHILE (%s)' % scalar_logical_expr
+            loopctrl = "WHILE (%s)" % scalar_logical_expr
         # Return loop control construct containing counter expression:
         # <do-variable> as LHS and <scalar-int-expr> list as RHS
         elif counter_expr[0] is not None and counter_expr[1] is not None:
-            loopctrl = '%s = %s' % \
-                (counter_expr[0], ', '.join(map(str, counter_expr[1])))
+            loopctrl = "%s = %s" % (
+                counter_expr[0],
+                ", ".join(map(str, counter_expr[1])),
+            )
         # Add optional delimiter to loop control construct if present
         if optional_delim is not None:
             loopctrl = optional_delim + loopctrl
         return loopctrl
 
 
 class Do_Variable(Base):  # pylint: disable=invalid-name
     """
-    R831
+    R831::
+
+        <do-variable> = <scalar-int-variable>
 
-    <do-variable> = <scalar-int-variable>
     """
-    subclass_names = ['Scalar_Int_Variable']
+
+    subclass_names = ["Scalar_Int_Variable"]
 
 
 class Do_Block(BlockBase):  # pylint: disable=invalid-name
     """
-    R832
+    R832::
+
+        <do-block> = [ <execution-part-construct> ]...
 
-    <do-block> = [ <execution-part-construct> ]...
     """
-    subclass_names = ['Block']
+
+    subclass_names = ["Block"]
     subclass_names = []
-    use_names = ['Execution_Part_Construct']
+    use_names = ["Execution_Part_Construct"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: code block matching the execution part construct within
                  the "DO" block
         :rtype: string
-        '''
+        """
         return BlockBase.match(None, [Execution_Part_Construct], None, string)
 
 
 class End_Do(Base):  # pylint: disable=invalid-name
     """
-    R833
+    R833::
+
+        <end-do> = <end-do-stmt>
+                   | <continue-stmt>
 
-    <end-do> = <end-do-stmt>
-               | <continue-stmt>
     """
-    subclass_names = ['End_Do_Stmt', 'Continue_Stmt']
+
+    subclass_names = ["End_Do_Stmt", "Continue_Stmt"]
 
 
 class End_Do_Stmt(EndStmtBase):  # pylint: disable=invalid-name
     """
-    R834
+    R834::
+
+        <end-do-stmt> = END DO [ <do-construct-name> ]
 
-    <end-do-stmt> = END DO [ <do-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Do_Construct_Name']
+    use_names = ["Do_Construct_Name"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: code line matching the "END DO" statement
         :rtype: string
-        '''
-        return EndStmtBase.match('DO', Do_Construct_Name, string,
-                                 require_stmt_type=True)
+        """
+        return EndStmtBase.match(
+            "DO", Do_Construct_Name, string, require_stmt_type=True
+        )
 
 
 class Nonblock_Do_Construct(Base):  # pylint: disable=invalid-name
     """
-    R835
+    R835::
+
+        <nonblock-do-stmt> = <action-term-do-construct>
+                             | <outer-shared-do-construct>
 
-    <nonblock-do-stmt> = <action-term-do-construct>
-                         | <outer-shared-do-construct>
     """
-    subclass_names = ['Action_Term_Do_Construct', 'Outer_Shared_Do_Construct']
+
+    subclass_names = ["Action_Term_Do_Construct", "Outer_Shared_Do_Construct"]
 
 
 class Action_Term_Do_Construct(BlockBase):  # R836
     """
-::
-    <action-term-do-construct> = <label-do-stmt>
-                                     <do-body>
+    ::
+
+        <action-term-do-construct> = <label-do-stmt>
+                                         <do-body>
+                                         <do-term-action-stmt>
+
+        <action-term-do-construct> = <label-do-stmt>
+                                     [ <execution-part-construct> ]...
                                      <do-term-action-stmt>
 
-::
-    <action-term-do-construct> = <label-do-stmt>
-                                 [ <execution-part-construct> ]...
-                                 <do-term-action-stmt>
     """
+
     subclass_names = []
-    use_names = ['Label_Do_Stmt', 'Execution_Part_Construct',
-                 'Do_Term_Action_Stmt']
+    use_names = ["Label_Do_Stmt", "Execution_Part_Construct", "Do_Term_Action_Stmt"]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Label_Do_Stmt, [Execution_Part_Construct],
-                               Do_Term_Action_Stmt, reader,
-                               match_labels=True,
-                               enable_do_label_construct_hook=True)
+        return BlockBase.match(
+            Label_Do_Stmt,
+            [Execution_Part_Construct],
+            Do_Term_Action_Stmt,
+            reader,
+            match_labels=True,
+            enable_do_label_construct_hook=True,
+        )
+
+    def tofortran(self, tab="", isfix=None):
+        """
+        Converts this node (and all children) into Fortran.
+
+        :param str tab: white space to prefix to output.
+        :param bool isfix: whether or not to generate fixed-format output.
 
-    def tofortran(self, tab='', isfix=None):
+        :returns: Fortran code.
+        :rtype: str
+
+        """
         line = []
         start = self.content[0]
         end = self.content[-1]
-        extra_tab = '  '
+        extra_tab = "  "
         line.append(start.tofortran(tab=tab, isfix=isfix))
         for item in self.content[1:-1]:
-            line.append(item.tofortran(tab=tab+extra_tab, isfix=isfix))
+            line.append(item.tofortran(tab=tab + extra_tab, isfix=isfix))
             if isinstance(item, Label_Do_Stmt):
-                extra_tab += '  '
+                extra_tab += "  "
         if len(self.content) > 1:
             line.append(end.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(line)
+        return "\n".join(line)
 
 
 class Do_Body(BlockBase):  # R837
     """
     <do-body> = [ <execution-part-construct> ]...
     """
+
     subclass_names = []
-    use_names = ['Execution_Part_Construct']
+    use_names = ["Execution_Part_Construct"]
 
+    @staticmethod
     def match(string):
-        return BlockBase.match(None, [Execution_Part_Construct],
-                               None, string)
-    match = staticmethod(match)
+        return BlockBase.match(None, [Execution_Part_Construct], None, string)
 
 
 class Do_Term_Action_Stmt(StmtBase):  # R838
     """
-::
-    <do-term-action-stmt> = <action-stmt>
+    ::
+
+        <do-term-action-stmt> = <action-stmt>
+
+    Notes::
+
+        C824 - <do-term-action-stmt> shall not be <continue-stmt>, <goto-stmt>,
+              <return-stmt>, <stop-stmt>, <exit-stmt>, <cycle-stmt>,
+              <end-function-stmt>, <end-subroutine-stmt>, <end-program-stmt>,
+              <arithmetic-if-stmt>
 
-Notes
------
-C824: <do-term-action-stmt> shall not be <continue-stmt>, <goto-stmt>,
-      <return-stmt>, <stop-stmt>, <exit-stmt>, <cycle-stmt>,
-      <end-function-stmt>, <end-subroutine-stmt>, <end-program-stmt>,
-      <arithmetic-if-stmt>
     """
-    subclass_names = ['Action_Stmt_C824']
+
+    subclass_names = ["Action_Stmt_C824"]
 
 
 class Outer_Shared_Do_Construct(BlockBase):  # R839
     """
-    <outer-shared-do-construct> = <label-do-stmt>
-                                      <do-body>
-                                      <shared-term-do-construct>
+    ::
+
+        <outer-shared-do-construct> = <label-do-stmt>
+                                          <do-body>
+                                          <shared-term-do-construct>
+
     """
+
     subclass_names = []
-    use_names = ['Label_Do_Stmt', 'Do_Body', 'Shared_Term_Do_Construct']
+    use_names = ["Label_Do_Stmt", "Do_Body", "Shared_Term_Do_Construct"]
 
+    @staticmethod
     def match(reader):
         content = []
         for cls in [Label_Do_Stmt, Do_Body, Shared_Term_Do_Construct]:
             obj = cls(reader)
             if obj is None:  # todo: restore reader
                 return
             content.append(obj)
-        return content,
-    match = staticmethod(match)
+        return (content,)
 
 
 class Shared_Term_Do_Construct(Base):  # R840
     """
-    <shared-term-do-construct> = <outer-shared-do-construct>
-                                 | <inner-shared-do-construct>
+    ::
+
+        <shared-term-do-construct> = <outer-shared-do-construct>
+                                     | <inner-shared-do-construct>
+
     """
-    subclass_names = ['Outer_Shared_Do_Construct', 'Inner_Shared_Do_Construct']
+
+    subclass_names = ["Outer_Shared_Do_Construct", "Inner_Shared_Do_Construct"]
 
 
 class Inner_Shared_Do_Construct(BlockBase):  # R841
     """
-    <inner-shared-do-construct> = <label-do-stmt>
-                                      <do-body>
-                                      <do-term-shared-stmt>
+    ::
+
+        <inner-shared-do-construct> = <label-do-stmt>
+                                          <do-body>
+                                          <do-term-shared-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Label_Do_Stmt', 'Do_Body', 'Do_Term_Shared_Stmt']
+    use_names = ["Label_Do_Stmt", "Do_Body", "Do_Term_Shared_Stmt"]
 
+    @staticmethod
     def match(reader):
         content = []
         for cls in [Label_Do_Stmt, Do_Body, Do_Term_Shared_Stmt]:
             obj = cls(reader)
             if obj is None:  # todo: restore reader
                 return
             content.append(obj)
-        return content,
-    match = staticmethod(match)
+        return (content,)
 
 
 class Do_Term_Shared_Stmt(StmtBase):  # R842
     """
-    <do-term-shared-stmt> = <action-stmt>
-    C826: see C824 above.
+    ::
+
+        <do-term-shared-stmt> = <action-stmt>
+
+    C826 - see C824 above.
     """
-    subclass_names = ['Action_Stmt']
+
+    subclass_names = ["Action_Stmt"]
 
 
 class Cycle_Stmt(StmtBase, WORDClsBase):  # R843
     """
     <cycle-stmt> = CYCLE [ <do-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Do_Construct_Name']
+    use_names = ["Do_Construct_Name"]
 
+    @staticmethod
     def match(string):
-        return WORDClsBase.match('CYCLE', Do_Construct_Name, string)
-    match = staticmethod(match)
+        return WORDClsBase.match("CYCLE", Do_Construct_Name, string)
 
 
 class Exit_Stmt(StmtBase, WORDClsBase):  # R844
     """
     <exit-stmt> = EXIT [ <do-construct-name> ]
     """
+
     subclass_names = []
-    use_names = ['Do_Construct_Name']
+    use_names = ["Do_Construct_Name"]
 
+    @staticmethod
     def match(string):
-        return WORDClsBase.match('EXIT', Do_Construct_Name, string)
-    match = staticmethod(match)
+        return WORDClsBase.match("EXIT", Do_Construct_Name, string)
 
 
 class Goto_Stmt(StmtBase):  # R845
     """
     <goto-stmt> = GO TO <label>
     """
+
     subclass_names = []
-    use_names = ['Label']
+    use_names = ["Label"]
 
+    @staticmethod
     def match(string):
-        if string[:2].upper() != 'GO':
+        if string[:2].upper() != "GO":
             return
         line = string[2:].lstrip()
-        if line[:2].upper() != 'TO':
+        if line[:2].upper() != "TO":
             return
-        return Label(line[2:].lstrip()),
-    match = staticmethod(match)
+        return (Label(line[2:].lstrip()),)
 
     def tostr(self):
-        return 'GO TO %s' % (self.items[0])
+        return "GO TO %s" % (self.items[0])
 
 
 class Computed_Goto_Stmt(StmtBase):  # R846
     """
     <computed-goto-stmt> = GO TO ( <label-list> ) [ , ] <scalar-int-expr>
     """
+
     subclass_names = []
-    use_names = ['Label_List', 'Scalar_Int_Expr']
+    use_names = ["Label_List", "Scalar_Int_Expr"]
 
+    @staticmethod
     def match(string):
-        if string[:2].upper() != 'GO':
+        if string[:2].upper() != "GO":
             return
         line = string[2:].lstrip()
-        if line[:2].upper() != 'TO':
+        if line[:2].upper() != "TO":
             return
         line = line[2:].lstrip()
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         lst = line[1:i].strip()
         if not lst:
             return
-        line = line[i+1:].lstrip()
-        if line.startswith(','):
+        line = line[i + 1 :].lstrip()
+        if line.startswith(","):
             line = line[1:].lstrip()
         if not line:
             return
         return Label_List(lst), Scalar_Int_Expr(line)
-    match = staticmethod(match)
 
     def tostr(self):
-        return 'GO TO (%s), %s' % self.items
+        return "GO TO (%s), %s" % self.items
 
 
 class Arithmetic_If_Stmt(StmtBase):  # R847
     """
-    <arithmetic-if-stmt> = IF ( <scalar-numeric-expr> ) <label> ,
-        <label> , <label>
+    ::
+
+        <arithmetic-if-stmt> = IF ( <scalar-numeric-expr> ) <label> ,
+            <label> , <label>
+
     """
+
     subclass_names = []
-    use_names = ['Scalar_Numeric_Expr', 'Label']
+    use_names = ["Scalar_Numeric_Expr", "Label"]
 
+    @staticmethod
     def match(string):
-        if string[:2].upper() != 'IF':
+        if string[:2].upper() != "IF":
             return
         line = string[2:].lstrip()
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        i = line.rfind(')')
+        i = line.rfind(")")
         if i == -1:
             return
-        labels = line[i+1:].lstrip().split(',')
+        labels = line[i + 1 :].lstrip().split(",")
         if len(labels) != 3:
             return
         labels = [Label(l.strip()) for l in labels]
         return (Scalar_Numeric_Expr(line[1:i].strip()),) + tuple(labels)
-    match = staticmethod(match)
 
     def tostr(self):
-        return 'IF (%s) %s, %s, %s' % self.items
+        return "IF (%s) %s, %s, %s" % self.items
 
 
 class Continue_Stmt(StmtBase, STRINGBase):  # R848
     """
     <continue-stmt> = CONTINUE
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match('CONTINUE', string)
-    match = staticmethod(match)
+        return STRINGBase.match("CONTINUE", string)
 
     def get_end_label(self):
         return self.item.label
 
 
 class Stop_Stmt(StmtBase, WORDClsBase):  # R849
     """
     <stop-stmt> = STOP [ <stop-code> ]
     """
+
     subclass_names = []
-    use_names = ['Stop_Code']
+    use_names = ["Stop_Code"]
 
+    @staticmethod
     def match(string):
-        return WORDClsBase.match('STOP', Stop_Code, string)
-    match = staticmethod(match)
+        return WORDClsBase.match("STOP", Stop_Code, string)
 
 
 class Stop_Code(StringBase):  # R850
     """
-    <stop-code> = <scalar-char-constant>
-                  | <digit> [ <digit> [ <digit> [ <digit> [ <digit> ] ] ] ]
+    ::
+
+        <stop-code> = <scalar-char-constant>
+                      | <digit> [ <digit> [ <digit> [ <digit> [ <digit> ] ] ] ]
+
     """
-    subclass_names = ['Scalar_Char_Constant']
 
+    subclass_names = ["Scalar_Char_Constant"]
+
+    @staticmethod
     def match(string):
         return StringBase.match(pattern.abs_label, string)
-    match = staticmethod(match)
+
 
 #
 # SECTION  9
 #
 
 
 class Io_Unit(StringBase):  # R901
     """
-    <io-unit> = <file-unit-number>
-                | *
-                | <internal-file-variable>
+    ::
+
+        <io-unit> = <file-unit-number>
+                    | *
+                    | <internal-file-variable>
+
     """
-    subclass_names = ['File_Unit_Number', 'Internal_File_Variable']
 
+    subclass_names = ["File_Unit_Number", "Internal_File_Variable"]
+
+    @staticmethod
     def match(string):
-        return StringBase.match('*', string)
-    match = staticmethod(match)
+        return StringBase.match("*", string)
 
 
 class File_Unit_Number(Base):  # R902
     """
     <file-unit-number> = <scalar-int-expr>
     """
-    subclass_names = ['Scalar_Int_Expr']
+
+    subclass_names = ["Scalar_Int_Expr"]
 
 
 class Internal_File_Variable(Base):  # R903
     """
-    <internal-file-variable> = <char-variable>
-    C901: <char-variable> shall not be an array section with a
-        vector subscript.
+    ::
+
+        <internal-file-variable> = <char-variable>
+
+    C901 -  <char-variable> shall not be an array section with a
+    vector subscript.
+
     """
-    subclass_names = ['Char_Variable']
+
+    subclass_names = ["Char_Variable"]
 
 
 class Open_Stmt(StmtBase, CALLBase):  # R904
     """
     <open-stmt> = OPEN ( <connect-spec-list> )
     """
+
     subclass_names = []
-    use_names = ['Connect_Spec_List']
+    use_names = ["Connect_Spec_List"]
 
     @staticmethod
     def match(string):
         # The Connect_Spec_List class is generated automatically
         # by code at the end of this module
-        return CALLBase.match('OPEN', Connect_Spec_List, string,
-                              require_rhs=True)
+        return CALLBase.match("OPEN", Connect_Spec_List, string, require_rhs=True)
 
 
 class Connect_Spec(KeywordValueBase):
     """
-    R905
-    <connect-spec> = [ UNIT = ] <file-unit-number>
-                     | ACCESS = <scalar-default-char-expr>
-                     | ACTION = <scalar-default-char-expr>
-                     | ASYNCHRONOUS = <scalar-default-char-expr>
-                     | BLANK = <scalar-default-char-expr>
-                     | DECIMAL = <scalar-default-char-expr>
-                     | DELIM = <scalar-default-char-expr>
-                     | ENCODING = <scalar-default-char-expr>
-                     | ERR = <label>
-                     | FILE = <file-name-expr>
-                     | FORM = <scalar-default-char-expr>
-                     | IOMSG = <iomsg-variable>
-                     | IOSTAT = <scalar-int-variable>
-                     | PAD = <scalar-default-char-expr>
-                     | POSITION = <scalar-default-char-expr>
-                     | RECL = <scalar-int-expr>
-                     | ROUND = <scalar-default-char-expr>
-                     | SIGN = <scalar-default-char-expr>
-                     | STATUS = <scalar-default-char-expr>
-    """
-    subclass_names = []
-    use_names = ['File_Unit_Number', 'Scalar_Default_Char_Expr', 'Label',
-                 'File_Name_Expr', 'Iomsg_Variable',
-                 'Scalar_Int_Expr', 'Scalar_Int_Variable']
+    R905::
+
+        <connect-spec> = [ UNIT = ] <file-unit-number>
+                         | ACCESS = <scalar-default-char-expr>
+                         | ACTION = <scalar-default-char-expr>
+                         | ASYNCHRONOUS = <scalar-default-char-expr>
+                         | BLANK = <scalar-default-char-expr>
+                         | DECIMAL = <scalar-default-char-expr>
+                         | DELIM = <scalar-default-char-expr>
+                         | ENCODING = <scalar-default-char-expr>
+                         | ERR = <label>
+                         | FILE = <file-name-expr>
+                         | FORM = <scalar-default-char-expr>
+                         | IOMSG = <iomsg-variable>
+                         | IOSTAT = <scalar-int-variable>
+                         | PAD = <scalar-default-char-expr>
+                         | POSITION = <scalar-default-char-expr>
+                         | RECL = <scalar-int-expr>
+                         | ROUND = <scalar-default-char-expr>
+                         | SIGN = <scalar-default-char-expr>
+                         | STATUS = <scalar-default-char-expr>
+
+    """
+
+    subclass_names = []
+    use_names = [
+        "File_Unit_Number",
+        "Scalar_Default_Char_Expr",
+        "Label",
+        "File_Name_Expr",
+        "Iomsg_Variable",
+        "Scalar_Int_Expr",
+        "Scalar_Int_Variable",
+    ]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: 2-tuple containing the keyword and value or None if the
                  supplied string is not a match
         :rtype: 2-tuple containing keyword (e.g. "UNIT") and associated value
-        '''
+        """
         if "=" not in string:
             # The only argument which need not be named is the unit number
-            return 'UNIT', File_Unit_Number(string)
+            return "UNIT", File_Unit_Number(string)
         # We have a keyword-value pair. Check whether it is valid...
-        for (keyword, value) in [
-                (['ACCESS', 'ACTION', 'ASYNCHRONOUS', 'BLANK', 'DECIMAL',
-                  'DELIM', 'ENCODING', 'FORM', 'PAD', 'POSITION', 'ROUND',
-                  'SIGN', 'STATUS'], Scalar_Default_Char_Expr),
-                ('ERR', Label),
-                ('FILE', File_Name_Expr),
-                ('IOSTAT', Scalar_Int_Variable),
-                ('IOMSG', Iomsg_Variable),
-                ('RECL', Scalar_Int_Expr),
-                ('UNIT', File_Unit_Number)]:
+        for keyword, value in [
+            (
+                [
+                    "ACCESS",
+                    "ACTION",
+                    "ASYNCHRONOUS",
+                    "BLANK",
+                    "DECIMAL",
+                    "DELIM",
+                    "ENCODING",
+                    "FORM",
+                    "PAD",
+                    "POSITION",
+                    "ROUND",
+                    "SIGN",
+                    "STATUS",
+                ],
+                Scalar_Default_Char_Expr,
+            ),
+            ("ERR", Label),
+            ("FILE", File_Name_Expr),
+            ("IOSTAT", Scalar_Int_Variable),
+            ("IOMSG", Iomsg_Variable),
+            ("RECL", Scalar_Int_Expr),
+            ("UNIT", File_Unit_Number),
+        ]:
             try:
-                obj = KeywordValueBase.match(keyword, value, string,
-                                             upper_lhs=True)
+                obj = KeywordValueBase.match(keyword, value, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
         return None
 
 
 class File_Name_Expr(Base):  # R906
     """
     <file-name-expr> = <scalar-default-char-expr>
     """
-    subclass_names = ['Scalar_Default_Char_Expr']
+
+    subclass_names = ["Scalar_Default_Char_Expr"]
 
 
 class Iomsg_Variable(Base):  # R907
     """
     <iomsg-variable> = <scalar-default-char-variable>
     """
-    subclass_names = ['Scalar_Default_Char_Variable']
+
+    subclass_names = ["Scalar_Default_Char_Variable"]
 
 
 class Close_Stmt(StmtBase, CALLBase):  # R908
     """
     <close-stmt> = CLOSE ( <close-spec-list> )
     """
+
     subclass_names = []
-    use_names = ['Close_Spec_List']
+    use_names = ["Close_Spec_List"]
 
+    @staticmethod
     def match(string):
-        return CALLBase.match('CLOSE', Close_Spec_List, string,
-                              require_rhs=True)
-    match = staticmethod(match)
+        return CALLBase.match("CLOSE", Close_Spec_List, string, require_rhs=True)
 
 
 class Close_Spec(KeywordValueBase):  # R909
     """
-    <close-spec> = [ UNIT = ] <file-unit-number>
-                   | IOSTAT = <scalar-int-variable>
-                   | IOMSG = <iomsg-variable>
-                   | ERR = <label>
-                   | STATUS = <scalar-default-char-expr>
-    """
-    subclass_names = []
-    use_names = ['File_Unit_Number', 'Scalar_Default_Char_Expr',
-                 'Label', 'Iomsg_Variable',
-                 'Scalar_Int_Variable']
-
-    def match(string):
-        for (k, v) in [
-                ('ERR', Label),
-                ('IOSTAT', Scalar_Int_Variable),
-                ('IOMSG', Iomsg_Variable),
-                ('STATUS', Scalar_Default_Char_Expr),
-                ('UNIT', File_Unit_Number), ]:
+    ::
+
+        <close-spec> = [ UNIT = ] <file-unit-number>
+                       | IOSTAT = <scalar-int-variable>
+                       | IOMSG = <iomsg-variable>
+                       | ERR = <label>
+                       | STATUS = <scalar-default-char-expr>
+
+    """
+
+    subclass_names = []
+    use_names = [
+        "File_Unit_Number",
+        "Scalar_Default_Char_Expr",
+        "Label",
+        "Iomsg_Variable",
+        "Scalar_Int_Variable",
+    ]
+
+    @staticmethod
+    def match(string):
+        for k, v in [
+            ("ERR", Label),
+            ("IOSTAT", Scalar_Int_Variable),
+            ("IOMSG", Iomsg_Variable),
+            ("STATUS", Scalar_Default_Char_Expr),
+            ("UNIT", File_Unit_Number),
+        ]:
             try:
                 obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return 'UNIT', File_Unit_Number(string)
-    match = staticmethod(match)
+        return "UNIT", File_Unit_Number(string)
 
 
 class Read_Stmt(StmtBase):  # R910
     """
-:F03R:`910`::
-    <read-stmt> = READ ( <io-control-spec-list> ) [ <input-item-list> ]
-                    | READ <format> [ , <input-item-list> ]
+    Fortran2003 Rule R910::
+
+        <read-stmt> = READ ( <io-control-spec-list> ) [ <input-item-list> ]
+                        | READ <format> [ , <input-item-list> ]
+
+    Attributes::
+
+        items : (Io_Control_Spec_List, Format, Input_Item_List)
 
-Attributes
-----------
-items : (Io_Control_Spec_List, Format, Input_Item_List)
     """
+
     subclass_names = []
-    use_names = ['Io_Control_Spec_List', 'Input_Item_List', 'Format']
+    use_names = ["Io_Control_Spec_List", "Input_Item_List", "Format"]
 
     @staticmethod
     def match(string):
-        if string[:4].upper() != 'READ':
+        if string[:4].upper() != "READ":
             return
         line = string[4:].lstrip()
-        if line.startswith('('):
+        if line.startswith("("):
             line, repmap = string_replace_map(line)
-            idx = line.find(')')
+            idx = line.find(")")
             if idx == -1:
                 return
             trimline = line[1:idx].strip()
             if not trimline:
                 return
             if idx == len(line) - 1:
                 return Io_Control_Spec_List(repmap(trimline)), None, None
-            return Io_Control_Spec_List(repmap(trimline)), None, \
-                Input_Item_List(repmap(line[idx+1:].lstrip()))
+            return (
+                Io_Control_Spec_List(repmap(trimline)),
+                None,
+                Input_Item_List(repmap(line[idx + 1 :].lstrip())),
+            )
         if not line:
             return
         char = line[0].upper()
         # No parentheses therefore first argument must be a format
         # specifier (either a string or a line/label number
-        if 'A' <= char <= 'Z' or char == '_':
+        if "A" <= char <= "Z" or char == "_":
             return
         line, repmap = string_replace_map(line.lstrip())
         # There must be a comma betwee the format specifier and the following
         # list of values/variables
-        idx = line.find(',')
+        idx = line.find(",")
         if idx == -1:
             return None
-        trimline = repmap(line[idx+1:].lstrip())
+        trimline = repmap(line[idx + 1 :].lstrip())
         if not trimline:
             return
-        return (None, Format(repmap(line[:idx].rstrip())),
-                Output_Item_List(trimline))
+        return (None, Format(repmap(line[:idx].rstrip())), Output_Item_List(trimline))
 
     def tostr(self):
         if self.items[0] is not None:
             assert self.items[1] is None, repr(self.items)
             if self.items[2] is None:
-                return 'READ(%s)' % (self.items[0])
-            return 'READ(%s) %s' % (self.items[0], self.items[2])
+                return "READ(%s)" % (self.items[0])
+            return "READ(%s) %s" % (self.items[0], self.items[2])
         assert self.items[1] is not None, repr(self.items)
         if self.items[2] is None:
-            return 'READ %s' % (self.items[1])
-        return 'READ %s, %s' % (self.items[1], self.items[2])
+            return "READ %s" % (self.items[1])
+        return "READ %s, %s" % (self.items[1], self.items[2])
 
 
 class Write_Stmt(StmtBase):  # pylint: disable=invalid-name
-    '''
-    :F03R:`911`::
+    """
+    Fortran 2003 rule R911.
+
+    Specifies the syntax of a "WRITE" statement::
+
+        write-stmt is WRITE ( io-control-spec-list ) [ output-item-list ]
 
-    Fortran 2003 rule R911
-    that specifies syntax of a "WRITE" statement.
+    """
 
-    <write-stmt> = WRITE ( <io-control-spec-list> ) [ <output-item-list> ]
-    '''
     subclass_names = []
-    use_names = ['Io_Control_Spec_List', 'Output_Item_List']
+    use_names = ["Io_Control_Spec_List", "Output_Item_List"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: 2-tuple containing strings and instances of the classes
                  describing "WRITE" statement (mandatory IO control
                  specification list and optional output item list.
         :rtype: 2-tuple of objects (1 mandatory and 1 optional)
-        '''
-        if string[:5].upper() != 'WRITE':
+        """
+        if string[:5].upper() != "WRITE":
             return
         line = string[5:].lstrip()
         # Look for mandatory IO control specification list and
         # return without a match if it is not found
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
         line, repmap = string_replace_map(line)
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         tmp = line[1:i].strip()
         if not tmp:
             return
         tmp = repmap(tmp)
-        if i == len(line)-1:
+        if i == len(line) - 1:
             return Io_Control_Spec_List(tmp), None
         # Return optional output item list as well
-        return Io_Control_Spec_List(tmp), \
-            Output_Item_List(repmap(line[i+1:].lstrip()))
+        return (
+            Io_Control_Spec_List(tmp),
+            Output_Item_List(repmap(line[i + 1 :].lstrip())),
+        )
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of a "WRITE" statement
         :rtype: str
-        '''
+        """
         if self.items[1] is None:
-            return 'WRITE(%s)' % (self.items[0])
-        return 'WRITE(%s) %s' % tuple(self.items)
+            return "WRITE(%s)" % (self.items[0])
+        return "WRITE(%s) %s" % tuple(self.items)
 
 
 class Print_Stmt(StmtBase):  # R912
     """
-:F03R:`912`::
-    <print-stmt> = PRINT <format> [ , <output-item-list> ]
+    Fortran2003 Rule R912::
+
+        <print-stmt> = PRINT <format> [ , <output-item-list> ]
+
+    Parameters::
+
+        items : (Format, Output_Item_List)
 
-Parameters
-----------
-items : (Format, Output_Item_List)
     """
+
     subclass_names = []
-    use_names = ['Format', 'Output_Item_List']
+    use_names = ["Format", "Output_Item_List"]
 
+    @staticmethod
     def match(string):
-        if string[:5].upper() != 'PRINT':
+        if string[:5].upper() != "PRINT":
             return
         line = string[5:]
         if not line:
             return
         c = line[0].upper()
-        if 'A' <= c <= 'Z' or c == '_' or '0' <= c <= '9':
+        if "A" <= c <= "Z" or c == "_" or "0" <= c <= "9":
             return
         line, repmap = string_replace_map(line.lstrip())
-        i = line.find(',')
+        i = line.find(",")
         if i == -1:
             return Format(repmap(line)), None
-        tmp = repmap(line[i+1:].lstrip())
+        tmp = repmap(line[i + 1 :].lstrip())
         if not tmp:
             return
         return Format(repmap(line[:i].rstrip())), Output_Item_List(tmp)
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[1] is None:
-            return 'PRINT %s' % (self.items[0])
-        return 'PRINT %s, %s' % tuple(self.items)
+            return "PRINT %s" % (self.items[0])
+        return "PRINT %s, %s" % tuple(self.items)
 
 
-class Io_Control_Spec_List(SequenceBase):  # R913-list
+class Io_Control_Spec_List(SequenceBase):
     """
-    <io-control-spec-list> is a list taking into account C910, C917, C918
+    Rule 913 - Control information list::
+
+        io-control-spec-list is a list of io-control-spec items.
+
+    Subject to the following constraints::
+
+        C909 No specifier shall appear more than once in a given
+             io-control-spec-list.
+        C910 An io-unit shall be specified; if the optional characters UNIT= are
+             omitted, the io-unit shall be the first item in the
+             io-control-spec-list.
+        C911 A DELIM= or SIGN= specifier shall not appear in a read-stmt.
+        C912 A BLANK=, PAD=, END=, EOR=, or SIZE=specifier shall not appear in a
+             write-stmt.
+        C913 The label in the ERR=, EOR=, or END= specifier shall be the statement
+             label of a branch target statement that appears in the same scoping
+             unit as the data transfer statement.
+        C914 A namelist-group-name shall be the name of a namelist group.
+        C915 A namelist-group-name shall not appear if an input-item-list or an
+             output-item-list appears in the data transfer statement.
+        C916 An io-control-spec-list shall not contain both a format and a
+             namelist-group-name.
+        C917 If format appears without a preceding FMT=, it shall be the second
+             item in the iocontrol-spec-list and the first item shall be io-unit.
+        C918 If namelist-group-name appears without a preceding NML=, it shall be
+             the second item in the io-control-spec-list and the first item shall
+             be io-unit.
+        C919 If io-unit is not a file-unit-number, the io-control-spec-list shall
+             not contain a REC= specifier or a POS= specifier.
+        C920 If the REC= specifier appears, an END= specifier shall not appear, a
+             namelist-groupname shall not appear, and the format, if any, shall not
+             be an asterisk.
+        C921 An ADVANCE= specifier may appear only in a formatted sequential or
+             stream input/output statement with explicit format specification
+             (10.1) whose control information list does not contain an
+             internal-file-variable as the io-unit.
+        C922 If an EOR= specifier appears, an ADVANCE= specifier also shall appear.
+        C923 If a SIZE= specifier appears, an ADVANCE= specifier also shall appear.
+        C924 The scalar-char-initialization-expr in an ASYNCHRONOUS= specifier
+             shall be of type default character and shall have the value YES or NO.
+        C925 An ASYNCHRONOUS= specifier with a value YES shall not appear unless
+             io-unit is a file-unit-number.
+        C926 If an ID= specifier appears, an ASYNCHRONOUS= specifier with the value
+             YES shall also appear.
+        C927 If a POS= specifier appears, the io-control-spec-list shall not
+             contain a REC= specifier.
+        C928 If a DECIMAL=, BLANK=, PAD=, SIGN=, or ROUND= specifier appears, a
+             format or namelist-group-name shall also appear.
+        C929 If a DELIM= specifier appears, either format shall be an asterisk or
+             namelist-group-name shall appear.
+
+    TODO #267. Of these constraints, only C910 & C916-918 are currently
+    enforced.
+
     """
+
     subclass_names = []
-    use_names = ['Io_Control_Spec']
+    use_names = ["Io_Control_Spec", "Namelist_Group_Name", "Format"]
 
     @staticmethod
     def match(string):
+        """
+        Attempts to match the supplied string with a list of Io_Control_Spec
+        items. We have to override the base implementation because the first
+        two items in the list have specific meanings if they are not explictly
+        named: the first must be the unit number and the second may be either
+        a format specifier *or* a namelist-group-name.
+
+        :param str string: the string that is checked for a match.
+
+        :returns: a tuple of Io_Control_Spec objects if the match is \
+                  successful, None otherwise.
+        :rtype: tuple of :py:class:`fparser.two.Fortran2003.Io_Control_Spec` \
+                objects or NoneType
+
+        """
         line, repmap = string_replace_map(string)
-        splitted = line.split(',')
+        splitted = line.split(",")
         lst = []
-        unit_is_positional = False
-        for idx in range(len(splitted)):
-            spec = splitted[idx].strip()
-            spec = repmap(spec)
-            if idx == 0 and "=" not in spec:
-                # Must be a unit number. However, we do not prepend "UNIT="
-                # to it in case the following Io_Control_Spec is positional
-                # (and therefore either a Format or Namelist spec).
-                lst.append(Io_Control_Spec(spec))
-                unit_is_positional = True
-            elif idx == 1 and "=" not in spec:
-                if not unit_is_positional:
-                    # Cannot have a positional argument following a
-                    # named argument
-                    return
-                # Without knowing the type of the variable named in spec
-                # we have no way of knowing whether this is a format or
-                # a namelist specifier. However, if it is a character
-                # constant or "*" then it must be a Format spec and we can
-                # prepend "FMT=" to it.
-                spec = spec.lstrip().rstrip()
-                if Char_Literal_Constant.match(spec) or \
-                   StringBase.match("*", spec):
-                    spec = "FMT={0}".format(spec)
-                lst.append(Io_Control_Spec(spec))
-            else:
+
+        # Examine the first entry in the list. If it is not named then it must
+        # be a unit number (C910).
+        have_unit = False
+        have_unnamed_nml_or_fmt = False
+        spec = splitted.pop(0).strip()
+        spec = repmap(spec)
+
+        try:
+            try:
+                Io_Unit(spec)
+                # We matched an unamed unit number. We now need to construct an
+                # Io_Control_Spec for it. In order to do so we have to
+                # temporarily name it so that Io_Control_Spec matches it.
+                io_spec = Io_Control_Spec("unit=" + spec)
+                # Remove the name from the new object
+                io_spec.items = (None, io_spec.items[1])
+                lst.append(io_spec)
+                # Record that we have found a unit number for the purpose of
+                # performing validation checks.
+                have_unit = True
+
+                if not splitted:
+                    # The list only has one entry and it is an IO unit
+                    return ",", tuple(lst)
+
+                # Since the unit-number was not named, the following item may
+                # also not be named if it is a format specifier or namelist
+                # group name.
+                spec = splitted.pop(0).strip()
+                spec = repmap(spec)
+                for cls, name in [(Namelist_Group_Name, "nml"), (Format, "fmt")]:
+                    try:
+                        if cls(spec):
+                            # We have a match on an un-named entry. We
+                            # temporarily add the name so that Io_Control_Spec
+                            # matches the correct one.
+                            io_spec = Io_Control_Spec(name + "=" + spec)
+                            # Remove the name from the new object
+                            io_spec.items = (None, io_spec.items[1])
+                            lst.append(io_spec)
+                            have_unnamed_nml_or_fmt = True
+                            break
+                    except NoMatchError:
+                        pass
+                else:
+                    raise NoMatchError("Not an un-named nml-group-name or fmt")
+
+            except NoMatchError:
+                # If we get here we failed to match an un-named spec so from
+                # here on, they must all be named.
                 lst.append(Io_Control_Spec(spec))
-        return ',', tuple(lst)
 
+            # Deal with the remainder of the list entries. These must all be
+            # named.
+            for spec in splitted:
+                mapped_spec = repmap(spec.strip())
+                lst.append(Io_Control_Spec(mapped_spec))
 
-class Io_Control_Spec(KeywordValueBase):  # R913
-    """
-    <io-control-spec> = [ UNIT = ] <io-unit>
-                        | [ FMT = ] <format>
-                        | [ NML = ] <namelist-group-name>
-                        | ADVANCE = <scalar-default-char-expr>
-                        | ASYNCHRONOUS = <scalar-char-initialization-expr>
-                        | BLANK = <scalar-default-char-expr>
-                        | DECIMAL = <scalar-default-char-expr>
-                        | DELIM = <scalar-default-char-expr>
-                        | END = <label>
-                        | EOR = <label>
-                        | ERR = <label>
-                        | ID = <scalar-int-variable>
-                        | IOMSG = <iomsg-variable>
-                        | IOSTAT = <scalar-int-variable>
-                        | PAD = <scalar-default-char-expr>
-                        | POS = <scalar-int-expr>
-                        | REC = <scalar-int-expr>
-                        | ROUND = <scalar-default-char-expr>
-                        | SIGN = <scalar-default-char-expr>
-                        | SIZE = <scalar-int-variable>
-    """
-    subclass_names = []
-    use_names = ['Io_Unit', 'Format', 'Namelist_Group_Name',
-                 'Scalar_Default_Char_Expr',
-                 'Scalar_Char_Initialization_Expr', 'Label',
-                 'Scalar_Int_Variable',
-                 'Iomsg_Variable', 'Scalar_Int_Expr']
+        except NoMatchError:
+            return None
+
+        # At this point we need to check the list and apply constraints.
+        # TODO #267 enforce remaining constraints.
+        have_nml = False
+        have_fmt = False
+        for spec in lst:
+            if spec.children[0] == "UNIT":
+                have_unit = True
+            elif spec.children[0] == "NML":
+                have_nml = True
+            elif spec.children[0] == "FMT":
+                have_fmt = True
+        # C910: An io-unit shall be specified
+        if not have_unit:
+            return None
+        # C916: an io-control-spec-list shall not contain both a format
+        # and a namelist-group-name
+        if have_nml and have_fmt:
+            return None
+        if have_unnamed_nml_or_fmt and (have_nml or have_fmt):
+            return None
+
+        return ",", tuple(lst)
+
+
+class Io_Control_Spec(KeywordValueBase):
+    """
+    This class implements *partial* support for Rule 913::
+
+        <io-control-spec> is  [UNIT = ] <io-unit>
+                            | [ FMT = ] <format>
+                            | [ NML = ] <namelist-group-name>
+                            | ADVANCE = <scalar-default-char-expr>
+                            | ASYNCHRONOUS = <scalar-char-initialization-expr>
+                            | BLANK = <scalar-default-char-expr>
+                            | DECIMAL = <scalar-default-char-expr>
+                            | DELIM = <scalar-default-char-expr>
+                            | END = <label>
+                            | EOR = <label>
+                            | ERR = <label>
+                            | ID = <scalar-int-variable>
+                            | IOMSG = <iomsg-variable>
+                            | IOSTAT = <scalar-int-variable>
+                            | PAD = <scalar-default-char-expr>
+                            | POS = <scalar-int-expr>
+                            | REC = <scalar-int-expr>
+                            | ROUND = <scalar-default-char-expr>
+                            | SIGN = <scalar-default-char-expr>
+                            | SIZE = <scalar-int-variable>
+
+    The support is partial because this class requires that every spec be
+    named. The specs that may not be named are explicitly handled in
+    Io_Control_Spec_List.match().
+
+    """
+
+    subclass_names = []
+    use_names = [
+        "Io_Unit",
+        "Format",
+        "Namelist_Group_Name",
+        "Scalar_Default_Char_Expr",
+        "Scalar_Char_Initialization_Expr",
+        "Label",
+        "Scalar_Int_Variable",
+        "Iomsg_Variable",
+        "Scalar_Int_Expr",
+    ]
 
     @staticmethod
     def match(string):
-        for (k, v) in [('UNIT', Io_Unit),
-                       ('FMT', Format),
-                       ('NML', Namelist_Group_Name)]:
-            obj = KeywordValueBase.match(k, v, string,
-                                         require_lhs=False,
-                                         upper_lhs=True)
-            if obj:
-                return obj
-
-        for (k, v) in [(['ADVANCE', 'BLANK', 'DECIMAL', 'DELIM', 'PAD',
-                         'ROUND', 'SIGN'], Scalar_Default_Char_Expr),
-                       ('ASYNCHRONOUS', Scalar_Char_Initialization_Expr),
-                       (['END', 'EOR', 'ERR'], Label),
-                       (['ID', 'IOSTAT', 'SIZE'], Scalar_Int_Variable),
-                       ('IOMSG', Iomsg_Variable),
-                       (['POS', 'REC'], Scalar_Int_Expr)]:
+        for k, v in [
+            ("UNIT", Io_Unit),
+            ("FMT", Format),
+            ("NML", Namelist_Group_Name),
+            (
+                ["ADVANCE", "BLANK", "DECIMAL", "DELIM", "PAD", "ROUND", "SIGN"],
+                Scalar_Default_Char_Expr,
+            ),
+            ("ASYNCHRONOUS", Scalar_Char_Initialization_Expr),
+            (["END", "EOR", "ERR"], Label),
+            (["ID", "IOSTAT", "SIZE"], Scalar_Int_Variable),
+            ("IOMSG", Iomsg_Variable),
+            (["POS", "REC"], Scalar_Int_Expr),
+        ]:
             obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
             if obj:
                 return obj
-        return
+        return None
 
 
 class Format(StringBase):  # R914
     """
-    <format> = <default-char-expr>
-               | <label>
-               | *
+    ::
+
+        <format> = <default-char-expr>
+                   | <label>
+                   | *
+
     """
-    subclass_names = ['Label', 'Default_Char_Expr']
+
+    subclass_names = ["Label", "Default_Char_Expr"]
 
     @staticmethod
     def match(string):
-        return StringBase.match('*', string)
+        return StringBase.match("*", string)
 
 
 class Input_Item(Base):  # R915
     """
-    <input-item> = <variable>
-                   | <io-implied-do>
+    ::
+
+        <input-item> = <variable>
+                       | <io-implied-do>
+
     """
-    subclass_names = ['Variable', 'Io_Implied_Do']
+
+    subclass_names = ["Variable", "Io_Implied_Do"]
 
 
 class Output_Item(Base):  # R916
     """
-    <output-item> = <expr>
-                    | <io-implied-do>
+    ::
+
+        <output-item> = <expr>
+                        | <io-implied-do>
     """
-    subclass_names = ['Expr', 'Io_Implied_Do']
+
+    subclass_names = ["Expr", "Io_Implied_Do"]
 
 
 class Io_Implied_Do(Base):  # R917
     """
-    <io-implied-do> = ( <io-implied-do-object-list> , <io-implied-do-control> )
+    ::
+
+        <io-implied-do> = ( <io-implied-do-object-list> , <io-implied-do-control> )
     """
+
     subclass_names = []
-    use_names = ['Io_Implied_Do_Object_List', 'Io_Implied_Do_Control']
+    use_names = ["Io_Implied_Do_Object_List", "Io_Implied_Do_Control"]
 
     @staticmethod
     def match(string):
-        if len(string) <= 9 or string[0] != '(' or string[-1] != ')':
+        if len(string) <= 9 or string[0] != "(" or string[-1] != ")":
             return
         line, repmap = string_replace_map(string[1:-1].strip())
-        i = line.rfind('=')
+        i = line.rfind("=")
         if i == -1:
             return
-        j = line[:i].rfind(',')
+        j = line[:i].rfind(",")
         if j == -1:
             return
-        return Io_Implied_Do_Object_List(
-            repmap(line[:j].rstrip())), \
-            Io_Implied_Do_Control(repmap(line[j+1:].lstrip()))
+        return (
+            Io_Implied_Do_Object_List(repmap(line[:j].rstrip())),
+            Io_Implied_Do_Control(repmap(line[j + 1 :].lstrip())),
+        )
 
     def tostr(self):
-        return '(%s, %s)' % (self.items)
+        return "(%s, %s)" % (self.items)
 
 
 class Io_Implied_Do_Object(Base):  # R918
     """
-    <io-implied-do-object> = <input-item>
-                             | <output-item>
+    ::
+
+        <io-implied-do-object> = <input-item>
+                                 | <output-item>
+
     """
-    subclass_names = ['Input_Item', 'Output_Item']
+
+    subclass_names = ["Input_Item", "Output_Item"]
 
 
 class Io_Implied_Do_Control(Base):  # R919
     """
-    <io-implied-do-control> = <do-variable> = <scalar-int-expr> ,
-        <scalar-int-expr> [ , <scalar-int-expr> ]
+    ::
+
+        <io-implied-do-control> = <do-variable> = <scalar-int-expr> ,
+            <scalar-int-expr> [ , <scalar-int-expr> ]
+
     """
+
     subclass_names = []
-    use_names = ['Do_Variable', 'Scalar_Int_Expr']
+    use_names = ["Do_Variable", "Scalar_Int_Expr"]
 
     @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
-        if '=' not in line:
+        if "=" not in line:
             return
-        v, exprs = line.split('=', 1)
+        v, exprs = line.split("=", 1)
         v = Do_Variable(repmap(v.rstrip()))
-        exprs = exprs.lstrip().split(',')
+        exprs = exprs.lstrip().split(",")
         if len(exprs) not in [2, 3]:
             return
         exprs = tuple([Scalar_Int_Expr(repmap(e.strip())) for e in exprs])
         if len(exprs) == 2:
             return (v,) + exprs + (None,)
         return (v,) + exprs
 
     def tostr(self):
         if self.items[3] is not None:
-            return '%s = %s, %s, %s' % (self.items)
-        return '%s = %s, %s' % (self.items[:-1])
+            return "%s = %s, %s, %s" % (self.items)
+        return "%s = %s, %s" % (self.items[:-1])
 
 
 class Dtv_Type_Spec(CALLBase):  # R920
     """
-    <dtv-type-spec> = TYPE ( <derived-type-spec> )
-                      | CLASS ( <derived-type-spec> )
+    ::
+
+        <dtv-type-spec> = TYPE ( <derived-type-spec> )
+                          | CLASS ( <derived-type-spec> )
+
     """
+
     subclass_names = []
-    use_names = ['Derived_Type_Spec']
+    use_names = ["Derived_Type_Spec"]
 
     @staticmethod
     def match(string):
-        return CALLBase.match(['TYPE', 'CLASS'], Derived_Type_Spec,
-                              string, require_rhs=True)
+        return CALLBase.match(
+            ["TYPE", "CLASS"], Derived_Type_Spec, string, require_rhs=True
+        )
 
 
 class Wait_Stmt(StmtBase, CALLBase):  # R921
     """
     <wait-stmt> = WAIT ( <wait-spec-list> )
     """
+
     subclass_names = []
-    use_names = ['Wait_Spec_List']
+    use_names = ["Wait_Spec_List"]
 
     @staticmethod
     def match(string):
-        return CALLBase.match('WAIT', Wait_Spec_List, string, require_rhs=True)
+        return CALLBase.match("WAIT", Wait_Spec_List, string, require_rhs=True)
 
 
 class Wait_Spec(KeywordValueBase):  # R922
     """
-    <wait-spec> = [ UNIT = ] <file-unit-number>
-                  | END = <label>
-                  | EOR = <label>
-                  | ERR = <label>
-                  | ID = <scalar-int-expr>
-                  | IOMSG = <iomsg-variable>
-                  | IOSTAT = <scalar-int-variable>
-    """
-    subclass_names = []
-    use_names = ['File_Unit_Number', 'Label', 'Scalar_Int_Expr',
-                 'Iomsg_Variable', 'Scalar_Int_Variable']
+    ::
+
+        <wait-spec> = [ UNIT = ] <file-unit-number>
+                      | END = <label>
+                      | EOR = <label>
+                      | ERR = <label>
+                      | ID = <scalar-int-expr>
+                      | IOMSG = <iomsg-variable>
+                      | IOSTAT = <scalar-int-variable>
+
+    """
+
+    subclass_names = []
+    use_names = [
+        "File_Unit_Number",
+        "Label",
+        "Scalar_Int_Expr",
+        "Iomsg_Variable",
+        "Scalar_Int_Variable",
+    ]
 
     @staticmethod
     def match(string):
-        for (k, v) in [
-                (['END', 'EOR', 'ERR'], Label),
-                ('IOSTAT', Scalar_Int_Variable),
-                ('IOMSG', Iomsg_Variable),
-                ('ID', Scalar_Int_Expr),
-                ('UNIT', File_Unit_Number), ]:
+        for k, v in [
+            (["END", "EOR", "ERR"], Label),
+            ("IOSTAT", Scalar_Int_Variable),
+            ("IOMSG", Iomsg_Variable),
+            ("ID", Scalar_Int_Expr),
+            ("UNIT", File_Unit_Number),
+        ]:
             try:
                 obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return 'UNIT', File_Unit_Number(string)
+        return "UNIT", File_Unit_Number(string)
 
 
 class Backspace_Stmt(StmtBase):  # R923
     """
-:F03R:`923`::
-    <backspace-stmt> = BACKSPACE <file-unit-number>
-                       | BACKSPACE ( <position-spec-list> )
+    Fortran2003 Rule R923::
+
+        <backspace-stmt> = BACKSPACE <file-unit-number>
+                           | BACKSPACE ( <position-spec-list> )
+
+    Attributes::
+
+        items : (File_Unit_Number, Position_Spec_List)
 
-Attributes
-----------
-items : (File_Unit_Number, Position_Spec_List)
     """
+
     subclass_names = []
-    use_names = ['File_Unit_Number', 'Position_Spec_List']
+    use_names = ["File_Unit_Number", "Position_Spec_List"]
 
     @staticmethod
     def match(string):
-        if string[:9].upper() != 'BACKSPACE':
+        if string[:9].upper() != "BACKSPACE":
             return
         line = string[9:].lstrip()
-        if line.startswith('('):
-            if not line.endswith(')'):
+        if line.startswith("("):
+            if not line.endswith(")"):
                 return
             return None, Position_Spec_List(line[1:-1].strip())
         return File_Unit_Number(line), None
 
     def tostr(self):
         if self.items[0] is not None:
             assert self.items[1] is None, repr(self.items)
-            return 'BACKSPACE %s' % (self.items[0])
-        return 'BACKSPACE(%s)' % (self.items[1])
+            return "BACKSPACE %s" % (self.items[0])
+        return "BACKSPACE(%s)" % (self.items[1])
 
 
 class Endfile_Stmt(StmtBase):  # R924
     """
-:F03R:`924`::
-    <endfile-stmt> = ENDFILE <file-unit-number>
-                     | ENDFILE ( <position-spec-list> )
+    Fortran2003 Rule R924::
+
+        <endfile-stmt> = ENDFILE <file-unit-number>
+                         | ENDFILE ( <position-spec-list> )
+
+    Attributes::
+
+        items : (File_Unit_Number, Position_Spec_List)
 
-Attributes
-----------
-items : (File_Unit_Number, Position_Spec_List)
     """
+
     subclass_names = []
-    use_names = ['File_Unit_Number', 'Position_Spec_List']
+    use_names = ["File_Unit_Number", "Position_Spec_List"]
 
     @staticmethod
     def match(string):
-        if string[:7].upper() != 'ENDFILE':
+        if string[:7].upper() != "ENDFILE":
             return
         line = string[7:].lstrip()
-        if line.startswith('('):
-            if not line.endswith(')'):
+        if line.startswith("("):
+            if not line.endswith(")"):
                 return
             return None, Position_Spec_List(line[1:-1].strip())
         return File_Unit_Number(line), None
 
     def tostr(self):
         if self.items[0] is not None:
             assert self.items[1] is None, repr(self.items)
-            return 'ENDFILE %s' % (self.items[0])
-        return 'ENDFILE(%s)' % (self.items[1])
+            return "ENDFILE %s" % (self.items[0])
+        return "ENDFILE(%s)" % (self.items[1])
 
 
 class Rewind_Stmt(StmtBase):  # R925
     """
-:F03R:`925`::
-    <rewind-stmt> = REWIND <file-unit-number>
-                    | REWIND ( <position-spec-list> )
+    Fortran2003 Rule R925::
+
+        <rewind-stmt> = REWIND <file-unit-number>
+                        | REWIND ( <position-spec-list> )
+
+    Attributes::
+
+        items : (File_Unit_Number, Position_Spec_List)
 
-Attributes
-----------
-items : (File_Unit_Number, Position_Spec_List)
     """
+
     subclass_names = []
-    use_names = ['File_Unit_Number', 'Position_Spec_List']
+    use_names = ["File_Unit_Number", "Position_Spec_List"]
 
     @staticmethod
     def match(string):
-        if string[:6].upper() != 'REWIND':
+        if string[:6].upper() != "REWIND":
             return
         line = string[6:].lstrip()
-        if line.startswith('('):
-            if not line.endswith(')'):
+        if line.startswith("("):
+            if not line.endswith(")"):
                 return
             return None, Position_Spec_List(line[1:-1].strip())
         return File_Unit_Number(line), None
 
     def tostr(self):
         if self.items[0] is not None:
             assert self.items[1] is None, repr(self.items)
-            return 'REWIND %s' % (self.items[0])
-        return 'REWIND(%s)' % (self.items[1])
+            return "REWIND %s" % (self.items[0])
+        return "REWIND(%s)" % (self.items[1])
 
 
 class Position_Spec(KeywordValueBase):  # R926
     """
-    <position-spec> = [ UNIT = ] <file-unit-number>
-                      | IOMSG = <iomsg-variable>
-                      | IOSTAT = <scalar-int-variable>
-                      | ERR = <label>
+    ::
+
+        <position-spec> = [ UNIT = ] <file-unit-number>
+                          | IOMSG = <iomsg-variable>
+                          | IOSTAT = <scalar-int-variable>
+                          | ERR = <label>
+
     """
+
     subclass_names = []
-    use_names = ['File_Unit_Number', 'Iomsg_Variable',
-                 'Scalar_Int_Variable', 'Label']
+    use_names = ["File_Unit_Number", "Iomsg_Variable", "Scalar_Int_Variable", "Label"]
 
+    @staticmethod
     def match(string):
-        for (k, v) in [
-                ('ERR', Label),
-                ('IOSTAT', Scalar_Int_Variable),
-                ('IOMSG', Iomsg_Variable),
-                ('UNIT', File_Unit_Number), ]:
+        for k, v in [
+            ("ERR", Label),
+            ("IOSTAT", Scalar_Int_Variable),
+            ("IOMSG", Iomsg_Variable),
+            ("UNIT", File_Unit_Number),
+        ]:
             try:
                 obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return 'UNIT', File_Unit_Number(string)
-    match = staticmethod(match)
+        return "UNIT", File_Unit_Number(string)
 
 
 class Flush_Stmt(StmtBase):  # R927
     """
-:F03R:`927`::
-    <flush-stmt> = FLUSH <file-unit-number>
-                    | FLUSH ( <position-spec-list> )
-Attributes
-----------
-items : (File_Unit_Number, Position_Spec_List)
+    Fortran2003 Rule R927::
+
+        <flush-stmt> = FLUSH <file-unit-number>
+                        | FLUSH ( <position-spec-list> )
+
+    Attributes::
+
+        items : (File_Unit_Number, Position_Spec_List)
+
     """
+
     subclass_names = []
-    use_names = ['File_Unit_Number', 'Position_Spec_List']
+    use_names = ["File_Unit_Number", "Position_Spec_List"]
 
     @staticmethod
     def match(string):
-        if string[:5].upper() != 'FLUSH':
+        if string[:5].upper() != "FLUSH":
             return
         line = string[5:].lstrip()
-        if line.startswith('('):
-            if not line.endswith(')'):
+        if line.startswith("("):
+            if not line.endswith(")"):
                 return
             return None, Position_Spec_List(line[1:-1].strip())
         return File_Unit_Number(line), None
 
     def tostr(self):
         if self.items[0] is not None:
             assert self.items[1] is None, repr(self.items)
-            return 'FLUSH %s' % (self.items[0])
-        return 'FLUSH(%s)' % (self.items[1])
+            return "FLUSH %s" % (self.items[0])
+        return "FLUSH(%s)" % (self.items[1])
 
 
 class Flush_Spec(KeywordValueBase):  # R928
     """
-:F03R:`928`::
-    <flush-spec> = [ UNIT = ] <file-unit-number>
-                   | IOMSG = <iomsg-variable>
-                   | IOSTAT = <scalar-int-variable>
-                   | ERR = <label>
-Attributes
-----------
-items : ({'UNIT', 'IOMSG', 'IOSTAT', 'ERR'}, {File_Unit_Number,
-          Iomsg_Variable, Scalar_Int_Variable, Label})
-    """
-    subclass_names = []
-    use_names = ['File_Unit_Number', 'Iomsg_Variable',
-                 'Scalar_Int_Variable', 'Label']
-
-    def match(string):
-        for (k, v) in [
-                ('ERR', Label),
-                ('IOSTAT', Scalar_Int_Variable),
-                ('IOMSG', Iomsg_Variable),
-                ('UNIT', File_Unit_Number), ]:
+    Fortran2003 Rule R928::
+
+        <flush-spec> = [ UNIT = ] <file-unit-number>
+                       | IOMSG = <iomsg-variable>
+                       | IOSTAT = <scalar-int-variable>
+                       | ERR = <label>
+
+    Attributes::
+
+        items : ({'UNIT', 'IOMSG', 'IOSTAT', 'ERR'}, {File_Unit_Number,
+                  Iomsg_Variable, Scalar_Int_Variable, Label})
+
+    """
+
+    subclass_names = []
+    use_names = ["File_Unit_Number", "Iomsg_Variable", "Scalar_Int_Variable", "Label"]
+
+    @staticmethod
+    def match(string):
+        for k, v in [
+            ("ERR", Label),
+            ("IOSTAT", Scalar_Int_Variable),
+            ("IOMSG", Iomsg_Variable),
+            ("UNIT", File_Unit_Number),
+        ]:
             try:
                 obj = KeywordValueBase.match(k, v, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
-        return 'UNIT', File_Unit_Number(string)
-    match = staticmethod(match)
+        return "UNIT", File_Unit_Number(string)
 
 
 class Inquire_Stmt(StmtBase):  # R929
     """
-:F03R:`929`::
-    <inquire-stmt> = INQUIRE ( <inquire-spec-list> )
-                     | INQUIRE ( IOLENGTH = <scalar-int-variable> )
-                       <output-item-list>
-Attributes
-----------
-items : (Inquire_Spec_List, Scalar_Int_Variable, Output_Item_List)
+    Fortran2003 Rule R929::
+
+        <inquire-stmt> = INQUIRE ( <inquire-spec-list> )
+                         | INQUIRE ( IOLENGTH = <scalar-int-variable> )
+                           <output-item-list>
+
+    Attributes::
+
+        items : (Inquire_Spec_List, Scalar_Int_Variable, Output_Item_List)
+
     """
+
     subclass_names = []
-    use_names = ['Inquire_Spec_List', 'Scalar_Int_Variable',
-                 'Output_Item_List']
+    use_names = ["Inquire_Spec_List", "Scalar_Int_Variable", "Output_Item_List"]
 
     @staticmethod
     def match(string):
-        if string[:7].upper() != 'INQUIRE':
+        if string[:7].upper() != "INQUIRE":
             return
         line = string[7:].lstrip()
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
-        if line.endswith(')'):
+        if line.endswith(")"):
             return Inquire_Spec_List(line[1:-1].strip()), None, None
         line, repmap = string_replace_map(line)
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         tmp = repmap(line[1:i])
-        if tmp[:8].upper() != 'IOLENGTH':
+        if tmp[:8].upper() != "IOLENGTH":
             return
         tmp = tmp[8:].lstrip()
-        if not tmp.startswith('='):
+        if not tmp.startswith("="):
             return
         tmp = tmp[1:].lstrip()
-        return None, Scalar_Int_Variable(tmp), \
-            Output_Item_List(repmap(line[i+1:].lstrip()))
+        return (
+            None,
+            Scalar_Int_Variable(tmp),
+            Output_Item_List(repmap(line[i + 1 :].lstrip())),
+        )
 
     def tostr(self):
         if self.items[0] is None:
             assert None not in self.items[1:], repr(self.items)
-            return 'INQUIRE(IOLENGTH=%s) %s' % (self.items[1:])
-        return 'INQUIRE(%s)' % (self.items[0])
+            return "INQUIRE(IOLENGTH=%s) %s" % (self.items[1:])
+        return "INQUIRE(%s)" % (self.items[0])
 
 
 class Inquire_Spec(KeywordValueBase):  # R930
     """
-    :F03R:`930`::
-    <inquire-spec> = [ UNIT = ] <file-unit-number>
-                     | FILE = <file-name-expr>
-                     | ACCESS = <scalar-default-char-variable>
-                     | ACTION = <scalar-default-char-variable>
-                     | ASYNCHRONOUS = <scalar-default-char-variable>
-                     | BLANK = <scalar-default-char-variable>
-                     | DECIMAL = <scalar-default-char-variable>
-                     | DELIM = <scalar-default-char-variable>
-                     | DIRECT = <scalar-default-char-variable>
-                     | ENCODING = <scalar-default-char-variable>
-                     | ERR = <label>
-                     | EXIST = <scalar-default-logical-variable>
-                     | FORM = <scalar-default-char-variable>
-                     | FORMATTED = <scalar-default-char-variable>
-                     | ID = <scalar-int-expr>
-                     | IOMSG = <iomsg-variable>
-                     | IOSTAT = <scalar-int-variable>
-                     | NAME = <scalar-default-char-variable>
-                     | NAMED = <scalar-default-logical-variable>
-                     | NEXTREC = <scalar-int-variable>
-                     | NUMBER = <scalar-int-variable>
-                     | OPENED = <scalar-default-logical-variable>
-                     | PAD = <scalar-default-char-variable>
-                     | PENDING = <scalar-default-logical-variable>
-                     | POS = <scalar-int-variable>
-                     | POSITION = <scalar-default-char-variable>
-                     | READ = <scalar-default-char-variable>
-                     | READWRITE = <scalar-default-char-variable>
-                     | RECL = <scalar-int-variable>
-                     | ROUND = <scalar-default-char-variable>
-                     | SEQUENTIAL = <scalar-default-char-variable>
-                     | SIGN = <scalar-default-char-variable>
-                     | SIZE = <scalar-int-variable>
-                     | STREAM = <scalar-default-char-variable>
-                     | UNFORMATTED = <scalar-default-char-variable>
-                     | WRITE = <scalar-default-char-variable>
-
-    Attributes
-    ----------
-    items : (str, instance)
-    """
-    subclass_names = []
-    use_names = ['File_Unit_Number', 'File_Name_Expr',
-                 'Scalar_Default_Char_Variable',
-                 'Scalar_Default_Logical_Variable', 'Scalar_Int_Variable',
-                 'Scalar_Int_Expr', 'Label', 'Iomsg_Variable']
+    Fortran2003 Rule R930::
+
+        <inquire-spec> = [ UNIT = ] <file-unit-number>
+                         | FILE = <file-name-expr>
+                         | ACCESS = <scalar-default-char-variable>
+                         | ACTION = <scalar-default-char-variable>
+                         | ASYNCHRONOUS = <scalar-default-char-variable>
+                         | BLANK = <scalar-default-char-variable>
+                         | DECIMAL = <scalar-default-char-variable>
+                         | DELIM = <scalar-default-char-variable>
+                         | DIRECT = <scalar-default-char-variable>
+                         | ENCODING = <scalar-default-char-variable>
+                         | ERR = <label>
+                         | EXIST = <scalar-default-logical-variable>
+                         | FORM = <scalar-default-char-variable>
+                         | FORMATTED = <scalar-default-char-variable>
+                         | ID = <scalar-int-expr>
+                         | IOMSG = <iomsg-variable>
+                         | IOSTAT = <scalar-int-variable>
+                         | NAME = <scalar-default-char-variable>
+                         | NAMED = <scalar-default-logical-variable>
+                         | NEXTREC = <scalar-int-variable>
+                         | NUMBER = <scalar-int-variable>
+                         | OPENED = <scalar-default-logical-variable>
+                         | PAD = <scalar-default-char-variable>
+                         | PENDING = <scalar-default-logical-variable>
+                         | POS = <scalar-int-variable>
+                         | POSITION = <scalar-default-char-variable>
+                         | READ = <scalar-default-char-variable>
+                         | READWRITE = <scalar-default-char-variable>
+                         | RECL = <scalar-int-variable>
+                         | ROUND = <scalar-default-char-variable>
+                         | SEQUENTIAL = <scalar-default-char-variable>
+                         | SIGN = <scalar-default-char-variable>
+                         | SIZE = <scalar-int-variable>
+                         | STREAM = <scalar-default-char-variable>
+                         | UNFORMATTED = <scalar-default-char-variable>
+                         | WRITE = <scalar-default-char-variable>
+
+    The `items` attribute for this class contains (str, instance).
+
+    """
+
+    subclass_names = []
+    use_names = [
+        "File_Unit_Number",
+        "File_Name_Expr",
+        "Scalar_Default_Char_Variable",
+        "Scalar_Default_Logical_Variable",
+        "Scalar_Int_Variable",
+        "Scalar_Int_Expr",
+        "Label",
+        "Iomsg_Variable",
+    ]
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: The string to check for conformance with an
                            Inquire_Spec
         :return: 2-tuple of name (e.g. "UNIT") and value or None if
                  string is not a valid Inquire_Spec
         :rtype: 2-tuple where first object represents the name and the
                 second the value.
-        '''
+        """
         if "=" not in string:
             # The only argument which need not be named is the unit number
-            return 'UNIT', File_Unit_Number(string)
+            return "UNIT", File_Unit_Number(string)
         # We have a keyword-value pair. Check whether it is valid...
-        for (keyword, value) in [
-                (['ACCESS', 'ACTION', 'ASYNCHRONOUS', 'BLANK', 'DECIMAL',
-                  'DELIM', 'DIRECT', 'ENCODING', 'FORM', 'NAME', 'PAD',
-                  'POSITION', 'READ', 'READWRITE', 'ROUND', 'SEQUENTIAL',
-                  'SIGN', 'STREAM', 'UNFORMATTED', 'WRITE'],
-                 Scalar_Default_Char_Variable),
-                ('ERR', Label),
-                (['EXIST', 'NAMED', 'PENDING', 'OPENED'],
-                 Scalar_Default_Logical_Variable),
-                ('ID', Scalar_Int_Expr),
-                (['IOSTAT', 'NEXTREC', 'NUMBER', 'POS', 'RECL', 'SIZE'],
-                 Scalar_Int_Variable),
-                ('IOMSG', Iomsg_Variable),
-                ('FILE', File_Name_Expr),
-                ('UNIT', File_Unit_Number)]:
+        for keyword, value in [
+            (
+                [
+                    "ACCESS",
+                    "ACTION",
+                    "ASYNCHRONOUS",
+                    "BLANK",
+                    "DECIMAL",
+                    "DELIM",
+                    "DIRECT",
+                    "ENCODING",
+                    "FORM",
+                    "NAME",
+                    "PAD",
+                    "POSITION",
+                    "READ",
+                    "READWRITE",
+                    "ROUND",
+                    "SEQUENTIAL",
+                    "SIGN",
+                    "STREAM",
+                    "UNFORMATTED",
+                    "WRITE",
+                ],
+                Scalar_Default_Char_Variable,
+            ),
+            ("ERR", Label),
+            (["EXIST", "NAMED", "PENDING", "OPENED"], Scalar_Default_Logical_Variable),
+            ("ID", Scalar_Int_Expr),
+            (
+                ["IOSTAT", "NEXTREC", "NUMBER", "POS", "RECL", "SIZE"],
+                Scalar_Int_Variable,
+            ),
+            ("IOMSG", Iomsg_Variable),
+            ("FILE", File_Name_Expr),
+            ("UNIT", File_Unit_Number),
+        ]:
             try:
-                obj = KeywordValueBase.match(keyword, value, string,
-                                             upper_lhs=True)
+                obj = KeywordValueBase.match(keyword, value, string, upper_lhs=True)
             except NoMatchError:
                 obj = None
             if obj is not None:
                 return obj
         return None
 
+
 #
 # SECTION 10
 #
 
 
 class Format_Stmt(StmtBase, WORDClsBase):  # R1001
     """
     <format-stmt> = FORMAT <format-specification>
     """
+
     subclass_names = []
-    use_names = ['Format_Specification']
+    use_names = ["Format_Specification"]
 
     @staticmethod
     def match(string):
-        return WORDClsBase.match('FORMAT', Format_Specification,
-                                 string, require_cls=True)
+        return WORDClsBase.match(
+            "FORMAT", Format_Specification, string, require_cls=True
+        )
 
 
 class Format_Item_List(SequenceBase):  # pylint: disable=invalid-name
-    '''This class replaces the one generated by fparser. This class is
+    """This class replaces the one generated by fparser. This class is
     required as support for hollerith strings makes matching more
     complicated.
 
-    '''
+    """
+
     use_names = []
-    subclass_names = ['Format_Item']
+    subclass_names = ["Format_Item"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a list of format items.
+        """Implements the matching for a list of format items.
 
         Supporting Hollerith strings makes it very difficult to
         correctly split the input string into items a-priori. The
         reason for this can be seen in the following example:
 
         `2H,x,e2.2` is `2H,x` and `e2.2` but when split with commas
         incorrectly gives `2H`, `x` and `e2.2`.
 
         Further, hollerith strings could also confuse any code that
         tried to determine whether code was inside quotes or not. For
-        example:
+        example::
 
-        `2H"x,2H"x` does not mean that `x,2H` is part of a string.
+            `2H"x,2H"x` does not mean that `x,2H` is part of a string.
 
         The solution chosen is to match one item at a time, first
         checking for a valid Hollerith string and then checking for
         any other valid input.
 
         :param str string: the string to match as a Format List.
         :return: None if there is no match or a tuple of size 2 \
         containing a string with a comma followed by a tuple \
         containing a list which itself contains the matched \
         format items.
         :rtype: (`str`, \
         ([:py:class:`fparser.two.Fortran2003.Format_Item`s])) or `NoneType`
 
-        '''
+        """
         if not string:
             return None
-        current_string = string.strip()
+        current_string = string.lstrip()
         if not current_string:
             return None
         item_list = []
         while current_string:
+            # Look for a slash edit descriptor with repeat modifier
+            found, index = skip_digits(current_string)
+            if found and current_string[index] == "/":
+                item_list.append(Control_Edit_Desc(current_string[: index + 1]))
+                current_string = current_string[index + 1 :].lstrip()
+                # Rule C1002 allows omitting a comma after slash edit descriptors,
+                # so skip the comma if it exists and carry on
+                if current_string and current_string[0] == ",":
+                    current_string = current_string[1:].lstrip()
+                continue
+
+            # Look for a colon edit descriptor or a slash edit descriptor without
+            # a repeat modifier
+            if current_string[0] in ":/":
+                item_list.append(Control_Edit_Desc(current_string[0]))
+                current_string = current_string[index + 1 :].lstrip()
+                # Rule C1002 allows omitting a comma after colon or slash edit
+                # descriptors, so skip the comma if it exists and carry on
+                if current_string and current_string[0] == ",":
+                    current_string = current_string[1:].lstrip()
+                continue
+
             # Does the current item match the start of a
             # hollerith string?
             my_pattern = Hollerith_Item.match_pattern
             match = re.search(my_pattern, current_string)
             if match:
                 # The current item matches with a hollerith string.
                 match_str = match.group(0)
                 hol_length_str = match_str[:-1]
                 hol_length = int(hol_length_str)
                 num_chars = len(match_str) + hol_length
                 if len(current_string) < num_chars:
                     # The string is not long enough.
                     return None
-                item_list.append(Format_Item(current_string[:num_chars]))
+                item_list.append(Hollerith_Item(current_string[:num_chars]))
                 current_string = current_string[num_chars:].lstrip()
                 if current_string:
-                    # Remove the next comma and any white space.
-                    if current_string[0] != ',':
-                        # There is no comma so we have a format error.
+                    if current_string[0] == ",":
+                        # Remove the next comma and any white space.
+                        current_string = current_string[1:].lstrip()
+                    elif current_string[0] == "/":
+                        # Commas aren't required before a slash edit descriptor without
+                        # repeat modifier (C1002)
+                        pass
+                    elif current_string[0] == ":":
+                        # Commas aren't required before a colon edit descriptor (C1002)
+                        pass
+                    else:
                         return None
-                    current_string = current_string[1:].lstrip()
             else:
                 # Current item does not match with a hollerith string
-                # so we are safe to split using a ',' as separator
+                # so get the next format item by splitting on ',', '/' or ':'
                 # after applying string_replace_map.
                 line, repmap = string_replace_map(current_string)
-                splitted = line.split(',', 1)
-                item_list.append(Format_Item(repmap(splitted[0].strip())))
-                current_string = ""
-                if len(splitted) == 2:
-                    current_string = repmap(splitted[1]).strip()
-        if len(item_list) <= 1:
-            # a list must contain at least 2 items (see SequenceBase)
-            return None
-        return ',', tuple(item_list)
+                match = re.search("[,/:]", line)
+                if match:
+                    item_list.append(Format_Item(repmap(line[: match.start()])))
+                    current_string = repmap(line[match.start() :])
+                    if match.group() == ",":
+                        # skip the comma
+                        current_string = current_string[1:].lstrip()
+                else:
+                    item_list.append(Format_Item(repmap(line)))
+                    current_string = ""
+        return ",", tuple(item_list)
 
 
 class Format_Specification(BracketBase):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R1002
+    """
+    Fortran 2003 rule R1002::
 
-    format-specification = ( [ format-item-list ] )
+        format-specification = ( [ format-item-list ] )
 
     C1002 is implemented in a separate class Format_Item_C1002
 
     C1002 (R1002) The comma used to separate format-items in a
     format-item-list may be omitted
 
     (1) Between a P edit descriptor and an immediately following F, E,
@@ -7475,70 +9739,70 @@
     (2) Before a slash edit descriptor when the optional repeat
     specification is not present,
 
     (3) After a slash edit descriptor, or
 
     (4) Before or after a colon edit descriptor.
 
-    '''
+    """
+
     subclass_names = []
-    use_names = ['Format_Item_List']
+    use_names = ["Format_Item_List"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a format specification.
+        """Implements the matching for a format specification.
 
         :param str string: The string to check for conformance with a \
                            format specification.
         :return: `None` if there is no match, otherwise a tuple of \
         size three, the first entry being a string containing a left \
         bracket and the third being a string containing a right \
         bracket. The second entry is either a Format_Item or a \
         Format_Item_List.
         :rtype: `NoneType` or ( `str`, \
         :py:class:`fparser.two.Fortran2003.Format_Item` or \
         :py:class:`fparser.two.Fortran2003.Format_Item_List`, `str` )
 
-        '''
-        return BracketBase.match('()', Format_Item_List, string,
-                                 require_cls=False)
+        """
+        return BracketBase.match("()", Format_Item_List, string, require_cls=False)
 
 
 def skip_digits(string):
-    '''Skips over any potential digits (including spaces) to the next
+    """Skips over any potential digits (including spaces) to the next
     non-digit character and return its index. If no such character is
     found or if the first character in the string is not a digit then
     specify that the skip has failed.
 
     :param str string: The string to search
     :returns: a 2-tuple with the first entry indicating if a valid \
     character has been found and the second entry indicating the index \
     of this character in the 'string' argument.
     :rtype: (bool, int)
 
-    '''
+    """
     found = False
     index = 0
     for index, char in enumerate(string):
-        if not (char.isdigit() or char == ' '):
+        if not (char.isdigit() or char == " "):
             if index > 0:
                 found = True
             break
     return found, index
 
 
 class Format_Item_C1002(Base):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 constraint C1002
+    """
+    Fortran 2003 constraint C1002::
 
-    format-item-c1002 is kP [,] (F|D)w.d | (E|EN|ES|G)w.d[Ee]
-                      or [r]/ [,] format-item
-                      or : [,] format-item
-                      or format-item [,] / [[,] format-item]
-                      or format-item [,] : [[,] format-item]
+        format-item-c1002 is kP [,] (F|D)w.d | (E|EN|ES|G)w.d[Ee]
+                          or [r]/ [,] format-item
+                          or : [,] format-item
+                          or format-item [,] / [[,] format-item]
+                          or format-item [,] : [[,] format-item]
 
     C1002 (R1002) The comma used to separate format-items in a
     format-item-list may be omitted
 
     (1) Between a P edit descriptor and an immediately following F, E,
     EN, ES, D, or G edit descriptor, possibly preceded by a repeat
     specifier,
@@ -7546,21 +9810,22 @@
     (2) Before a slash edit descriptor when the optional repeat
     specification is not present (10.7.2),
 
     (3) After a slash edit descriptor, or
 
     (4) Before or after a colon edit descriptor.
 
-    '''
+    """
+
     subclass_names = []
-    use_names = ['K', 'W', 'D', 'E', 'Format_Item', 'R']
+    use_names = ["K", "W", "D", "E", "Format_Item", "R"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for the C1002 Format Item constraint. The
+        """Implements the matching for the C1002 Format Item constraint. The
         constraints specify certain combinations of format items that
         do not need a comma to separate them. Rather than sorting this
         out when parsing the list, it was decided to treat these
         separately and match them in this class. As a result the
         generated class hierarchy is a little more complicated.
 
         :param str string: The string to check for conformance with a \
@@ -7573,221 +9838,241 @@
         :py:class:`fparser.two.Control_Edit_Desc`, \
         :py:class:`fparser.two.Format_Item` ) or \
         (:py:class:`fparser.two.Format_Item`, \
         :py:class:`fparser.two.Control_Edit_Desc`) or \
         (:py:class:`fparser.two.Format_Item`, \
         :py:class:`fparser.two.Format_Item`)
 
-        '''
+        """
         if not string:
             return None
         strip_string = string.strip()
         if len(strip_string) <= 1:
             return None
-        if strip_string[0] in ':/':
+        if strip_string[0] in ":/":
             # No comma is required after slash edit descriptor (3) or
             # after a colon edit descriptor (4)
-            return Control_Edit_Desc(strip_string[0]), \
-                Format_Item(strip_string[1:].lstrip())
-        if strip_string[-1] in ':/':
+            return (
+                Control_Edit_Desc(strip_string[0]),
+                Format_Item(strip_string[1:].lstrip()),
+            )
+        if strip_string[-1] in ":/":
             # No comma is required before a slash edit descriptor,
             # when the optional repeat specification is not present
             # (2), or before a colon edit descriptor (4). Note, if an
             # optional repeat specification is present it will be
             # treated as if it is part of the previous item.
-            return Format_Item(strip_string[:-1].rstrip()), \
-                Control_Edit_Desc(strip_string[-1])
+            return (
+                Format_Item(strip_string[:-1].rstrip()),
+                Control_Edit_Desc(strip_string[-1]),
+            )
         # We may have a P edit descriptor (which requires a number
         # before the 'P') (1) or a slash edit descriptor with a repeat
         # specifier (3) so look for the repeat specifier.
         found, index = skip_digits(strip_string)
         if found:
             # We found a possible repeat specifier (which may contain
             # white space after the first digit)
             result = strip_string[index].upper()
-            if result == '/':
+            if result == "/":
                 # We found a possible slash edit descriptor with a
                 # repeat specifier (3).
-                return Control_Edit_Desc(strip_string[:index+1]), \
-                    Format_Item(strip_string[index+1:].lstrip())
-            if result == 'P':
+                return (
+                    Control_Edit_Desc(strip_string[: index + 1]),
+                    Format_Item(strip_string[index + 1 :].lstrip()),
+                )
+            if result == "P":
                 # We found a possible P edit descriptor (1).
                 # Rule C1002 only allows a comma to be ommited between
                 # a P edit descriptor and a following F, E, EN, ES, D,
                 # or G edit descriptor with an optional repeat
                 # specifier. In fparser2 this translates to a
                 # Format_Item instance containing a Data_Edit_Desc, or
                 # Data_Edit_Desc_C1002 instance as its second item
                 # with the data edit descriptor instance's first item
                 # specifying the type of edit descriptor.
-                lhs = Control_Edit_Desc(strip_string[:index+1])
-                rhs = Format_Item(strip_string[index+1:].lstrip())
+                lhs = Control_Edit_Desc(strip_string[: index + 1])
+                rhs = Format_Item(strip_string[index + 1 :].lstrip())
                 if not isinstance(rhs, Format_Item):
                     # Matched with a subclass of Format_item or no match.
                     return None
                 descriptor_object = rhs.items[1]
-                if not isinstance(descriptor_object, (Data_Edit_Desc,
-                                                      Data_Edit_Desc_C1002)):
+                if not isinstance(
+                    descriptor_object, (Data_Edit_Desc, Data_Edit_Desc_C1002)
+                ):
                     return None
                 edit_descriptor = descriptor_object.items[0]
-                if edit_descriptor.upper() not in ['F', 'E', 'EN', 'ES',
-                                                   'D', 'G']:
+                if edit_descriptor.upper() not in ["F", "E", "EN", "ES", "D", "G"]:
                     return None
                 return lhs, rhs
 
         # Replace any content inside strings etc. so we dont split the
         # line in the wrong place.
         line, repmap = string_replace_map(strip_string)
 
         # Slash and colon edit descriptors may have no comma's both
         # before and after them (2,3,4) e.g. ('a' / 'b'). To match this
         # situation we split the line with the first potential descriptor found
         # in the string and try to match the lhs and rhs separately
         # (adding the edit descriptor to the RHS).
-        for option in '/:':
+        for option in "/:":
             if option in line:
                 left, right = line.split(option, 1)
-                return Format_Item(repmap(left.rstrip())), \
-                    Format_Item(option+repmap(right.lstrip()))
+                return (
+                    Format_Item(repmap(left.rstrip())),
+                    Format_Item(option + repmap(right.lstrip())),
+                )
 
     def tostr(self):
-        '''
+        """
         :return: Parsed representation of two format items
         :rtype: str
 
         :raises InternalError: if the length of the internal items \
         list is not 2.
         :raises InternalError: if the first entry of the internal \
         items list has no content.
         :raises InternalError: if the second entry of the internal \
         items list has no content.
 
-        '''
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Class Format_Item_C1002 method tostr(): internal items list "
-                "should be length 2 but found '{0}'".format(len(self.items)))
+                "should be length 2 but found '{0}'".format(len(self.items))
+            )
         if not self.items[0]:
             raise InternalError(
                 "Class Format_Item_C1002 method tostr() items entry 0 should "
-                "contain a format items object but it is empty or None")
+                "contain a format items object but it is empty or None"
+            )
         if not self.items[1]:
             raise InternalError(
                 "Class Format_Item_C1002 method tostr() items entry 1 should "
-                "contain a format items object but it is empty or None")
+                "contain a format items object but it is empty or None"
+            )
         return "{0}, {1}".format(self.items[0], self.items[1])
 
 
 class Hollerith_Item(Base):  # pylint: disable=invalid-name
-    '''Hollerith strings take the form `nHx`, where `n` is an integer and
+    """Hollerith strings take the form `nHx`, where `n` is an integer and
     `x` is a sequence of characters of length `n`.
 
     Note, the Hollerith format was deprecated in Fortran77 and removed in
     Fortran95. However, Fortran compilers still support it. See, for example
-    https://gcc.gnu.org/onlinedocs/gcc-4.8.2/gfortran/
-    Hollerith-constants-support.html
+    `<https://gcc.gnu.org/onlinedocs/gcc-4.8.2/gfortran/
+    Hollerith-constants-support.html>`_
+
+    """
 
-    '''
     subclass_names = []
     use_names = []
-    match_pattern = '^[1-9][0-9 ]*[hH]'
+    match_pattern = "^[1-9][0-9 ]*[hH]"
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Hollerith string.
+        """Implements the matching for a Hollerith string.
 
         :param str string: The string to check for conformance with a \
                            Hollerith string
         :return: String containing the contents of the Hollerith \
         string.
         :rtype: str
 
-        '''
+        """
         from fparser.two.utils import EXTENSIONS
-        if 'hollerith' not in EXTENSIONS:
+
+        if "hollerith" not in EXTENSIONS:
             return None
         if not string:
             return None
         # Only strip space to the left as space to the right could be
         # part of the hollerith string.
         strip_string = string.lstrip()
         match = re.search(Hollerith_Item.match_pattern, strip_string)
         if not match:
             return None
         # Current item matches with a hollerith string.
         match_str = match.group(0)
-        hol_length_str = match_str[:-1].replace(' ', '')
+        hol_length_str = match_str[:-1].replace(" ", "")
         hol_length = int(hol_length_str)
         num_chars = len(match_str) + hol_length
         if len(strip_string) < num_chars:
             # The string is too short
             return None
         if len(strip_string) > num_chars:
             # The string is too long
             if strip_string[num_chars:].strip():
                 # The extra is not just white space
                 return None
-        return strip_string[len(match_str):num_chars],
+        return (strip_string[len(match_str) : num_chars],)
 
     def tostr(self):
-        '''
+        """
         :return: Parsed representation of a Hollerith String.
         :rtype: str
 
         :raises InternalError: if the length of the internal items \
         list is not 1.
         :raises InternalError: if the first entry of the internal \
         items list has no content.
 
-        '''
+        """
         if len(self.items) != 1:
             raise InternalError(
                 "Class Hollerith_Item method tostr(): internal items list "
-                "should be of length 1 but found '{0}'".
-                format(len(self.items)))
+                "should be of length 1 but found '{0}'".format(len(self.items))
+            )
         if not self.items[0]:
             raise InternalError(
                 "Class Hollerith_Item method tostr() items entry 0 should be "
-                "a valid Hollerith string but it is empty or None")
+                "a valid Hollerith string but it is empty or None"
+            )
         return "{0}H{1}".format(len(self.items[0]), self.items[0])
 
 
 class Format_Item(Base):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R1003
-    format-item is [ r ] data-edit-desc
-                or control-edit-desc
-                or char-string-edit-desc
-                or [ r ] ( format-item-list )
-                or format-item-c1002
-                or hollerith-item
-
-    '''
-    subclass_names = ['Hollerith_Item', 'Control_Edit_Desc',
-                      'Char_String_Edit_Desc', 'Format_Item_C1002']
-    use_names = ['R', 'Format_Item_List', 'Data_Edit_Desc']
+    """
+    Fortran 2003 rule R1003::
+
+        format-item is [ r ] data-edit-desc
+                    or control-edit-desc
+                    or char-string-edit-desc
+                    or [ r ] ( format-item-list )
+                    or format-item-c1002
+                    or hollerith-item
+
+    """
+
+    subclass_names = [
+        "Hollerith_Item",
+        "Control_Edit_Desc",
+        "Char_String_Edit_Desc",
+        "Format_Item_C1002",
+    ]
+    use_names = ["R", "Format_Item_List", "Data_Edit_Desc"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching of a Format Item. This method matches '[ r
+        """Implements the matching of a Format Item. This method matches '[ r
         ] data-edit-desc' and '[ r ] ( format-item-list )'. The
         remaining options are matched via subclasses specified in the
         subclass_names variable.
 
         :param str string: A string or the Fortran reader containing the \
                     line of code that we are trying to match.
         :return: `None` if there is no match or a `tuple` of size 2 \
         containing an instance of the R class followed by an \
         instance of either the Format_Item_List or the Data_Edit_Desc \
         class.
         :rtype: `None` or ( :py:class:`fparser.two.Fortran2003.R`, \
         :py:class:`fparser.two.Fortran2003.Format_Item_List` or \
         :py:class:`fparser.two.Fortran2003.Data_Edit_Desc`)
 
-        '''
+        """
         if not string:
             return None
         strip_string = string.strip()
         if not strip_string:
             return None
         index = 0
         # Look for an optional repeat specifier (the 'r' in this rule)
@@ -7797,151 +10082,157 @@
         if found:
             # We found a repeat specifier (with content after it) so
             # create an R class using the value
             rpart = R(strip_string[:index])
             my_string = strip_string[index:].lstrip()
         # We deal with format-item-list and data-edit-desc in this
         # match method. Other matches are performed by the subclasses.
-        if my_string[0] == '(' and my_string[-1] == ')':
+        if my_string[0] == "(" and my_string[-1] == ")":
             # This could be a format-item-list
-            rest = Format_Item_List(my_string[1:-1].strip())
+            rest = Format_Item_List(my_string[1:-1].lstrip())
         else:
             # This is not a format-item-list so see if it is a
             # data-edit-descriptor
             rest = Data_Edit_Desc(my_string)
         return rpart, rest
 
     def tostr(self):
-        '''
+        """
         :return: Parsed representation of a Format Item.
         :rtype: str
 
         :raises InternalError: if the length of the internal items \
         list is not 2.
         :raises InternalError: if the first entry of the internal \
         items list has no content.
 
-        '''
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Class Format_Item method tostr(): internal items list "
-                "should be of length 2 but found '{0}'".
-                format(len(self.items)))
+                "should be of length 2 but found '{0}'".format(len(self.items))
+            )
         if not self.items[1]:
             raise InternalError(
                 "Class Format_Item method tostr(): items list second entry "
-                "should be a valid descriptor but it is empty or None")
+                "should be a valid descriptor but it is empty or None"
+            )
         rpart = self.items[0]
         rest = self.items[1]
 
         rpart_str = rpart if rpart else ""
         if isinstance(rest, (Data_Edit_Desc, Data_Edit_Desc_C1002)):
             return "{0}{1}".format(rpart_str, rest)
         return "{0}({1})".format(rpart_str, rest)
 
 
 class R(Base):  # R1004
     """
-::
-    <r> = <int-literal-constant>
+    ::
+
+        <r> = <int-literal-constant>
 
-Notes
------
-C1003, C1004: <r> shall be positive and without kind parameter specified.
+    Notes::
+
+        C1003, C1004: <r> shall be positive and without kind parameter specified.
     """
-    subclass_names = ['Digit_String']
+
+    subclass_names = ["Digit_String"]
 
 
 class Data_Edit_Desc_C1002(Base):
-    '''This class helps implement the matching for the first part of the
+    """This class helps implement the matching for the first part of the
     Fortran 2003 Constraint C1002 which constrains rule R1002. In
     particular it matches with the subset of edit descriptors that can
-    follow a P edit descriptor without needing a comma, see below:
+    follow a P edit descriptor without needing a comma, see below.
 
     C1002 (applied to R1002) The comma used to separate format-items
     in a format-item-list may be omitted
 
     (1) Between a P edit descriptor and an immediately following F, E,
     EN, ES, D, or G edit descriptor, possibly preceded by a
     repeat specifier.
 
     [Remaining constraint clauses ommitted as they are not relevant
     here.]
 
-    data-edit-desc is F w . d
-                   or E w . d [ E e ]
-                   or EN w . d [ E e ]
-                   or ES w . d [ E e]
-                   or G w . d [ E e ]
-                   or D w . d
+    ::
+
+        data-edit-desc is F w . d
+                       or E w . d [ E e ]
+                       or EN w . d [ E e ]
+                       or ES w . d [ E e]
+                       or G w . d [ E e ]
+                       or D w . d
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['W', 'D', 'E']
+    use_names = ["W", "D", "E"]
 
     @staticmethod
     def match(string):
-        '''Check whether the input matches the rule.
+        """Check whether the input matches the rule.
 
         param str string: contains the Fortran that we are trying to \
         match.
         :return: `None` if there is no match, otherwise a `tuple` of \
         size 4, the first entry containing a string with one of ['F', \
         'E', 'EN', 'ES', 'G', 'D'], the second entry containing a W \
         class instance, the third entry containing D class instance \
         and the fourth entry containing either None or an E class \
         instance.
         :rtype: `NoneType`, (`str`, :py:class:`fparser.two.W`, \
         :py:class:`fparser.two.D`, `NoneType`) or, (`str`, \
         :py:class:`fparser.two.W`, :py:class:`fparser.two.D`, \
         :py:class:`fparser.two.E`)
 
-        '''
+        """
         if not string:
             return None
         strip_string = string.strip()
         if not strip_string:
             return None
         char = strip_string[0].upper()
-        if char in ['F', 'D']:
+        if char in ["F", "D"]:
             # match w . d
             my_str = strip_string[1:].lstrip().upper()
-            if '.' in my_str:
-                left, right = my_str.split('.', 1)
+            if "." in my_str:
+                left, right = my_str.split(".", 1)
                 left = left.rstrip()
                 right = right.lstrip()
                 return char, W(left), D(right), None
             return None
-        if char in ['E', 'G']:
+        if char in ["E", "G"]:
             # match w . d [ E e ]
             # Format descriptor could also be 'ES' or 'EN'
             my_str = strip_string[1:].lstrip().upper()
             char2 = my_str[0]
-            if char == 'E' and char2 in ['S', 'N']:
+            if char == "E" and char2 in ["S", "N"]:
                 my_str = my_str[1:].lstrip()
             else:
                 char2 = ""
             if "." not in my_str:
                 return None
-            left, right = my_str.split('.', 1)
+            left, right = my_str.split(".", 1)
             left = left.rstrip()
             right = right.lstrip()
             # Can optionally specify the number of digits for the
             # exponent
-            if right.count('E') >= 1:
-                middle, right = right.split('E', 1)
+            if right.count("E") >= 1:
+                middle, right = right.split("E", 1)
                 middle = middle.rstrip()
                 right = right.lstrip()
-                return char+char2, W(left), D(middle), E(right)
-            return char+char2, W(left), D(right), None
+                return char + char2, W(left), D(middle), E(right)
+            return char + char2, W(left), D(right), None
         # Invalid char
         return None
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of a Data Edit Descriptor \
         conforming to constraint C1002.
         :rtype: str
 
         :raises InternalError: if the length of the internal items \
         list is not 4.
         :raises InternalError: if the first, second or third entry of \
@@ -7949,486 +10240,551 @@
         :raises InternalError: if the value of the first entry is \
         unsupported.
         :raises InternalError: if the value of the first entry is 'F' \
         or 'D' and the fourth entry has content.
         :raises InternalError: if the value of the first entry is 'E', \
         'EN', 'ES' or 'G' and the fourth entry is empty or None.
 
-        '''
+        """
         if not len(self.items) == 4:
             raise InternalError(
                 "Class Data_Edit_Desc_C1002 method tostr() has '{0}' items, "
-                "but expecting 4.".format(len(self.items)))
+                "but expecting 4.".format(len(self.items))
+            )
         if not self.items[0]:
             raise InternalError(
                 "items[0] in Class Data_Edit_Desc_C1002 method tostr() "
-                "should be a descriptor name but is empty or None")
+                "should be a descriptor name but is empty or None"
+            )
         if not self.items[1]:
             raise InternalError(
                 "items[1] in Class Data_Edit_Desc_C1002 method tostr() "
-                "should be the w value but is empty or None")
+                "should be the w value but is empty or None"
+            )
         if not self.items[2]:
             raise InternalError(
                 "items[2] in Class Data_Edit_Desc_C1002 method tostr() "
-                "should be the m value but is empty or None")
+                "should be the m value but is empty or None"
+            )
         descriptor_name = self.items[0]
-        if descriptor_name in ['F', 'D']:
+        if descriptor_name in ["F", "D"]:
             if self.items[3]:
                 raise InternalError(
                     "items[3] in Class Data_Edit_Desc_C1002 method tostr() "
                     "has an exponent value '{0}' but this is not allowed for "
                     "'F' and 'D' descriptors and should therefore be "
-                    "None".format(self.items[3]))
-            return "{0}{1}.{2}".format(descriptor_name, self.items[1],
-                                       self.items[2])
-        elif descriptor_name in ['E', 'EN', 'ES', 'G']:
+                    "None".format(self.items[3])
+                )
+            return "{0}{1}.{2}".format(descriptor_name, self.items[1], self.items[2])
+        elif descriptor_name in ["E", "EN", "ES", "G"]:
             if self.items[3] is None:
-                return "{0}{1}.{2}".format(descriptor_name, self.items[1],
-                                           self.items[2])
-            return "{0}{1}.{2}E{3}".format(descriptor_name, self.items[1],
-                                           self.items[2], self.items[3])
+                return "{0}{1}.{2}".format(
+                    descriptor_name, self.items[1], self.items[2]
+                )
+            return "{0}{1}.{2}E{3}".format(
+                descriptor_name, self.items[1], self.items[2], self.items[3]
+            )
         raise InternalError(
             "Unexpected descriptor name '{0}' in Class Data_Edit_Desc_C1002 "
-            "method tostr()".format(descriptor_name))
+            "method tostr()".format(descriptor_name)
+        )
 
 
 class Data_Edit_Desc(Base):  # R1005
     """
-::
-    <data-edit-desc> =   I <w> [ . <m> ]
-                       | B <w> [ . <m> ]
-                       | O <w> [ . <m> ]
-                       | Z <w> [ . <m> ]
-                       | L <w>
-                       | A [ <w> ]
-                       | DT [ <char-literal-constant> ] [ ( <v-list> ) ]
-                       | <data-edit-desc-c1002>
+    ::
+
+        <data-edit-desc> =   I <w> [ . <m> ]
+                           | B <w> [ . <m> ]
+                           | O <w> [ . <m> ]
+                           | Z <w> [ . <m> ]
+                           | L <w>
+                           | A [ <w> ]
+                           | DT [ <char-literal-constant> ] [ ( <v-list> ) ]
+                           | <data-edit-desc-c1002>
+
     """
-    subclass_names = ['Data_Edit_Desc_C1002']
-    use_names = ['W', 'M', 'Char_Literal_Constant', 'V_List']
+
+    subclass_names = ["Data_Edit_Desc_C1002"]
+    use_names = ["W", "M", "Char_Literal_Constant", "V_List"]
 
     @staticmethod
     def match(string):
         c = string[0].upper()
-        if c in ['I', 'B', 'O', 'Z']:
+        if c in ["I", "B", "O", "Z"]:
             line = string[1:].lstrip()
-            if '.' in line:
-                i1, i2 = line.split('.', 1)
+            if "." in line:
+                i1, i2 = line.split(".", 1)
                 i1 = i1.rstrip()
                 i2 = i2.lstrip()
                 return c, W(i1), M(i2), None, Int_Literal_Constant
             return c, W(line), None, None
-        if c == 'L':
+        if c == "L":
             line = string[1:].lstrip()
             if not line:
                 return
             return c, W(line), None, None
-        if c == 'A':
+        if c == "A":
             line = string[1:].lstrip()
             if not line:
                 return c, None, None, None
             return c, W(line), None, None
         c = string[:2].upper()
         if len(c) != 2:
             return
-        if c == 'DT':
+        if c == "DT":
             line = string[2:].lstrip()
             if not line:
                 return c, None, None, None
             lst = None
-            if line.endswith(')'):
-                i = line.rfind('(')
+            if line.endswith(")"):
+                i = line.rfind("(")
                 if i == -1:
                     return
-                tmp = line[i+1:-1].strip()
+                tmp = line[i + 1 : -1].strip()
                 if not tmp:
                     return
                 lst = V_List(tmp)
                 line = line[:i].rstrip()
             if not line:
                 return c, None, lst, None
             return c, Char_Literal_Constant(line), lst, None
-        return
+        return None
 
     def tostr(self):
         c = self.items[0]
-        if c in ['I', 'B', 'O', 'Z', 'A', 'L']:
+        if c in ["I", "B", "O", "Z", "A", "L"]:
             if self.items[2] is None:
                 if self.items[1] is None:
                     return c
-                return '%s%s' % (c, self.items[1])
-            return '%s%s.%s' % (c, self.items[1], self.items[2])
-        if c == 'DT':
+                return "%s%s" % (c, self.items[1])
+            return "%s%s.%s" % (c, self.items[1], self.items[2])
+        if c == "DT":
             if self.items[1] is None:
                 if self.items[2] is None:
                     return c
                 else:
-                    return '%s(%s)' % (c, self.items[2])
+                    return "%s(%s)" % (c, self.items[2])
             else:
                 if self.items[2] is None:
-                    return '%s%s' % (c, self.items[1])
+                    return "%s%s" % (c, self.items[1])
                 else:
-                    return '%s%s(%s)' % (c, self.items[1], self.items[2])
+                    return "%s%s(%s)" % (c, self.items[1], self.items[2])
         raise NotImplementedError(repr(c))
 
 
 class W(Base):  # R1006
     """
-::
-    <w> = <int-literal-constant> == <digit-string>
+    ::
+
+        w is int-literal-constant == digit-string
+
+    Subject to constraints::
+
+        C1006, C1007: w is zero or postive and without kind parameters.
 
-Notes
------
-C1006, C1007: <w> is zero or postive and without kind parameters.
     """
-    subclass_names = ['Digit_String']
+
+    subclass_names = ["Digit_String"]
 
 
 class M(Base):  # R1007
     """
-::
-    <m> = <int-literal-constant>
+    ::
+
+        m = int-literal-constant
+
+    Subject to the constraint::
+
+        C1007: m is without kind parameters.
 
-Notes
------
-C1007: <w> is without kind parameters.
     """
-    subclass_names = ['Int_Literal_Constant']
+
+    subclass_names = ["Int_Literal_Constant"]
 
 
 class D(Base):  # R1008
     """
-::
-    <d> = <int-literal-constant>
+    ::
+
+        d = int-literal-constant
+
+    Subject to the constraint::
+
+        C1007: d is without kind parameters.
 
-Notes
------
-C1007: <d> is without kind parameters.
     """
-    subclass_names = ['Int_Literal_Constant']
+
+    subclass_names = ["Int_Literal_Constant"]
 
 
 class E(Base):  # R1009
     """
-::
-    <e> = <int-literal-constant>
+    ::
+
+        e is int-literal-constant
+
+    Subject to the constraints::
+
+        C1005, C1007: e is postive and without kind parameters.
 
-Notes
------
-C1005, C1007: <e> is postive and without kind parameters.
     """
-    subclass_names = ['Digit_String']
+
+    subclass_names = ["Digit_String"]
 
 
 class V(Base):  # R1010
     """
-::
-    <v> = <signed-int-literal-constant>
+    ::
+
+        v is signed-int-literal-constant
+
+    Subject to the constraint::
+
+        C1007: w is without kind parameters.
 
-Notes
------
-C1007: <w> is without kind parameters.
     """
-    subclass_names = ['Signed_Int_Literal_Constant']
+
+    subclass_names = ["Signed_Int_Literal_Constant"]
 
 
 class Control_Edit_Desc(Base):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R1011
+    """
+    Fortran 2003 rule R1011::
 
-    control-edit-desc is position-edit-desc
-                      or [ r ] /
-                      or :
-                      or sign-edit-desc
-                      or k P
-                      or blank-interp-edit-desc
-                      or round-edit-desc
-                      or decimal-edit-desc
-                      or $
+        control-edit-desc is position-edit-desc
+                          or [ r ] /
+                          or :
+                          or sign-edit-desc
+                          or k P
+                          or blank-interp-edit-desc
+                          or round-edit-desc
+                          or decimal-edit-desc
+                          or $
 
     '$' is used to suppress the carriage return on output.  Note that
     this is an extension to the Fortran standard.
 
-    '''
-    subclass_names = ['Position_Edit_Desc', 'Sign_Edit_Desc',
-                      'Blank_Interp_Edit_Desc', 'Round_Edit_Desc',
-                      'Decimal_Edit_Desc']
-    use_names = ['R', 'K']
+    """
+
+    subclass_names = [
+        "Position_Edit_Desc",
+        "Sign_Edit_Desc",
+        "Blank_Interp_Edit_Desc",
+        "Round_Edit_Desc",
+        "Decimal_Edit_Desc",
+    ]
+    use_names = ["R", "K"]
 
     @staticmethod
     def match(string):
-        '''Check whether the input matches the rule.
+        """Check whether the input matches the rule.
 
         param str string: contains the Fortran that we are trying to \
         match.
         :return: `None` if there is no match, otherwise a `tuple` of \
         size 2 containing, None and a string with one of '/', ':', or \
         '$', an R class and a string containing '/' or a K class and a \
         string containing 'P'.
         :rtype: `NoneType`, (`NoneType`, `str`), \
         (:py:class:`fparser.two.Fortran2003.R`, `str`), or \
         (:py:class:`fparser.two.Fortran2003.K`, `str`)
 
-        '''
+        """
         if not string:
             return None
         strip_string = string.strip()
         if not strip_string:
             return None
-        if len(strip_string) == 1 and strip_string in '/:$':
+        if len(strip_string) == 1 and strip_string in "/:$":
             from fparser.two.utils import EXTENSIONS
-            if strip_string == '$' and 'dollar-descriptor' not in EXTENSIONS:
+
+            if strip_string == "$" and "dollar-descriptor" not in EXTENSIONS:
                 return None
             return None, strip_string
-        if strip_string[-1] == '/':
-            return R(strip_string[:-1].rstrip()), '/'
-        if strip_string[-1].upper() == 'P':
-            return K(strip_string[:-1].rstrip()), 'P'
+        if strip_string[-1] == "/":
+            return R(strip_string[:-1].rstrip()), "/"
+        if strip_string[-1].upper() == "P":
+            return K(strip_string[:-1].rstrip()), "P"
         return None
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of a Control Edit Descriptor
         :rtype: str
         :raises InternalError: if the length of the internal items \
         list is not 2.
         :raises InternalError: if the second entry of the internal \
         items list has no content.
 
-        '''
+        """
         if len(self.items) != 2:
             raise InternalError(
                 "Class Control_Edit_Desc method tostr() has '{0}' items, "
-                "but expecting 2.".format(len(self.items)))
+                "but expecting 2.".format(len(self.items))
+            )
         if not self.items[1]:
             raise InternalError(
                 "items[1] in Class Control_Edit_Desc method tostr() should "
-                "be an edit descriptor name but is empty or None")
+                "be an edit descriptor name but is empty or None"
+            )
         if self.items[0] is not None:
             return "{0}{1}".format(self.items[0], self.items[1])
         return "{0}".format(self.items[1])
 
 
 class K(Base):  # R1012
     """
-::
-    <k> = <signed-int-literal-constant>
+    ::
+
+        <k> = <signed-int-literal-constant>
+
+    Notes::
+
+        C1009: <k> is without kind parameters.
 
-Notes
------
-C1009: <k> is without kind parameters.
     """
-    subclass_names = ['Signed_Int_Literal_Constant']
+
+    subclass_names = ["Signed_Int_Literal_Constant"]
 
 
 class Position_Edit_Desc(Base):  # R1013
-    '''
-    Fortran 2003 rule R1013
+    """
+    Fortran 2003 rule R1013::
 
-    position-edit-desc is T n
-                       or TL n
-                       or TR n
-                       or n X
+        position-edit-desc is T n
+                           or TL n
+                           or TR n
+                           or n X
 
     where n is a positive integer.
 
     If the extensions list includes the string 'x-format' then 'X'
     without a preceeding integer is also matched. This is a common
     extension in Fortran compilers.
 
-    '''
+    """
+
     subclass_names = []
-    use_names = ['N']
+    use_names = ["N"]
 
     @staticmethod
     def match(string):
-        '''Check whether the input matches the rule.
+        """Check whether the input matches the rule.
 
         param str string: contains the Fortran that we are trying to \
         match.
         :return: `None` if there is no match, otherwise a `tuple` of \
         size 2 either containing a `string` which is one of "T", "TL" \
         or "TR", followed by an `N` class, or containing an `N` class, \
         or `None`, followed by an "X".
         :rtype: `NoneType`, (`str`, \
         :py:class:`fparser.two.Fortran2003.N`), \
         (:py:class:`fparser.two.Fortran2003.N`, `str`) or (`NoneType`, \
         `str`)
 
-        '''
+        """
         if not string:
             return None
         strip_string_upper = string.strip().upper()
         if not strip_string_upper:
             # empty input string
             return None
-        if strip_string_upper[0] == 'T':
+        if strip_string_upper[0] == "T":
             if not len(strip_string_upper) > 1:
                 # string is not long enough to be valid
                 return None
-            if strip_string_upper[1] in 'LR':
+            if strip_string_upper[1] in "LR":
                 # We match TL* or TR* where * is stored in variable
                 # rest
                 start = strip_string_upper[:2]
                 rest = strip_string_upper[2:].lstrip()
             else:
                 # We match T* where * is stored in variable rest
                 start = strip_string_upper[0]
                 rest = strip_string_upper[1:].lstrip()
             # Note, if class N does not match it raises an exception
             number_obj = N(rest)
             return start, number_obj
-        if strip_string_upper[-1] == 'X':
+        if strip_string_upper[-1] == "X":
             # We match *X
             from fparser.two.utils import EXTENSIONS
+
             if "x-format" in EXTENSIONS and len(strip_string_upper) == 1:
                 # The match just contains 'X' which is not valid
                 # fortran 2003 but is an accepted extension
                 return None, "X"
             # Note, if class N does not match it raises an
             # exception
             number_obj = N(strip_string_upper[:-1].rstrip())
-            return number_obj, 'X'
+            return number_obj, "X"
         else:
             return None
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of a Position Edit Descriptor
         :rtype: str
         :raises InternalError: if the length of the internal items \
         list is not 2.
         :raises InternalError: if the second entry of the internal \
         items list has no content.
 
-        '''
+        """
         if not len(self.items) == 2:
             raise InternalError(
                 "Class Position_Edit_Desc method tostr() has '{0}' items, "
-                "but expecting 2.".format(len(self.items)))
+                "but expecting 2.".format(len(self.items))
+            )
         if not self.items[1]:
             raise InternalError(
                 "items[1] in Class Position_Edit_Desc method tostr() is "
-                "empty or None")
+                "empty or None"
+            )
         if self.items[0]:
             return "{0}{1}".format(self.items[0], self.items[1])
         # This output is only required for the "x-format" extension.
         return "{0}".format(self.items[1])
 
 
 class N(Base):  # R1014
     """
-::
-    <n> = <int-literal-constant> == <digit-string>
+    ::
+
+        <n> = <int-literal-constant> == <digit-string>
+
+    Subject to::
+
+        C1010, C1011: <n> is positive and without kind parameter.
 
-C1010, C1011: <n> is positive and without kind parameter.
     """
-    subclass_names = ['Digit_String']
+
+    subclass_names = ["Digit_String"]
 
 
 class Sign_Edit_Desc(STRINGBase):  # R1015
     """
-    <sign-edit-desc> = SS
-                       | SP
-                       | S
+    ::
+
+        <sign-edit-desc> = SS
+                           | SP
+                           | S
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['SS', 'SP', 'S'], string)
-    match = staticmethod(match)
+        return STRINGBase.match(["SS", "SP", "S"], string)
 
 
 class Blank_Interp_Edit_Desc(STRINGBase):  # R1016
     """
-    <blank-interp-edit-desc> = BN
-                               | BZ
+    ::
+
+        <blank-interp-edit-desc> = BN
+                                 | BZ
+
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['BN', 'BZ', ], string)
-    match = staticmethod(match)
+        return STRINGBase.match(["BN", "BZ"], string)
 
 
 class Round_Edit_Desc(STRINGBase):  # R1017
     """
-    <round-edit-desc> = RU
-                        | RD
-                        | RZ
-                        | RN
-                        | RC
-                        | RP
+    ::
+
+        <round-edit-desc> = RU
+                            | RD
+                            | RZ
+                            | RN
+                            | RC
+                            | RP
 
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['RU', 'RD', 'RZ', 'RN', 'RC', 'RP'],
-                                string)
-    match = staticmethod(match)
+        return STRINGBase.match(["RU", "RD", "RZ", "RN", "RC", "RP"], string)
 
 
 class Decimal_Edit_Desc(STRINGBase):  # R1018
     """
     <decimal-edit-desc> = DC
                           | DP
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match(['DC', 'DP'], string)
-    match = staticmethod(match)
+        return STRINGBase.match(["DC", "DP"], string)
 
 
 class Char_String_Edit_Desc(Base):  # R1019
     """
     <char-string-edit-desc> = <char-literal-constant>
     """
-    subclass_names = ['Char_Literal_Constant']
+
+    subclass_names = ["Char_Literal_Constant"]
+
 
 #
 # SECTION 11
 #
 
 
 class Main_Program(BlockBase):  # R1101 [C1101, C1102, C1103]
-    '''Fortran 2003 rule R1101
+    """
+    Fortran 2003 rule R1101::
+
+        main-program is program-stmt
+                        [ specification-part ]
+                        [ execution-part ]
+                        [ internal-subprogram-part ]
+                        end-program-stmt
 
     This class does not cater for the case where there is no
     program-stmt. The separate Main_Program0() class matches this
     situation. See Class Program() method match() for how this is
     implemented.
 
-    main-program is program-stmt
-                    [ specification-part ]
-                    [ execution-part ]
-                    [ internal-subprogram-part ]
-                    end-program-stmt
-
     C1101 In a main-program, the execution-part shall not contain a
     RETURN statement or an ENTRY statement. This is currently not
     checked, see issue #140.
 
     C1102 The program-name may be included in the end-program-stmt
     only if the optional program-stmt is used and, if included, shall
     be identical to the program-name specified in the program-stmt.
 
     C1103 An automatic object shall not appear in the
     specification-part (R204) of a main program. This is currently not
     checked, see issue #140.
 
-    '''
+    """
+
     subclass_names = []
-    use_names = ['Program_Stmt', 'Specification_Part', 'Execution_Part',
-                 'Internal_Subprogram_Part', 'End_Program_Stmt']
+    use_names = [
+        "Program_Stmt",
+        "Specification_Part",
+        "Execution_Part",
+        "Internal_Subprogram_Part",
+        "End_Program_Stmt",
+    ]
 
     @staticmethod
     def match(reader):
-        '''Implements the matching of a main program which has a Program
+        """Implements the matching of a main program which has a Program
         statement. See class Main_Program0 for matching without a
         Program Statement. Matching uses `BlockBase` as it conforms to
         the start/end with optional content pattern. `match_names` is
         set to `True` so that different names e.g. `program x` and
         `end program y` will not match.
 
         :param reader: the Fortran reader containing the line(s) of \
@@ -8451,291 +10807,433 @@
                 :py:class:`fparser.two.Fortran2003.Specification_Part`, \
                 optional \
                 :py:class:`fparser.two.Fortran2003.Execution_Part`, \
                 optional \
                 :py:class:`fparser.two.Fortran2003.Internal_Subprogram_Part`, \
                 :py:class:`fparser.two.Fortran2003.End_Program_Stmt`])
 
-        '''
+        """
         return BlockBase.match(
-            Program_Stmt, [Specification_Part, Execution_Part,
-                           Internal_Subprogram_Part], End_Program_Stmt,
-            reader, match_names=True, strict_order=True)
+            Program_Stmt,
+            [Specification_Part, Execution_Part, Internal_Subprogram_Part],
+            End_Program_Stmt,
+            reader,
+            match_names=True,
+            strict_order=True,
+        )
 
 
 class Main_Program0(BlockBase):
-    """<main-program> =
+    """
+    Rule 1101 specifies that the opening 'program-stmt' is optional. This
+    class handles the special case when it is not supplied and thus
+    matches on::
+
+        <main-program> =
                          [ <specification-part> ]
                          [ <execution-part> ]
                          [ <internal-subprogram-part> ]
                          <end-program-stmt>
 
     C1102 The program-name may be included in the end-program-stmt
     only if the optional program-stmt is used and, if included, shall
     be identical to the program-name specified in the
     program-stmt.
 
     In this class an end program name is not allowed due to C1102.
 
     """
+
     subclass_names = []
-    use_names = ['Program_Stmt', 'Specification_Part',
-                 'Execution_Part', 'Internal_Subprogram_Part',
-                 'End_Program_Stmt']
+    use_names = [
+        "Program_Stmt",
+        "Specification_Part",
+        "Execution_Part",
+        "Internal_Subprogram_Part",
+        "End_Program_Stmt",
+    ]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(None,
-                               [Specification_Part, Execution_Part,
-                                Internal_Subprogram_Part],
-                               End_Program_Stmt, reader)
+        """
+        Attempts to match the content in the reader with a program that is
+        missing the optional opening program-stmt (R1101). If the match
+        is successful, a symbol table named "fparser2:main_program" is
+        also created.
+
+        :param reader: Content to check for match
+        :type reader: str or instance of :py:class:`FortranReaderBase`
+
+        :return: 2-tuple of (list of matched classes,  None) or None \
+                 if no match is found.
+        :rtype: (list of matched classes, None) or NoneType
 
+        """
+        # For this special case we have to supply a name for the top-level
+        # symbol table. We include a ':' so that it is not a valid Fortran
+        # name and therefore cannot clash with any routine names.
+        table_name = "fparser2:main_program"
+        SYMBOL_TABLES.enter_scope(table_name)
+
+        result = BlockBase.match(
+            None,
+            [Specification_Part, Execution_Part, Internal_Subprogram_Part],
+            End_Program_Stmt,
+            reader,
+        )
+
+        SYMBOL_TABLES.exit_scope()
+        if not result:
+            # The match failed so remove the associated symbol table
+            SYMBOL_TABLES.remove(table_name)
+
+        return result
 
-class Program_Stmt(StmtBase, WORDClsBase):  # R1102
-    '''
-    Fortran 2003 rule R1102
-    program-stmt is PROGRAM program-name
 
-    '''
+class Program_Stmt(StmtBase, WORDClsBase, ScopingRegionMixin):  # R1102
+    """
+    Fortran 2003 rule R1102::
+
+        program-stmt is PROGRAM program-name
+
+    """
+
     subclass_names = []
-    use_names = ['Program_Name']
+    use_names = ["Program_Name"]
 
     @staticmethod
     def match(string):
-        '''Implements the matching for a Program Statement. Makes use of
+        """Implements the matching for a Program Statement. Makes use of
         `WORDClsBase`, as the required match is a string followed by a
         class. The class is made compulsory for the match as the
         PROGRAM keyword is not valid without a program name.
 
         :param str string: Fortran code to check for a match
         :returns: `None` if there is no match or, if there is a match, \
                   a tuple of size 2 with the first entry being the \
                   string 'PROGRAM' and the second entry being a `Name` \
                   class containing the name of the program.
         :rtype: `NoneType` or ( `str`, \
                 :py:class:`fparser.two.Fortran2003.Name` )
 
-        '''
-        return WORDClsBase.match('PROGRAM', Program_Name, string,
-                                 require_cls=True)
+        """
+        return WORDClsBase.match("PROGRAM", Program_Name, string, require_cls=True)
 
     def get_name(self):
-        '''Provides the program name as an instance of the `Name` class.
+        """Provides the program name as an instance of the `Name` class.
 
-        :returns: the program name as a `Name` class
-        :rtype: `Name`
+        :returns: the program name as a :py:class:`Name` class
+        :rtype: :py:class:`Name`
 
-        '''
+        """
         return self.items[1]
 
     def get_start_name(self):
-        '''Provides the program name as a string. This is used for matching
+        """Provides the program name as a string. This is used for matching
         with the equivalent `end program` name if there is one.
 
         :returns: the program name as a string
         :rtype: str
 
-        '''
+        """
         return self.get_name().string
 
 
 class End_Program_Stmt(EndStmtBase):  # R1103
     """
     <end-program-stmt> = END [ PROGRAM [ <program-name> ] ]
     """
+
     subclass_names = []
-    use_names = ['Program_Name']
+    use_names = ["Program_Name"]
 
     @staticmethod
     def match(string):
-        return EndStmtBase.match('PROGRAM', Program_Name, string)
+        return EndStmtBase.match("PROGRAM", Program_Name, string)
 
 
 class Module(BlockBase):  # R1104
     """
-    <module> = <module-stmt>
-                   [ <specification-part> ]
-                   [ <module-subprogram-part> ]
-                   <end-module-stmt>
+    ::
+
+        <module> = <module-stmt>
+                       [ <specification-part> ]
+                       [ <module-subprogram-part> ]
+                       <end-module-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Module_Stmt', 'Specification_Part',
-                 'Module_Subprogram_Part', 'End_Module_Stmt']
+    use_names = [
+        "Module_Stmt",
+        "Specification_Part",
+        "Module_Subprogram_Part",
+        "End_Module_Stmt",
+    ]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Module_Stmt,
-                               [Specification_Part, Module_Subprogram_Part],
-                               End_Module_Stmt, reader)
+        return BlockBase.match(
+            Module_Stmt,
+            [Specification_Part, Module_Subprogram_Part],
+            End_Module_Stmt,
+            reader,
+        )
 
 
-class Module_Stmt(StmtBase, WORDClsBase):  # R1105
+class Module_Stmt(StmtBase, WORDClsBase, ScopingRegionMixin):  # R1105
     """
     <module-stmt> = MODULE <module-name>
     """
+
     subclass_names = []
-    use_names = ['Module_Name']
+    use_names = ["Module_Name"]
 
     @staticmethod
     def match(string):
-        return WORDClsBase.match('MODULE', Module_Name, string,
-                                 require_cls=True)
+        return WORDClsBase.match("MODULE", Module_Name, string, require_cls=True)
 
     def get_name(self):
         return self.items[1]
 
 
 class End_Module_Stmt(EndStmtBase):  # R1106
     """
     <end-module-stmt> = END [ MODULE [ <module-name> ] ]
     """
+
     subclass_names = []
-    use_names = ['Module_Name']
+    use_names = ["Module_Name"]
 
     @staticmethod
     def match(string):
-        return EndStmtBase.match('MODULE', Module_Name, string)
+        return EndStmtBase.match("MODULE", Module_Name, string)
 
 
 class Module_Subprogram_Part(BlockBase):  # R1107
     """
-    <module-subprogram-part> = <contains-stmt>
-                                   <module-subprogram>
-                                   [ <module-subprogram> ]...
+    ::
+
+        <module-subprogram-part> = <contains-stmt>
+                                       <module-subprogram>
+                                       [ <module-subprogram> ]...
+
     """
+
     subclass_names = []
-    use_names = ['Contains_Stmt', 'Module_Subprogram']
+    use_names = ["Contains_Stmt", "Module_Subprogram"]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Contains_Stmt, [Module_Subprogram],
-                               None, reader)
+        return BlockBase.match(Contains_Stmt, [Module_Subprogram], None, reader)
 
 
 class Module_Subprogram(Base):  # R1108
     """
-    <module-subprogram> = <function-subprogram>
-                          | <subroutine-subprogram>
+    ::
+
+        <module-subprogram> = <function-subprogram>
+                              | <subroutine-subprogram>
+
     """
-    subclass_names = ['Function_Subprogram', 'Subroutine_Subprogram']
+
+    subclass_names = ["Function_Subprogram", "Subroutine_Subprogram"]
 
 
 class Use_Stmt(StmtBase):  # pylint: disable=invalid-name
-    '''
-    Fortran 2003 rule R1109
+    """
+    Fortran 2003 rule R1109::
+
+        use-stmt is USE [ [ , module-nature ] :: ] module-name [ , rename-list ]
+                 or USE [ [ , module-nature ] :: ] module-name ,
+                     ONLY : [ only-list ]
 
-    use-stmt is USE [ [ , module-nature ] :: ] module-name [ , rename-list ]
-             or USE [ [ , module-nature ] :: ] module-name ,
-                 ONLY : [ only-list ]
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Module_Nature', 'Module_Name', 'Rename_List', 'Only_List']
+    use_names = ["Module_Nature", "Module_Name", "Rename_List", "Only_List"]
 
     @staticmethod
     def match(string):
-        '''
-        :param str string: Fortran code to check for a match
+        """
+        Wrapper for the match method that captures any successfully-matched
+        use statements in the symbol table associated with the current scope
+        (if there is one).
+
+        TODO #379 - currently operator imports/renaming are not captured in
+                    the symbol table.
+
+        :param str string: Fortran code to check for a match.
+
         :return: 5-tuple containing strings and instances of the classes
                  describing a module (optional module nature, optional
                  double colon delimiter, mandatory module name, optional
                  "ONLY" specification and optional "Rename" or "Only" list)
+                 or None if the match fails.
+        :rtype: 5-tuple of objects (module name and 4 optional) or NoneType
+
+        :raises InternalError: if an Only_List is found to contain anything \
+                               other than Name or Rename objects.
+
+        """
+        result = Use_Stmt._match(string)
+        if result:
+            table = SYMBOL_TABLES.current_scope
+            if table:
+                only_list = None
+                rename_list = None
+                if "only" in result[3].lower():
+                    only_list = []
+                if isinstance(result[4], Only_List):
+                    # An Only_List can contain either Name or Rename entries.
+                    for child in result[4].children:
+                        if isinstance(child, Name):
+                            only_list.append((child.string, None))
+                        elif isinstance(child, Rename):
+                            if not child.children[0]:
+                                # This is a Rename of a symbol rather than an operator
+                                # (which would have child.children[0] == 'OPERATOR'.
+                                # TODO #379 - support operators.
+                                only_list.append(
+                                    (child.children[1].string, child.children[2].string)
+                                )
+                        elif isinstance(child, Generic_Spec):
+                            # For now we ignore anything other than symbol names
+                            # and this includes operators (TODO #379).
+                            pass
+                        else:
+                            raise InternalError(
+                                f"An Only_List can contain only Name, Rename or "
+                                f"Generic_Spec entries but found "
+                                f"'{type(child).__name__}' when matching '{string}'"
+                            )
+                elif isinstance(result[4], Rename_List):
+                    # Tuples of <local-name>, <use-name>
+                    rename_list = []
+                    for rename in walk(result[4], Rename):
+                        # For now we exclude any operators in the Rename_List
+                        # (these have rename.children[0] == 'OPERATOR').
+                        # TODO #379.
+                        if rename.children[0] is None:
+                            rename_list.append(
+                                (rename.children[1].string, rename.children[2].string)
+                            )
+
+                table.add_use_symbols(str(result[2]), only_list, rename_list)
+
+        return result
+
+    @staticmethod
+    def _match(string):
+        """
+        :param str string: Fortran code to check for a match.
+
+        :return: 5-tuple containing strings and instances of the classes
+                 describing a module (optional module nature, optional
+                 double colon delimiter, mandatory module name, optional
+                 "ONLY" specification and optional "Rename" or "Only" list).
         :rtype: 5-tuple of objects (module name and 4 optional)
-        '''
+
+        """
         line = string.strip()
         # Incorrect 'USE' statement or line too short
-        if line[:3].upper() != 'USE':
-            return
+        if line[:3].upper() != "USE":
+            return None
         line = line[3:]
         # Empty string after 'USE'
         if not line:
-            return
+            return None
         # No separation between 'USE' statement and its specifiers
         if line[0].isalnum():
-            return
+            return None
         line = line.lstrip()
-        i = line.find('::')
+        idx = line.find("::")
         nature = None
         dcolon = None
-        if i != -1:
+        if idx != -1:
             # The nature of the module ("intrinsic" or
             # "non-intrinsic") is specified
-            dcolon = '::'
-            if line.startswith(','):
-                line_nat = line[1:i].strip()
+            dcolon = "::"
+            if line.startswith(","):
+                line_nat = line[1:idx].strip()
                 # Missing Module_Nature between ',' and '::'
                 if not line_nat:
-                    return
+                    return None
                 nature = Module_Nature(line_nat)
-            line = line[i+2:].lstrip()
+            line = line[idx + 2 :].lstrip()
             # No Module_Name after 'USE, Module_Nature ::'
             if not line:
-                return
+                return None
         else:
             # Check for missing '::' after Module_Nature
             items = re.findall(r"[\w']+", line)
             for item in items:
                 try:
                     nature = Module_Nature(item)
                 except NoMatchError:
                     pass
             # Missing '::' after Module_Nature
             if nature is not None:
                 return
 
-        position = line.find(',')
+        position = line.find(",")
         if position == -1:
-            return nature, dcolon, Module_Name(line), '', None
+            return nature, dcolon, Module_Name(line), "", None
         name = line[:position].rstrip()
         # Missing Module_Name before Only_List
         if not name:
-            return
+            return None
         name = Module_Name(name)
-        line = line[position+1:].lstrip()
+        line = line[position + 1 :].lstrip()
         # Missing 'ONLY' specification after 'USE Module_Name,'
         if not line:
-            return
-        if line[:4].upper() == 'ONLY':
+            return None
+        if line[:4].upper() == "ONLY":
             line = line[4:].lstrip()
             if not line:
                 # Expected ':' but there is nothing after the 'ONLY'
                 # specification
-                return
-            if line[0] != ':':
+                return None
+            if line[0] != ":":
                 # Expected ':' but there is a different character
                 # after the 'ONLY' specification
-                return
+                return None
             line = line[1:].lstrip()
             if not line:
                 # Missing Only_List after 'USE Module_Name, ONLY:'
-                return nature, dcolon, name, ', ONLY:', None
-            return nature, dcolon, name, ', ONLY:', Only_List(line)
-        return nature, dcolon, name, ',', Rename_List(line)
+                return nature, dcolon, name, ", ONLY:", None
+            return nature, dcolon, name, ", ONLY:", Only_List(line)
+        return nature, dcolon, name, ",", Rename_List(line)
 
     def tostr(self):
-        '''
+        """
         :return: parsed representation of "USE" statement
         :rtype: string
         :raises InternalError: if items array is not the expected size
         :raises InternalError: if items array[2] is not a string or is an \
                                empty string
         :raises InternalError: if items array[3] is 'None' as it should be \
                                a string
-        '''
+        """
         if len(self.items) != 5:
             raise InternalError(
                 "Use_Stmt.tostr(). 'Items' should be of size 5 but found "
-                "'{0}'.".format(len(self.items)))
+                "'{0}'.".format(len(self.items))
+            )
         if not self.items[2]:
-            raise InternalError("Use_Stmt.tostr(). 'Items' entry 2 should "
-                                "be a module name but it is empty")
+            raise InternalError(
+                "Use_Stmt.tostr(). 'Items' entry 2 should "
+                "be a module name but it is empty"
+            )
         if self.items[3] is None:
-            raise InternalError("Use_Stmt.tostr(). 'Items' entry 3 should "
-                                "be a string but found 'None'")
-        usestmt = 'USE'
+            raise InternalError(
+                "Use_Stmt.tostr(). 'Items' entry 3 should "
+                "be a string but found 'None'"
+            )
+        usestmt = "USE"
         # Add optional Module_Nature ("INTRINSIC" or "NON_INTRINSIC")
         # followed by a double colon to "USE" statement
         if self.items[0] and self.items[1]:
             usestmt += ", {0} {1}".format(self.items[0], self.items[1])
         # Add optional double colon after "USE" statement without
         # Module_Nature (valid Fortran)
         elif not self.items[0] and self.items[1]:
@@ -8746,742 +11244,958 @@
         if self.items[4] is not None:
             usestmt += " {0}".format(self.items[4])
         return usestmt
 
 
 class Module_Nature(STRINGBase):  # pylint: disable=invalid-name
     """
-    R1110
+    R1110::
+
+        <module-nature> = INTRINSIC
+                          | NON_INTRINSIC
 
-    <module-nature> = INTRINSIC
-                      | NON_INTRINSIC
     """
+
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''
+        """
         :param str string: Fortran code to check for a match
         :return: keyword describing module nature ("INTRINSIC" or
                  "NON_INTRINSIC") or nothing if no match is found
         :rtype: string
-        '''
-        return STRINGBase.match(['INTRINSIC', 'NON_INTRINSIC'], string)
+        """
+        return STRINGBase.match(["INTRINSIC", "NON_INTRINSIC"], string)
 
 
 class Rename(Base):  # R1111
     """
-    <rename> = <local-name> => <use-name>
-               | OPERATOR(<local-defined-operator>) =>
-                 OPERATOR(<use-defined-operator>)
+    Class defining Rule #R1111::
+
+        rename is local-name => use-name
+               or OPERATOR(local-defined-operator) => OPERATOR(use-defined-operator)
+
+    where::
+
+        local-defined-operator is defined-uary-op or defined-binary-op
+        defined-binary-op is .letter [letter] ... .
+
     """
+
     subclass_names = []
-    use_names = ['Local_Name', 'Use_Name', 'Local_Defined_Operator',
-                 'Use_Defined_Operator']
+    use_names = [
+        "Local_Name",
+        "Use_Name",
+        "Local_Defined_Operator",
+        "Use_Defined_Operator",
+    ]
 
+    @staticmethod
     def match(string):
-        s = string.split('=>', 1)
-        if len(s) != 2:
-            return
-        lhs, rhs = s[0].rstrip(), s[1].lstrip()
+        """
+        :param str string: the string to attempt to match.
+
+        :returns: three tuple containing description, local name, remote name.
+        :rtype: Optional[ \
+                    Tuple[Optional[str], \
+                          :py:class:`fparser.two.Fortran2003.Local_Name` | \
+                          :py:class:`fparser.two.Fortran2003.Local_Defined_Operator`, \
+                          :py:class:`fparser.two.Fortran2003.Use_Name` | \
+                          :py:class:`fparser.two.Fortran2003.Use_Defined_Operator`]]
+        """
+        parts = string.split("=>", 1)
+        if len(parts) != 2:
+            return None
+        lhs, rhs = parts[0].rstrip(), parts[1].lstrip()
         if not lhs or not rhs:
-            return
-        if lhs[:8].upper() == 'OPERATOR' and rhs[:8].upper() == 'OPERATOR':
+            return None
+        if lhs[:8].upper() == "OPERATOR" and rhs[:8].upper() == "OPERATOR":
             tmp = lhs[8:].lstrip()
-            r = rhs[8:].lstrip()
-            if tmp and r and tmp[0] + tmp[-1] == '()':
-                if r[0]+r[-1] != '()':
-                    return
+            rhs_op = rhs[8:].lstrip()
+            if tmp and rhs_op and tmp[0] == "(" and tmp[-1] == ")":
+                if rhs_op[0] != "(" or rhs_op[-1] != ")":
+                    return None
                 tmp = tmp[1:-1].strip()
-                r = r[1:-1].strip()
-                if not tmp or not r:
-                    return
-                return 'OPERATOR', Local_Defined_Operator(tmp), \
-                    Use_Defined_Operator(r)
+                rhs_op = rhs_op[1:-1].strip()
+                if not tmp or not rhs_op:
+                    return None
+                return (
+                    "OPERATOR",
+                    Local_Defined_Operator(tmp),
+                    Use_Defined_Operator(rhs_op),
+                )
         return None, Local_Name(lhs), Use_Name(rhs)
-    match = staticmethod(match)
 
     def tostr(self):
+        """
+        :returns: the string representation of this Rename object.
+        :rtype: str
+        """
         if not self.items[0]:
-            return '%s => %s' % self.items[1:]
-        return '%s(%s) => %s(%s)' % (self.items[0], self.items[1],
-                                     self.items[0], self.items[2])
+            # Not an operator.
+            return f"{self.children[1]} => {self.children[2]}"
+        # This represents the renaming of an Operator.
+        return (
+            f"{self.children[0]}({self.children[1]}) => "
+            f"{self.children[0]}({self.children[2]})"
+        )
 
 
 class Only(Base):  # R1112
     """
-    <only> = <generic-spec>
-             | <only-use-name>
-             | <rename>
+    ::
+
+        <only> = <generic-spec>
+                 | <only-use-name>
+                 | <rename>
+
     """
-    subclass_names = ['Generic_Spec', 'Only_Use_Name', 'Rename']
+
+    subclass_names = ["Generic_Spec", "Only_Use_Name", "Rename"]
 
 
 class Only_Use_Name(Base):  # R1113
     """
-    <only-use-name> = <name>
+    ::
+
+        <only-use-name> = <name>
+
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Local_Defined_Operator(Base):  # R1114
     """
-    <local-defined-operator> = <defined-unary-op>
-                               | <defined-binary-op>
+    ::
+
+        <local-defined-operator> = <defined-unary-op>
+                                   | <defined-binary-op>
+
     """
-    subclass_names = ['Defined_Unary_Op', 'Defined_Binary_Op']
+
+    subclass_names = ["Defined_Unary_Op", "Defined_Binary_Op"]
 
 
 class Use_Defined_Operator(Base):  # R1115
     """
-    <use-defined-operator> = <defined-unary-op>
-                             | <defined-binary-op>
+    ::
+
+        <use-defined-operator> = <defined-unary-op>
+                                 | <defined-binary-op>
+
     """
-    subclass_names = ['Defined_Unary_Op', 'Defined_Binary_Op']
+
+    subclass_names = ["Defined_Unary_Op", "Defined_Binary_Op"]
 
 
 class Block_Data(BlockBase):  # R1116
     """
-::
-    <block-data> = <block-data-stmt>
-                       [ <specification-part> ]
-                       <end-block-data-stmt>
+    ::
+        <block-data> = <block-data-stmt>
+                           [ <specification-part> ]
+                           <end-block-data-stmt>
     """
+
     subclass_names = []
-    use_names = ['Block_Data_Stmt', 'Specification_Part',
-                 'End_Block_Data_Stmt']
+    use_names = ["Block_Data_Stmt", "Specification_Part", "End_Block_Data_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Block_Data_Stmt, [Specification_Part],
-            End_Block_Data_Stmt, reader)
+            Block_Data_Stmt, [Specification_Part], End_Block_Data_Stmt, reader
+        )
 
 
 class Block_Data_Stmt(StmtBase):  # R1117
     """
-::
-    <block-data-stmt> = BLOCK DATA [ <block-data-name> ]
+    ::
+
+        <block-data-stmt> = BLOCK DATA [ <block-data-name> ]
+
     """
+
     subclass_names = []
-    use_names = ['Block_Data_Name']
+    use_names = ["Block_Data_Name"]
 
     @staticmethod
     def match(string):
-        if string[:5].upper() != 'BLOCK':
+        if string[:5].upper() != "BLOCK":
             return
         line = string[5:].lstrip()
-        if line[:4].upper() != 'DATA':
+        if line[:4].upper() != "DATA":
             return
         line = line[4:].lstrip()
         if not line:
-            return None,
-        return Block_Data_Name(line),
+            return (None,)
+        return (Block_Data_Name(line),)
 
     def tostr(self):
         if self.items[0] is None:
-            return 'BLOCK DATA'
-        return 'BLOCK DATA %s' % self.items
+            return "BLOCK DATA"
+        return "BLOCK DATA %s" % self.items
 
     def get_name(self):
         return self.items[0]
 
 
 class End_Block_Data_Stmt(EndStmtBase):  # R1118
     """
-::
-    <end-block-data-stmt> = END [ BLOCK DATA [ <block-data-name> ] ]
+    ::
+
+        <end-block-data-stmt> = END [ BLOCK DATA [ <block-data-name> ] ]
+
     """
+
     subclass_names = []
-    use_names = ['Block_Data_Name']
+    use_names = ["Block_Data_Name"]
 
     @staticmethod
     def match(string):
-        return EndStmtBase.match('BLOCK DATA', Block_Data_Name, string)
+        return EndStmtBase.match("BLOCK DATA", Block_Data_Name, string)
 
 
 #
 # SECTION 12
 #
 
 
 class Interface_Block(BlockBase):  # R1201
     """
-::
-    <interface-block> = <interface-stmt>
-                            [ <interface-specification> ]...
-                            <end-interface-stmt>
+    ::
+
+        <interface-block> = <interface-stmt>
+                                [ <interface-specification> ]...
+                                <end-interface-stmt>
     """
+
     subclass_names = []
-    use_names = ['Interface_Stmt', 'Interface_Specification',
-                 'End_Interface_Stmt']
+    use_names = ["Interface_Stmt", "Interface_Specification", "End_Interface_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Interface_Stmt, [Interface_Specification],
-            End_Interface_Stmt, reader)
+            Interface_Stmt, [Interface_Specification], End_Interface_Stmt, reader
+        )
 
 
 class Interface_Specification(Base):  # R1202
     """
-    <interface-specification> = <interface-body>
-                                | <procedure-stmt>
+    ::
+
+        <interface-specification> = <interface-body>
+                                    | <procedure-stmt>
+
     """
-    subclass_names = ['Interface_Body', 'Procedure_Stmt']
+
+    subclass_names = ["Interface_Body", "Procedure_Stmt"]
 
 
 class Interface_Stmt(StmtBase):  # R1203
     """
-::
-    <interface-stmt> = INTERFACE [ <generic-spec> ]
-                       | ABSTRACT INTERFACE
+    ::
+
+        <interface-stmt> = INTERFACE [ <generic-spec> ]
+                           | ABSTRACT INTERFACE
+
+    Attributes::
+
+        items : ({Generic_Spec, 'ABSTRACT'},)
 
-Attributes
-----------
-items : ({Generic_Spec, 'ABSTRACT'},)
     """
+
     subclass_names = []
-    use_names = ['Generic_Spec']
+    use_names = ["Generic_Spec"]
 
     @staticmethod
     def match(string):
-        if string[:9].upper() == 'INTERFACE':
+        if string[:9].upper() == "INTERFACE":
             line = string[9:].strip()
             if not line:
-                return None,
-            return Generic_Spec(line),
-        if string[:8].upper() == 'ABSTRACT':
+                return (None,)
+            return (Generic_Spec(line),)
+        if string[:8].upper() == "ABSTRACT":
             line = string[8:].strip()
-            if line.upper() == 'INTERFACE':
-                return 'ABSTRACT',
+            if line.upper() == "INTERFACE":
+                return ("ABSTRACT",)
 
     def tostr(self):
-        if self.items[0] == 'ABSTRACT':
-            return 'ABSTRACT INTERFACE'
+        if self.items[0] == "ABSTRACT":
+            return "ABSTRACT INTERFACE"
         if self.items[0] is None:
-            return 'INTERFACE'
-        return 'INTERFACE %s' % (self.items[0])
+            return "INTERFACE"
+        return "INTERFACE %s" % (self.items[0])
 
 
 class End_Interface_Stmt(EndStmtBase):  # R1204
     """
-::
-    <end-interface-stmt> = END INTERFACE [ <generic-spec> ]
+    ::
+
+        <end-interface-stmt> = END INTERFACE [ <generic-spec> ]
+
+    Attributes::
+
+        items : (Generic_Spec, )
 
-Attributes
-----------
-items : (Generic_Spec, )
     """
+
     subclass_names = []
-    use_names = ['Generic_Spec']
+    use_names = ["Generic_Spec"]
 
+    @staticmethod
     def match(string):
         return EndStmtBase.match(
-            'INTERFACE', Generic_Spec, string, require_stmt_type=True)
-    match = staticmethod(match)
+            "INTERFACE", Generic_Spec, string, require_stmt_type=True
+        )
 
 
 class Function_Body(BlockBase):
     """
-::
-    <function-body> = <function-stmt>
-                        [ <specification-part> ]
-                      <end-function-stmt>
+    ::
+
+        <function-body> = <function-stmt>
+                            [ <specification-part> ]
+                          <end-function-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Function_Stmt', 'Specification_Part', 'End_Function_Stmt']
+    use_names = ["Function_Stmt", "Specification_Part", "End_Function_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Function_Stmt, [Specification_Part],
-            End_Function_Stmt, reader)
+            Function_Stmt, [Specification_Part], End_Function_Stmt, reader
+        )
 
 
 class Subroutine_Body(BlockBase):
     """
-::
-    <subroutine-body> = <subroutine-stmt>
-                        [ <specification-part> ]
-                      <end-subroutine-stmt>
+    ::
+
+        <subroutine-body> = <subroutine-stmt>
+                            [ <specification-part> ]
+                          <end-subroutine-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Subroutine_Stmt', 'Specification_Part',
-                 'End_Subroutine_Stmt']
+    use_names = ["Subroutine_Stmt", "Specification_Part", "End_Subroutine_Stmt"]
 
     @staticmethod
     def match(reader):
         return BlockBase.match(
-            Subroutine_Stmt, [Specification_Part],
-            End_Subroutine_Stmt, reader)
+            Subroutine_Stmt, [Specification_Part], End_Subroutine_Stmt, reader
+        )
 
 
 class Interface_Body(Base):  # R1205
     """
-::
-    <interface-body> = <function-body> | <subroutine-body>
+    ::
+
+        <interface-body> = <function-body> | <subroutine-body>
+
+    See also :py:class:`fparser.two.Fortran2003.Function_Body` and
+    :py:class:`fparser.two.Fortran2003.Subroutine_Body`
 
-See also
---------
-Function_Body, Subroutine_Body
     """
-    subclass_names = ['Function_Body', 'Subroutine_Body']
+
+    subclass_names = ["Function_Body", "Subroutine_Body"]
     use_names = []
 
 
 class Procedure_Stmt(StmtBase):  # R1206
     """
-::
-    <procedure-stmt> = [ MODULE ] PROCEDURE <procedure-name-list>
+    ::
+
+        <procedure-stmt> = [ MODULE ] PROCEDURE <procedure-name-list>
+
+    Attributes::
+
+        items : (Procedure_Name_List, )
 
-Attributes
-----------
-items : (Procedure_Name_List, )
     """
+
     subclass_names = []
-    use_names = ['Procedure_Name_List']
+    use_names = ["Procedure_Name_List"]
 
     @staticmethod
     def match(string):
-        if string[:6].upper() == 'MODULE':
+        if string[:6].upper() == "MODULE":
             line = string[6:].lstrip()
         else:
             line = string
-        if line[:9].upper() != 'PROCEDURE':
+        if line[:9].upper() != "PROCEDURE":
             return
         line = line[9:].lstrip()
-        return Procedure_Name_List(line),
+        return (Procedure_Name_List(line),)
 
     def tostr(self):
-        return 'MODULE PROCEDURE %s' % (self.items[0])
+        return "MODULE PROCEDURE %s" % (self.items[0])
 
 
 class Generic_Spec(Base):  # R1207
     """
-::
-    <generic-spec> = <generic-name>
-                     | OPERATOR ( <defined-operator> )
-                     | ASSIGNMENT ( = )
-                     | <dtio-generic-spec>
-Attributes
-----------
-items : ({'OPERATOR', 'ASSIGNMENT'}, {Defined_Operator, '='})
+    ::
+
+        <generic-spec> = <generic-name>
+                         | OPERATOR ( <defined-operator> )
+                         | ASSIGNMENT ( = )
+                         | <dtio-generic-spec>
+    Attributes::
+
+        items : ({'OPERATOR', 'ASSIGNMENT'}, {Defined_Operator, '='})
+
     """
-    subclass_names = ['Generic_Name', 'Dtio_Generic_Spec']
-    use_names = ['Defined_Operator']
+
+    subclass_names = ["Generic_Name", "Dtio_Generic_Spec"]
+    use_names = ["Defined_Operator"]
 
     @staticmethod
     def match(string):
-        if string[:8].upper() == 'OPERATOR':
+        if string[:8].upper() == "OPERATOR":
             line = string[8:].lstrip()
-            if not line or line[0] != '(' or line[-1] != ')':
+            if not line or line[0] != "(" or line[-1] != ")":
                 return
-            return 'OPERATOR', Defined_Operator(line[1:-1].strip())
-        if string[:10].upper() == 'ASSIGNMENT':
+            return "OPERATOR", Defined_Operator(line[1:-1].strip())
+        if string[:10].upper() == "ASSIGNMENT":
             line = string[10:].lstrip()
-            if not line or line[0] != '(' or line[-1] != ')':
+            if not line or line[0] != "(" or line[-1] != ")":
                 return
-            if line[1:-1].strip() == '=':
-                return 'ASSIGNMENT', '='
+            if line[1:-1].strip() == "=":
+                return "ASSIGNMENT", "="
 
     def tostr(self):
-        return '%s(%s)' % (self.items)
+        return "%s(%s)" % (self.items)
 
 
 class Dtio_Generic_Spec(Base):  # R1208
     """
-::
-    <dtio-generic-spec> = READ ( FORMATTED )
-                          | READ ( UNFORMATTED )
-                          | WRITE ( FORMATTED )
-                          | WRITE ( UNFORMATTED )
-Attributes
-----------
-items : (str, )
+    ::
+
+        <dtio-generic-spec> = READ ( FORMATTED )
+                              | READ ( UNFORMATTED )
+                              | WRITE ( FORMATTED )
+                              | WRITE ( UNFORMATTED )
+
+    Attributes::
+
+        items : (str, )
+
     """
+
     subclass_names = []
 
     @staticmethod
     def match(string):
-        for rw in ['READ', 'WRITE']:
-            if string[:len(rw)].upper() == rw:
-                line = string[len(rw):].lstrip()
+        for rw in ["READ", "WRITE"]:
+            if string[: len(rw)].upper() == rw:
+                line = string[len(rw) :].lstrip()
                 if not line:
                     return
-                if line[0] != '(' or line[-1] != ')':
+                if line[0] != "(" or line[-1] != ")":
                     return
                 line = line[1:-1].strip().upper()
-                if line in ['FORMATTED', 'UNFORMATTED']:
-                    return '%s(%s)' % (rw, line),
+                if line in ["FORMATTED", "UNFORMATTED"]:
+                    return ("%s(%s)" % (rw, line),)
 
     def tostr(self):
-        return '%s' % (self.items[0])
+        return "%s" % (self.items[0])
 
 
-class Import_Stmt(StmtBase, WORDClsBase):  # R1209
+class Import_Stmt(StmtBase, WORDClsBase):  # pylint: disable=invalid-name
     """
-    <import-stmt> = IMPORT [ :: ] <import-name-list>
+    Fortran 2003 rule R1209::
+
+        import-stmt is IMPORT [[ :: ] import-name-list ]
+
+    C1210 (R1209) The IMPORT statement is allowed only in an
+    interface-body. Note, this constraint is not currently enforced.
+
+    C1211 (R1209) Each import-name shall be the name of an entity in
+    the host scoping unit. This constraint is not currently enforced
+    and can not be generally enforced as the name may come from a use
+    statement without an only clause.
+
     """
+
     subclass_names = []
-    use_names = ['Import_Name_List']
+    use_names = ["Import_Name_List"]
+    tostr = WORDClsBase.tostr_a
 
     @staticmethod
     def match(string):
+        """
+        Implements the matching for the import-stmt rule.
+
+        Makes use of the WORDClsBase base class.
+
+        :param str string: the string to match.
+
+        :returns: None if there is no match, otherwise a tuple of size \
+            2 containing the string `IMPORT` as the first entry and \
+            an object of type `Import_Name_List` if names are \
+            specified in the string or `None` if not.
+
+        :rtype: None, or (str, \
+            :py:class:`fparser.two.Fortran2003.Import_Name_List`) or \
+            (str, None)
+
+        """
         return WORDClsBase.match(
-            'IMPORT', Import_Name_List, string, check_colons=True,
-            require_cls=True)
-    tostr = WORDClsBase.tostr_a
+            "IMPORT", Import_Name_List, string, colons=True, require_cls=False
+        )
 
 
 class External_Stmt(StmtBase, WORDClsBase):  # R1210
     """
-    <external-stmt> = EXTERNAL [ :: ] <external-name-list>
+    ::
+
+        <external-stmt> = EXTERNAL [ :: ] <external-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['External_Name_List']
+    use_names = ["External_Name_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'EXTERNAL', External_Name_List, string,
-            check_colons=True, require_cls=True)
-    match = staticmethod(match)
+            "EXTERNAL", External_Name_List, string, colons=True, require_cls=True
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Procedure_Declaration_Stmt(StmtBase):  # R1211
     """
-::
-    <procedure-declaration-stmt> = PROCEDURE ( [ <proc-interface> ] )
-        [ [ , <proc-attr-spec> ]... :: ] <proc-decl-list>
+    ::
+
+        <procedure-declaration-stmt> = PROCEDURE ( [ <proc-interface> ] )
+            [ [ , <proc-attr-spec> ]... :: ] <proc-decl-list>
+
+    Attributes::
+
+        items : (Proc_Interface, Proc_Attr_Spec_List, Proc_Decl_List)
 
-Attributes
-----------
-items : (Proc_Interface, Proc_Attr_Spec_List, Proc_Decl_List)
     """
+
     subclass_names = []
-    use_names = ['Proc_Interface', 'Proc_Attr_Spec_List', 'Proc_Decl_List']
+    use_names = ["Proc_Interface", "Proc_Attr_Spec_List", "Proc_Decl_List"]
 
     @staticmethod
     def match(string):
-        if string[:9].upper() != 'PROCEDURE':
+        if string[:9].upper() != "PROCEDURE":
             return
         line = string[9:].lstrip()
-        if not line.startswith('('):
+        if not line.startswith("("):
             return
         line, repmap = string_replace_map(line)
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         tmp = line[1:i].strip()
         proc_interface = Proc_Interface(repmap(tmp)) if tmp else None
-        line = line[i+1:].lstrip()
-        i = line.find('::')
+        line = line[i + 1 :].lstrip()
+        i = line.find("::")
         proc_attr_spec_list = None
         if i != -1:
             tmp = line[:i].rstrip()
-            if tmp and tmp[0] == ',':
-                proc_attr_spec_list = Proc_Attr_Spec_List(
-                    repmap(tmp[1:].lstrip()))
-            line = line[i+2:].lstrip()
-        return proc_interface, proc_attr_spec_list, \
-            Proc_Decl_List(repmap(line))
+            if tmp and tmp[0] == ",":
+                proc_attr_spec_list = Proc_Attr_Spec_List(repmap(tmp[1:].lstrip()))
+            line = line[i + 2 :].lstrip()
+        return proc_interface, proc_attr_spec_list, Proc_Decl_List(repmap(line))
 
     def tostr(self):
-        r = 'PROCEDURE'
+        r = "PROCEDURE"
         if self.items[0] is not None:
-            r += '(%s)' % (self.items[0])
+            r += "(%s)" % (self.items[0])
         else:
-            r += '()'
+            r += "()"
         if self.items[1] is not None:
-            r += ', %s ::' % (self.items[1])
-        return '%s %s' % (r, self.items[2])
+            r += ", %s ::" % (self.items[1])
+        return "%s %s" % (r, self.items[2])
 
 
 class Proc_Interface(Base):  # R1212
     """
-    <proc-interface> = <interface-name>
-                       | <declaration-type-spec>
+    ::
+
+        <proc-interface> = <interface-name>
+                           | <declaration-type-spec>
+
     """
-    subclass_names = ['Interface_Name', 'Declaration_Type_Spec']
+
+    subclass_names = ["Interface_Name", "Declaration_Type_Spec"]
 
 
 class Proc_Attr_Spec(Base):  # R1213
     """
-    <proc-attr-spec> = <access-spec>
-                       | <proc-language-binding-spec>
-                       | INTENT ( <intent-spec> )
-                       | OPTIONAL
-                       | POINTER
-                       | PROTECTED
-                       | SAVE
+    ::
+
+        <proc-attr-spec> = <access-spec>
+                           | <proc-language-binding-spec>
+                           | INTENT ( <intent-spec> )
+                           | OPTIONAL
+                           | POINTER
+                           | PROTECTED
+                           | SAVE
+
+    Attributes::
+
+        items : ({'INTENT', 'OPTIONAL', 'POINTER', 'PROTECTED', 'SAVE'}, Intent_Spec)
 
-Attributes
-----------
-items : ({'INTENT', 'OPTIONAL', 'POINTER', 'PROTECTED', 'SAVE'}, Intent_Spec)
     """
-    subclass_names = ['Access_Spec', 'Proc_Language_Binding_Spec']
-    use_names = ['Intent_Spec']
+
+    subclass_names = ["Access_Spec", "Proc_Language_Binding_Spec"]
+    use_names = ["Intent_Spec"]
 
     @staticmethod
     def match(string):
-        '''
+        """
         Matches procedure arguments.
 
         :param str string: Candidate string.
         :return: Discovered arguments.
         :rtype: tuple, str or None
-        '''
-        if string[:6].upper() == 'INTENT':
+        """
+        if string[:6].upper() == "INTENT":
             line = string[6:].lstrip()
             if not line:
                 return
-            if line[0] != '(' or line[-1] != ')':
+            if line[0] != "(" or line[-1] != ")":
                 return
-            return 'INTENT', Intent_Spec(line[1:-1].strip())
-        if len(string) == 8 and string.upper() == 'OPTIONAL':
-            return 'OPTIONAL', None
-        if len(string) == 7 and string.upper() == 'POINTER':
-            return 'POINTER', None
-        if len(string) == 9 and string.upper() == 'PROTECTED':
-            return 'PROTECTED', None
-        if len(string) == 4 and string.upper() == 'SAVE':
-            return 'SAVE', None
+            return "INTENT", Intent_Spec(line[1:-1].strip())
+        if len(string) == 8 and string.upper() == "OPTIONAL":
+            return "OPTIONAL", None
+        if len(string) == 7 and string.upper() == "POINTER":
+            return "POINTER", None
+        if len(string) == 9 and string.upper() == "PROTECTED":
+            return "PROTECTED", None
+        if len(string) == 4 and string.upper() == "SAVE":
+            return "SAVE", None
 
     def tostr(self):
         if self.items[1] is None:
-            return '%s' % (self.items[0])
-        return '%s(%s)' % (self.items)
+            return "%s" % (self.items[0])
+        return "%s(%s)" % (self.items)
 
 
 class Proc_Decl(BinaryOpBase):  # R1214
     """
-::
-    <proc-decl> = <procedure-entity-name> [ => <null-init> ]
+    ::
+
+        <proc-decl> = <procedure-entity-name> [ => <null-init> ]
+
+    Attributes::
+
+        items : (Procedure_Entity_Name, Null_Init)
 
-Attributes
-----------
-items : (Procedure_Entity_Name, Null_Init)
     """
-    subclass_names = ['Procedure_Entity_Name']
-    use_names = ['Null_Init']
 
+    subclass_names = ["Procedure_Entity_Name"]
+    use_names = ["Null_Init"]
+
+    @staticmethod
     def match(string):
-        return BinaryOpBase.match(Procedure_Entity_Name, '=>',
-                                  Null_Init, string)
-    match = staticmethod(match)
+        return BinaryOpBase.match(Procedure_Entity_Name, "=>", Null_Init, string)
 
 
 class Interface_Name(Base):  # R1215
     """
     <interface-name> = <name>
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Intrinsic_Stmt(StmtBase, WORDClsBase):  # R1216
     """
-    <intrinsic-stmt> = INTRINSIC [ :: ] <intrinsic-procedure-name-list>
+    ::
+
+        <intrinsic-stmt> = INTRINSIC [ :: ] <intrinsic-procedure-name-list>
+
     """
+
     subclass_names = []
-    use_names = ['Intrinsic_Procedure_Name_List']
+    use_names = ["Intrinsic_Procedure_Name_List"]
 
+    @staticmethod
     def match(string):
         return WORDClsBase.match(
-            'INTRINSIC', Intrinsic_Procedure_Name_List,
-            string, check_colons=True, require_cls=True)
-    match = staticmethod(match)
+            "INTRINSIC",
+            Intrinsic_Procedure_Name_List,
+            string,
+            colons=True,
+            require_cls=True,
+        )
+
     tostr = WORDClsBase.tostr_a
 
 
 class Function_Reference(CallBase):  # R1217
     """
     <function-reference> = <procedure-designator>
         ( [ <actual-arg-spec-list> ] )
     """
+
     subclass_names = []
-    use_names = ['Procedure_Designator', 'Actual_Arg_Spec_List']
+    use_names = ["Procedure_Designator", "Actual_Arg_Spec_List"]
 
+    @staticmethod
     def match(string):
-        return CallBase.match(
-            Procedure_Designator, Actual_Arg_Spec_List, string)
-    match = staticmethod(match)
+        return CallBase.match(Procedure_Designator, Actual_Arg_Spec_List, string)
 
 
 class Intrinsic_Name(STRINGBase):  # No explicit rule
-    '''Represents the name of a Fortran intrinsic function.
+    """Represents the name of a Fortran intrinsic function.
 
     All generic intrinsic names are specified as keys in the
     `generic_function_names` dictionary, with their values indicating
     the minimum and maximum number of arguments allowed for this
     intrinsic function. A `-1` indicates an unlimited number of
     arguments. The names are split into the categories specified in
     the Fortran2003 specification document.
 
     All specific intrinsic names (which have a different name to their
     generic counterpart) are specified as keys in the
     `specific_function_names` dictionary, with their values indicating
     which generic function they are associated with.
 
-    '''
+    """
 
     numeric_names = {
-        "ABS": {"min": 1, "max": 1}, "AIMAG": {"min": 1, "max": 1},
-        "AINT": {"min": 1, "max": 2}, "ANINT": {"min": 1, "max": 2},
-        "CEILING": {"min": 1, "max": 2}, "CMPLX": {"min": 1, "max": 3},
-        "CONJG": {"min": 1, "max": 1}, "DBLE": {"min": 1, "max": 1},
-        "DIM": {"min": 2, "max": 2}, "DPROD": {"min": 2, "max": 2},
-        "FLOOR": {"min": 1, "max": 2}, "INT": {"min": 1, "max": 2},
-        "MAX": {"min": 2, "max": None}, "MIN": {"min": 2, "max": None},
-        "MOD": {"min": 2, "max": 2}, "MODULO": {"min": 2, "max": 2},
-        "NINT": {"min": 1, "max": 2}, "REAL": {"min": 1, "max": 2},
-        "SIGN": {"min": 2, "max": 2}}
+        "ABS": {"min": 1, "max": 1},
+        "AIMAG": {"min": 1, "max": 1},
+        "AINT": {"min": 1, "max": 2},
+        "ANINT": {"min": 1, "max": 2},
+        "CEILING": {"min": 1, "max": 2},
+        "CMPLX": {"min": 1, "max": 3},
+        "CONJG": {"min": 1, "max": 1},
+        "DBLE": {"min": 1, "max": 1},
+        "DIM": {"min": 2, "max": 2},
+        "DPROD": {"min": 2, "max": 2},
+        "FLOOR": {"min": 1, "max": 2},
+        "INT": {"min": 1, "max": 2},
+        "MAX": {"min": 2, "max": None},
+        "MIN": {"min": 2, "max": None},
+        "MOD": {"min": 2, "max": 2},
+        "MODULO": {"min": 2, "max": 2},
+        "NINT": {"min": 1, "max": 2},
+        "REAL": {"min": 1, "max": 2},
+        "SIGN": {"min": 2, "max": 2},
+    }
 
     mathematical_names = {
-        "ACOS": {"min": 1, "max": 1}, "ASIN": {"min": 1, "max": 1},
-        "ATAN": {"min": 1, "max": 1}, "ATAN2": {"min": 2, "max": 2},
-        "COS": {"min": 1, "max": 1}, "COSH": {"min": 1, "max": 1},
-        "EXP": {"min": 1, "max": 1}, "LOG": {"min": 1, "max": 1},
-        "LOG10": {"min": 1, "max": 1}, "SIN": {"min": 1, "max": 1},
-        "SINH": {"min": 1, "max": 1}, "SQRT": {"min": 1, "max": 1},
-        "TAN": {"min": 1, "max": 1}, "TANH": {"min": 1, "max": 1}}
+        "ACOS": {"min": 1, "max": 1},
+        "ASIN": {"min": 1, "max": 1},
+        "ATAN": {"min": 1, "max": 1},
+        "ATAN2": {"min": 2, "max": 2},
+        "COS": {"min": 1, "max": 1},
+        "COSH": {"min": 1, "max": 1},
+        "EXP": {"min": 1, "max": 1},
+        "LOG": {"min": 1, "max": 1},
+        "LOG10": {"min": 1, "max": 1},
+        "SIN": {"min": 1, "max": 1},
+        "SINH": {"min": 1, "max": 1},
+        "SQRT": {"min": 1, "max": 1},
+        "TAN": {"min": 1, "max": 1},
+        "TANH": {"min": 1, "max": 1},
+    }
 
     # Removed max and min from this dictionary as they already appear
     # in numeric_function_names.
     character_names = {
-        "ACHAR": {"min": 1, "max": 2}, "ADJUSTL": {"min": 1, "max": 1},
-        "ADJUSTR": {"min": 1, "max": 1}, "CHAR": {"min": 1, "max": 2},
-        "IACHAR": {"min": 1, "max": 2}, "ICHAR": {"min": 1, "max": 2},
-        "INDEX": {"min": 2, "max": 4}, "LEN_TRIM": {"min": 1, "max": 2},
-        "LGE": {"min": 2, "max": 2}, "LGT": {"min": 2, "max": 2},
-        "LLE": {"min": 2, "max": 2}, "LLT": {"min": 2, "max": 2},
-        "REPEAT": {"min": 2, "max": 2}, "SCAN": {"min": 2, "max": 4},
-        "TRIM": {"min": 1, "max": 1}, "VERIFY": {"min": 2, "max": 4}}
+        "ACHAR": {"min": 1, "max": 2},
+        "ADJUSTL": {"min": 1, "max": 1},
+        "ADJUSTR": {"min": 1, "max": 1},
+        "CHAR": {"min": 1, "max": 2},
+        "IACHAR": {"min": 1, "max": 2},
+        "ICHAR": {"min": 1, "max": 2},
+        "INDEX": {"min": 2, "max": 4},
+        "LEN_TRIM": {"min": 1, "max": 2},
+        "LGE": {"min": 2, "max": 2},
+        "LGT": {"min": 2, "max": 2},
+        "LLE": {"min": 2, "max": 2},
+        "LLT": {"min": 2, "max": 2},
+        "REPEAT": {"min": 2, "max": 2},
+        "SCAN": {"min": 2, "max": 4},
+        "TRIM": {"min": 1, "max": 1},
+        "VERIFY": {"min": 2, "max": 4},
+    }
 
     kind_names = {
         "KIND": {"min": 1, "max": 1},
         "SELECTED_CHAR_KIND": {"min": 1, "max": 1},
         "SELECTED_INT_KIND": {"min": 1, "max": 1},
-        "SELECTED_REAL_KIND": {"min": 1, "max": 2}}
+        "SELECTED_REAL_KIND": {"min": 1, "max": 2},
+    }
 
     miscellaneous_type_conversion_names = {
         "LOGICAL": {"min": 1, "max": 2},
-        "TRANSFER": {"min": 2, "max": 3}}
+        "TRANSFER": {"min": 2, "max": 3},
+    }
 
     numeric_inquiry_names = {
         "DIGITS": {"min": 1, "max": 1},
         "EPSILON": {"min": 1, "max": 1},
         "HUGE": {"min": 1, "max": 1},
         "MAXEXPONENT": {"min": 1, "max": 1},
         "MINEXPONENT": {"min": 1, "max": 1},
         "PRECISION": {"min": 1, "max": 1},
         "RADIX": {"min": 1, "max": 1},
         "RANGE": {"min": 1, "max": 1},
-        "TINY": {"min": 1, "max": 1}}
+        "TINY": {"min": 1, "max": 1},
+    }
 
     array_inquiry_names = {
         "LBOUND": {"min": 1, "max": 3},
         "SHAPE": {"min": 1, "max": 2},
         "SIZE": {"min": 1, "max": 3},
-        "UBOUND": {"min": 1, "max": 3}}
+        "UBOUND": {"min": 1, "max": 3},
+    }
 
     other_inquiry_names = {
         "ALLOCATED": {"min": 1, "max": 1},
         "ASSOCIATED": {"min": 1, "max": 2},
         "BIT_SIZE": {"min": 1, "max": 1},
         "EXTENDS_TYPE_OF": {"min": 2, "max": 2},
         "LEN": {"min": 1, "max": 2},
         "NEW_LINE": {"min": 1, "max": 1},
         "PRESENT": {"min": 1, "max": 1},
-        "SAME_TYPE_AS": {"min": 2, "max": 2}}
+        "SAME_TYPE_AS": {"min": 2, "max": 2},
+    }
 
     bit_manipulation_names = {
         "BTEST": {"min": 2, "max": 2},
         "IAND": {"min": 2, "max": 2},
         "IBCLR": {"min": 2, "max": 2},
-        "IBITS": {"min": 2, "max": 2},
+        "IBITS": {"min": 3, "max": 3},
         "IBSET": {"min": 2, "max": 2},
         "IEOR": {"min": 2, "max": 2},
         "IOR": {"min": 2, "max": 2},
         "ISHFT": {"min": 2, "max": 2},
         "ISHFTC": {"min": 2, "max": 3},
         "MVBITS": {"min": 5, "max": 5},
-        "NOT": {"min": 1, "max": 1}}
+        "NOT": {"min": 1, "max": 1},
+    }
 
     floating_point_manipulation_names = {
         "EXPONENT": {"min": 1, "max": 1},
         "FRACTION": {"min": 1, "max": 1},
         "NEAREST": {"min": 2, "max": 2},
         "RRSPACING": {"min": 1, "max": 1},
         "SCALE": {"min": 2, "max": 2},
         "SET_EXPONENT": {"min": 2, "max": 2},
-        "SPACING": {"min": 1, "max": 1}}
+        "SPACING": {"min": 1, "max": 1},
+    }
 
     vector_and_matrix_multiply_names = {
         "DOT_PRODUCT": {"min": 2, "max": 2},
-        "MATMUL": {"min": 2, "max": 2}}
+        "MATMUL": {"min": 2, "max": 2},
+    }
 
     array_reduction_names = {
         "ALL": {"min": 1, "max": 2},
         "ANY": {"min": 1, "max": 2},
         "COUNT": {"min": 1, "max": 3},
         "MAXVAL": {"min": 1, "max": 3},
         "MINVAL": {"min": 1, "max": 3},
         "PRODUCT": {"min": 1, "max": 3},
-        "SUM": {"min": 1, "max": 3}}
+        "SUM": {"min": 1, "max": 3},
+    }
 
     array_construction_names = {
         "CSHIFT": {"min": 2, "max": 3},
         "EOSHIFT": {"min": 2, "max": 4},
         "MERGE": {"min": 3, "max": 3},
         "PACK": {"min": 2, "max": 3},
         "RESHAPE": {"min": 2, "max": 4},
         "SPREAD": {"min": 3, "max": 3},
         "TRANSPOSE": {"min": 1, "max": 1},
-        "UNPACK": {"min": 3, "max": 3}}
+        "UNPACK": {"min": 3, "max": 3},
+    }
 
     array_location_names = {
         "MAXLOC": {"min": 1, "max": 4},
-        "MINLOC": {"min": 1, "max": 4}}
+        "MINLOC": {"min": 1, "max": 4},
+    }
 
-    null_names = {
-        "NULL": {"min": 0, "max": 1}}
+    null_names = {"NULL": {"min": 0, "max": 1}}
 
-    allocation_transfer_names = {
-        "MOVE_ALLOC": {"min": 2, "max": 2}}
+    allocation_transfer_names = {"MOVE_ALLOC": {"min": 2, "max": 2}}
 
     random_number_names = {
         "RANDOM_NUMBER": {"min": 1, "max": 1},
-        "RANDOM_SEED": {"min": 0, "max": 3}}
+        "RANDOM_SEED": {"min": 0, "max": 3},
+    }
 
     system_environment_names = {
         "COMMAND_ARGUMENT_COUNT": {"min": 0, "max": 0},
         "CPU_TIME": {"min": 1, "max": 1},
         "DATE_AND_TIME": {"min": 0, "max": 4},
         "GET_COMMAND": {"min": 0, "max": 3},
         "GET_COMMAND_ARGUMENT": {"min": 1, "max": 4},
         "GET_ENVIRONMENT_VARIABLE": {"min": 1, "max": 5},
         "IS_IOSTAT_END": {"min": 1, "max": 1},
         "IS_IOSTAT_EOR": {"min": 1, "max": 1},
-        "SYSTEM_CLOCK": {"min": 0, "max": 3}}
+        "SYSTEM_CLOCK": {"min": 0, "max": 3},
+    }
 
     # A map from specific function names to their generic equivalent.
     specific_function_names = {
-        "ALOG": "LOG", "ALOG10": "LOG10", "AMAX0": "MAX", "AMAX1": "MAX",
-        "AMIN0": "MIN", "AMIN1": "MIN", "AMOD": "MOD", "CABS": "ABS",
-        "CCOS": "COS", "CEXP": "EXP", "CLOG": "LOG", "CSIN": "SIN",
-        "CSQRT": "SQRT", "DABS": "ABS", "DACOS": "ACOS", "DASIN": "ASIN",
-        "DATAN": "ATAN", "DATAN2": "ATAN2", "DCOS": "COS", "DCOSH": "COSH",
-        "DDIM": "DIM", "DEXP": "EXP", "DINT": "AINT", "DLOG": "LOG",
-        "DLOG10": "LOG10", "DMAX1": "MAX", "DMIN1": "MIN", "DMOD": "MOD",
-        "DNINT": "ANINT", "DSIGN": "SIGN", "DSIN": "SIN", "DSINH": "SINH",
-        "DSQRT": "SQRT", "DTAN": "TAN", "DTANH": "TANH", "FLOAT": "REAL",
-        "IABS": "ABS", "IDIM": "DIM", "IDINT": "INT", "IDNINT": "NINT",
-        "IFIX": "INT", "ISIGN": "SIGN", "MAX0": "MAX", "MAX1": "MAX",
-        "MIN0": "MIN", "MIN1": "MIN", "SNGL": "REAL"}
+        "ALOG": "LOG",
+        "ALOG10": "LOG10",
+        "AMAX0": "MAX",
+        "AMAX1": "MAX",
+        "AMIN0": "MIN",
+        "AMIN1": "MIN",
+        "AMOD": "MOD",
+        "CABS": "ABS",
+        "CCOS": "COS",
+        "CEXP": "EXP",
+        "CLOG": "LOG",
+        "CSIN": "SIN",
+        "CSQRT": "SQRT",
+        "DABS": "ABS",
+        "DACOS": "ACOS",
+        "DASIN": "ASIN",
+        "DATAN": "ATAN",
+        "DATAN2": "ATAN2",
+        "DCOS": "COS",
+        "DCOSH": "COSH",
+        "DDIM": "DIM",
+        "DEXP": "EXP",
+        "DINT": "AINT",
+        "DLOG": "LOG",
+        "DLOG10": "LOG10",
+        "DMAX1": "MAX",
+        "DMIN1": "MIN",
+        "DMOD": "MOD",
+        "DNINT": "ANINT",
+        "DSIGN": "SIGN",
+        "DSIN": "SIN",
+        "DSINH": "SINH",
+        "DSQRT": "SQRT",
+        "DTAN": "TAN",
+        "DTANH": "TANH",
+        "FLOAT": "REAL",
+        "IABS": "ABS",
+        "IDIM": "DIM",
+        "IDINT": "INT",
+        "IDNINT": "NINT",
+        "IFIX": "INT",
+        "ISIGN": "SIGN",
+        "MAX0": "MAX",
+        "MAX1": "MAX",
+        "MIN0": "MIN",
+        "MIN1": "MIN",
+        "SNGL": "REAL",
+    }
 
     generic_function_names = {}
     generic_function_names.update(numeric_names)
     generic_function_names.update(mathematical_names)
     generic_function_names.update(character_names)
     generic_function_names.update(kind_names)
     generic_function_names.update(miscellaneous_type_conversion_names)
@@ -9496,48 +12210,51 @@
     generic_function_names.update(array_location_names)
     generic_function_names.update(null_names)
     generic_function_names.update(allocation_transfer_names)
     generic_function_names.update(random_number_names)
     generic_function_names.update(system_environment_names)
 
     # A list of all function names
-    function_names = (list(generic_function_names.keys()) +
-                      list(specific_function_names.keys()))
+    function_names = list(generic_function_names.keys()) + list(
+        specific_function_names.keys()
+    )
 
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''Attempt to match the input `string` with the intrinsic function
+        """Attempt to match the input `string` with the intrinsic function
         names defined in `generic_function_names` or
         `specific_function_names`. If there is a match the resultant
         string will be converted to upper case.
 
         :param str string: The pattern to be matched.
 
         :returns: A tuple containing the matched string (converted to \
         upper case) if there is a match or None if there is not.
         :rtype: (str,) or NoneType
 
-        '''
+        """
         return STRINGBase.match(Intrinsic_Name.function_names, string)
 
 
 class Intrinsic_Function_Reference(CallBase):  # No explicit rule
-    '''Represents Fortran intrinsics.
+    """
+    Represents Fortran intrinsics::
 
-    function-reference is intrinsic-name ( [ actual-arg-spec-list ] )
+        function-reference is intrinsic-name ( [ actual-arg-spec-list ] )
+
+    """
 
-    '''
     subclass_names = []
-    use_names = ['Intrinsic_Name', 'Actual_Arg_Spec_List']
+    use_names = ["Intrinsic_Name", "Actual_Arg_Spec_List"]
 
     @staticmethod
     def match(string):
-        '''Match the string as an intrinsic function. Also check that the
+        """Match the string as an intrinsic function. Also check that the
         number of arguments provided matches the number expected by
         the intrinsic.
 
         :param str string: the string to match with the pattern rule.
 
         :return: a tuple of size 2 containing the name of the \
         intrinsic and its arguments if there is a match, or None if \
@@ -9546,607 +12263,823 @@
         :py:class:`fparser.two.Fortran2003.Actual_Arg_Spec_List`) or \
         NoneType
 
         :raises InternalSyntaxError: If the number of arguments \
         provided does not match the number of arguments expected by \
         the intrinsic.
 
-        '''
-        result = CallBase.match(
-            Intrinsic_Name, Actual_Arg_Spec_List, string)
+        """
+        result = CallBase.match(Intrinsic_Name, Actual_Arg_Spec_List, string)
         if result:
             # There is a match so check the number of args provided
             # matches the number of args expected by the intrinsic.
             function_name = str(result[0])
             function_args = result[1]
+
+            # Check that that this name is not being shadowed (i.e. overridden)
+            # by a symbol in scope at this point.
+            table = SYMBOL_TABLES.current_scope
+            try:
+                table.lookup(function_name)
+                # We found a matching name so refuse to match this intrinsic.
+                return None
+            except (KeyError, AttributeError):
+                # There is either no matching name in the table or we have
+                # no current scoping region.
+                pass
+
             # This if/else will not be needed once issue #170 has been
             # addressed.
             if isinstance(function_args, Actual_Arg_Spec_List):
                 nargs = len(function_args.items)
             elif function_args is None:
                 nargs = 0
             else:
                 nargs = 1
 
             if function_name in Intrinsic_Name.specific_function_names.keys():
                 # If this is a specific function then use its generic
                 # name to test min and max number of arguments.
-                test_name = Intrinsic_Name.specific_function_names[
-                    function_name]
+                test_name = Intrinsic_Name.specific_function_names[function_name]
             else:
                 test_name = function_name
 
             min_nargs = Intrinsic_Name.generic_function_names[test_name]["min"]
             max_nargs = Intrinsic_Name.generic_function_names[test_name]["max"]
 
             if max_nargs is None:
                 if nargs < min_nargs:
                     # None indicates an unlimited number of arguments
                     raise InternalSyntaxError(
                         "Intrinsic '{0}' expects at least {1} args but found "
-                        "{2}.".format(function_name, min_nargs, nargs))
+                        "{2}.".format(function_name, min_nargs, nargs)
+                    )
                 # The number of arguments is valid. Return here as
                 # further tests will fail due to max_args being
                 # None.
                 return result
             if min_nargs == max_nargs and nargs != min_nargs:
                 raise InternalSyntaxError(
                     "Intrinsic '{0}' expects {1} arg(s) but found {2}."
-                    "".format(function_name, min_nargs, nargs))
-            if min_nargs < max_nargs and (nargs < min_nargs or
-                                          nargs > max_nargs):
+                    "".format(function_name, min_nargs, nargs)
+                )
+            if min_nargs < max_nargs and (nargs < min_nargs or nargs > max_nargs):
                 raise InternalSyntaxError(
                     "Intrinsic '{0}' expects between {1} and {2} args but "
-                    "found {3}.".format(function_name, min_nargs, max_nargs,
-                                        nargs))
+                    "found {3}.".format(function_name, min_nargs, max_nargs, nargs)
+                )
         return result
 
 
 class Call_Stmt(StmtBase):  # R1218
     """
-    <call-stmt> = CALL <procedure-designator>
-                  [ ( [ <actual-arg-spec-list> ] ) ]
+    ::
+
+        <call-stmt> = CALL <procedure-designator>
+                      [ ( [ <actual-arg-spec-list> ] ) ]
+
+    Attributes::
+
+        items : (Procedure_Designator, Actual_Arg_Spec_List)
 
-Attributes
-----------
-items : (Procedure_Designator, Actual_Arg_Spec_List)
     """
+
     subclass_names = []
-    use_names = ['Procedure_Designator', 'Actual_Arg_Spec_List']
+    use_names = ["Procedure_Designator", "Actual_Arg_Spec_List"]
 
+    @staticmethod
     def match(string):
-        if string[:4].upper() != 'CALL':
+        if string[:4].upper() != "CALL":
             return
         line, repmap = string_replace_map(string[4:].lstrip())
-        if line.endswith(')'):
-            i = line.rfind('(')
+        if line.endswith(")"):
+            i = line.rfind("(")
             if i == -1:
                 return
-            args = repmap(line[i+1:-1].strip())
+            args = repmap(line[i + 1 : -1].strip())
             if args:
-                return Procedure_Designator(repmap(line[:i].rstrip())), \
-                       Actual_Arg_Spec_List(args)
+                return (
+                    Procedure_Designator(repmap(line[:i].rstrip())),
+                    Actual_Arg_Spec_List(args),
+                )
             return Procedure_Designator(repmap(line[:i].rstrip())), None
         return Procedure_Designator(string[4:].lstrip()), None
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[1] is None:
-            return 'CALL %s' % (self.items[0])
-        return 'CALL %s(%s)' % self.items
+            return "CALL %s" % (self.items[0])
+        return "CALL %s(%s)" % self.items
 
 
 class Procedure_Designator(BinaryOpBase):  # R1219
     """
-    <procedure-designator> = <procedure-name>
-                             | <proc-component-ref>
-                             | <data-ref> % <binding-name>
+    ::
+
+        <procedure-designator> = <procedure-name>
+                                 | <proc-component-ref>
+                                 | <data-ref> % <binding-name>
+
     """
-    subclass_names = ['Procedure_Name', 'Proc_Component_Ref']
-    use_names = ['Data_Ref', 'Binding_Name']
 
+    subclass_names = ["Procedure_Name", "Proc_Component_Ref"]
+    use_names = ["Data_Ref", "Binding_Name"]
+
+    @staticmethod
     def match(string):
-        return BinaryOpBase.match(Data_Ref, pattern.percent_op.named(),
-                                  Binding_Name, string)
-    match = staticmethod(match)
+        return BinaryOpBase.match(
+            Data_Ref, pattern.percent_op.named(), Binding_Name, string
+        )
 
 
 class Actual_Arg_Spec(KeywordValueBase):  # R1220
     """
     <actual-arg-spec> = [ <keyword> = ] <actual-arg>
     """
-    subclass_names = ['Actual_Arg']
-    use_names = ['Keyword']
+
+    subclass_names = ["Actual_Arg"]
+    use_names = ["Keyword"]
 
     @staticmethod
     def match(string):
         return KeywordValueBase.match(Keyword, Actual_Arg, string)
 
 
 class Actual_Arg(Base):  # R1221
     """
-    <actual-arg> = <expr>
-                 | <variable>
-                 | <procedure-name>
-                 | <proc-component-ref>
-                 | <alt-return-spec>
-    """
-    subclass_names = ['Expr',
-                      'Procedure_Name',
-                      'Proc_Component_Ref',
-                      'Alt_Return_Spec',
-                      'Variable']
+    ::
+
+        <actual-arg> = <expr>
+                     | <variable>
+                     | <procedure-name>
+                     | <proc-component-ref>
+                     | <alt-return-spec>
+
+    """
+
+    subclass_names = [
+        "Expr",
+        "Procedure_Name",
+        "Proc_Component_Ref",
+        "Alt_Return_Spec",
+        "Variable",
+    ]
 
 
 class Alt_Return_Spec(Base):  # R1222
     """
-    <alt-return-spec> = * <label>
+    ::
+
+        <alt-return-spec> = * <label>
+
     """
+
     subclass_names = []
-    use_names = ['Label']
+    use_names = ["Label"]
 
+    @staticmethod
     def match(string):
-        if not string.startswith('*'):
+        if not string.startswith("*"):
             return
         line = string[1:].lstrip()
         if not line:
             return
-        return Label(line),
-    match = staticmethod(match)
+        return (Label(line),)
 
     def tostr(self):
-        return '*%s' % (self.items[0])
+        return "*%s" % (self.items[0])
 
 
 class Function_Subprogram(BlockBase):  # R1223
     """
-    <function-subprogram> = <function-stmt>
-                               [ <specification-part> ]
-                               [ <execution-part> ]
-                               [ <internal-subprogram-part> ]
-                            <end-function-stmt>
+    ::
+
+        <function-subprogram> = <function-stmt>
+                                   [ <specification-part> ]
+                                   [ <execution-part> ]
+                                   [ <internal-subprogram-part> ]
+                                <end-function-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Function_Stmt', 'Specification_Part', 'Execution_Part',
-                 'Internal_Subprogram_Part', 'End_Function_Stmt']
+    use_names = [
+        "Function_Stmt",
+        "Specification_Part",
+        "Execution_Part",
+        "Internal_Subprogram_Part",
+        "End_Function_Stmt",
+    ]
 
     @staticmethod
     def match(reader):
-        return BlockBase.match(Function_Stmt,
-                               [Specification_Part,
-                                Execution_Part,
-                                Internal_Subprogram_Part],
-                               End_Function_Stmt,
-                               reader)
+        return BlockBase.match(
+            Function_Stmt,
+            [Specification_Part, Execution_Part, Internal_Subprogram_Part],
+            End_Function_Stmt,
+            reader,
+        )
 
 
-class Function_Stmt(StmtBase):  # R1224
+class Function_Stmt(StmtBase, ScopingRegionMixin):  # R1224
     """
-    <function-stmt> = [ <prefix> ] FUNCTION <function-name>
-                      ( [ <dummy-arg-name-list> ] ) [ <suffix> ]
+    ::
+
+        <function-stmt> = [ <prefix> ] FUNCTION <function-name>
+                          ( [ <dummy-arg-name-list> ] ) [ <suffix> ]
+
+    C1242 (R1227) A prefix shall not specify ELEMENTAL if
+    proc-language-binding-spec appears in the function-stmt or
+    subroutine-stmt. The spec associates this constraint with R1227
+    but it needs to be checked here.
+
     """
+
     subclass_names = []
-    use_names = ['Prefix', 'Function_Name', 'Dummy_Arg_Name_List', 'Suffix']
+    use_names = ["Prefix", "Function_Name", "Dummy_Arg_Name_List", "Suffix"]
 
     @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
         m = pattern.function.search(line)
         if m is None:
             return
-        prefix = line[:m.start()].rstrip() or None
+        prefix = line[: m.start()].rstrip() or None
         if prefix is not None:
             prefix = Prefix(repmap(prefix))
-        line = line[m.end():].lstrip()
+        line = line[m.end() :].lstrip()
         m = pattern.name.match(line)
         if m is None:
             return
         name = Function_Name(m.group())
-        line = line[m.end():].lstrip()
-        if not line.startswith('('):
+        line = line[m.end() :].lstrip()
+        if not line.startswith("("):
             return
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         dummy_args = line[1:i].strip() or None
         if dummy_args is not None:
             dummy_args = Dummy_Arg_List(repmap(dummy_args))
-        line = line[i+1:].lstrip()
+        line = line[i + 1 :].lstrip()
         suffix = None
         if line:
             suffix = Suffix(repmap(line))
+        if suffix:
+            # A suffix may or may not contain a binding spec.
+            binding_spec = walk(suffix, Language_Binding_Spec)
+            # Check that we conform to C1242.
+            if not c1242_valid(prefix, binding_spec):
+                return None
         return prefix, name, dummy_args, suffix
 
     def tostr(self):
         prefix, name, dummy_args, suffix = self.items
         if prefix is not None:
-            s = '%s FUNCTION %s' % (prefix, name)
+            s = "%s FUNCTION %s" % (prefix, name)
         else:
-            s = 'FUNCTION %s' % (name)
+            s = "FUNCTION %s" % (name)
         if dummy_args is not None:
-            s += '(%s)' % (dummy_args)
+            s += "(%s)" % (dummy_args)
         else:
-            s += '()'
+            s += "()"
         if suffix is not None:
-            s += ' %s' % (suffix)
+            s += " %s" % (suffix)
         return s
 
+    def get_name(self):
+        """
+        :returns: the function name.
+        :rtype: :py:class:`Name`
+        """
+        return self.items[1]
+
 
 class Proc_Language_Binding_Spec(Base):  # 1225
     """
     <proc-language-binding-spec> = <language-binding-spec>
     """
-    subclass_names = ['Language_Binding_Spec']
+
+    subclass_names = ["Language_Binding_Spec"]
 
 
 class Dummy_Arg_Name(Base):  # R1226
     """
     <dummy-arg-name> = <name>
     """
-    subclass_names = ['Name']
+
+    subclass_names = ["Name"]
 
 
 class Prefix(SequenceBase):
-    '''
-    Fortran2003 rule R1227
+    """
+    Fortran2003 rule R1227::
+
+        prefix is prefix-spec [ prefix-spec ] ...
 
-    prefix is prefix-spec [ prefix-spec ] ...
+    C1240 (R1227) A prefix shall contain at most one of each
+    prefix-spec. Checked below.
+
+    C1241 (R1227) A prefix shall not specify both ELEMENTAL and
+    RECURSIVE. Checked below.
+
+    C1242 (R1227) A prefix shall not specify ELEMENTAL if
+    proc-language-binding-spec appears in the function-stmt or
+    subroutine-stmt. This constraint can not be checked here, it is
+    checked in R1224 and R1232.
+
+    """
 
-    '''
     subclass_names = []
 
     @staticmethod
     def match(string):
-        '''Match a space separated list of Prefix_Spec objects. Objects may be
+        """Match a space separated list of Prefix_Spec objects. Objects may be
         separated by 1 or more spaces.
 
         :returns: A tuple of size 2 containing the separator and a \
         tuple containing one or more Prefix_Spec objects if there is a \
         match and None if not.
 
-        :rtype: (str, (:class:py:`fparser.two.Fortran2003.Prefix_Spec`,)) \
-        or NoneType
+        :rtype: Optional[Tuple[Str, \
+                Tuple[:py:class:`fparser.two.Fortran2003.Prefix_Spec`, ...]]]
 
-        '''
-        return SequenceBase.match(' ', Prefix_Spec, string)
+        """
+        start_match_list = []
+        end_match_list = []
+        decl_spec_list = []
+        keyword_list = []
+        split = string.split()
+        # Match prefix-spec (apart from declaration-type-spec) from
+        # the left end of the string. These can be tokenised with a
+        # simple split as they are guaranteed to not contain any
+        # whitespace (as they are keywords).
+        while split and split[0].upper() in Prefix_Spec.keywords:
+            start_match_list.append(Prefix_Spec(split[0]))
+            keyword_list.append(split[0].upper())
+            split = split[1:]
+        # Match prefix-spec (apart from declaration-type-spec) from
+        # the right end of the string.
+        while split and split[-1].upper() in Prefix_Spec.keywords:
+            end_match_list.insert(0, Prefix_Spec(split[-1]))
+            keyword_list.append(split[-1].upper())
+            split = split[:-1]
+        # What is remaining must be a declaration-type-spec (or is
+        # empty) as only one of each prefix-spec is allowed in a
+        # prefix (C1240). This may contain internal white space so
+        # join the remaining parts together.
+        remaining = " ".join(split)
+        if remaining:
+            decl_spec_list = [Declaration_Type_Spec(remaining)]
+        if len(set(keyword_list)) != len(keyword_list):
+            # C1240 A prefix shall contain at most one of each
+            # prefix-spec. No need to check declaration-type-spec as
+            # that is limited to at most one by design.
+            return None
+        if "ELEMENTAL" in keyword_list and "RECURSIVE" in keyword_list:
+            # C1241 A prefix shall not specify both ELEMENTAL and RECURSIVE.
+            return None
+        result_list = start_match_list + decl_spec_list + end_match_list
+        if result_list:
+            return " ", tuple(result_list)
+        # A prefix must contain at least one prefix-spec.
+        return None
 
 
-class Prefix_Spec(STRINGBase):  # R1226
+class Prefix_Spec(STRINGBase):  # R1228
     """
-    <prefix-spec> = <declaration-type-spec>
-                    | ELEMENTAL
-                    | IMPURE
-                    | MODULE
-                    | PURE
-                    | RECURSIVE
+    ::
+
+        <prefix-spec> = <declaration-type-spec>
+                        | ELEMENTAL
+                        | IMPURE
+                        | MODULE
+                        | PURE
+                        | RECURSIVE
+
     """
-    subclass_names = ['Declaration_Type_Spec']
 
+    subclass_names = ["Declaration_Type_Spec"]
+    # issue #221. IMPURE and MODULE are Fortran2008.
+    keywords = ["ELEMENTAL", "IMPURE", "MODULE", "PURE", "RECURSIVE"]
+
+    @staticmethod
     def match(string):
-        '''
+        """
         Matches procedure prefixes.
 
         :param str string: Candidate string.
         :return: Discovered prefix.
         :rtype: str
-        '''
-        return STRINGBase.match(['ELEMENTAL', 'IMPURE', 'MODULE', 'PURE',
-                                 'RECURSIVE'], string)
-    match = staticmethod(match)
+        """
+        return STRINGBase.match(Prefix_Spec.keywords, string)
 
 
 class Suffix(Base):  # R1229
     """
-    <suffix> = <proc-language-binding-spec> [ RESULT ( <result-name> ) ]
-               | RESULT ( <result-name> ) [ <proc-language-binding-spec> ]
+    ::
+
+        <suffix> = <proc-language-binding-spec> [ RESULT ( <result-name> ) ]
+                   | RESULT ( <result-name> ) [ <proc-language-binding-spec> ]
     """
-    subclass_names = ['Proc_Language_Binding_Spec']
-    use_names = ['Result_Name']
 
+    subclass_names = ["Proc_Language_Binding_Spec"]
+    use_names = ["Result_Name"]
+
+    @staticmethod
     def match(string):
-        if string[:6].upper() == 'RESULT':
+        if string[:6].upper() == "RESULT":
             line = string[6:].lstrip()
-            if not line.startswith('('):
+            if not line.startswith("("):
                 return
-            i = line.find(')')
+            i = line.find(")")
             if i == -1:
                 return
             name = line[1:i].strip()
             if not name:
                 return
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
             if line:
                 return Result_Name(name), Proc_Language_Binding_Spec(line)
             return Result_Name(name), None
-        if not string.endswith(')'):
+        if not string.endswith(")"):
             return
-        i = string.rfind('(')
+        i = string.rfind("(")
         if i == -1:
             return
-        name = string[i+1:-1].strip()
+        name = string[i + 1 : -1].strip()
         if not name:
             return
         line = string[:i].rstrip()
-        if line[-6:].upper() != 'RESULT':
+        if line[-6:].upper() != "RESULT":
             return
         line = line[:-6].rstrip()
         if not line:
             return
         return Result_Name(name), Proc_Language_Binding_Spec(line)
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[1] is None:
-            return 'RESULT(%s)' % (self.items[0])
-        return 'RESULT(%s) %s' % self.items
+            return "RESULT(%s)" % (self.items[0])
+        return "RESULT(%s) %s" % self.items
 
 
 class End_Function_Stmt(EndStmtBase):  # R1230
     """
     <end-function-stmt> = END [ FUNCTION [ <function-name> ] ]
     """
+
     subclass_names = []
-    use_names = ['Function_Name']
+    use_names = ["Function_Name"]
 
+    @staticmethod
     def match(string):
-        return EndStmtBase.match('FUNCTION', Function_Name, string)
-    match = staticmethod(match)
+        return EndStmtBase.match("FUNCTION", Function_Name, string)
 
 
 class Subroutine_Subprogram(BlockBase):  # R1231
     """
-    <subroutine-subprogram> = <subroutine-stmt>
-                                 [ <specification-part> ]
-                                 [ <execution-part> ]
-                                 [ <internal-subprogram-part> ]
-                              <end-subroutine-stmt>
+    ::
+
+        <subroutine-subprogram> = <subroutine-stmt>
+                                     [ <specification-part> ]
+                                     [ <execution-part> ]
+                                     [ <internal-subprogram-part> ]
+                                  <end-subroutine-stmt>
+
     """
+
     subclass_names = []
-    use_names = ['Subroutine_Stmt', 'Specification_Part', 'Execution_Part',
-                 'Internal_Subprogram_Part', 'End_Subroutine_Stmt']
+    use_names = [
+        "Subroutine_Stmt",
+        "Specification_Part",
+        "Execution_Part",
+        "Internal_Subprogram_Part",
+        "End_Subroutine_Stmt",
+    ]
 
+    @staticmethod
     def match(reader):
-        return BlockBase.match(Subroutine_Stmt,
-                               [Specification_Part,
-                                Execution_Part,
-                                Internal_Subprogram_Part],
-                               End_Subroutine_Stmt,
-                               reader)
-    match = staticmethod(match)
+        return BlockBase.match(
+            Subroutine_Stmt,
+            [Specification_Part, Execution_Part, Internal_Subprogram_Part],
+            End_Subroutine_Stmt,
+            reader,
+        )
 
 
-class Subroutine_Stmt(StmtBase):  # R1232
+def c1242_valid(prefix, binding_spec):
+    """If prefix and binding-spec exist then check whether they conform to
+    constraint C1242 - "A prefix shall not specify ELEMENTAL if
+    proc-language-binding-spec appears in the function-stmt or
+    subroutine-stmt."
+
+    :param prefix: matching prefix instance if one exists.
+    :type: :py:class:`fparser.two.Fortran2003.Prefix` or `NoneType`
+    :param binding_spec: matching binding specification instance if \
+        one exists.
+    :type binding_spec: \
+        :py:class:`fparser.two.Fortran2003.Language_Binding_Spec` or
+        `NoneType`
+    :returns: False if prefix and binding-spec break constraint C1242, \
+        otherwise True.
+    :rtype: bool
+
+    """
+    if binding_spec and prefix:
+        # Prefix(es) may or may not be of type ELEMENTAL
+        elemental = any(
+            "ELEMENTAL" in str(child) for child in walk(prefix.items, Prefix_Spec)
+        )
+        if elemental:
+            # Constraint C1242. A prefix shall not specify ELEMENTAL if
+            # proc-language-binding-spec appears in the function-stmt or
+            # subroutine-stmt.
+            return False
+    return True
+
+
+class Subroutine_Stmt(StmtBase, ScopingRegionMixin):  # R1232
     """
-    <subroutine-stmt>
-    = [ <prefix> ] SUBROUTINE <subroutine-name>
-      [ ( [ <dummy-arg-list> ] ) [ <proc-language-binding-spec> ] ]
+    Fortran2003 rule R1232::
+
+        subroutine-stmt is [ prefix ] SUBROUTINE subroutine-name \
+[ ( [ dummy-arg-list ] ) [ proc-language-binding-spec ] ]
+
+    C1242 (R1227) A prefix shall not specify ELEMENTAL if
+    proc-language-binding-spec appears in the function-stmt or
+    subroutine-stmt. The spec associates this constraint with R1227
+    but it needs to be checked here.
+
     """
+
     subclass_names = []
-    use_names = ['Prefix', 'Subroutine_Name', 'Dummy_Arg_List',
-                 'Proc_Language_Binding_Spec']
+    use_names = [
+        "Prefix",
+        "Subroutine_Name",
+        "Dummy_Arg_List",
+        "Proc_Language_Binding_Spec",
+    ]
 
+    @staticmethod
     def match(string):
         line, repmap = string_replace_map(string)
         m = pattern.subroutine.search(line)
         if m is None:
             return
-        prefix = line[:m.start()].rstrip() or None
+        prefix = line[: m.start()].rstrip() or None
         if prefix is not None:
             prefix = Prefix(repmap(prefix))
-        line = line[m.end():].lstrip()
+        line = line[m.end() :].lstrip()
         m = pattern.name.match(line)
         if m is None:
             return
         name = Subroutine_Name(m.group())
-        line = line[m.end():].lstrip()
+        line = line[m.end() :].lstrip()
         dummy_args = None
-        if line.startswith('('):
-            i = line.find(')')
+        if line.startswith("("):
+            i = line.find(")")
             if i == -1:
                 return
             dummy_args = line[1:i].strip() or None
             if dummy_args is not None:
                 dummy_args = Dummy_Arg_List(repmap(dummy_args))
-            line = line[i+1:].lstrip()
+            line = line[i + 1 :].lstrip()
         binding_spec = None
         if line:
             binding_spec = Proc_Language_Binding_Spec(repmap(line))
+        if not c1242_valid(prefix, binding_spec):
+            return None
         return prefix, name, dummy_args, binding_spec
-    match = staticmethod(match)
 
-    def get_name(self): return self.items[1]
+    def get_name(self):
+        return self.items[1]
 
     def tostr(self):
         if self.items[0] is not None:
-            s = '%s SUBROUTINE %s' % (self.items[0], self.items[1])
+            s = "%s SUBROUTINE %s" % (self.items[0], self.items[1])
         else:
-            s = 'SUBROUTINE %s' % (self.items[1])
+            s = "SUBROUTINE %s" % (self.items[1])
         if self.items[2] is not None:
-            s += '(%s)' % (self.items[2])
+            s += "(%s)" % (self.items[2])
         if self.items[3] is not None:
-            s += ' %s' % (self.items[3])
+            s += " %s" % (self.items[3])
         return s
 
 
 class Dummy_Arg(StringBase):  # R1233
     """
-    <dummy-arg> = <dummy-arg-name>
-                  | *
+    ::
+
+        <dummy-arg> = <dummy-arg-name>
+                      | *
+
     """
-    subclass_names = ['Dummy_Arg_Name']
+
+    subclass_names = ["Dummy_Arg_Name"]
 
     @staticmethod
-    def match(string): return StringBase.match('*', string)
+    def match(string):
+        return StringBase.match("*", string)
 
 
 class End_Subroutine_Stmt(EndStmtBase):  # R1234
     """
     <end-subroutine-stmt> = END [ SUBROUTINE [ <subroutine-name> ] ]
     """
+
     subclass_names = []
-    use_names = ['Subroutine_Name']
+    use_names = ["Subroutine_Name"]
 
     @staticmethod
     def match(string):
-        return EndStmtBase.match('SUBROUTINE', Subroutine_Name, string)
+        return EndStmtBase.match("SUBROUTINE", Subroutine_Name, string)
 
 
 class Entry_Stmt(StmtBase):  # R1235
     """
-::
-    <entry-stmt> = ENTRY <entry-name> [ ( [ <dummy-arg-list> ] ) [ <suffix> ] ]
+    ::
+
+        <entry-stmt> = ENTRY <entry-name> [ ( [ <dummy-arg-list> ] ) [ <suffix> ] ]
+
+    Attributes::
+
+        items : (Entry_Name, Dummy_Arg_List, Suffix)
 
-Attributes
-----------
-items : (Entry_Name, Dummy_Arg_List, Suffix)
     """
+
     subclass_names = []
-    use_names = ['Entry_Name', 'Dummy_Arg_List', 'Suffix']
+    use_names = ["Entry_Name", "Dummy_Arg_List", "Suffix"]
 
     @staticmethod
     def match(string):
-        if string[:5].upper() != 'ENTRY':
+        if string[:5].upper() != "ENTRY":
             return
         line = string[5:].lstrip()
-        i = line.find('(')
+        i = line.find("(")
         if i == -1:
             return Entry_Name(line), None, None
         name = Entry_Name(line[:i].rstrip())
         line, repmap = string_replace_map(line[i:])
-        i = line.find(')')
+        i = line.find(")")
         if i == -1:
             return
         args = line[1:i].strip()
         args = Dummy_Arg_List(repmap(args)) if args else None
-        line = line[i+1:].lstrip()
+        line = line[i + 1 :].lstrip()
         if line:
             return name, args, Suffix(repmap(line))
         return name, args, None
 
     def tostr(self):
         name, args, suffix = self.items
         if suffix is None:
             if args is None:
-                return 'ENTRY %s()' % (name)
-            return 'ENTRY %s(%s)' % (name, args)
+                return "ENTRY %s()" % (name)
+            return "ENTRY %s(%s)" % (name, args)
         elif args is None:
-            return 'ENTRY %s() %s' % (name, suffix)
-        return 'ENTRY %s(%s) %s' % (name, args, suffix)
+            return "ENTRY %s() %s" % (name, suffix)
+        return "ENTRY %s(%s) %s" % (name, args, suffix)
 
 
 class Return_Stmt(StmtBase):  # R1236
     """
     <return-stmt> = RETURN [ <scalar-int-expr> ]
     """
+
     subclass_names = []
-    use_names = ['Scalar_Int_Expr']
+    use_names = ["Scalar_Int_Expr"]
 
+    @staticmethod
     def match(string):
         start = string[:6].upper()
-        if start != 'RETURN':
+        if start != "RETURN":
             return
         if len(string) == 6:
-            return None,
-        return Scalar_Int_Expr(string[6:].lstrip()),
-    match = staticmethod(match)
+            return (None,)
+        return (Scalar_Int_Expr(string[6:].lstrip()),)
 
     def tostr(self):
         if self.items[0] is None:
-            return 'RETURN'
-        return 'RETURN %s' % self.items
+            return "RETURN"
+        return "RETURN %s" % self.items
 
 
 class Contains_Stmt(StmtBase, STRINGBase):  # R1237
     """
     <contains-stmt> = CONTAINS
     """
+
     subclass_names = []
 
+    @staticmethod
     def match(string):
-        return STRINGBase.match('CONTAINS', string)
-
-    match = staticmethod(match)
+        return STRINGBase.match("CONTAINS", string)
 
 
 class Stmt_Function_Stmt(StmtBase):  # R1238
     """
-    <stmt-function-stmt>
-    = <function-name> ( [ <dummy-arg-name-list> ] ) = Scalar_Expr
+    ::
+
+        <stmt-function-stmt>
+        = <function-name> ( [ <dummy-arg-name-list> ] ) = Scalar_Expr
+
     """
+
     subclass_names = []
-    use_names = ['Function_Name', 'Dummy_Arg_Name_List', 'Scalar_Expr']
+    use_names = ["Function_Name", "Dummy_Arg_Name_List", "Scalar_Expr"]
 
+    @staticmethod
     def match(string):
-        i = string.find('=')
+        i = string.find("=")
         if i == -1:
             return
-        expr = string[i+1:].lstrip()
+        expr = string[i + 1 :].lstrip()
         if not expr:
             return
         line = string[:i].rstrip()
-        if not line or not line.endswith(')'):
+        if not line or not line.endswith(")"):
             return
-        i = line.find('(')
+        i = line.find("(")
         if i == -1:
             return
         name = line[:i].rstrip()
         if not name:
             return
-        args = line[i+1:-1].strip()
+        args = line[i + 1 : -1].strip()
         if args:
-            return Function_Name(name),       \
-                   Dummy_Arg_Name_List(args), \
-                   Scalar_Expr(expr)
+            return Function_Name(name), Dummy_Arg_Name_List(args), Scalar_Expr(expr)
         return Function_Name(name), None, Scalar_Expr(expr)
 
-    match = staticmethod(match)
-
     def tostr(self):
         if self.items[1] is None:
-            return '%s () = %s' % (self.items[0], self.items[2])
-        return '%s (%s) = %s' % self.items
+            return "%s () = %s" % (self.items[0], self.items[2])
+        return "%s (%s) = %s" % self.items
+
 
 #
 # GENERATE Scalar_, _List, _Name CLASSES
 #
 
 
 ClassType = type(Base)
 _names = dir()
 for clsname in _names:
     my_cls = eval(clsname)
-    if not (isinstance(my_cls, ClassType) and issubclass(my_cls, Base) and
-            not my_cls.__name__.endswith('Base')):
+    if not (
+        isinstance(my_cls, ClassType)
+        and issubclass(my_cls, Base)
+        and not my_cls.__name__.endswith("Base")
+    ):
         continue
 
-    names = getattr(my_cls, 'subclass_names', []) + \
-        getattr(my_cls, 'use_names', [])
+    names = getattr(my_cls, "subclass_names", []) + getattr(my_cls, "use_names", [])
     for n in names:
         if n in _names:
             continue
-        if n.endswith('_List'):
+        if n.endswith("_List"):
             _names.append(n)
             n = n[:-5]
             # Generate 'list' class
-            exec('''\
+            exec(
+                """\
 class %s_List(SequenceBase):
     subclass_names = [\'%s\']
     use_names = []
     def match(string): return SequenceBase.match(r\',\', %s, string)
-    match = staticmethod(match)
-''' % (n, n, n))
-        elif n.endswith('_Name'):
+
+"""
+                % (n, n, n)
+            )
+        elif n.endswith("_Name"):
             _names.append(n)
             n = n[:-5]
-            exec('''\
+            exec(
+                """\
 class %s_Name(Base):
     subclass_names = [\'Name\']
-''' % (n))
-        elif n.startswith('Scalar_'):
+"""
+                % (n)
+            )
+        elif n.startswith("Scalar_"):
             _names.append(n)
             n = n[7:]
-            exec('''\
+            exec(
+                """\
 class Scalar_%s(Base):
     subclass_names = [\'%s\']
-''' % (n, n))
+"""
+                % (n, n)
+            )
+
+
+DynamicImport().import_now()
+
+
+# Inspect the contents of this module and list all of the classes in __all__
+# for automatic documentation generation with AutoDoc.
+
+classes = inspect.getmembers(
+    sys.modules[__name__],
+    lambda member: inspect.isclass(member) and member.__module__ == __name__,
+)
 
-# EOF
+__all__ = [name[0] for name in classes]
```

### Comparing `fparser-0.0.9/src/fparser/two/parser.py` & `fparser-0.1.0/src/fparser/two/parser.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,9 +1,9 @@
-# Modified work Copyright (c) 2018 Science and Technology
-# Facilities Council
+# Modified work Copyright (c) 2018-2023 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -59,214 +59,223 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-'''This file provides utilities to create a Fortran parser suitable
-for a particular standard.'''
-# pylint: disable=eval-used
+"""This file provides utilities to create a Fortran parser suitable
+for a particular standard."""
 
 import inspect
+import logging
 import sys
+from fparser.two.symbol_table import SYMBOL_TABLES
 
 
 def get_module_classes(input_module):
-    '''Return all classes local to a module.
+    """
+    Return all classes local to a module.
 
     :param module input_module: the module containing the classes.
-    :return: a `list` of tuples each containing a class name and a \
-    class.
 
-    '''
+    :returns: list of class names and types.
+    :rtype: List[Tuple[str, type]]
+
+    """
     module_cls_members = []
     module_name = input_module.__name__
-    # first find all classes in the module. This includes imported
-    # classes.
-    all_cls_members = inspect.getmembers(sys.modules[module_name],
-                                         inspect.isclass)
+    # First find all classes in the module. This includes imported classes.
+    all_cls_members = inspect.getmembers(sys.modules[module_name], inspect.isclass)
     # next only keep classes that are specified in the module.
-    for cls_member in all_cls_members:
-        if cls_member[1].__module__ == module_name:
-            module_cls_members.append(cls_member)
+    for name, cls in all_cls_members:
+        if cls.__module__ == module_name:
+            module_cls_members.append((name, cls))
     return module_cls_members
 
 
-class ParserFactory(object):
-    '''Creates a parser suitable for the specified Fortran standard.'''
+class ParserFactory:
+    """Creates a parser suitable for the specified Fortran standard."""
 
     def create(self, std=None):
-        '''Creates a class hierarchy suitable for the specified Fortran
-        standard.
+        """Creates a class hierarchy suitable for the specified Fortran
+        standard. Also sets-up the list of classes that define scoping
+        regions in the global SymbolTables object and clears any existing
+        symbol table information.
 
         :param str std: the Fortran standard. Choices are 'f2003' or \
                         'f2008'. 'f2003' is the default.
         :return: a Program class (not object) for use with the Fortran reader
         :rtype: :py:class:`fparser.two.Fortran2003.Program`
+
         :raises ValueError: if the supplied value for the std parameter \
                             is invalid
 
         For example:
 
         >>> from fparser.two.parser import ParserFactory
         >>> f2003_parser = ParserFactory().create()
         >>> f2003_parser = ParserFactory().create(std='f2003')
         >>> f2008_parser = ParserFactory().create(std='f2008')
         >>> # Assuming that a reader has already been created ...
         >>> ast = f2008_parser(reader)
-        >>> print ast
+        >>> print(ast)
+
+        """
+        # Clear any existing symbol tables.
+        SYMBOL_TABLES.clear()
 
-        '''
         # find all relevant classes in our Fortran2003 file as we
         # always need these.
+        # pylint: disable=import-outside-toplevel
         from fparser.two import Fortran2003
+
         f2003_cls_members = get_module_classes(Fortran2003)
         if not std:
             # default to f2003.
             std = "f2003"
+
         if std == "f2003":
             # we already have our required list of classes so call _setup
             # to setup our class hierarchy.
             self._setup(f2003_cls_members)
-            # the class hierarchy has been set up so return the top
+            # The class hierarchy has been set up so return the top
             # level class that we start from when parsing Fortran code.
             return Fortran2003.Program
-        elif std == "f2008":
+        if std == "f2008":
             # we need to find all relevent classes in our Fortran2003
             # and Fortran2008 files and then ensure that where classes
             # have the same name we return the Fortran2008 class
             # i.e. where Fortran2008 extends Fortran2003 we return
             # Fortran2008.
             # First find all Fortran2008 classes.
             from fparser.two import Fortran2008
+
             f2008_cls_members = get_module_classes(Fortran2008)
+
             # next add in Fortran2003 classes if they do not already
             # exist as a Fortran2008 class.
             f2008_class_names = [i[0] for i in f2008_cls_members]
             for local_cls in f2003_cls_members:
                 if local_cls[0] not in f2008_class_names:
                     f2008_cls_members.append(local_cls)
             # we now have our required list of classes so call _setup
             # to setup our class hierarchy.
             self._setup(f2008_cls_members)
-            # the class hierarchy has been set up so return the top
+            # The class hierarchy has been set up so return the top
             # level class that we start from when parsing Fortran
             # code. Fortran2008 does not extend the top level class so
             # we return the Fortran2003 one.
             return Fortran2003.Program
-        else:
-            raise ValueError("'{0}' is an invalid standard".format(std))
+
+        raise ValueError(f"'{std}' is an invalid standard")
 
     def _setup(self, input_classes):
-        '''Perform some Python magic to create the connections between classes
+        """Perform some Python magic to create the connections between classes
         and populate the baseclass with this information. This has
         been lifted from the original implementation and no attempt
         has been made to tidy up the code, other than making it
         conformant to the coding rules.
 
         :param list input_classes: a list of tuples each containing a \
         class name and a class.
 
-        '''
-
-        __autodoc__ = []
-        base_classes = {}
+        """
+        # pylint: disable=import-outside-toplevel
+        from fparser.two import Fortran2003
 
-        import logging
-        import fparser.two.Fortran2003
-        class_type = type(fparser.two.Fortran2003.Base)
+        class_type = type(Fortran2003.Base)
 
         # Reset subclasses dictionary in case this function has been
         # called before. If this is not done then multiple calls to
         # the ParserFactory create method may not work correctly.
-        fparser.two.Fortran2003.Base.subclasses = {}
+        Fortran2003.Base.subclasses = {}
+        base_classes = {}
 
-        for clsinfo in input_classes:
-            clsname = "{0}.{1}".format(clsinfo[1].__module__, clsinfo[0])
-            cls = eval(clsname)
+        for _, cls in input_classes:
             # ?? classtype is set to Base so why have issubclass?
-            if isinstance(cls, class_type) and \
-               issubclass(cls, fparser.two.Fortran2003.Base) \
-               and not cls.__name__.endswith('Base'):
+            if (
+                isinstance(cls, class_type)
+                and issubclass(cls, Fortran2003.Base)
+                and not cls.__name__.endswith("Base")
+            ):
                 base_classes[cls.__name__] = cls
-                if len(__autodoc__) < 10:
-                    __autodoc__.append(cls.__name__)
 
-        #
         # OPTIMIZE subclass_names tree.
         #
+        def _closest_descendants_with_match(clsname):
+            """
+            Starting at the named class, searches down the tree defined by the
+            classes named in the `subclass_names` list to find the closest that
+            have `match` methods. If the current class does not have a
+            `match` method then this method is called again for each of
+            the classes in its `subclass_names` list.
+
+            :param str clsname: The name of the class from which to search.
+
+            :returns: names of 'nearest' subclasses with `match` methods.
+            :rtype: List[str | NoneType]
+
+            """
+            if clsname not in base_classes:
+                error_string = f"Not implemented: {clsname}"
+                logging.getLogger(__name__).debug(error_string)
+                return []
+            # remove this code when all classes are implemented.
+            cls = base_classes[clsname]
+            if hasattr(cls, "match"):
+                # This class has a `match` method so no need to search further
+                # down the tree.
+                return [clsname]
+            # clsname doesn't have a `match` method so we look at each of its
+            # subclasses and find the nearest class in each that does have a
+            # `match` method.
+            bits = []
+            for names in getattr(cls, "subclass_names", []):
+                list1 = _closest_descendants_with_match(names)
+                for names1 in list1:
+                    if names1 not in bits:
+                        bits.append(names1)
+            return bits
 
-        if 1:  # Optimize subclass tree:
+        # Dict in which to store optimised list of subclass names for each cls.
+        local_subclass_names = {}
 
-            def _rpl_list(clsname):
-                if clsname not in base_classes:
-                    error_string = 'Not implemented: {0}'.format(clsname)
-                    logging.getLogger(__name__).debug(error_string)
-                    return []
-                # remove this code when all classes are implemented.
-                cls = base_classes[clsname]
-                if 'match' in cls.__dict__:
-                    return [clsname]
-                bits = []
-                for names in getattr(cls, 'subclass_names', []):
-                    list1 = _rpl_list(names)
-                    for names1 in list1:
-                        if names1 not in bits:
-                            bits.append(names1)
-                return bits
-
-            for cls in list(base_classes.values()):
-                if not hasattr(cls, 'subclass_names'):
-                    continue
-                opt_subclass_names = []
-                for names in cls.subclass_names:
-                    for names1 in _rpl_list(names):
-                        if names1 not in opt_subclass_names:
-                            opt_subclass_names.append(names1)
-                if not opt_subclass_names == cls.subclass_names:
-                    cls.subclass_names[:] = opt_subclass_names
-
-        # Initialize Base.subclasses dictionary:
-        for clsname, cls in list(base_classes.items()):
-            subclass_names = getattr(cls, 'subclass_names', None)
-            if subclass_names is None:
-                message = '%s class is missing subclass_names list' % (clsname)
+        for cls in base_classes.values():
+            if not hasattr(cls, "subclass_names"):
+                continue
+            # The optimised list of subclass names will only include subclasses
+            # that have `match` methods.
+            opt_subclass_names = []
+            for names in cls.subclass_names:
+                for names1 in _closest_descendants_with_match(names):
+                    if names1 not in opt_subclass_names:
+                        opt_subclass_names.append(names1)
+            local_subclass_names[cls] = opt_subclass_names[:]
+
+        # Now that we've optimised the list of subclass names for each class,
+        # use this information to initialise the Base.subclasses dictionary:
+        for clsname, cls in base_classes.items():
+            if not hasattr(cls, "subclass_names"):
+                message = f"{clsname} class is missing subclass_names list"
                 logging.getLogger(__name__).debug(message)
                 continue
+            subclass_names = local_subclass_names.get(cls, [])
             try:
-                bits = fparser.two.Fortran2003.Base.subclasses[clsname]
+                bits = Fortran2003.Base.subclasses[clsname]
             except KeyError:
-                fparser.two.Fortran2003.Base.subclasses[clsname] = bits = []
+                Fortran2003.Base.subclasses[clsname] = bits = []
             for name in subclass_names:
                 if name in base_classes:
                     bits.append(base_classes[name])
                 else:
-                    message = '{0} not implemented needed by {1}'. \
-                              format(name, clsname)
+                    message = f"{name} not implemented needed by {clsname}"
                     logging.getLogger(__name__).debug(message)
 
-        if 1:
-            for cls in list(base_classes.values()):
-                # subclasses = fparser.two.Fortran2003.Base.subclasses.get(
-                #     cls.__name__, [])
-                # subclasses_names = [c.__name__ for c in subclasses]
-                subclass_names = getattr(cls, 'subclass_names', [])
-                use_names = getattr(cls, 'use_names', [])
-                # for name in subclasses_names:
-                #     break
-                #     if name not in subclass_names:
-                #         message = ('%s needs to be added to %s '
-                #                    'subclasses_name list'
-                #                    % (name, cls.__name__))
-                #         logging.getLogger(__name__).debug(message)
-                # for name in subclass_names:
-                #     break
-                #     if name not in subclasses_names:
-                #         message = '%s needs to be added to %s '
-                #         'subclass_name list' % (name, cls.__name__)
-                #         logging.getLogger(__name__).debug(message)
-                for name in use_names + subclass_names:
-                    if name not in base_classes:
-                        message = ('%s not defined used '
-                                   'by %s' % (name, cls.__name__))
-                        logging.getLogger(__name__).debug(message)
+        # Double-check that all required classes have been constructed.
+        for cls in base_classes.values():
+            subclass_names = local_subclass_names.get(cls, [])
+            use_names = getattr(cls, "use_names", [])
+            for name in use_names + subclass_names:
+                if name not in base_classes:
+                    message = f"{name} not defined, used by {cls.__name__}"
+                    logging.getLogger(__name__).debug(message)
```

### Comparing `fparser-0.0.9/src/fparser/two/pattern_tools.py` & `fparser-0.1.0/src/fparser/two/pattern_tools.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-# Modified work Copyright (c) 2017 Science and Technology Facilities Council
+# Modified work Copyright (c) 2017-2022 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -61,428 +62,484 @@
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
 """
 Tools for constructing patterns.
 
------
 Permission to use, modify, and distribute this software is given under the
-terms of the NumPy License. See http://scipy.org.
+terms of the NumPy License. See http\://scipy.org.
 
 NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
 Author: Pearu Peterson <pearu@cens.ioc.ee>
 Created: Oct 2006
------
+
 """
 import re
 
 dollar_ok = True
 
 
-class Pattern(object):
+class Pattern:
     """
-    p1 | p2    -> <p1> | <p2>
-    p1 + p2    -> <p1> <p2>
-    p1 & p2    -> <p1><p2>
-    ~p1        -> [ <p1> ]
-    ~~p1       -> [ <p1> ]...
-    ~~~p1      -> <p1> [ <p1> ]...
-    ~~~~p1     -> ~~~p1
-    abs(p1)    -> whole string match of <p1>
-    p1.named(name) -> match of <p1> has name
-    p1.match(string) -> return string match with <p1>
-    p1.flags(<re.I,..>)
-    p1.rsplit(..) -> split a string from the rightmost p1 occurrence
-    p1.lsplit(..) -> split a string from the leftmost p1 occurrence
+
+    ::
+
+        p1 | p2    -> <p1> | <p2>
+        p1 + p2    -> <p1> <p2>
+        p1 & p2    -> <p1><p2>
+        ~p1        -> [ <p1> ]
+        ~~p1       -> [ <p1> ]...
+        ~~~p1      -> <p1> [ <p1> ]...
+        ~~~~p1     -> ~~~p1
+        abs(p1)    -> whole string match of <p1>
+        p1.named(name) -> match of <p1> has name
+        p1.match(string) -> return string match with <p1>
+        p1.flags(<re.I,..>)
+        p1.rsplit(..) -> split a string from the rightmost p1 occurrence
+        p1.lsplit(..) -> split a string from the leftmost p1 occurrence
+
     """
-    _special_symbol_map = {'.': '[.]',
-                           '*': '[*]',
-                           '+': '[+]',
-                           '|': '[|]',
-                           '(': r'\(',
-                           ')': r'\)',
-                           '[': r'\[',
-                           ']': r'\]',
-                           '^': '[^]',
-                           '$': '[$]',
-                           '?': '[?]',
-                           '{': '\{',
-                           '}': '\}',
-                           '>': '[>]',
-                           '<': '[<]',
-                           '=': '[=]'
-                           }
+
+    _special_symbol_map = {
+        ".": "[.]",
+        "*": "[*]",
+        "+": "[+]",
+        "|": "[|]",
+        "(": r"\(",
+        ")": r"\)",
+        "[": r"\[",
+        "]": r"\]",
+        "^": "[^]",
+        "$": "[$]",
+        "?": "[?]",
+        "{": r"\{",
+        "}": r"\}",
+        ">": "[>]",
+        "<": "[<]",
+        "=": "[=]",
+    }
 
     def __init__(self, label, pattern, optional=0, flags=0, value=None):
         self.label = label
         self.pattern = pattern
         self.optional = optional
         self._flags = flags
         self.value = value
-        return
 
     def flags(self, *flags):
         f = self._flags
         for f1 in flags:
             f = f | f1
-        return Pattern(self.label, self.pattern, optional=self.optional,
-                       flags=f, value=self.value)
+        return Pattern(
+            self.label, self.pattern, optional=self.optional, flags=f, value=self.value
+        )
 
     def get_compiled(self):
         try:
             return self._compiled_pattern
         except AttributeError:
-            self._compiled_pattern = compiled = re.compile(self.pattern,
-                                                           self._flags)
+            self._compiled_pattern = compiled = re.compile(self.pattern, self._flags)
             return compiled
 
     def match(self, string):
         return self.get_compiled().match(string)
 
     def search(self, string):
         return self.get_compiled().search(string)
 
     def rsplit(self, string, is_add=False):
         """
-        Return (<lhs>, <pattern_match>, <rhs>) where
-          string = lhs + pattern_match + rhs
+        Return (<lhs>, <pattern_match>, <rhs>) where::
+
+            string = lhs + pattern_match + rhs
+
         and rhs does not contain pattern_match.
         If no pattern_match is found in string, return None.
         """
         compiled = self.get_compiled()
         t = compiled.split(string)
         if is_add:
-            n = ''.join(t[-3:]).replace(' ', '')
+            n = "".join(t[-3:]).replace(" ", "")
             if abs_real_literal_constant.match(n):
                 t = t[:-3] + [n]
         if len(t) < 3:
             return
-        if '' in t[1:-1]:
+        if "" in t[1:-1]:
             return
         rhs = t[-1].strip()
         pattern_match = t[-2].strip()
-        assert abs(self).match(pattern_match), \
-            repr((self, string, t, pattern_match))
-        lhs = (''.join(t[:-2])).strip()
+        assert abs(self).match(pattern_match), repr((self, string, t, pattern_match))
+        lhs = ("".join(t[:-2])).strip()
         return lhs, pattern_match, rhs
 
     def lsplit(self, string):
         """
-        Return (<lhs>, <pattern_match>, <rhs>) where
-          string = lhs + pattern_match + rhs
+        Return (<lhs>, <pattern_match>, <rhs>) where::
+
+            string = lhs + pattern_match + rhs
+
         and rhs does not contain pattern_match.
         If no pattern_match is found in string, return None.
         """
         compiled = self.get_compiled()
         t = compiled.split(string)  # can be optimized
         if len(t) < 3:
             return
         lhs = t[0].strip()
         pattern_match = t[1].strip()
-        rhs = (''.join(t[2:])).strip()
+        rhs = ("".join(t[2:])).strip()
         assert abs(self).match(pattern_match), repr(pattern_match)
         return lhs, pattern_match, rhs
 
     def __abs__(self):
-        return Pattern(self.label, r'\A' + self.pattern + r'\Z',
-                       flags=self._flags, value=self.value)
+        return Pattern(
+            self.label,
+            r"\A" + self.pattern + r"\Z",
+            flags=self._flags,
+            value=self.value,
+        )
 
     def __repr__(self):
-        return '%s(%r, %r)' % (self.__class__.__name__, self.label,
-                               self.pattern)
+        return "%s(%r, %r)" % (self.__class__.__name__, self.label, self.pattern)
 
     def __or__(self, other):
-        label = '( %s OR %s )' % (self.label, other.label)
+        label = "( %s OR %s )" % (self.label, other.label)
         if self.pattern == other.pattern:
             pattern = self.pattern
             flags = self._flags
         else:
-            pattern = '(%s|%s)' % (self.pattern, other.pattern)
+            pattern = "(%s|%s)" % (self.pattern, other.pattern)
             flags = self._flags | other._flags
         return Pattern(label, pattern, flags=flags)
 
     def __and__(self, other):
         if isinstance(other, Pattern):
-            label = '%s%s' % (self.label, other.label)
+            label = "%s%s" % (self.label, other.label)
             pattern = self.pattern + other.pattern
             flags = self._flags | other._flags
         else:
             assert isinstance(other, str), repr(other)
-            label = '%s%s' % (self.label, other)
+            label = "%s%s" % (self.label, other)
             pattern = self.pattern + other
             flags = self._flags
         return Pattern(label, pattern, flags=flags)
 
     def __rand__(self, other):
         assert isinstance(other, str), repr(other)
-        label = '%s%s' % (other, self.label)
+        label = "%s%s" % (other, self.label)
         pattern = other + self.pattern
         return Pattern(label, pattern, flags=self._flags)
 
     def __invert__(self):
         if self.optional:
             if self.optional == 1:
                 return Pattern(
-                    self.label + '...', self.pattern[:-1] + '*',
-                    optional=2, flags=self._flags)
+                    self.label + "...",
+                    self.pattern[:-1] + "*",
+                    optional=2,
+                    flags=self._flags,
+                )
             if self.optional == 2:
-                return Pattern('%s %s' % (self.label[1:-4].strip(),
-                                          self.label),
-                               self.pattern[:-1] + '+',
-                               optional=3, flags=self._flags)
+                return Pattern(
+                    "%s %s" % (self.label[1:-4].strip(), self.label),
+                    self.pattern[:-1] + "+",
+                    optional=3,
+                    flags=self._flags,
+                )
             return self
-        label = '[ %s ]' % (self.label)
-        pattern = '(%s)?' % (self.pattern)
+        label = "[ %s ]" % (self.label)
+        pattern = "(%s)?" % (self.pattern)
         return Pattern(label, pattern, optional=1, flags=self._flags)
 
     def __add__(self, other):
         if isinstance(other, Pattern):
-            label = '%s %s' % (self.label, other.label)
-            pattern = self.pattern + r'\s*' + other.pattern
+            label = "%s %s" % (self.label, other.label)
+            pattern = self.pattern + r"\s*" + other.pattern
             flags = self._flags | other._flags
         else:
             assert isinstance(other, str), repr(other)
-            label = '%s %s' % (self.label, other)
+            label = "%s %s" % (self.label, other)
             other = self._special_symbol_map.get(other, other)
-            pattern = self.pattern + r'\s*' + other
+            pattern = self.pattern + r"\s*" + other
             flags = self._flags
         return Pattern(label, pattern, flags=flags)
 
     def __radd__(self, other):
         assert isinstance(other, str), repr(other)
-        label = '%s %s' % (other, self.label)
+        label = "%s %s" % (other, self.label)
         other = self._special_symbol_map.get(other, other)
-        pattern = other + r'\s*' + self.pattern
+        pattern = other + r"\s*" + self.pattern
         return Pattern(label, pattern, flags=self._flags)
 
     def named(self, name=None):
         if name is None:
             label = self.label
-            assert label[0] + label[-1] == '<>' and ' ' not in \
-                label, repr(label)
+            assert label[0] + label[-1] == "<>" and " " not in label, repr(label)
         else:
-            label = '<%s>' % (name)
-        pattern = '(?P%s%s)' % (label.replace('-', '_'), self.pattern)
+            label = "<%s>" % (name)
+        pattern = "(?P%s%s)" % (label.replace("-", "_"), self.pattern)
         return Pattern(label, pattern, flags=self._flags, value=self.value)
 
     def rename(self, label):
-        if label[0] + label[-1] != '<>':
-            label = '<%s>' % (label)
-        return Pattern(label, self.pattern, optional=self.optional,
-                       flags=self._flags, value=self.value)
+        if label[0] + label[-1] != "<>":
+            label = "<%s>" % (label)
+        return Pattern(
+            label,
+            self.pattern,
+            optional=self.optional,
+            flags=self._flags,
+            value=self.value,
+        )
 
     def __call__(self, string):
         m = self.match(string)
         if m is None:
             return
         if self.value is not None:
             return self.value
         return m.group()
 
+
 # Predefined patterns
 
 
-letter = Pattern('<letter>', '[A-Z]', flags=re.I)
+letter = Pattern("<letter>", "[A-Z]", flags=re.I)
 if dollar_ok:
-    name = Pattern('<name>', r'[A-Z][\w$]*', flags=re.I)
+    name = Pattern("<name>", r"[A-Z][\w$]*", flags=re.I)
 else:
-    name = Pattern('<name>', r'[A-Z]\w*', flags=re.I)
+    name = Pattern("<name>", r"[A-Z]\w*", flags=re.I)
 # file_name pattern is start of match '^' to end of match '$', either
 # match a single character that is not space '\S', or '|' a single
 # character that is not space at the start '\S' and end '\S' of the
 # match with anything '.*' inbetween.
-file_name = Pattern('<file_name>', '^(\S|\S.*\S)$', flags=re.I)
-digit = Pattern('<digit>', r'\d')
-underscore = Pattern('<underscore>', '_')
-binary_digit = Pattern('<binary-digit>', r'[01]')
-octal_digit = Pattern('<octal-digit>', r'[0-7]')
-hex_digit = Pattern('<hex-digit>', r'[\dA-F]', flags=re.I)
+file_name = Pattern("<file_name>", r"^(\S|\S.*\S)$", flags=re.I)
+macro_name = Pattern("<macro_name>", r"[A-Z_]\w*", flags=re.I)
+abs_macro_name = abs(macro_name)
+digit = Pattern("<digit>", r"\d")
+underscore = Pattern("<underscore>", "_")
+binary_digit = Pattern("<binary-digit>", r"[01]")
+octal_digit = Pattern("<octal-digit>", r"[0-7]")
+hex_digit = Pattern("<hex-digit>", r"[\dA-F]", flags=re.I)
 
-digit_string = Pattern('<digit-string>', r'\d+')
+digit_string = Pattern("<digit-string>", r"\d+")
 abs_digit_string = abs(digit_string)
-abs_digit_string_named = abs(digit_string.named('value'))
-binary_digit_string = Pattern('<binary-digit-string>', r'[01]+')
-octal_digit_string = Pattern('<octal-digit-string>', r'[0-7]+')
-hex_digit_string = Pattern('<hex-digit-string>', r'[\dA-F]+', flags=re.I)
-
-sign = Pattern('<sign>', r'[+-]')
-exponent_letter = Pattern('<exponent-letter>', r'[ED]', flags=re.I)
-
-alphanumeric_character = Pattern('<alphanumeric-character>',
-                                 r'\w')  # [A-Z0-9_]
-special_character = Pattern('<special-character>',
-                            r'[ =+-*/\()[\]{},.:;!"%&~<>?,\'`^|$#@]')
+abs_digit_string_named = abs(digit_string.named("value"))
+binary_digit_string = Pattern("<binary-digit-string>", r"[01]+")
+octal_digit_string = Pattern("<octal-digit-string>", r"[0-7]+")
+hex_digit_string = Pattern("<hex-digit-string>", r"[\dA-F]+", flags=re.I)
+
+sign = Pattern("<sign>", r"[+-]")
+exponent_letter = Pattern("<exponent-letter>", r"[ED]", flags=re.I)
+
+alphanumeric_character = Pattern("<alphanumeric-character>", r"\w")  # [A-Z0-9_]
+special_character = Pattern(
+    "<special-character>", r'[ =+-*/\()[\]{},.:;!"%&~<>?,\'`^|$#@]'
+)
 character = alphanumeric_character | special_character
 
 kind_param = digit_string | name
-kind_param_named = kind_param.named('kind-param')
+kind_param_named = kind_param.named("kind-param")
 signed_digit_string = ~sign + digit_string
-int_literal_constant = digit_string + ~('_' + kind_param)
+int_literal_constant = digit_string + ~("_" + kind_param)
 signed_int_literal_constant = ~sign + int_literal_constant
-int_literal_constant_named = digit_string.named('value') + \
-                             ~ ('_' + kind_param_named)
-signed_int_literal_constant_named = (~sign + digit_string).named('value') \
-                                    + ~ ('_' + kind_param_named)
-
-binary_constant = ('B' + ("'" & binary_digit_string & "'" |
-                          '"' & binary_digit_string & '"')).flags(re.I)
-octal_constant = ('O' + ("'" & octal_digit_string & "'" |
-                         '"' & octal_digit_string & '"')).flags(re.I)
-hex_constant = ('Z' + ("'" & hex_digit_string & "'" |
-                       '"' & hex_digit_string & '"')).flags(re.I)
+int_literal_constant_named = digit_string.named("value") + ~("_" + kind_param_named)
+signed_int_literal_constant_named = (~sign + digit_string).named("value") + ~(
+    "_" + kind_param_named
+)
+
+binary_constant = (
+    "B" + ("'" & binary_digit_string & "'" | '"' & binary_digit_string & '"')
+).flags(re.I)
+octal_constant = (
+    "O" + ("'" & octal_digit_string & "'" | '"' & octal_digit_string & '"')
+).flags(re.I)
+hex_constant = (
+    "Z" + ("'" & hex_digit_string & "'" | '"' & hex_digit_string & '"')
+).flags(re.I)
 boz_literal_constant = binary_constant | octal_constant | hex_constant
 
 exponent = signed_digit_string
-significand = digit_string + '.' + ~digit_string | '.' + digit_string
-real_literal_constant = significand + ~(exponent_letter + exponent) \
-                        + ~ ('_' + kind_param) | digit_string + \
-                        exponent_letter + exponent + ~ ('_' + kind_param)
-real_literal_constant_named = (significand + ~(exponent_letter + exponent) |
-                               digit_string + exponent_letter +
-                               exponent).named('value') \
-                               + ~ ('_' + kind_param_named)
-signed_real_literal_constant_named = (~sign +
-                                      (significand +
-                                       ~(exponent_letter + exponent) |
-                                       digit_string + exponent_letter +
-                                       exponent)).named('value') + \
-                                       ~ ('_' + kind_param_named)
+significand = digit_string + "." + ~digit_string | "." + digit_string
+real_literal_constant = significand + ~(exponent_letter + exponent) + ~(
+    "_" + kind_param
+) | digit_string + exponent_letter + exponent + ~("_" + kind_param)
+real_literal_constant_named = (
+    significand + ~(exponent_letter + exponent)
+    | digit_string + exponent_letter + exponent
+).named("value") + ~("_" + kind_param_named)
+signed_real_literal_constant_named = (
+    ~sign
+    + (
+        significand + ~(exponent_letter + exponent)
+        | digit_string + exponent_letter + exponent
+    )
+).named("value") + ~("_" + kind_param_named)
 signed_real_literal_constant = ~sign + real_literal_constant
 
 named_constant = name
-real_part = signed_int_literal_constant | signed_real_literal_constant |\
-            named_constant
+real_part = signed_int_literal_constant | signed_real_literal_constant | named_constant
 imag_part = real_part
-complex_literal_constant = '(' + real_part + ',' + imag_part + ')'
-
-a_n_rep_char = Pattern('<alpha-numeric-rep-char>', r'\w')
-rep_char = Pattern('<rep-char>', r'.')
-char_literal_constant = ~(kind_param + '_') + ("'" + ~~rep_char + "'" |
-                                               '"' + ~~rep_char + '"')
-a_n_char_literal_constant_named1 = ~(kind_param_named + '_') + \
-                                   (~~~("'" + ~~a_n_rep_char + "'")).\
-                                   named('value')
-a_n_char_literal_constant_named2 = ~(kind_param_named + '_') + \
-                                   (~~~('"' + ~~a_n_rep_char + '"')).\
-                                   named('value')
+complex_literal_constant = "(" + real_part + "," + imag_part + ")"
 
-logical_literal_constant = (r'[.]\s*(TRUE|FALSE)\s*[.]' +
-                            ~ ('_' + kind_param)).flags(re.I)
+a_n_rep_char = Pattern("<alpha-numeric-rep-char>", r"\w")
+rep_char = Pattern("<rep-char>", r".")
+char_literal_constant = ~(kind_param + "_") + (
+    "'" + ~~rep_char + "'" | '"' + ~~rep_char + '"'
+)
+a_n_char_literal_constant_named1 = ~(kind_param_named + "_") + (
+    ~~~("'" + ~~a_n_rep_char + "'")
+).named("value")
+a_n_char_literal_constant_named2 = ~(kind_param_named + "_") + (
+    ~~~('"' + ~~a_n_rep_char + '"')
+).named("value")
+
+logical_literal_constant = (r"[.]\s*(TRUE|FALSE)\s*[.]" + ~("_" + kind_param)).flags(
+    re.I
+)
 logical_literal_constant_named = Pattern(
-    '<value>', r'[.]\s*(TRUE|FALSE)\s*[.]', flags=re.I).named() + \
-    ~ ('_' + kind_param_named)
-literal_constant = int_literal_constant | real_literal_constant | \
-                   complex_literal_constant | logical_literal_constant | \
-                   char_literal_constant | boz_literal_constant
+    "<value>", r"[.]\s*(TRUE|FALSE)\s*[.]", flags=re.I
+).named() + ~("_" + kind_param_named)
+literal_constant = (
+    int_literal_constant
+    | real_literal_constant
+    | complex_literal_constant
+    | logical_literal_constant
+    | char_literal_constant
+    | boz_literal_constant
+)
 constant = literal_constant | named_constant
 int_constant = int_literal_constant | boz_literal_constant | named_constant
 char_constant = char_literal_constant | named_constant
 
 # assume that replace_string_map is applied:
-part_ref = name + ~((r'[(]' + name + r'[)]'))
-data_ref = part_ref + ~~~(r'[%]' + part_ref)
-primary = constant | name | data_ref | (r'[(]' + name + r'[)]')
-
-power_op = Pattern('<power-op>', r'(?<![*])[*]{2}(?![*])')
-mult_op = Pattern('<mult-op>', r'(?<![*])[*](?![*])|(?<![/])[/](?![/])')
-add_op = Pattern('<add-op>', r'[+-]')
-concat_op = Pattern('<concat-op>', r'(?<![/])[/]\s*[/](?![/])')
+part_ref = name + ~((r"[(]" + name + r"[)]"))
+data_ref = part_ref + ~~~(r"[%]" + part_ref)
+primary = constant | name | data_ref | (r"[(]" + name + r"[)]")
+
+power_op = Pattern("<power-op>", r"(?<![*])[*]{2}(?![*])")
+mult_op = Pattern("<mult-op>", r"(?<![*])[*](?![*])|(?<![/])[/](?![/])")
+add_op = Pattern("<add-op>", r"[+-]")
+concat_op = Pattern("<concat-op>", r"(?<![/])[/]\s*[/](?![/])")
 rel_op = Pattern(
-    '<rel-op>',
-    '[.]\s*EQ\s*[.]|[.]\s*NE\s*[.]|[.]\s*LT\s*[.]|[.]\s*LE\s*[.]|'
-    '[.]\s*GT\s*[.]|[.]\s*GE\s*[.]|[=]{2}|/[=]|[<][=]|[<]|[>][=]|[>]',
-    flags=re.I)
-not_op = Pattern('<not-op>', '[.]\s*NOT\s*[.]', flags=re.I)
-and_op = Pattern('<and-op>', '[.]\s*AND\s*[.]', flags=re.I)
-or_op = Pattern('<or-op>', '[.]\s*OR\s*[.]', flags=re.I)
-equiv_op = Pattern('<equiv-op>', '[.]\s*EQV\s*[.]|[.]\s*NEQV\s*[.]',
-                   flags=re.I)
-percent_op = Pattern('<percent-op>', r'%', flags=re.I)
-intrinsic_operator = power_op | mult_op | add_op | concat_op | \
-                     rel_op | not_op | and_op | or_op | equiv_op
+    "<rel-op>",
+    r"[.]\s*EQ\s*[.]|[.]\s*NE\s*[.]|[.]\s*LT\s*[.]|[.]\s*LE\s*[.]|"
+    r"[.]\s*GT\s*[.]|[.]\s*GE\s*[.]|[=]{2}|/[=]|[<][=]|[<]|[>][=]|[>]",
+    flags=re.I,
+)
+not_op = Pattern("<not-op>", r"[.]\s*NOT\s*[.]", flags=re.I)
+and_op = Pattern("<and-op>", r"[.]\s*AND\s*[.]", flags=re.I)
+or_op = Pattern("<or-op>", r"[.]\s*OR\s*[.]", flags=re.I)
+equiv_op = Pattern("<equiv-op>", r"[.]\s*EQV\s*[.]|[.]\s*NEQV\s*[.]", flags=re.I)
+percent_op = Pattern("<percent-op>", r"%", flags=re.I)
+intrinsic_operator = (
+    power_op
+    | mult_op
+    | add_op
+    | concat_op
+    | rel_op
+    | not_op
+    | and_op
+    | or_op
+    | equiv_op
+)
 extended_intrinsic_operator = intrinsic_operator
 
-defined_unary_op = Pattern(
-    '<defined-unary-op>', '[.]\s*[A-Z]+\s*[.]', flags=re.I)
-defined_binary_op = Pattern(
-    '<defined-binary-op>', '[.]\s*[A-Z]+\s*[.]', flags=re.I)
-defined_operator = defined_unary_op | defined_binary_op | \
-                   extended_intrinsic_operator
+defined_unary_op = Pattern("<defined-unary-op>", r"[.]\s*[A-Z]+\s*[.]", flags=re.I)
+defined_binary_op = Pattern("<defined-binary-op>", r"[.]\s*[A-Z]+\s*[.]", flags=re.I)
+defined_operator = defined_unary_op | defined_binary_op | extended_intrinsic_operator
 abs_defined_operator = abs(defined_operator)
-defined_op = Pattern('<defined-op>', '[.][A-Z]+[.]', flags=re.I)
+defined_op = Pattern("<defined-op>", "[.][A-Z]+[.]", flags=re.I)
 abs_defined_op = abs(defined_op)
 
 non_defined_binary_op = intrinsic_operator | logical_literal_constant
 
-label = Pattern('<label>', '\d{1,5}')
+label = Pattern("<label>", r"\d{1,5}")
 abs_label = abs(label)
 
 keyword = name
-keyword_equal = keyword + '='
+keyword_equal = keyword + "="
 
 abs_constant = abs(constant)
 abs_literal_constant = abs(literal_constant)
 abs_int_literal_constant = abs(int_literal_constant)
 abs_signed_int_literal_constant = abs(signed_int_literal_constant)
 abs_signed_int_literal_constant_named = abs(signed_int_literal_constant_named)
 abs_int_literal_constant_named = abs(int_literal_constant_named)
 abs_real_literal_constant = abs(real_literal_constant)
 abs_signed_real_literal_constant = abs(signed_real_literal_constant)
-abs_signed_real_literal_constant_named = abs(
-    signed_real_literal_constant_named)
+abs_signed_real_literal_constant_named = abs(signed_real_literal_constant_named)
 abs_real_literal_constant_named = abs(real_literal_constant_named)
 abs_complex_literal_constant = abs(complex_literal_constant)
 abs_logical_literal_constant = abs(logical_literal_constant)
 abs_char_literal_constant = abs(char_literal_constant)
 abs_boz_literal_constant = abs(boz_literal_constant)
 abs_name = abs(name)
 abs_a_n_char_literal_constant_named1 = abs(a_n_char_literal_constant_named1)
 abs_a_n_char_literal_constant_named2 = abs(a_n_char_literal_constant_named2)
 abs_logical_literal_constant_named = abs(logical_literal_constant_named)
 abs_binary_constant = abs(binary_constant)
 abs_octal_constant = abs(octal_constant)
 abs_hex_constant = abs(hex_constant)
 
 intrinsic_type_name = Pattern(
-    '<intrinsic-type-name>',
-    r'(INTEGER|REAL|COMPLEX|LOGICAL|CHARACTER|DOUBLE\s*COMPLEX|'
-    'DOUBLE\s*PRECISION|BYTE)', flags=re.I)
+    "<intrinsic-type-name>",
+    r"(INTEGER|REAL|COMPLEX|LOGICAL|CHARACTER|DOUBLE\s*COMPLEX|"
+    r"DOUBLE\s*PRECISION|BYTE)",
+    flags=re.I,
+)
 abs_intrinsic_type_name = abs(intrinsic_type_name)
 double_complex_name = Pattern(
-    '<double-complex-name>', 'DOUBLE\s*COMPLEX', flags=re.I,
-    value='DOUBLE COMPLEX')
+    "<double-complex-name>", r"DOUBLE\s*COMPLEX", flags=re.I, value="DOUBLE COMPLEX"
+)
 double_precision_name = Pattern(
-    '<double-precision-name>', 'DOUBLE\s*PRECISION',
-    flags=re.I, value='DOUBLE PRECISION')
+    "<double-precision-name>",
+    r"DOUBLE\s*PRECISION",
+    flags=re.I,
+    value="DOUBLE PRECISION",
+)
 abs_double_complex_name = abs(double_complex_name)
 abs_double_precision_name = abs(double_precision_name)
 
-access_spec = Pattern('<access-spec>', r'PUBLIC|PRIVATE', flags=re.I)
+access_spec = Pattern("<access-spec>", r"PUBLIC|PRIVATE", flags=re.I)
 abs_access_spec = abs(access_spec)
 
-implicit_none = Pattern('<implicit-none>', r'IMPLICIT\s*NONE',
-                        flags=re.I, value='IMPLICIT NONE')
+implicit_none = Pattern(
+    "<implicit-none>", r"IMPLICIT\s*NONE", flags=re.I, value="IMPLICIT NONE"
+)
 abs_implicit_none = abs(implicit_none)
 
 attr_spec = Pattern(
-    '<attr-spec>',
-    r'ALLOCATABLE|ASYNCHRONOUS|EXTERNAL|INTENT|INTRINSIC|'
-    'OPTIONAL|PARAMETER|POINTER|PROTECTED|SAVE|TARGET|VALUE|VOLATILE',
-    flags=re.I)
+    "<attr-spec>",
+    r"(ALLOCATABLE|ASYNCHRONOUS|EXTERNAL|INTENT|INTRINSIC|"
+    "OPTIONAL|PARAMETER|POINTER|PROTECTED|SAVE|TARGET|VALUE|VOLATILE)",
+    flags=re.I,
+)
 abs_attr_spec = abs(attr_spec)
 
-dimension = Pattern('<dimension>', r'DIMENSION', flags=re.I)
+attr_spec_f08 = Pattern(
+    "<attr-spec>",
+    r"({})".format(
+        "|".join(  # extend attr_spec with attribute CONTIGUOUS
+            sorted(attr_spec.pattern.strip("()").split("|") + ["CONTIGUOUS"])
+        )
+    ),
+    flags=re.I,
+)
+abs_attr_spec_f08 = abs(attr_spec_f08)
+
+dimension = Pattern("<dimension>", r"DIMENSION", flags=re.I)
 abs_dimension = abs(dimension)
 
-intent = Pattern('<intent>', r'INTENT', flags=re.I)
+intent = Pattern("<intent>", r"INTENT", flags=re.I)
 abs_intent = abs(intent)
 
-intent_spec = Pattern('<intent-spec>', r'INOUT|IN|OUT', flags=re.I)
+intent_spec = Pattern("<intent-spec>", r"INOUT|IN|OUT", flags=re.I)
 abs_intent_spec = abs(intent_spec)
 
-function = Pattern('<function>', r'FUNCTION', flags=re.I)
-subroutine = Pattern('<subroutine>', r'SUBROUTINE', flags=re.I)
+function = Pattern("<function>", r"FUNCTION", flags=re.I)
+subroutine = Pattern("<subroutine>", r"SUBROUTINE", flags=re.I)
 
-select_case = Pattern('<select-case>', r'SELECT\s*CASE', flags=re.I,
-                      value='SELECT CASE')
+select_case = Pattern(
+    "<select-case>", r"SELECT\s*CASE", flags=re.I, value="SELECT CASE"
+)
 abs_select_case = abs(select_case)
```

### Comparing `fparser-0.0.9/src/fparser/two/utils.py` & `fparser-0.1.0/src/fparser/two/utils.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,9 +1,9 @@
-# Modified work Copyright (c) 2017-2019 Science and Technology
-# Facilities Council
+# Modified work Copyright (c) 2017-2023 Science and Technology
+# Facilities Council.
 # Original work Copyright (c) 1999-2008 Pearu Peterson
 
 # All rights reserved.
 
 # Modifications made as part of the fparser project are distributed
 # under the following license:
 
@@ -59,27 +59,25 @@
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 # DAMAGE.
 
-'''Base classes and exception handling for Fortran parser
+"""Base classes and exception handling for Fortran parser.
 
-'''
+"""
 # Original author: Pearu Peterson <pearu@cens.ioc.ee>
 # First version created: Oct 2006
 
 import re
-import logging
-import six
+from fparser.common import readfortran
 from fparser.common.splitline import string_replace_map
-from fparser.two import pattern_tools as pattern
 from fparser.common.readfortran import FortranReaderBase
-
+from fparser.two.symbol_table import SYMBOL_TABLES
 
 # A list of supported extensions to the standard(s)
 
 # An X edit descriptor in a format statement specifies the position
 # (forward from the current position) at which the next character will
 # be transmitted to or from a record. In standard Fortran2003 the X
 # edit descriptor must be preceeded by an integer which specifies how
@@ -107,116 +105,158 @@
 
 # Many compilers support the use of '$' in a fortran write statement
 # to indicate that the carriage return should be suppressed. This is
 # an extension to the Fortran standard and is supported by fparser if
 # 'dollar-descriptor' is specified in the EXTENSIONS list.
 EXTENSIONS += ["dollar-descriptor"]
 
+# Set this to True to get verbose output (on stdout) detailing the matches made
+# while parsing.
+_SHOW_MATCH_RESULTS = False
+
 
 class FparserException(Exception):
-    '''Base class exception for fparser. This allows an external tool to
+    """Base class exception for fparser. This allows an external tool to
     capture all exceptions if required.
 
     :param str info: a string giving contextual error information.
 
-    '''
+    """
+
     def __init__(self, info):
         Exception.__init__(self, info)
 
 
 class NoMatchError(FparserException):
-    '''An exception indicating that a particular rule implemented by a
+    """An exception indicating that a particular rule implemented by a
     class does not match the provided string. It does not necessary
     mean there is an error as another rule may match. This exception
     is used internally so should never be visible externally.
 
-    '''
+    """
 
 
 class FortranSyntaxError(FparserException):
-    '''An exception indicating that fparser believes the provided code to
+    """An exception indicating that fparser believes the provided code to
     be invalid Fortran. Also returns information about the location of
     the error if that information is available.
 
     :param reader: input string or reader where the error took \
     place. This is used to provide line number and line content \
     information.
     :type reader: str or :py:class:`FortranReaderBase`
     :param str info: a string giving contextual error information.
 
-    '''
+    """
+
     def __init__(self, reader, info):
         output = "at unknown location "
         if isinstance(reader, FortranReaderBase):
             output = "at line {0}\n>>>{1}\n".format(
-                reader.linecount,
-                reader.source_lines[reader.linecount-1])
+                reader.linecount, reader.source_lines[reader.linecount - 1]
+            )
         if info:
             output += "{0}".format(info)
         FparserException.__init__(self, output)
 
 
 class InternalError(FparserException):
-    '''An exception indicating that an unexpected error has occured in the
+    """An exception indicating that an unexpected error has occured in the
     parser.
 
     :param str info: a string giving contextual error information.
 
-    '''
+    """
+
     def __init__(self, info):
-        new_info = ("'{0}'. Please report this to the "
-                    "authors.".format(info))
+        new_info = "'{0}'. Please report this to the " "authors.".format(info)
         FparserException.__init__(self, new_info)
 
 
 class InternalSyntaxError(FparserException):
-    '''An exception indicating that a syntax error has been found by the
+    """An exception indicating that a syntax error has been found by the
     parser. This is used instead of `FortranSyntaxError` when the
     reader object is not available.
 
-    '''
+    """
 
 
 def show_result(func):
-    return func
+    """
+    A decorator that enables the matching sequence to be debugged by outputting
+    the result (to stdout) whenever a new node in the parse tree is successfully
+    constructed.
 
-    def new_func(cls, string, **kws):
-        r = func(cls, string, **kws)
-        if r is not None and isinstance(r, StmtBase):
-            print('%s(%r) -> %r' % (cls.__name__, string, str(r)))
-        return r
-    return new_func
+    :param function func: the functor that is being called.
+
+    :returns: the supplied functor.
+    :rtype: function
+
+    """
+    if not _SHOW_MATCH_RESULTS:
+        # Just return the supplied functor unchanged.
+        return func
+
+    # It's not possible to monkeypatch decorators since the functions they are
+    # wrapping get modified at module-import time. Therefore, we can't get
+    # coverage of the rest of this routine.
+    def new_func(cls, string, **kws):  # pragma: no cover
+        """
+        New functor to replace the one supplied. Simply wraps the supplied
+        functor with some code that prints the match if it was successful.
+
+        :param type cls: the Class that is being matched.
+        :param str string: the string we are attempting to match.
+        :param *kws: additional keyword arguments.
+        :type *kws: Dict[str, Any]
+
+        :returns: new functor object.
+        :rtype: function
+
+        """
+        result = func(cls, string, **kws)
+        if isinstance(result, StmtBase):
+            if result:
+                print(f"{cls.__name__}({string}) -> {result}")
+            else:
+                print(f"{cls.__name__}({string}) did NOT match")
+        return result
+
+    return new_func  # pragma: no cover
 
 
 #
 # BASE CLASSES
 #
 
 
-class ComparableMixin(object):
-    """ Mixin class to provide rich comparison operators.
+class ComparableMixin:
+    """Mixin class to provide rich comparison operators.
 
     This mixin provides a set of rich comparison operators. Each class using
     this mixin has to provide a _cmpkey() method that returns a key of objects
     that can be compared.
 
     See also http://python3porting.com/preparing.html#richcomparisons
     """
+
     # pylint: disable=too-few-public-methods
 
     def _compare(self, other, method):
-        """ Call the method, if other is able to be used within it.
+        """Call the method, if other is able to be used within it.
 
         :param object other: The other object to compare with
         :type other: object
         :param method: The method to call to compare self and other.
         :type method: LambdaType
+
         :return: NotImplemented, when the comparison for the given type
                  combination can't be performed.
-        :rtype: :py:type:`NotImplementedType`
+        :rtype: :py:class:`types.NotImplementedType`
+
         """
         try:
             # This routine's purpose is to access the protected method
             # _cmpkey() from client classes, therefore: pylint:
             # disable=protected-access
             return method(self._cmpkey(), other._cmpkey())
         except (AttributeError, TypeError):
@@ -242,599 +282,881 @@
     def __gt__(self, other):
         return self._compare(other, lambda s, o: s > o)
 
     def __ne__(self, other):
         return self._compare(other, lambda s, o: s != o)
 
 
+class DynamicImport:
+    """This class imports a set of fparser.two dependencies that can not
+    be imported during the Python Import time because they have a circular
+    dependency with this file.
+
+    They are imported once when the Fortran2003 is already processed by
+    calling the import_now() method.
+
+    The alternative is to have the equivalent top-level imports in the
+    Base.__new__ method, but this method is in the parser critical path and
+    is best to keep expensive operations out of it.
+    """
+
+    @staticmethod
+    def import_now():
+        """Execute the Import of Fortran2003 dependencies."""
+        # pylint: disable=import-outside-toplevel
+        from fparser.two.Fortran2003 import (
+            Else_If_Stmt,
+            Else_Stmt,
+            End_If_Stmt,
+            Masked_Elsewhere_Stmt,
+            Elsewhere_Stmt,
+            End_Where_Stmt,
+            Type_Guard_Stmt,
+            End_Select_Type_Stmt,
+            Case_Stmt,
+            End_Select_Stmt,
+            Comment,
+            Include_Stmt,
+            add_comments_includes_directives,
+        )
+        from fparser.two import C99Preprocessor
+
+        DynamicImport.Else_If_Stmt = Else_If_Stmt
+        DynamicImport.Else_Stmt = Else_Stmt
+        DynamicImport.End_If_Stmt = End_If_Stmt
+        DynamicImport.Masked_Elsewhere_Stmt = Masked_Elsewhere_Stmt
+        DynamicImport.Elsewhere_Stmt = Elsewhere_Stmt
+        DynamicImport.End_Where_Stmt = End_Where_Stmt
+        DynamicImport.Type_Guard_Stmt = Type_Guard_Stmt
+        DynamicImport.End_Select_Type_Stmt = End_Select_Type_Stmt
+        DynamicImport.Case_Stmt = Case_Stmt
+        DynamicImport.End_Select_Stmt = End_Select_Stmt
+        DynamicImport.Comment = Comment
+        DynamicImport.Include_Stmt = Include_Stmt
+        DynamicImport.C99Preprocessor = C99Preprocessor
+        DynamicImport.add_comments_includes_directives = (
+            add_comments_includes_directives
+        )
+
+
+di = DynamicImport()
+
+
+def _set_parent(parent_node, items):
+    """ Recursively set the parent of all of the elements
+    in the list that are a sub-class of Base. (Recursive because
+    sometimes the list of elements itself contains a list or tuple.)
+
+    :param parent_node: the parent of the nodes listed in `items`.
+    :type parent_node: sub-class of :py:class:`fparser.two.utils.Base`
+    :param items: list or tuple of nodes for which to set the parent.
+    :type items: list or tuple of :py:class:`fparser.two.utils.Base` \
+                 or `str` or `list` or `tuple` or NoneType.
+    """
+    for item in items:
+        if item:
+            if isinstance(item, Base):
+                # We can only set the parent of `Base` objects.
+                # Anything else (e.g. str) is passed over.
+                item.parent = parent_node
+            elif isinstance(item, (list, tuple)):
+                _set_parent(parent_node, item)
+
+
 class Base(ComparableMixin):
-    ''' Base class for Fortran 2003 syntax rules.
+    """Base class for Fortran 2003 syntax rules.
+
+    All Base classes have the following attributes::
 
-    All Base classes have the following attributes:
-      self.string - original argument to construct a class instance, its type \
-                    is either str or FortranReaderBase.
-      self.item   - Line instance (holds label) or None.
+        self.string - original argument to construct a class instance, its
+                      type is either str or FortranReaderBase.
+        self.item   - Line instance (holds label) or None.
+
+    :param type cls: the class of object to create.
+    :param string: (source of) Fortran string to parse.
+    :type string: str | :py:class:`fparser.common.readfortran.FortranReaderBase`
+    :param parent_cls: the parent class of this object.
+    :type parent_cls: `type`
+
+    """
 
-    '''
     # This dict of subclasses is populated dynamically by code at the end
-    # of this module. That code uses the entries in the
+    # of the fparser.two.parser module. That code uses the entries in the
     # 'subclass_names' list belonging to each class defined in this module.
+    # See Issue #191 for a discussion of a way of getting rid of this state.
     subclasses = {}
 
+    def __init__(self, string, parent_cls=None):
+        # pylint:disable=unused-argument
+        self.parent = None
+
     @show_result
     def __new__(cls, string, parent_cls=None):
-        """
-        Create a new instance of this object.
-
-        :param type cls: the class of object to create
-        :param string: (source of) Fortran string to parse
-        :type string: str or :py:class:`FortranReaderBase`
-        :param parent_cls: the parent class of this object
-        :type parent_cls: :py:type:`type`
-        """
-        from fparser.common import readfortran
         if parent_cls is None:
             parent_cls = [cls]
         elif cls not in parent_cls:
             parent_cls.append(cls)
 
         # Get the class' match method if it has one
-        match = cls.__dict__.get('match')
+        match = getattr(cls, "match", None)
 
-        if isinstance(string, FortranReaderBase) and \
-           match and not issubclass(cls, BlockBase):
+        if (
+            isinstance(string, FortranReaderBase)
+            and match
+            and not issubclass(cls, BlockBase)
+        ):
             reader = string
             item = reader.get_item()
             if item is None:
-                return
+                return None
             if isinstance(item, readfortran.Comment):
                 # We got a comment but we weren't after a comment (we handle
                 # those in Comment.__new__)
                 obj = None
             else:
                 try:
                     obj = item.parse_line(cls, parent_cls)
                 except NoMatchError:
                     obj = None
             if obj is None:
                 # No match so give the item back to the reader
                 reader.put_item(item)
-                return
+                return None
             obj.item = item
             return obj
 
         result = None
         if match:
             # IMPORTANT: if string is FortranReaderBase then cls must
             # restore readers content when no match is found.
             try:
                 result = cls.match(string)
             except NoMatchError as msg:
-                if str(msg) == '%s: %r' % (cls.__name__, string):
+                if str(msg) == "%s: %r" % (cls.__name__, string):
                     # avoid recursion 1.
                     raise
 
         if isinstance(result, tuple):
             obj = object.__new__(cls)
             obj.string = string
             obj.item = None
-            if hasattr(cls, 'init'):
+            # Set-up parent information for the results of the match
+            _set_parent(obj, result)
+            if hasattr(cls, "init"):
                 obj.init(*result)
             return obj
-        elif isinstance(result, Base):
+        if isinstance(result, Base):
             return result
-        elif result is None:
+        if result is None:
             # Loop over the possible sub-classes of this class and
-            # check for matches
+            # check for matches. This uses the list of subclasses calculated
+            # at runtime in fparser.two.parser.
             for subcls in Base.subclasses.get(cls.__name__, []):
                 if subcls in parent_cls:  # avoid recursion 2.
                     continue
                 try:
                     obj = subcls(string, parent_cls=parent_cls)
-                except NoMatchError as msg:
+                except NoMatchError:
                     obj = None
                 if obj is not None:
                     return obj
         else:
             raise AssertionError(repr(result))
         # If we get to here then we've failed to match the current line
         if isinstance(string, FortranReaderBase):
             content = False
             for index in range(string.linecount):
                 # Check all lines up to this one for content. We
                 # should be able to only check the current line but
                 # but as the line number returned is not always
-                # correct (due to coding errors) we can not assume the
+                # correct (due to coding errors) we cannot assume the
                 # line pointed to is the line where the error actually
                 # happened.
                 if string.source_lines[index].strip():
                     content = True
                     break
             if not content:
                 # There are no lines in the input or all lines up to
                 # this one are empty or contain only white space. This
                 # is typically accepted by fortran compilers so we
                 # follow their lead and do not raise an exception.
                 return
-            line = string.source_lines[string.linecount-1]
-            errmsg = u"at line {0}\n>>>{1}\n".format(
-                string.linecount, line)
+            line = string.source_lines[string.linecount - 1]
+            errmsg = f"at line {string.linecount}\n>>>{line}\n"
         else:
-            errmsg = u"{0}: '{1}'".format(cls.__name__, string)
+            errmsg = f"{cls.__name__}: '{string}'"
         raise NoMatchError(errmsg)
 
+    def get_root(self):
+        """
+        Gets the node at the root of the parse tree to which this node belongs.
+
+        :returns: the node at the root of the parse tree.
+        :rtype: :py:class:`fparser.two.utils.Base`
+
+        """
+        current = self
+        while current.parent:
+            current = current.parent
+        return current
+
+    @property
+    def children(self):
+        """Return an iterable containing the immediate children of this node in
+        the parse tree.
+
+        If this node represents an expression then its children are
+        contained in a tuple which is immutable. Therefore, the
+        manipulation of the children of such a node must be done by
+        replacing the `items` property of the node directly rather than via the
+        objects returned by this method.
+
+        :returns: the immediate children of this node.
+        :rtype: list or tuple containing zero or more of \
+                :py:class:`fparser.two.utils.Base` or NoneType or str
+
+        """
+        child_list = getattr(self, "content", None)
+        if child_list is None:
+            child_list = getattr(self, "items", [])
+        return child_list
+
     def init(self, *items):
+        """
+        Store the supplied list of nodes in the `items` list of this node.
+
+        :param items: the children of this node.
+        :type items: tuple of :py:class:`fparser.two.utils.Base`
+
+        """
         self.items = items
-        return
 
     def torepr(self):
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(map(repr,
-                                                                  self.items)))
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(map(repr, self.items)))
 
     def __str__(self):
         return self.tostr()
 
     def __repr__(self):
         return self.torepr()
 
     def _cmpkey(self):
-        """ Provides a key of objects to be used for comparing.
-        """
+        """Provides a key of objects to be used for comparing."""
         return self.items
 
-    def tofortran(self, tab='', isfix=None):
-        '''
+    def tofortran(self, tab="", isfix=None):
+        """
         Produce the Fortran representation of this Comment.
 
         :param str tab: characters to pre-pend to output.
         :param bool isfix: whether or not this is fixed-format code.
 
         :returns: Fortran representation of this comment.
         :rtype: str
-        '''
-        this_str = six.text_type(self)
+        """
+        this_str = str(self)
         if this_str.strip():
             return tab + this_str
-        else:
-            # If this_str is empty (i.e this Comment is a blank line) then
-            # don't prepend any spaces to it
-            return this_str
+        # If this_str is empty (i.e this Comment is a blank line) then
+        # don't prepend any spaces to it
+        return this_str
 
     def restore_reader(self, reader):
         reader.put_item(self.item)
 
 
+class ScopingRegionMixin:
+    """
+    Mixin class for use in all classes that represent a scoping region and
+    thus have an associated symbol table.
+
+    """
+
+    def get_scope_name(self):
+        """
+        :returns: the name of this scoping region.
+        :rtype: str
+        """
+        return self.get_name().string
+
+
 class BlockBase(Base):
     """
-::
-    <block-base> = [ <startcls> ]
-                     [ <subcls> ]...
-                     ...
-                     [ <subcls> ]...
-                     [ <endcls> ]
+    Base class for matching all block constructs::
+
+        <block-base> = [ <startcls> ]
+                         [ <subcls> ]...
+                         ...
+                         [ <subcls> ]...
+                         [ <endcls> ]
 
-content : tuple
     """
+
     @staticmethod
-    def match(startcls, subclasses, endcls, reader,
-              match_labels=False,
-              match_names=False,
-              match_name_classes=(),
-              enable_do_label_construct_hook=False,
-              enable_if_construct_hook=False,
-              enable_where_construct_hook=False,
-              enable_select_type_construct_hook=False,
-              enable_case_construct_hook=False,
-              strict_order=False,
-              ):
-        '''
+    def match(
+        startcls,
+        subclasses,
+        endcls,
+        reader,
+        match_labels=False,
+        match_names=False,
+        match_name_classes=(),
+        enable_do_label_construct_hook=False,
+        enable_if_construct_hook=False,
+        enable_where_construct_hook=False,
+        strict_order=False,
+        strict_match_names=False,
+    ):
+        """
         Checks whether the content in reader matches the given
         type of block statement (e.g. DO..END DO, IF...END IF etc.)
 
-        :param type startcls: The class marking the beginning of the block
-        :param list subclasses: List of classes that can be children of
-                                the block
-        :param type endcls: The class marking the end of the block
-        :param reader: Content to check for match
+        :param type startcls: the class marking the beginning of the block
+        :param list subclasses: list of classes that can be children of \
+                                the block.
+        :param type endcls: the class marking the end of the block.
+        :param reader: content to check for match.
         :type reader: str or instance of :py:class:`FortranReaderBase`
-        :param bool match_labels: TBD
+        :param bool match_labels: whether or not the statement terminating \
+            the block must have a label that matches the opening statement. \
+            Default is False.
         :param bool match_names: TBD
         :param tuple match_name_classes: TBD
         :param bool enable_do_label_construct_hook: TBD
         :param bool enable_if_construct_hook: TBD
         :param bool enable_where_construct_hook: TBD
-        :param bool enable_select_type_construct_hook: TBD
-        :param bool enable_case_construct_hook: TBD
-        :param bool strict_order: Whether to enforce the order of the
+        :param bool strict_order: whether to enforce the order of the \
                                   given subclasses.
+        :param bool strict_match_names: if start name present, end name \
+                                        must exist and match.
 
         :return: instance of startcls or None if no match is found
         :rtype: startcls
-        '''
-        from fparser.two.Fortran2003 import Comment, Include_Stmt, \
-            add_comments_includes
+
+        """
+        # This implementation uses the DynamicImport class and its instance di
+        # to access the Fortran2003 and C99Preprocessor classes, this is a
+        # performance optimization to avoid importing the classes inside this
+        # method since it is in the hotpath (and it can't be done in the
+        # top-level due to circular dependencies).
         assert isinstance(reader, FortranReaderBase), repr(reader)
         content = []
+        # This will store the name of the new SymbolTable if we match a
+        # scoping region.
+        table_name = None
 
         if startcls is not None:
-            # Deal with any preceding comments and/or includes
-            add_comments_includes(content, reader)
+            # Deal with any preceding comments, includes, and/or directives
+            DynamicImport.add_comments_includes_directives(content, reader)
             # Now attempt to match the start of the block
             try:
                 obj = startcls(reader)
             except NoMatchError:
                 obj = None
             if obj is None:
                 # Ultimately we failed to find a match for the
                 # start of the block so put back any comments that
                 # we processed along the way
                 for obj in reversed(content):
                     obj.restore_reader(reader)
                 return
+            if isinstance(obj, ScopingRegionMixin):
+                # We are entering a new scoping unit so create a new
+                # symbol table.
+                # NOTE: if the match subsequently fails then we must
+                #       delete this symbol table.
+                table_name = obj.get_scope_name()
+                SYMBOL_TABLES.enter_scope(table_name)
             # Store the index of the start of this block proper (i.e.
             # excluding any comments)
             start_idx = len(content)
             content.append(obj)
-            if enable_do_label_construct_hook:
+
+            if hasattr(obj, "get_start_label") and enable_do_label_construct_hook:
                 start_label = obj.get_start_label()
             if match_names:
                 start_name = obj.get_start_name()
 
         # Comments and Include statements are always valid sub-classes
-        classes = subclasses + [Comment, Include_Stmt]
+        classes = subclasses + [di.Comment, di.Include_Stmt]
+        # Preprocessor directives are always valid sub-classes
+        cpp_classes = [
+            getattr(di.C99Preprocessor, cls_name)
+            for cls_name in di.C99Preprocessor.CPP_CLASS_NAMES
+        ]
+        classes += cpp_classes
         if endcls is not None:
             classes += [endcls]
-            endcls_all = tuple([endcls]+endcls.subclasses[endcls.__name__])
+            endcls_all = tuple([endcls] + endcls.subclasses[endcls.__name__])
 
-        # Start trying to match the various subclasses, starting from
-        # the beginning of the list (where else?)
-        i = 0
-        had_match = False
-        found_end = False
-        while i < len(classes):
-            if enable_do_label_construct_hook:
-                try:
+        try:
+            # Start trying to match the various subclasses, starting from
+            # the beginning of the list (where else?)
+            i = 0
+            had_match = False
+            found_end = False
+            while i < len(classes):
+                if enable_do_label_construct_hook:
+                    # Multiple, labelled DO statements can reference the
+                    # same label.
                     obj = startcls(reader)
+                    if obj is not None and hasattr(obj, "get_start_label"):
+                        if start_label == obj.get_start_label():
+                            content.append(obj)
+                            continue
+                        obj.restore_reader(reader)
+                # Attempt to match the i'th subclass
+                cls = classes[i]
+                try:
+                    obj = cls(reader)
                 except NoMatchError:
                     obj = None
-                if obj is not None:
-                    if start_label == obj.get_start_label():
-                        content.append(obj)
-                        continue
-                    else:
-                        obj.restore_reader(reader)
-            # Attempt to match the i'th subclass
-            cls = classes[i]
-            try:
-                obj = cls(reader)
-            except NoMatchError:
-                obj = None
-            if obj is None:
-                # No match for this class, continue checking the list
-                # starting from the i+1'th...
-                i += 1
-                continue
+                if obj is None:
+                    # No match for this class, continue checking the list
+                    # starting from the i+1'th...
+                    i += 1
+                    continue
 
-            # We got a match for this class
-            had_match = True
-            content.append(obj)
+                # We got a match for this class
+                had_match = True
+                content.append(obj)
 
-            if match_names and isinstance(obj, match_name_classes):
-                end_name = obj.get_end_name()
-                if end_name and not start_name:
-                    raise FortranSyntaxError(
-                        reader, "Name '{0}' has no corresponding starting "
-                        "name".format(end_name))
-                if end_name and start_name and \
-                   end_name.lower() != start_name.lower():
-                    raise FortranSyntaxError(
-                        reader, "Expecting name '{0}'".format(start_name))
-
-            if endcls is not None and isinstance(obj, endcls_all):
-                if match_labels:
-                    start_label, end_label = content[start_idx].\
-                                             get_start_label(),\
-                                             content[-1].get_end_label()
-                    if start_label != end_label:
-                        continue
-                if match_names:
-                    start_name, end_name = content[start_idx].\
-                                           get_start_name(), \
-                                           content[-1].get_end_name()
+                if match_names and isinstance(obj, match_name_classes):
+                    end_name = obj.get_end_name()
                     if end_name and not start_name:
                         raise FortranSyntaxError(
-                            reader, "Name '{0}' has no corresponding starting "
-                            "name".format(end_name))
-                    elif start_name and end_name and (start_name.lower() !=
-                                                      end_name.lower()):
+                            reader,
+                            f"Name '{end_name}' has no corresponding starting name",
+                        )
+                    if (
+                        end_name
+                        and start_name
+                        and end_name.lower() != start_name.lower()
+                    ):
                         raise FortranSyntaxError(
-                            reader, "Expecting name '{0}'".format(start_name))
-                # We've found the enclosing end statement so break out
-                found_end = True
-                break
-            if not strict_order:
-                # Return to start of classes list now that we've matched.
-                i = 0
-            if enable_if_construct_hook:
-                from fparser.two.Fortran2003 import Else_If_Stmt, Else_Stmt, \
-                    End_If_Stmt
-                if isinstance(obj, Else_If_Stmt):
-                    # Got an else-if so go back to start of possible
-                    # classes to match
-                    i = 0
-                if isinstance(obj, (Else_Stmt, End_If_Stmt)):
-                    # Found end-if
-                    enable_if_construct_hook = False
-            if enable_where_construct_hook:
-                from fparser.two.Fortran2003 import Masked_Elsewhere_Stmt, \
-                    Elsewhere_Stmt, End_Where_Stmt
-                if isinstance(obj, Masked_Elsewhere_Stmt):
+                            reader, f"Expecting name '{start_name}', got '{end_name}'"
+                        )
+
+                if endcls is not None and isinstance(obj, endcls_all):
+                    if match_labels:
+                        start_label, end_label = (
+                            content[start_idx].get_start_label(),
+                            content[-1].get_end_label(),
+                        )
+                        if start_label != end_label:
+                            continue
+                    if match_names:
+                        start_name, end_name = (
+                            content[start_idx].get_start_name(),
+                            content[-1].get_end_name(),
+                        )
+
+                        if end_name and not start_name:
+                            raise FortranSyntaxError(
+                                reader,
+                                f"Name '{end_name}' has no corresponding starting name",
+                            )
+                        elif strict_match_names and start_name and not end_name:
+                            raise FortranSyntaxError(
+                                reader, f"Expecting name '{start_name}' but none given"
+                            )
+                        elif (
+                            start_name
+                            and end_name
+                            and (start_name.lower() != end_name.lower())
+                        ):
+                            raise FortranSyntaxError(
+                                reader,
+                                f"Expecting name '{start_name}', got '{end_name}'",
+                            )
+                    # We've found the enclosing end statement so break out
+                    found_end = True
+                    break
+                if not strict_order:
+                    # Return to start of classes list now that we've matched.
                     i = 0
-                if isinstance(obj, (Elsewhere_Stmt, End_Where_Stmt)):
-                    enable_where_construct_hook = False
-            if enable_select_type_construct_hook:
-                from fparser.two.Fortran2003 import Type_Guard_Stmt, \
-                    End_Select_Type_Stmt
-                if isinstance(obj, Type_Guard_Stmt):
-                    i = 1
-                if isinstance(obj, End_Select_Type_Stmt):
-                    enable_select_type_construct_hook = False
-            if enable_case_construct_hook:
-                from fparser.two.Fortran2003 import Case_Stmt, \
-                    End_Select_Stmt
-                if isinstance(obj, Case_Stmt):
-                    i = 1
-                if isinstance(obj, End_Select_Stmt):
-                    enable_case_construct_hook = False
-            continue
+                if enable_if_construct_hook:
+                    if isinstance(obj, di.Else_If_Stmt):
+                        # Got an else-if so go back to start of possible
+                        # classes to match
+                        i = 0
+                    if isinstance(obj, (di.Else_Stmt, di.End_If_Stmt)):
+                        # Found end-if
+                        enable_if_construct_hook = False
+                if enable_where_construct_hook:
+                    if isinstance(obj, di.Masked_Elsewhere_Stmt):
+                        i = 0
+                    if isinstance(obj, (di.Elsewhere_Stmt, di.End_Where_Stmt)):
+                        enable_where_construct_hook = False
+                continue
+
+        except FortranSyntaxError as err:
+            # We hit trouble so clean up the symbol table
+            if table_name:
+                SYMBOL_TABLES.exit_scope()
+                # Remove any symbol table that we created
+                SYMBOL_TABLES.remove(table_name)
+            raise err
+
+        if table_name:
+            SYMBOL_TABLES.exit_scope()
 
         if not had_match or endcls and not found_end:
             # We did not get a match from any of the subclasses or
             # failed to find the endcls
             if endcls is not None:
+                if table_name:
+                    # Remove any symbol table that we created
+                    SYMBOL_TABLES.remove(table_name)
                 for obj in reversed(content):
                     obj.restore_reader(reader)
-                return
+                return None
 
         if not content:
-            return
+            # We can only get to here if startcls is None - if startcls is not
+            # None and fails to match then we will already have returned. If
+            # it is not None and matches then content will not be empty.
+            # Since startcls must be None, we won't have created a symbol
+            # table so we don't have to clean up.
+            return None
+
         if startcls is not None and endcls is not None:
             # check names of start and end statements:
             start_stmt = content[start_idx]
             end_stmt = content[-1]
-            if isinstance(end_stmt, endcls_all) and \
-               hasattr(end_stmt, 'get_name') and \
-               hasattr(start_stmt, 'get_name'):
+            if (
+                isinstance(end_stmt, endcls_all)
+                and hasattr(end_stmt, "get_name")
+                and hasattr(start_stmt, "get_name")
+            ):
                 if end_stmt.get_name() is not None:
-                    if start_stmt.get_name().string.lower() != \
-                       end_stmt.get_name().string.lower():
+                    if (
+                        start_stmt.get_name().string.lower()
+                        != end_stmt.get_name().string.lower()
+                    ):
                         end_stmt.item.reader.error(
-                            'expected <%s-name> is %s but got %s. Ignoring.'
-                            % (end_stmt.get_type().lower(),
-                               start_stmt.get_name(), end_stmt.get_name()))
-        return content,
+                            "expected <%s-name> is %s but got %s. Ignoring."
+                            % (
+                                end_stmt.get_type().lower(),
+                                start_stmt.get_name(),
+                                end_stmt.get_name(),
+                            )
+                        )
+        return (content,)
 
     def init(self, content):
+        """
+        Initialise the `content` attribute with the list of child nodes.
+
+        :param content: list of nodes that are children of this one.
+        :type content: list of :py:class:`fparser.two.utils.Base` or NoneType
+
+        """
         self.content = content
-        return
 
     def _cmpkey(self):
-        """ Provides a key of objects to be used for comparing.
-        """
+        """Provides a key of objects to be used for comparing."""
         return self.content
 
     def tostr(self):
         return self.tofortran()
 
     def torepr(self):
-        return '%s(%s)' % (self.__class__.__name__, ', '.
-                           join(map(repr, self.content)))
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(map(repr, self.content)))
 
-    def tofortran(self, tab='', isfix=None):
-        '''
+    def tofortran(self, tab="", isfix=None):
+        """
         Create a string containing the Fortran representation of this class
 
-        :param str tab: Indent to prefix to code
-        :param bool isfix: Whether or not to generate fixed-format code
-        :return: Fortran representation of this class
+        :param str tab: indent to prefix to code.
+        :param bool isfix: whether or not to generate fixed-format code.
+
+        :return: Fortran representation of this class.
         :rtype: str
-        '''
+        """
         mylist = []
         start = self.content[0]
         end = self.content[-1]
-        extra_tab = ''
+        extra_tab = ""
         if isinstance(end, EndStmtBase):
-            extra_tab = '  '
+            extra_tab = "  "
         if start is not None:
             mylist.append(start.tofortran(tab=tab, isfix=isfix))
         for item in self.content[1:-1]:
-            mylist.append(item.tofortran(tab=tab+extra_tab, isfix=isfix))
+            mylist.append(item.tofortran(tab=tab + extra_tab, isfix=isfix))
         if len(self.content) > 1:
             mylist.append(end.tofortran(tab=tab, isfix=isfix))
-        return '\n'.join(mylist)
+        return "\n".join(mylist)
 
     def restore_reader(self, reader):
         for obj in reversed(self.content):
             obj.restore_reader(reader)
 
 
 class SequenceBase(Base):
-    '''
-    Match one or more fparser2 rules separated by a defined separator.
+    """
+    Match one or more fparser2 rules separated by a defined separator::
 
-    sequence-base is obj [sep obj ] ...
+        sequence-base is obj [sep obj ] ...
+
+    """
 
-    '''
     @staticmethod
     def match(separator, subcls, string):
-        '''Match one or more 'subcls' fparser2 rules in the string 'string'
+        """Match one or more 'subcls' fparser2 rules in the string 'string'
         separated by 'separator'.
 
-        :param str separator: The separator used to split the supplied \
-        string.
-        :param subcls: An fparser2 object representing the rule that \
-        should be matched.
-        :type subcls: Subclass of :py:class:`fparser.two.utils.Base`
-        :param str string: The input string to match.
-
-        :returns: A tuple containing 1) the separator and 2) the \
-        matched objects in a tuple, or None if there is no match.
-        :rtype: (str, (Subclass of \
-        :py:class:`fparser.two.utils.Base`)) or NoneType
+        :param str separator: the separator used to split the supplied \
+                              string.
+        :param subcls: an fparser2 object representing the rule that \
+                       should be matched.
+        :type subcls: subclass of :py:class:`fparser.two.utils.Base`
+        :param str string: the input string to match.
+
+        :returns: a tuple containing 1) the separator and 2) the \
+                  matched objects in a tuple, or None if there is no match.
+        :rtype: Optional[(Str, :py:class:`fparser.two.utils.Base`)]
+
+        :raises InternalError: if the separator or string arguments  \
+                               are not the expected type.
+        :raises InternalError: if the separator is white space.
 
-        :raises InternalError: If the separator or string arguments \
-        are not the expected type.
-
-        '''
-        if not isinstance(separator, (str, six.text_type)):
+        """
+        if not isinstance(separator, str):
             raise InternalError(
-                "SequenceBase class match method argument separator expected "
-                "to be a string but found '{0}'.".format(type(string)))
-        if not isinstance(string, (str, six.text_type)):
+                f"SequenceBase class match method argument separator expected "
+                f"to be a string but found '{type(separator)}'."
+            )
+        if not isinstance(string, str):
             raise InternalError(
-                "SequenceBase class match method argument string expected to "
-                "be a string but found '{0}'.".format(type(string)))
+                f"SequenceBase class match method argument string expected to "
+                f"be a string but found '{type(string)}'."
+            )
+
+        if separator == " ":
+            raise InternalError(
+                "SequenceBase class match method argument separator cannot "
+                "be white space."
+            )
 
         line, repmap = string_replace_map(string)
-        # Remove multiple spaces in the string. This avoids empty
-        # matches when the separator is white space.
-        line = ' '.join(line.split())
         splitted = line.split(separator)
         if not splitted:
             # There should be at least one entry.
             return None
+
         lst = [subcls(repmap(entry.strip())) for entry in splitted]
+
         return separator, tuple(lst)
 
     def init(self, separator, items):
-        '''Store the result of the match method if the match is successful.
+        """Store the result of the match method if the match is successful.
 
-        :param str separator: The separator used to split the supplied \
-        string.
-        :param items: A tuple containing the matched objects in a \
-        tuple.
-        :type items: (Subclass of :py:class:`fparser.two.utils.Base`)
+        :param str separator: the separator used to split the supplied string.
+        :param items: a tuple containing the matched objects.
+        :type items: tuple(Subclass of :py:class:`fparser.two.utils.Base`)
 
-        '''
+        """
         self.separator = separator
         self.items = items
 
     def tostr(self):
-        '''
+        """
         :returns: The Fortran representation of this object as a string.
         :rtype: str
 
-        '''
+        """
         sep = self.separator
-        if sep == ',':
-            sep = sep + ' '
-        elif sep == ' ':
+        if sep == ",":
+            sep = sep + " "
+        elif sep == " ":
             pass
         else:
-            sep = ' ' + sep + ' '
+            sep = " " + sep + " "
         return sep.join(map(str, self.items))
 
     def torepr(self):
-        '''
+        """
         :returns: The Python representation of this object as a string.
         :rtype: str
 
-        '''
-        return "{0}('{1}', {2})".format(self.__class__.__name__,
-                                        self.separator, self.items)
+        """
+        return "{0}('{1}', {2})".format(
+            self.__class__.__name__, self.separator, self.items
+        )
 
     # The mixin class is likely to be removed so _cmpkey would not be
     # needed. It is not used at the moment. It is only commented out
     # at this point, rather than removed, in case it turns out that
     # the mixin class is useful.
     # def _cmpkey(self):
     #     """ Provides a key of objects to be used for comparing.
     #     """
     #     return (self.separator, self.items)
 
 
 class UnaryOpBase(Base):
     """
-::
-    <unary-op-base> = <unary-op> <rhs>
+    ::
+
+        unary-op-base is unary-op rhs
+
     """
+
     def tostr(self):
-        return '%s %s' % tuple(self.items)
+        return "%s %s" % tuple(self.items)
 
+    @staticmethod
     def match(op_pattern, rhs_cls, string, exclude_op_pattern=None):
         m = op_pattern.match(string)
         if not m:
             return
-        rhs = string[m.end():].lstrip()
+        rhs = string[m.end() :].lstrip()
         if not rhs:
             return
-        op = string[:m.end()].rstrip().upper()
+        op = string[: m.end()].rstrip().upper()
         if exclude_op_pattern is not None:
             if exclude_op_pattern.match(op):
                 return
         return op, rhs_cls(rhs)
-    match = staticmethod(match)
 
 
 class BinaryOpBase(Base):
     """
-::
-    <binary-op-base> = <lhs> <op> <rhs>
-    <op> is searched from right by default.
+    ::
+
+        binary-op-base is lhs op rhs
+
+    Splits the input text into text to the left of the matched
+    operator and text to the right of the matched operator and tries
+    to match the lhs text with the supplied lhs class rule and the rhs
+    text with the supplied rhs class rule.
+
     """
-    def match(lhs_cls, op_pattern, rhs_cls, string, right=True,
-              exclude_op_pattern=None, is_add=False):
+
+    @staticmethod
+    def match(
+        lhs_cls, op_pattern, rhs_cls, string, right=True, exclude_op_pattern=None
+    ):
+        """Matches the binary-op-base rule.
+
+        If the operator defined by argument 'op_pattern' is found in
+        the string provided in argument 'string' then the text to the
+        left-hand-side of the operator is matched with the class rule
+        provided in the 'lhs_cls' argument and the text to the
+        right-hand-side of the operator is matched with the class rule
+        provided in the 'rhs_cls' argument.
+
+        If the optional 'right' argument is set to true (the default)
+        then, in the case where the pattern matches multiple times in
+        the input string, the right-most match will be chosen. If the
+        'right' argument is set to false then the left-most match will
+        be chosen.
+
+        if a pattern is provided to the optional 'exclude_op_pattern'
+        argument then there will be no match if the pattern matched by
+        the 'op_pattern' argument also matches this pattern. The
+        default (None) does nothing.
+
+        :param lhs_cls: an fparser2 object representing the rule that \
+            should be matched to the lhs text.
+        :type lhs_cls: subclass of :py:class:`fparser.two.utils.Base`
+        :param op_pattern: the pattern to match.
+        :type op_pattern: `str` or \
+            :py:class:`fparser.two.pattern_tools.Pattern`
+        :param rhs_cls: an fparser2 object representing the rule that \
+            should be matched to the rhs text.
+        :type rhs_cls: subclass of :py:class:`fparser.two.utils.Base`
+        :param str string: the string to match with the pattern and \
+            lhs and rhs rules.
+        :param bool right: in the case where there are multiple \
+            matches to the pattern in the string this optional \
+            argument specifies whether the righmost pattern match \
+            should be chosen (True, the default) or whether the \
+            leftmost pattern should be chosen (False).
+        :param exclude_op_pattern: optional argument which specifies a \
+            particular subpattern to exclude from the match. Defaults \
+            to None which means there is no subpattern.
+        :type exclude_op_pattern: :py:class:`fparser.two.pattern_tools.Pattern`
+
+        :returns: a tuple containing the matched lhs, the operator and \
+            the matched rhs of the input string or None if there is \
+            no match.
+        :rtype: (:py:class:`fparser.two.utils.Base`, str, \
+            :py:class:`fparser.two.utils.Base`) or NoneType
+
+        """
         line, repmap = string_replace_map(string)
+
         if isinstance(op_pattern, str):
             if right:
-                t = line.rsplit(op_pattern, 1)
+                text_split = line.rsplit(op_pattern, 1)
             else:
-                t = line.split(op_pattern, 1)
-            if len(t) != 2:
-                return
-            lhs, rhs = t[0].rstrip(), t[1].lstrip()
-            op = op_pattern
+                text_split = line.split(op_pattern, 1)
+            if len(text_split) != 2:
+                return None
+            lhs, rhs = text_split[0].rstrip(), text_split[1].lstrip()
+            oper = op_pattern
         else:
             if right:
-                t = op_pattern.rsplit(line, is_add=is_add)
+                text_split = op_pattern.rsplit(line)
             else:
-                t = op_pattern.lsplit(line)
-            if t is None or len(t) != 3:
-                return
-            lhs, op, rhs = t
+                text_split = op_pattern.lsplit(line)
+            if not text_split or len(text_split) != 3:
+                return None
+            lhs, oper, rhs = text_split
             lhs = lhs.rstrip()
             rhs = rhs.lstrip()
-            op = op.upper()
-        if not lhs:
-            return
-        if not rhs:
-            return
-        if exclude_op_pattern is not None:
-            if exclude_op_pattern.match(op):
-                return
+            oper = oper.upper()
+        if not lhs or not rhs:
+            return None
+        if exclude_op_pattern and exclude_op_pattern.match(oper):
+            return None
 
-        lhs_obj = lhs_cls(repmap(lhs))
-        rhs_obj = rhs_cls(repmap(rhs))
-        return lhs_obj, op.replace(' ', ''), rhs_obj
-    match = staticmethod(match)
+        # Matching the shorter text first can be much more efficient
+        # for complex expressions.
+        if right:
+            # The split is closest to the right so try to match the
+            # RHS first.
+            rhs_obj = rhs_cls(repmap(rhs))
+            lhs_obj = lhs_cls(repmap(lhs))
+        else:
+            # The split is closest to the left so try to match the LHS
+            # first.
+            lhs_obj = lhs_cls(repmap(lhs))
+            rhs_obj = rhs_cls(repmap(rhs))
+
+        return (lhs_obj, oper.replace(" ", ""), rhs_obj)
 
     def tostr(self):
-        return '%s %s %s' % tuple(self.items)
+        """Return the string representation of this object. Uses join() which
+        is efficient and can make a big performance difference for
+        complex expressions.
+
+        :returns: the string representation of this object.
+        :rtype: str
+
+        """
+        return " ".join([str(self.items[0]), str(self.items[1]), str(self.items[2])])
 
 
 class SeparatorBase(Base):
     """
-::
-    <separator-base> = [ <lhs> ] : [ <rhs> ]
+    ::
+
+        separator-base is [ lhs ] : [ rhs ]
+
     """
+
+    @staticmethod
     def match(lhs_cls, rhs_cls, string, require_lhs=False, require_rhs=False):
         line, repmap = string_replace_map(string)
-        if ':' not in line:
+        if ":" not in line:
             return
-        lhs, rhs = line.split(':', 1)
+        lhs, rhs = line.split(":", 1)
         lhs = lhs.rstrip()
         rhs = rhs.lstrip()
         lhs_obj, rhs_obj = None, None
         if lhs:
             if lhs_cls is None:
                 return
             lhs_obj = lhs_cls(repmap(lhs))
@@ -843,104 +1165,128 @@
         if rhs:
             if rhs_cls is None:
                 return
             rhs_obj = rhs_cls(repmap(rhs))
         elif require_rhs:
             return
         return lhs_obj, rhs_obj
-    match = staticmethod(match)
 
     def tostr(self):
-        s = ''
+        s = ""
         if self.items[0] is not None:
-            s += '%s :' % (self.items[0])
+            s += "%s :" % (self.items[0])
         else:
-            s += ':'
+            s += ":"
         if self.items[1] is not None:
-            s += ' %s' % (self.items[1])
+            s += " %s" % (self.items[1])
         return s
 
 
 class KeywordValueBase(Base):
     """
-::
-    <keyword-value-base> = [ <lhs> = ] <rhs>
+    ::
+
+        keyword-value-base is [ lhs = ] rhs
+
+    where::
+
+        R215 keyword is name.
+
     """
+
     @staticmethod
     def match(lhs_cls, rhs_cls, string, require_lhs=True, upper_lhs=False):
-        '''
-        :param lhs_cls: list, tuple or single value of classes to attempt to
-                        match LHS against (in order), or string containing
-                        keyword to match
+        """
+        Attempts to match the supplied `string` with `lhs_cls` = `rhs_cls`.
+        If `lhs_cls` is a str then it is compared with the content to the
+        left of the first '=' character in `string`. If that content is a
+        valid Fortran name but does *not* match `lhs_cls` then the match
+        fails, irrespective of the setting of `require_lhs`.
+
+        :param lhs_cls: list, tuple or single value of classes to attempt to \
+                        match LHS against (in order), or string containing \
+                        keyword to match.
         :type lhs_cls: names of classes deriving from `:py:class:Base` or str
-        :param rhs_cls: name of class to match RHS against
+        :param rhs_cls: name of class to match RHS against.
         :type rhs_cls: name of a class deriving from `:py:class:Base`
-        :param str string: text to be matched
-        :param bool require_lhs: whether the expression to be matched must
-                                 contain a LHS that is assigned to
-        :param bool upper_lhs: whether or not to convert the LHS of the
-                               matched expression to upper case
-        :return: instances of the classes representing quantities on the LHS
-                 and RHS (LHS is optional) or nothing if no match is found
-        :rtype: 2-tuple of objects or nothing
-        '''
-        if require_lhs and '=' not in string:
-            return
+        :param str string: text to be matched.
+        :param bool require_lhs: whether the expression to be matched must \
+                                 contain a LHS that is assigned to.
+        :param bool upper_lhs: whether or not to convert the LHS of the \
+                               matched expression to upper case.
+
+        :return: instances of the classes representing quantities on the LHS \
+                 and RHS (LHS is optional) or None if no match is found.
+        :rtype: 2-tuple of objects or NoneType
+
+        """
+        if require_lhs and "=" not in string:
+            return None
         if isinstance(lhs_cls, (list, tuple)):
-            for s in lhs_cls:
-                obj = KeywordValueBase.match(s, rhs_cls, string,
-                                             require_lhs=require_lhs,
-                                             upper_lhs=upper_lhs)
+            for cls in lhs_cls:
+                obj = KeywordValueBase.match(
+                    cls, rhs_cls, string, require_lhs=require_lhs, upper_lhs=upper_lhs
+                )
                 if obj:
                     return obj
             return obj
         # We can't just blindly check whether 'string' contains an '='
         # character as it could itself hold a string constant containing
-        # an '=', e.g. FMT='("Hello = False")'
-        from fparser.two.Fortran2003 import Char_Literal_Constant
-        if not Char_Literal_Constant.match(string) and "=" in string:
-            lhs, rhs = string.split('=', 1)
-            lhs = lhs.rstrip()
-        else:
-            lhs = None
-            rhs = string.rstrip()
-        rhs = rhs.lstrip()
-        if not rhs:
-            return
+        # an '=', e.g. FMT='("Hello = False")'.
+        # Therefore we only split on the left-most '=' character
+        pieces = string.split("=", 1)
+        lhs = None
+        if len(pieces) == 2:
+            # It does contain at least one '='. Proceed to attempt to match
+            # the content on the LHS of it.
+            lhs = pieces[0].strip()
+            if isinstance(lhs_cls, str):
+                # lhs_cls is a keyword
+                if upper_lhs:
+                    lhs = lhs.upper()
+                if lhs != lhs_cls:
+                    # The content to the left of the '=' does not match the
+                    # supplied keyword
+                    lhs = None
+            else:
+                lhs = lhs_cls(lhs)
         if not lhs:
+            # We haven't matched the LHS and therefore proceed to treat the
+            # whole string as a RHS if the LHS is not strictly required.
             if require_lhs:
-                return
-            return None, rhs_cls(rhs)
-        if isinstance(lhs_cls, str):
-            if upper_lhs:
-                lhs = lhs.upper()
-            if lhs_cls != lhs:
-                return
-            return lhs, rhs_cls(rhs)
-        return lhs_cls(lhs), rhs_cls(rhs)
+                return None
+            rhs = string.strip()
+        else:
+            rhs = pieces[-1].strip()
+        if rhs:
+            rhs = rhs_cls(rhs)
+        if not rhs:
+            return None
+        return lhs, rhs
 
     def tostr(self):
         if self.items[0] is None:
             return str(self.items[1])
-        return '%s = %s' % tuple(self.items)
+        return "%s = %s" % tuple(self.items)
 
 
 class BracketBase(Base):
-    '''
+    """
     bracket-base is left-bracket something right-bracket.
 
     This class is able to cope with nested brackets as long as they
     are correctly nested. Brackets in strings are ignored.
 
     The 'something' can be specified as being optional.
 
-    '''
+    """
+
     @staticmethod
     def match(brackets, cls, string, require_cls=True):
-        '''A generic match method for all types of bracketed
+        """A generic match method for all types of bracketed
         expressions.
 
         :param str brackets: the format of the left and right brackets \
         provided as a string, for example '()'
         :param cls: the class to match the content within the brackets \
         :type cls: subclass of :py:class:`fparser.two.utils.Base`
         :param str string: the content to match
@@ -951,205 +1297,227 @@
         first and third entries being strings containing the left and \
         right brackets respectively and the second entry being either \
         None or an instance of the class provided as the second \
         argument (cls).
         :rtype: 'NoneType', ( `str`, `NoneType`, `str`) or ( `str`, \
         `cls`, `str` )
 
-        '''
+        """
         if not cls and require_cls:
             return None
         if not string:
             return None
         string_strip = string.strip()
         if not brackets:
             return None
-        brackets_nospc = brackets.replace(' ', '')
+        brackets_nospc = brackets.replace(" ", "")
         if not brackets_nospc:
             return None
         if len(brackets_nospc) % 2 == 1:
             # LHS and RHS bracketing must be the same size
             return None
-        bracket_len = len(brackets_nospc)//2
+        bracket_len = len(brackets_nospc) // 2
         left = brackets_nospc[:bracket_len]
         right = brackets_nospc[-bracket_len:]
-        if len(string_strip) < bracket_len*2:
+        if len(string_strip) < bracket_len * 2:
             return None
-        if not (string_strip.startswith(left) and
-                string_strip.endswith(right)):
+        if not (string_strip.startswith(left) and string_strip.endswith(right)):
             return None
         # Check whether or not there's anything between the open
         # and close brackets
-        line = string_strip[bracket_len:-bracket_len].strip()
+        line = string_strip[bracket_len:-bracket_len].lstrip()
         if (not line and cls and require_cls) or (line and not cls):
             return None
         if not line and (not cls or not require_cls):
             return left, None, right
         return left, cls(line), right
 
     def tostr(self):
-        '''
+        """
         :raises InternalError: if the internal items list variable is \
-        not the expected size.
+                               not the expected size.
         :raises InternalError: if the first element of the internal \
-        items list is None or is an empty string.
-        '''
+                               items list is None or is an empty string.
+        """
 
         if len(self.items) != 3:
             raise InternalError(
                 "Class BracketBase method tostr() has '{0}' items, "
-                "but expecting 3.".format(len(self.items)))
+                "but expecting 3.".format(len(self.items))
+            )
         if not self.items[0]:
             raise InternalError(
                 "Class BracketBase method tostr(). 'Items' entry 0 "
                 "should be a string containing the left hand bracket "
-                "but it is empty or None")
+                "but it is empty or None"
+            )
         if not self.items[2]:
             raise InternalError(
                 "Class BracketBase method tostr(). 'Items' entry 2 "
                 "should be a string containing the right hand bracket "
-                "but it is empty or None")
+                "but it is empty or None"
+            )
         if self.items[1] is None:
             return "{0}{1}".format(self.items[0], self.items[2])
         return "{0}{1}{2}".format(self.items[0], self.items[1], self.items[2])
 
 
 class NumberBase(Base):
     """
-::
-    <number-base> = <number> [ _ <kind-param> ]
+    ::
+
+        number-base is number [ _ kind-param ]
+
     """
 
+    @staticmethod
     def match(number_pattern, string):
-        m = number_pattern.match(string.replace(' ', ''))
+        m = number_pattern.match(string.replace(" ", ""))
         if m is None:
             return
         d = m.groupdict()
-        return d['value'].upper(), d.get('kind_param')
-    match = staticmethod(match)
+        return d["value"].upper(), d.get("kind_param")
 
     def tostr(self):
         if self.items[1] is None:
             return str(self.items[0])
-        return '%s_%s' % tuple(self.items)
+        return "%s_%s" % tuple(self.items)
 
     def _cmpkey(self):
-        """ Provides a key of objects to be used for comparing.
-        """
+        """Provides a key of objects to be used for comparing."""
         return self.items[0]
 
 
 class CallBase(Base):
     """
-::
-    <call-base> = <lhs> ( [ <rhs> ] )
+    ::
+
+        call-base is lhs ( [ rhs ] )
+
     """
+
+    @staticmethod
     def match(lhs_cls, rhs_cls, string, upper_lhs=False, require_rhs=False):
-        if not string.endswith(')'):
-            return
+        """
+        :param lhs_cls: the class to match with the lhs.
+        :type lhs_cls: str | class
+        :param rhs_cls: the class to match with the rhs.
+        :type rhs_cls: str | class
+        :param str string: the string to attempt to match.
+        :param bool upper_lhs: whether or not to convert the lhs to uppercase \
+                               before attempting the match.
+        :param bool require_rhs: whether the rhs (the part within parentheses) \
+                                 must be present.
+
+        :returns: a tuple containing the lhs and rhs matches or None if there is \
+                  no match.
+        :rtype: Optional[Tuple[:py:class:`fparser.two.utils.Base`, \
+                               Optional[:py:class:`fparser.two.utils.Base`]]]
+
+        """
+        if not string.rstrip().endswith(")"):
+            return None
         line, repmap = string_replace_map(string)
-        i = line.rfind('(')
-        if i == -1:
-            return
-        lhs = line[:i].rstrip()
+        open_idx = line.rfind("(")
+        if open_idx == -1:
+            return None
+        lhs = line[:open_idx].rstrip()
         if not lhs:
             return
-        j = line.rfind(')')
-        rhs = line[i+1: j].strip()
-        if line[j+1:].lstrip():
-            return
+        close_idx = line.rfind(")")
+        rhs = line[open_idx + 1 : close_idx].strip()
         lhs = repmap(lhs)
         if upper_lhs:
             lhs = lhs.upper()
         rhs = repmap(rhs)
         if isinstance(lhs_cls, str):
             if lhs_cls != lhs:
-                return
+                return None
         else:
             lhs = lhs_cls(lhs)
         if rhs:
             if isinstance(rhs_cls, str):
                 if rhs_cls != rhs:
-                    return
+                    return None
             else:
                 rhs = rhs_cls(rhs)
             return lhs, rhs
-        elif require_rhs:
-            return
+        if require_rhs:
+            return None
         return lhs, None
-    match = staticmethod(match)
 
     def tostr(self):
         if self.items[1] is None:
-            return '%s()' % (self.items[0])
-        return '%s(%s)' % (self.items[0], self.items[1])
+            return "%s()" % (self.items[0])
+        return "%s(%s)" % (self.items[0], self.items[1])
 
 
 class CALLBase(CallBase):
     """
-::
-    <CALL-base> = <LHS> ( [ <rhs> ] )
+    ::
+
+        CALL-base is LHS ( [ rhs ] )
+
     """
+
+    @staticmethod
     def match(lhs_cls, rhs_cls, string, require_rhs=False):
-        return CallBase.match(lhs_cls, rhs_cls, string,
-                              upper_lhs=True, require_rhs=require_rhs)
-    match = staticmethod(match)
+        return CallBase.match(
+            lhs_cls, rhs_cls, string, upper_lhs=True, require_rhs=require_rhs
+        )
 
 
 class StringBase(Base):
     """
-::
-    <string-base> = <xyz>
+    ::
+
+        string-base is xyz
 
-Attributes
-----------
-string
     """
+
+    @staticmethod
     def match(pattern, string):
         if isinstance(pattern, (list, tuple)):
             for p in pattern:
                 obj = StringBase.match(p, string)
                 if obj is not None:
                     return obj
             return
         if isinstance(pattern, str):
             if len(pattern) == len(string) and pattern == string:
-                return string,
+                return (string,)
             return
         if pattern.match(string):
-            return string,
-        return
-    match = staticmethod(match)
+            return (string,)
+        return None
 
     def init(self, string):
         self.string = string
-        return
 
     def tostr(self):
         return str(self.string)
 
     def torepr(self):
-        return '%s(%r)' % (self.__class__.__name__, self.string)
+        return "%s(%r)" % (self.__class__.__name__, self.string)
 
     def _cmpkey(self):
-        """ Provides a key of objects to be used for comparing.
-        """
+        """Provides a key of objects to be used for comparing."""
         return self.string
 
 
 class STRINGBase(StringBase):
-    '''STRINGBase matches an upper case version of the input string with
+    """STRINGBase matches an upper case version of the input string with
     another a pattern (typically taken from pattern_tools.py) and
     returns the string in upper case if there is a match.
 
-    '''
+    """
 
     @staticmethod
     def match(my_pattern, string):
-        '''Matches an input string with a specified pattern. Casts the string
+        """Matches an input string with a specified pattern. Casts the string
         to upper case before performing a match and, if there is a
         match, returns the string in upper case.
 
         The pattern can be a regular expression, a string, a list or a
         tuple. If the input pattern is a regular expression or a
         string, a direct equivalence is performed. If the input pattern is a
         list or a tuple, then all of the contents of the list
@@ -1169,354 +1537,419 @@
         :param pattern: the pattern to match
         :type pattern: `list`, `tuple`, `str` or an `re` expression
         :param str string: the string to match with the pattern
         :return: None if there is no match, or a tuple containing the \
         matched string in upper case.
         :rtype: `NoneType` or ( `str` )
 
-        '''
+        """
         if string is None:
             return None
-        if not isinstance(string, (str, six.text_type)):
+        if not isinstance(string, str):
             raise InternalError(
-                "Supplied string should be of type str or {0}, but found "
-                "{1}".format(six.text_type, type(string)))
+                f"Supplied string should be of type str, but found {type(string)}"
+            )
         if isinstance(my_pattern, (list, tuple)):
             for child in my_pattern:
                 result = STRINGBase.match(child, string)
                 if result:
                     return result
             return None
         string_upper = string.upper()
         if isinstance(my_pattern, str):
             if len(my_pattern) == len(string) and my_pattern == string_upper:
-                return string_upper,
+                return (string_upper,)
             return None
         try:
             if my_pattern.match(string_upper):
-                return string_upper,
+                return (string_upper,)
         except AttributeError:
             raise InternalError(
-                "Supplied pattern should be a list, tuple, str or regular "
-                "expression but found {0}".format(type(my_pattern)))
+                f"Supplied pattern should be a list, tuple, str or regular "
+                f"expression but found {type(my_pattern)}"
+            )
         return None
 
 
 class StmtBase(Base):
     """
-::
-    [ [ <label> ] [ <construct-name> : ] ] <stmt>
+    ::
+
+        [ [ label ] [ construct-name : ] ] stmt
+
+    Attributes::
+
+        item : readfortran.Line
 
-Attributes
-----------
-item : readfortran.Line
     """
-    def tofortran(self, tab='', isfix=None):
+
+    def tofortran(self, tab="", isfix=None):
         label = None
         name = None
         if self.item is not None:
             label = self.item.label
             name = self.item.name
         if isfix:
-            c = ' '
+            c = " "
         else:
-            c = ''
+            c = ""
         if label:
             t = c + str(label)
             if isfix:
                 while len(t) < 6:
-                    t += ' '
+                    t += " "
             else:
-                tab = tab[len(t):] or ' '
+                tab = tab[len(t) :] or " "
         else:
             # BUG allow for fixed format here
-            t = ''
+            t = ""
         if name:
-            return t + tab + name+':' + str(self)
+            return t + tab + name + ":" + str(self)
         return t + tab + str(self)
 
     def get_end_label(self):
         return self.item.label
 
 
 class EndStmtBase(StmtBase):
     """
-::
-    <end-stmt-base> = END [ <stmt> [ <stmt-name>] ]
+    ::
+
+        end-stmt-base = END [ stmt [ stmt-name] ]
+
     """
+
     @staticmethod
     def match(stmt_type, stmt_name, string, require_stmt_type=False):
+        """
+        Attempts to match the supplied string as a form of 'END xxx' statement.
+
+        :param str stmt_type: the type of end statement (e.g. "do") that we \
+            attempt to match.
+        :param type stmt_name: a class which should be used to match against \
+            the name should this statement be named (e.g. end subroutine sub).
+        :param str string: the string to attempt to match.
+        :param bool require_stmt_type: whether or not the string must contain \
+            the type of the block that is ending.
+
+        :returns: 2-tuple containing the matched end-statement type (if any) \
+            and, optionally, an associated name or None if there is no match.
+        :rtype: Optional[
+                    Tuple[Optional[str],
+                          Optional[:py:class:`fparser.two.Fortran2003.Name`]]]
+
+        """
         start = string[:3].upper()
-        if start != 'END':
-            return
+        if start != "END":
+            # string doesn't begin with 'END'
+            return None
         line = string[3:].lstrip()
-        start = line[:len(stmt_type)].upper()
+        start = line[: len(stmt_type)].upper()
         if start:
-            if start.replace(' ', '') != stmt_type.replace(' ', ''):
-                return
-            line = line[len(stmt_type):].lstrip()
+            if start.replace(" ", "") != stmt_type.replace(" ", ""):
+                # Not the correct type of 'END ...' statement.
+                return None
+            line = line[len(stmt_type) :].lstrip()
         else:
             if require_stmt_type:
-                return
+                # No type was found but one is required.
+                return None
+            # Got a bare "END" and that is a valid match.
             return None, None
         if line:
             if stmt_name is None:
-                return
+                # There is content after the 'end xxx' but this block isn't
+                # named so we fail to match.
+                return None
+            # Attempt to match the content after 'end xxx' with the supplied
+            # name class.
             return stmt_type, stmt_name(line)
+        # Successful match with an unnamed 'end xxx'.
         return stmt_type, None
 
     def init(self, stmt_type, stmt_name):
+        """
+        Initialise this EndStmtBase object.
+
+        :param str stmt_type: the type of statement, e.g. 'PROGRAM'.
+        :param stmt_name: the name associated with the statement or None.
+        :type stmt_name: :py:class:`fparser.two.Fortran2003.Name`
+
+        """
         self.items = [stmt_type, stmt_name]
-        return
 
     def get_name(self):
         return self.items[1]
 
     def get_type(self):
         return self.items[0]
 
     def tostr(self):
         if self.items[1] is not None:
-            return 'END %s %s' % tuple(self.items)
+            return "END %s %s" % tuple(self.items)
         if self.items[0] is not None:
-            return 'END %s' % (self.items[0])
-        return 'END'
+            return "END %s" % (self.items[0])
+        return "END"
 
     def torepr(self):
-        return '%s(%r, %r)' % (
-            self.__class__.__name__, self.get_type(), self.get_name())
+        return "%s(%r, %r)" % (
+            self.__class__.__name__,
+            self.get_type(),
+            self.get_name(),
+        )
 
     def get_end_name(self):
         name = self.items[1]
         if name is not None:
             return name.string
 
 
 def isalnum(c):
-    return c.isalnum() or c == '_'
+    return c.isalnum() or c == "_"
 
 
 class WORDClsBase(Base):
-    '''Base class to support situations where you have a keyword which is
+    """Base class to support situations where there is a keyword which is
     optionally followed by further text, potentially separated by
-    '::'.
+    a double colon. For example::
 
-    For example 'program fred', or 'import :: a,b'
+        'program fred', or 'import :: a,b'
 
-    WORD-cls is WORD [ [ :: ] cls ]
+        WORD-cls is WORD [ [ :: ] cls ]
+
+    """
 
-    '''
     @staticmethod
-    def match(pattern, cls, string, check_colons=False, require_cls=False):
-        ''':param pattern: the pattern of the WORD to match. This can be a \
-        string, a list of strings or a tuple of strings.
-        :type pattern: str, tuple of str or list of str.
+    def match(keyword, cls, string, colons=False, require_cls=False):
+        """Checks whether the content in string matches the expected
+        WORDClsBase format with 'keyword' providing the keyword, 'cls'
+        providing the following text, 'colons' specifying whether an
+        optional double colon is allowed as a separator between the keyword
+        and cls and 'require_cls' specifying whether cls must have
+        content or not.
+
+        Note, if the optional double colon is allowed and exists in the string
+        then 1) cls must also have content i.e. it implies
+        `require_cls=True` and 2) white space is not required between
+        the keyword and the double colon and the double colon and cls.
+
+        The simplest form of keyword pattern is a string. However this
+        method can also match more complex patterns as specified by
+        the Pattern class in pattern_tools.py. As patterns can be
+        built from combinations of other patterns (again see
+        pattern_tool.py) this method also supports a hierarchy of
+        lists and/or tuples of patterns.
+
+        :param keyword: the pattern of the WORD to match. This can be \
+            a Pattern, string, list or tuple, with a list or tuple \
+            containing one or more Pattern, string, list or tuple.
+        :type keyword: :py:class:`fparser.two.pattern_tools.Pattern`, \
+            str, tuple of str/Pattern/tuple/list or list of \
+            str/Pattern/tuple/list
         :param cls: the class to match.
-        :type cls: a subclass of :py:class:`fparser.two.utils.Base`.
+        :type cls: a subclass of :py:class:`fparser.two.utils.Base`
         :param str string: Text that we are trying to match.
-        :param bool check_colons: whether '::' is allowed or not \
-        between WORD and cls.
+        :param bool colons: whether a double colon is allowed as an optional \
+            separator between between WORD and cls.
         :param bool require_cls: whether content for cls is required \
-        or not.
+            or not.
 
-        '''
-        if isinstance(pattern, (tuple, list)):
-            for p in pattern:
+        :returns: None if there is no match or, if there is a match, a \
+            2-tuple containing a string matching the 'WORD' and an \
+            instance of 'cls' (or None if an instance of cls is not \
+            required and not provided).
+        :rtype: Optional[Tupe[Str, Optional[Cls]]]
+
+        """
+        if isinstance(keyword, (tuple, list)):
+            for child in keyword:
                 try:
-                    obj = WORDClsBase.match(p, cls, string,
-                                            check_colons=check_colons,
-                                            require_cls=require_cls)
+                    obj = WORDClsBase.match(
+                        child, cls, string, colons=colons, require_cls=require_cls
+                    )
                 except NoMatchError:
                     obj = None
                 if obj is not None:
                     return obj
-            return
-        if isinstance(pattern, str):
+            return None
+
+        if isinstance(keyword, str):
             line = string.lstrip()
-            if line[:len(pattern)].upper() != pattern.upper():
-                return
-            line = line[len(pattern):]
-            if not line:
-                if require_cls:
-                    # no text found but it is required
-                    return
-                return pattern, None
-            if isalnum(line[0]):
-                return
-            line = line.lstrip()
-            if check_colons and line.startswith('::'):
-                line = line[2:].lstrip()
-            if not line:
-                if require_cls:
-                    return
-                return pattern, None
-            if cls is None:
-                return
-            return pattern, cls(line)
-        m = pattern.match(string)
-        if m is None:
-            return
-        line = string[len(m.group()):]
-        if pattern.value is not None:
-            pattern_value = pattern.value
+            if line[: len(keyword)].upper() != keyword.upper():
+                return None
+            line = line[len(keyword) :]
+            pattern_value = keyword
         else:
-            pattern_value = m.group().upper()
+            my_match = keyword.match(string)
+            if my_match is None:
+                return None
+            line = string[len(my_match.group()) :]
+            pattern_value = keyword.value
+
         if not line:
+            if require_cls:
+                # no text found but it is required
+                return None
             return pattern_value, None
         if isalnum(line[0]):
-            return
+            return None
         line = line.lstrip()
-        if check_colons and line.startswith('::'):
+        has_colons = False
+        if colons and line.startswith("::"):
+            has_colons = True
             line = line[2:].lstrip()
         if not line:
-            if require_cls:
-                return
+            if has_colons or require_cls:
+                # colons without following content is not allowed.
+                return None
             return pattern_value, None
         if cls is None:
-            return
+            return None
         return pattern_value, cls(line)
 
     def tostr(self):
-        '''Convert the class into Fortran.
+        """Convert the class into Fortran.
 
         :return: String representation of this class without any \
-                 optional '::'.
+                 optional double colon.
         :rtype: str
 
-        '''
+        """
         if self.items[1] is None:
             return str(self.items[0])
         s = str(self.items[1])
-        if s and s[0] in '(*':
-            return '%s%s' % (self.items[0], s)
-        return '%s %s' % (self.items[0], s)
+        if s and s[0] in "(*":
+            return "%s%s" % (self.items[0], s)
+        return "%s %s" % (self.items[0], s)
 
     def tostr_a(self):
-        '''Convert the class into Fortran, adding in "::".
+        """Convert the class into Fortran, adding in the double colon.
 
         :return: String representation of this class including an \
-                 optional '::'.
+                 optional double colon.
         :rtype: str
 
-        '''
+        """
         if self.items[1] is None:
             return str(self.items[0])
-        return '%s :: %s' % (self.items[0], self.items[1])
+        return "%s :: %s" % (self.items[0], self.items[1])
 
 
 class Type_Declaration_StmtBase(StmtBase):
-    """<type-declaration-stmt> = <declaration-type-spec> [ [ ,
-    <attr-spec> ]... :: ] <entity-decl-list>
+    """
+    ::
+
+        type-declaration-stmt is declaration-type-spec [ [ ,
+            attr-spec ]... :: ] entity-decl-list
 
     """
+
     subclass_names = []
     use_names = None  # derived class must define this list
 
     @staticmethod
-    def match(decl_type_spec_cls, attr_spec_list_cls,
-              entity_decl_list_cls, string):
+    def match(decl_type_spec_cls, attr_spec_list_cls, entity_decl_list_cls, string):
         line, repmap = string_replace_map(string)
-        i = line.find('::')
+        i = line.find("::")
         if i != -1:
-            j = line[:i].find(',')
+            j = line[:i].find(",")
             if j != -1:
                 i = j
         else:
-            if line[:6].upper() == 'DOUBLE':
-                m = re.search(r'\s[a-z_]', line[6:].lstrip(), re.I)
+            if line[:6].upper() == "DOUBLE":
+                m = re.search(r"\s[a-z_]", line[6:].lstrip(), re.I)
                 if m is None:
                     return
-                i = m.start() + len(line)-len(line[6:].lstrip())
+                i = m.start() + len(line) - len(line[6:].lstrip())
             else:
-                m = re.search(r'\s[a-z_]', line, re.I)
+                m = re.search(r"\s[a-z_]", line, re.I)
                 if m is None:
                     return
                 i = m.start()
         type_spec = decl_type_spec_cls(repmap(line[:i].rstrip()))
         if type_spec is None:
             return
         line = line[i:].lstrip()
-        if line.startswith(','):
-            i = line.find('::')
+        if line.startswith(","):
+            i = line.find("::")
             if i == -1:
                 return
             attr_specs = attr_spec_list_cls(repmap(line[1:i].strip()))
             if attr_specs is None:
                 return
             line = line[i:]
         else:
             attr_specs = None
-        if line.startswith('::'):
+        if line.startswith("::"):
             line = line[2:].lstrip()
         entity_decls = entity_decl_list_cls(repmap(line))
         if entity_decls is None:
             return
         return type_spec, attr_specs, entity_decls
 
     def tostr(self):
+        """
+        :returns: the text representation of this node.
+        :rtype: str
+        """
         if self.items[1] is None:
-            return '%s :: %s' % (self.items[0], self.items[2])
-        else:
-            return '%s, %s :: %s' % self.items
+            return f"{self.items[0]} :: {self.items[2]}"
+        return f"{self.items[0]}, {self.items[1]} :: {self.items[2]}"
 
 
-def walk_ast(children, my_types=None, indent=0, debug=False):
-    '''
-    Walk down the tree produced by fparser2 where children
-    are listed under 'content'.  Returns a list of all nodes with the
-    specified type(s).
-
-    :param children: list of child nodes from which to walk.
-    :type children: list of :py:class:fparser.two.utils.Base.
-    :param my_types: list of types of Node to return. (Default is to \
-                     return all nodes.)
-    :type my_types: list of type
+def walk(node_list, types=None, indent=0, debug=False):
+    """
+    Walk down the parse tree produced by fparser2.  Returns a list of all
+    nodes with the specified type(s).
+
+    :param node_list: node or list of nodes from which to walk.
+    :type node_list: (list of) :py:class:fparser.two.utils.Base
+    :param types: type or tuple of types of Node to return. (Default is to \
+                  return all nodes.)
+    :type types: type or tuple of types
     :param int indent: extent to which to indent debug output.
     :param bool debug: whether or not to write textual representation of AST \
                        to stdout.
     :returns: a list of nodes
     :rtype: `list` of :py:class:`fparser.two.utils.Base`
-    '''
+    """
     local_list = []
-    for child in children:
+
+    if not isinstance(node_list, (list, tuple)):
+        node_list = [node_list]
+
+    for child in node_list:
         if debug:
             if isinstance(child, str):
-                print(indent*"  " + "child type = ", type(child), repr(child))
+                print(indent * "  " + "child type = ", type(child), repr(child))
             else:
-                print(indent*"  " + "child type = ", type(child))
-        if my_types is None or type(child) in my_types:
+                print(indent * "  " + "child type = ", type(child))
+        if types is None or isinstance(child, types):
             local_list.append(child)
-
-        # Depending on their level in the tree produced by fparser2003,
-        # some nodes have children listed in .content and some have them
-        # listed under .items. If a node has neither then it has no
-        # children.
-        if hasattr(child, "content"):
-            local_list += walk_ast(child.content, my_types, indent+1, debug)
-        elif hasattr(child, "items"):
-            local_list += walk_ast(child.items, my_types, indent+1, debug)
+        # Recurse down
+        if isinstance(child, Base):
+            local_list += walk(child.children, types, indent + 1, debug)
+        elif isinstance(child, tuple):
+            for component in child:
+                local_list += walk(component, types, indent + 1, debug)
 
     return local_list
 
 
-def get_child(root_node, node_type):
-    '''
-    Searches for the first immediate child of root_node that is of the
-    specified type.
+def get_child(node, node_type):
+    """
+    Searches for the first, immediate child of the supplied node that is of
+    the specified type.
 
-    :param root_node: the parent of the child nodes we will search through.
-    :type root_node: :py:class:`fparser.two.utils.Base`
+    :param node: the node whose children will be searched.
+    :type node: :py:class:`fparser.two.utils.Base`
     :param type node_type: the class of child node to search for.
 
-    :returns: the first child node of type node_type that is encountered or \
-              None.
+    :returns: the first child node of type node_type that is encountered \
+              or None.
     :rtype: :py:class:`fparser.two.utils.Base`
-    '''
-    children = []
-    if hasattr(root_node, "content"):
-        children = root_node.content
-    elif hasattr(root_node, "items"):
-        children = root_node.items
-    for node in children:
-        if isinstance(node, node_type):
-            return node
+
+    """
+    for child in node.children:
+        if isinstance(child, node_type):
+            return child
     return None
```

