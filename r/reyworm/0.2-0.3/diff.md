# Comparing `tmp/reyworm-0.2-py3-none-any.whl.zip` & `tmp/reyworm-0.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,24 @@
-Zip file size: 28431 bytes, number of entries: 21
--rw-rw-rw-  2.0 fat      238 b- defN 23-Mar-19 09:16 reyflask/__init__.py
--rw-rw-rw-  2.0 fat      694 b- defN 23-Mar-19 09:16 reytool/__init__.py
--rw-rw-rw-  2.0 fat     9362 b- defN 23-Mar-19 08:14 reytool/rbasic.py
--rw-rw-rw-  2.0 fat     8474 b- defN 23-Mar-09 03:43 reytool/rcommon.py
--rw-rw-rw-  2.0 fat     3237 b- defN 23-Mar-08 14:39 reytool/rcompress.py
--rw-rw-rw-  2.0 fat    10168 b- defN 23-Mar-19 08:14 reytool/rdata.py
--rw-rw-rw-  2.0 fat    18856 b- defN 23-Mar-19 09:08 reytool/rdatabase.py
--rw-rw-rw-  2.0 fat    13294 b- defN 23-Mar-07 02:29 reytool/rdatetime.py
--rw-rw-rw-  2.0 fat     5750 b- defN 23-Feb-23 13:12 reytool/remail.py
--rw-rw-rw-  2.0 fat     2917 b- defN 23-Mar-07 01:13 reytool/rmultitask.py
--rw-rw-rw-  2.0 fat      786 b- defN 23-Feb-23 13:12 reytool/roption.py
--rw-rw-rw-  2.0 fat     1963 b- defN 23-Feb-26 06:55 reytool/rregular.py
--rw-rw-rw-  2.0 fat     4974 b- defN 23-Mar-19 09:10 reytool/rrequest.py
--rw-rw-rw-  2.0 fat     9217 b- defN 23-Feb-23 13:12 reytool/rtext.py
--rw-rw-rw-  2.0 fat     7151 b- defN 23-Mar-07 01:13 reytool/rwrap.py
--rw-rw-rw-  2.0 fat      274 b- defN 23-Mar-19 09:16 reyworm/__init__.py
--rw-rw-rw-  2.0 fat     1206 b- defN 23-Feb-19 11:00 reyworm/rtranslate.py
--rw-rw-rw-  2.0 fat      201 b- defN 23-Mar-19 09:22 reyworm-0.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Mar-19 09:22 reyworm-0.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 23-Mar-19 09:22 reyworm-0.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1572 b- defN 23-Mar-19 09:22 reyworm-0.2.dist-info/RECORD
-21 files, 100434 bytes uncompressed, 25941 bytes compressed:  74.2%
+Zip file size: 31617 bytes, number of entries: 22
+-rw-rw-rw-  2.0 fat      237 b- defN 23-Apr-18 09:19 reyapi/__init__.py
+-rw-rw-rw-  2.0 fat      715 b- defN 23-Apr-18 09:19 reytool/__init__.py
+-rw-rw-rw-  2.0 fat     9517 b- defN 23-Apr-04 12:10 reytool/rbasic.py
+-rw-rw-rw-  2.0 fat     8690 b- defN 23-Apr-18 09:18 reytool/rcommon.py
+-rw-rw-rw-  2.0 fat     3271 b- defN 23-Mar-21 09:55 reytool/rcompress.py
+-rw-rw-rw-  2.0 fat    11618 b- defN 23-Apr-14 08:35 reytool/rdata.py
+-rw-rw-rw-  2.0 fat    22241 b- defN 23-Apr-10 05:02 reytool/rdatabase.py
+-rw-rw-rw-  2.0 fat    16545 b- defN 23-Apr-14 09:19 reytool/rdatetime.py
+-rw-rw-rw-  2.0 fat     6097 b- defN 23-Mar-30 03:12 reytool/remail.py
+-rw-rw-rw-  2.0 fat     4045 b- defN 23-Apr-04 15:53 reytool/rmonkey.py
+-rw-rw-rw-  2.0 fat     3054 b- defN 23-Mar-22 06:09 reytool/rmultitask.py
+-rw-rw-rw-  2.0 fat      786 b- defN 23-Mar-21 09:55 reytool/roption.py
+-rw-rw-rw-  2.0 fat     2607 b- defN 23-Mar-22 06:00 reytool/rregular.py
+-rw-rw-rw-  2.0 fat     5173 b- defN 23-Mar-22 06:11 reytool/rrequest.py
+-rw-rw-rw-  2.0 fat     8813 b- defN 23-Apr-04 15:53 reytool/rtext.py
+-rw-rw-rw-  2.0 fat     8402 b- defN 23-Apr-04 12:31 reytool/rwrap.py
+-rw-rw-rw-  2.0 fat      275 b- defN 23-Apr-18 09:19 reyworm/__init__.py
+-rw-rw-rw-  2.0 fat     1207 b- defN 23-Apr-18 09:17 reyworm/rtranslate.py
+-rw-rw-rw-  2.0 fat      202 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1645 b- defN 23-Apr-18 09:20 reyworm-0.3.dist-info/RECORD
+22 files, 115240 bytes uncompressed, 29019 bytes compressed:  74.8%
```

## zipnote {}

```diff
@@ -1,8 +1,8 @@
-Filename: reyflask/__init__.py
+Filename: reyapi/__init__.py
 Comment: 
 
 Filename: reytool/__init__.py
 Comment: 
 
 Filename: reytool/rbasic.py
 Comment: 
@@ -21,14 +21,17 @@
 
 Filename: reytool/rdatetime.py
 Comment: 
 
 Filename: reytool/remail.py
 Comment: 
 
+Filename: reytool/rmonkey.py
+Comment: 
+
 Filename: reytool/rmultitask.py
 Comment: 
 
 Filename: reytool/roption.py
 Comment: 
 
 Filename: reytool/rregular.py
@@ -45,20 +48,20 @@
 
 Filename: reyworm/__init__.py
 Comment: 
 
 Filename: reyworm/rtranslate.py
 Comment: 
 
-Filename: reyworm-0.2.dist-info/METADATA
+Filename: reyworm-0.3.dist-info/METADATA
 Comment: 
 
-Filename: reyworm-0.2.dist-info/WHEEL
+Filename: reyworm-0.3.dist-info/WHEEL
 Comment: 
 
-Filename: reyworm-0.2.dist-info/top_level.txt
+Filename: reyworm-0.3.dist-info/top_level.txt
 Comment: 
 
-Filename: reyworm-0.2.dist-info/RECORD
+Filename: reyworm-0.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## reytool/__init__.py

```diff
@@ -7,23 +7,23 @@
 @Contact : reyxbo@163.com
 @Explain : Rey's personal tool set.
 """
 
 
 from typing import Final
 
-from .rbasic import error, warn
+from .rbasic import warn
 from .rcompress import rzip
 from .rcommon import exc, digits, randn, sleep, get_paths, n_to_ch
-from .rdata import count, flatten, split, de_dup
-from .rdatabase import RConnect
-from .rdatetime import rdatetimeMark, now
+from .rdata import count, flatten, split, distinct
+from .rdatabase import REngine
+from .rdatetime import RDateTimeMark, now, time_to_str, str_to_time
 from .remail import REmail
 from .rmultitask import threads
 from . import roption
 from .rregular import res
 from .rrequest import request
 from .rtext import rprint
 from .rwrap import runtime
 
 
-__version__: Final[str] = "0.85"
+__version__: Final[str] = "0.105"
```

## reytool/rbasic.py

```diff
@@ -5,140 +5,151 @@
 @Time    : 2022-12-05 14:09:42
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey"s basic methods.
 """
 
 
-from typing import Any, List, Tuple, Iterable, Callable, NoReturn, Type, Literal, Optional, Union
+from typing import Any, List, Tuple, Iterable, Callable, Type, Literal, Optional, Union
 from warnings import warn as warnings_warn
 from varname import argname
 
 
-def error(error_info: Optional[Any] = None, error_type: Type[BaseException] = AssertionError) -> NoReturn:
-    """
-    Throw error.
-
-    Parameters
-    ----------
-    error_info : Error information.
-    error_type : Error type.
-    """
-    
-    if error_info == None:
-        raise error_type
-    raise error_type(error_info)
-
 def warn(*warn_infos: Any, warn_type: Type[BaseException] = UserWarning, stacklevel: int = 3) -> None:
     """
     Throw warning.
 
     Parameters
     ----------
     warn_info : Warn informations.
     warn_type : Warn type.
     stacklevel : Warning code location, number of recursions up the code level.
     """
-    
-    
+
+    # Handle parameters.    
     if warn_infos == ():
         warn_infos = "Warning!"
     elif len(warn_infos) == 1:
-        warn_info_type = type(warn_infos[0])
-        if warn_info_type == str:
+        if type(warn_infos[0]) == str:
             warn_infos = warn_infos[0]
         else:
             warn_infos = str(warn_infos[0])
     else:
         warn_infos = str(warn_infos)
+
+    # Throw warning.
     warnings_warn(warn_infos, warn_type, stacklevel)
 
-def check_param(value: Any, *targets: Union[Any, Literal["_iterable"]], check_element: bool = False) -> None:
+def check_target(value: Any, *targets: Union[Any, Literal["_iterable"]], check_element: bool = False) -> None:
     """
     Check the content or type of the value, when check fail, then throw error.
 
     Parameters
     ---------
     value : Check object.
     targets : Correct target, can be type.
         - Any : Check whether it is the target.
         - Literal['_iterable'] : Check whether it can be iterable.
 
     check_element : Whether check element in value.
     """
 
+    # Handle parameters.
     if check_element:
         values = value
     else:
         values = [value]
+
+    # Check.
     for element in values:
+
+        ## Check sub elements.
         if "_iterable" in targets and is_iterable(element):
             continue
+
+        ## Right tragets.
         if type(element) in targets:
             continue
         targets_id = [id(target) for target in targets]
         if id(element) in targets_id:
             continue
+
+        ## Throw error.
         var_name = get_name(value)
         if var_name != None:
             var_name = " '%s'" % var_name
         else:
             var_name = ""
         correct_targets_str = ", ".join([repr(target) for target in targets])
         if check_element:
-            error_text = "parameter%s the elements content or type must in [%s], now: %s" % (var_name, correct_targets_str, repr(value))
+            raise ValueError(
+                "parameter%s the elements content or type must in [%s], now: %s" % (
+                    var_name,
+                    correct_targets_str,
+                    repr(value)
+                )
+            )
         else:
-            error_text = "parameter%s the content or type must in [%s], now: %s" % (var_name, correct_targets_str, repr(value))
-        error(error_text, ValueError)
+            raise ValueError(
+                "parameter%s the content or type must in [%s], now: %s" % (
+                    var_name,
+                    correct_targets_str,
+                    repr(value)
+                )
+            )
 
 def check_least_one(*values: Any) -> None:
     """
     Check that at least one of multiple values is not None, when check fail, then throw error.
 
     Parameters
     ----------
     values : Check values.
     """
 
+    # Check.
     for value in values:
         if value != None:
             return
+
+    # Throw error.
     vars_name = get_name(values)
     if vars_name != None:
         vars_name_de_dup = list(set(vars_name))
         vars_name_de_dup.sort(key=vars_name.index)
-        vars_name_str = " " + " and ".join(["\"%s\"" % var_name for var_name in vars_name_de_dup])
+        vars_name_str = " " + " and ".join(["'%s'" % var_name for var_name in vars_name_de_dup])
     else:
         vars_name_str = ""
-    error_text = "at least one of parameters%s is not None" % vars_name_str
-    error(error_text, ValueError)
+    raise ValueError("at least one of parameters%s is not None" % vars_name_str)
 
-def check_only_one(*values: Any) -> None:
+def check_most_one(*values: Any) -> None:
     """
     Check that at most one of multiple values is not None, when check fail, then throw error.
 
     Parameters
     ----------
     values : Check values.
     """
 
+    # Check.
     none_count = 0
     for value in values:
         if value != None:
             none_count += 1
+
+    # Throw error.
     if none_count > 1:
         vars_name = get_name(values)
         if vars_name != None:
             vars_name_de_dup = list(set(vars_name))
             vars_name_de_dup.sort(key=vars_name.index)
-            vars_name_str = " " + " and ".join(["\"%s\"" % var_name for var_name in vars_name_de_dup])
+            vars_name_str = " " + " and ".join(["'%s'" % var_name for var_name in vars_name_de_dup])
         else:
             vars_name_str = ""
-        error_text = "at most one of parameters%s is not None" % vars_name_str
-        error(error_text, ValueError)
+        raise ValueError("at most one of parameters%s is not None" % vars_name_str)
 
 def is_iterable(obj: Any, exclude_types: Iterable[Type] = [str, bytes]) -> bool:
     """
     Judge whether it is iterable.
 
     Parameters
     ----------
@@ -146,17 +157,19 @@
     exclude_types : Non iterative types.
 
     Returns
     -------
     Judgment result.
     """
 
-    obj_type = type(obj)
-    if obj_type in exclude_types:
+    # Exclude types.
+    if type(obj) in exclude_types:
         return False
+
+    # Judge.
     try:
         obj_dir = obj.__dir__()
     except TypeError:
         return False
     if "__iter__" in obj_dir:
         return True
     else:
@@ -172,86 +185,95 @@
     check_fields : Do you want to check the keys and keys sort of the Dict are the same.
 
     Returns
     -------
     Judgment result.
     """
 
-    obj_type = type(obj)
-    if obj_type != list:
+    # Judge.
+    if type(obj) != list:
         return False
     for element in obj:
         if type(element) != dict:
             return False
+
+    ## Check fields of table.
     if check_fields:
         keys_strs = [
             ":".join([str(key) for key in element.keys()])
             for element in obj
         ]
         keys_strs_only = set(keys_strs)
         if len(keys_strs_only) != 1:
             return False
+
     return True
 
-def is_number_str(text: str, return_value: bool = False) -> Union[bool, int, float]:
+def is_number_str(text: str) -> bool:
     """
     Judge whether it is number string.
 
     Parameters
     ----------
     text : Judge text.
     return_value : Whether return value.
-    
+
     Returns
     -------
-    Judgment result or transformed value.
+    Judgment result.
     """
 
+    # Judge.
     try:
         if "." in text:
             number = float(text)
         else:
             number = int(text)
     except ValueError:
         return False
-    if return_value:
-        return number
+
     return True
 
-def get_first_notnull(*values: Any, default: Optional[Union[Any, Literal["error"]]] = None, none_values: List = [None]) -> Any:
+def get_first_notnull(
+    *values: Any,
+    default: Optional[Union[Any, Literal["error"]]] = None,
+    null_values: List = [None]) -> Any:
     """
     Get the first value that is not null.
 
     Parameters
     ----------
     values : Check values.
-    default : When all are None, then return this is value, or throw error.
+    default : When all are null, then return this is value, or throw error.
         - Any : Return this is value.
         - Literal['error'] : Throw error.
 
-    none_values : Range of None values.
+    null_values : Range of null values.
 
     Returns
     -------
-    When all are None, then return default value.
+    Return first not null value, when all are null, then return default value.
     """
-    
+
+    # Get value.
     for value in values:
-        if value not in none_values:
+        if value not in null_values:
             return value
+
+    # Throw error.
     if default == "error":
         vars_name = get_name(values)
         if vars_name != None:
             vars_name_de_dup = list(set(vars_name))
             vars_name_de_dup.sort(key=vars_name.index)
-            vars_name_str = " " + " and ".join(["\"%s\"" % var_name for var_name in vars_name_de_dup])
+            vars_name_str = " " + " and ".join(["'%s'" % var_name for var_name in vars_name_de_dup])
         else:
             vars_name_str = ""
-        error_text = "at least one of parameters%s is not None" % vars_name_str
-        error(error_text, ValueError)
+        raise ValueError("at least one of parameters%s is not None" % vars_name_str)
+
     return default
 
 def ins(obj: Any, *arrays: Iterable) -> bool:
     """
     Judge whether the object is in multiple array.
 
     Parameters
@@ -260,59 +282,68 @@
     arrays : Array.
 
     Returns
     -------
     Judge result.
     """
 
+    # Judge.
     for array in arrays:
         if obj in array:
             return True
+
     return False
 
 def mutual_in(*arrays: Iterable) -> bool:
     """
     Whether the same element exists in multiple array.
 
     Parameters
     ----------
     arrays : Array.
 
     Returns
     -------
     Judge result.
     """
-    
+
+    # Handle parameters.
     arrays = list(arrays)
+
+    # Judge.
     for n, array in enumerate(arrays):
         for after_array in arrays[n+1:]:
             for element in array:
                 if ins(element, after_array):
                     return True
+
     return False
 
 def to_type(obj: Any, to_type: Type, method: Optional[Callable] = None) -> Any:
     """
     Convert object type.
 
     Parameters
     ----------
     obj : Convert object.
     to_type : Target type.
     method : Convert method.
-        - None : Use value of parameter to_type.
+        - None : Use value of parameter 'to_type'.
         - Callable : Use this method.
 
     Returns
     -------
     Converted object.
     """
 
+    # Judge type.
     if type(obj) == to_type:
         return obj
+
+    # Convert type.
     if method != None:
         return method(obj)
     else:
         return to_type(obj)
 
 def get_name(obj: Any, frame: int = 2) -> Optional[Union[str, Tuple[str, ...]]]:
     """
@@ -324,20 +355,24 @@
     frame : Number of code to upper level.
 
     Returns
     -------
     Object name or None.
     """
 
+    # Get name using built in method.
     try:
         name = obj.__name__
     except AttributeError:
+
+        # Get name using module method.
         name = "obj"
         try:
             for _frame in range(1, frame + 1):
                 name = argname(name, frame=_frame)
             if type(name) != str:
                 if "".join(name) == "":
                     name = None
         except:
             name = None
+
     return name
```

## reytool/rcommon.py

```diff
@@ -11,39 +11,41 @@
 
 from typing import List, Tuple, Literal, Optional, Union
 import os
 import re
 import time
 import random
 from traceback import format_exc
-from zipfile import ZipFile, is_zipfile
 
-from .rbasic import error
 from . import roption
 from .rtext import rprint
 
 
-def exc(title: str = "Error", to_print: bool = True) -> str:
+def exc(title: str = "Error", report: bool = True) -> str:
     """
     Print and return error messages, must used in 'except' syntax.
 
     Parameters
     ----------
     title : Print title.
-    to_print : Whether print error messages.
+    report : Whether print error messages.
 
     Returns
     -------
     Error messages.
     """
 
+    # Get error information.
     error = format_exc()
     error = error.strip()
-    if to_print:
+
+    # Report.
+    if report:
         rprint(error, title=title, frame=roption.print_default_frame_half)
+
     return error
 
 def digits(number: Union[int, float]) -> Tuple[int, int]:
     """
     Judge the number of integer digits and deciaml digits.
 
     Parameters
@@ -51,104 +53,116 @@
     number : Number to judge.
 
     Returns
     -------
     Integer digits and deciaml digits.
     """
 
+    # Handle parameters.
     number_str = str(number)
+
+    # Get digits.
     if "." in number_str:
         integer_str, decimal_str = number_str.split(".")
         integer_digits = len(integer_str)
         deciaml_digits = len(decimal_str)
     else:
         integer_digits = len(number_str)
         deciaml_digits = 0
+
     return integer_digits, deciaml_digits
 
 def randn(*thresholds: Union[int, float], precision: Optional[int] = None) -> Union[int, float]:
     """
     Get random number.
 
     Parameters
     ----------
     thresholds : Low and high thresholds of random range, range contains thresholds.
         - When length is 0, then low and high thresholds is 0 and 10.
         - When length is 1, then low and high thresholds is 0 and thresholds[0].
         - When length is 2, then low and high thresholds is thresholds[0] and thresholds[1].
 
     precision : Precision of random range, that is maximum decimal digits of return value.
-        - None : Set to Maximum decimal digits of element of parameter *thresholds.
+        - None : Set to Maximum decimal digits of element of parameter 'thresholds'.
         - int : Set to this value.
-    
+
     Returns
     -------
     Random number.
-        - When parameters precision is 0, then return int.
-        - When parameters precision is greater than 0, then return float.
+        - When parameters 'precision' is 0, then return int.
+        - When parameters 'precision' is greater than 0, then return float.
     """
-    
+
+    # Handle parameters.
     thresholds_len = len(thresholds)
     if thresholds_len == 0:
         threshold_low = 0
         threshold_high = 10
     elif thresholds_len == 1:
         threshold_low = 0
         threshold_high = thresholds[0]
     elif thresholds_len == 2:
         threshold_low = thresholds[0]
         threshold_high = thresholds[1]
     else:
-        error("number of parameter '*thresholds' must is 0 or 1 or 2", ValueError)
+        raise ValueError("number of parameter 'thresholds' must is 0 or 1 or 2")
     if precision == None:
         threshold_low_desimal_digits = digits(threshold_low)[1]
         threshold_high_desimal_digits = digits(threshold_high)[1]
         desimal_digits_max = max(threshold_low_desimal_digits, threshold_high_desimal_digits)
         precision = desimal_digits_max
+
+    # Get random number.
     magnifier = 10 ** precision
     threshold_low *= magnifier
     threshold_high *= magnifier
     number = random.randint(threshold_low, threshold_high)
     number = number / magnifier
     if precision == 0:
         number = int(number)
+
     return number
 
 def sleep(*thresholds: Union[int, float], precision: Optional[int] = None) -> Union[int, float]:
     """
     Sleep random seconds.
 
     Parameters
     ----------
     thresholds : Low and high thresholds of random range, range contains thresholds.
         - When length is 0, then low and high thresholds is 0 and 10.
         - When length is 1, then sleep this value.
         - When length is 2, then low and high thresholds is thresholds[0] and thresholds[1].
     
     precision : Precision of random range, that is maximum decimal digits of sleep seconds.
-        - None : Set to Maximum decimal digits of element of parameter *thresholds.
+        - None : Set to Maximum decimal digits of element of parameter 'thresholds'.
         - int : Set to this value.
     
     Returns
     -------
     Random seconds.
-        - When parameters precision is 0, then return int.
-        - When parameters precision is greater than 0, then return float.
+        - When parameters 'precision' is 0, then return int.
+        - When parameters 'precision' is greater than 0, then return float.
     """
 
+    # Handle parameters.
     thresholds_len = len(thresholds)
     if thresholds_len == 0:
         second = randn(0, 10, precision=precision)
     elif thresholds_len == 1:
         second = thresholds[0]
     elif thresholds_len == 2:
         second = randn(thresholds[0], thresholds[1], precision=precision)
     else:
-        error("number of parameter '*thresholds' must is 0 or 1 or 2", ValueError)
+        raise ValueError("number of parameter 'thresholds' must is 0 or 1 or 2")
+
+    # Sleep.
     time.sleep(second)
+
     return second
 
 def get_paths(path: Optional[str] = None, target: Literal["all", "file", "folder"] = "all", recursion: bool = True) -> List:
     """
     Get the path of files and folders in the path.
 
     Parameters
@@ -162,18 +176,23 @@
     recursion : Is recursion directory.
 
     Returns
     -------
     String is path.
     """
 
+    # Handle parameters.
     if path == None:
         path = ""
     path = os.path.abspath(path)
+
+    # Get paths.
     paths = []
+
+    ## Recursive.
     if recursion:
         obj_walk = os.walk(path)
         if target == "all":
             targets_path = [
                 os.path.join(path, file_name)
                 for path, folders_name, files_name in obj_walk
                 for file_name in files_name + folders_name
@@ -189,14 +208,16 @@
         elif target in ["all", "folder"]:
             targets_path = [
                 os.path.join(path, folder_name)
                 for path, folders_name, files_name in obj_walk
                 for folder_name in folders_name
             ]
             paths.extend(targets_path)
+
+    ## Non recursive.
     else:
         names = os.listdir(path)
         if target == "all":
             for name in names:
                 target_path = os.path.join(path, name)
                 paths.append(target_path)
         elif target == "file":
@@ -207,14 +228,15 @@
                     paths.append(target_path)
         elif target == "folder":
             for name in names:
                 target_path = os.path.join(path, name)
                 is_dir = os.path.isdir(target_path)
                 if is_dir:
                     paths.append(target_path)
+
     return paths
 
 map_digit = {
     "0": "零",
     "1": "一",
     "2": "二",
     "3": "三",
```

## reytool/rcompress.py

```diff
@@ -5,20 +5,18 @@
 @Time    : 2023-01-19 19:23:57
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's zip methods.
 """
 
 
-from typing import List, Union, Optional
+from typing import List, Optional
 from zipfile import ZipFile, is_zipfile, ZIP_DEFLATED
 import os
 
-from .rbasic import error
-
 
 def compress(obj_path: str, build_dir: Optional[str] = None, overwrite: bool = True) -> None:
     """
     Compress file or folder.
 
     Parameters
     ----------
@@ -79,15 +77,15 @@
         - None : No Unzip Password.
         - str : Use this value.
     """
 
     # Check object whether can be decompress.
     is_support = is_zipfile(obj_path)
     if not is_support:
-        error("file format that cannot be decompressed")
+        raise AssertionError("file format that cannot be decompressed")
 
     # Processing parameters.
     if build_dir == None:
         build_dir = os.getcwd()
 
     # Decompress.
     with ZipFile(obj_path) as zip_file:
@@ -101,12 +99,15 @@
     ----------
     obj_path : File or folder or compressed object path.
     output_path : Build directory.
         - None : Work directory.
         - str : Use this value.
     """
 
+    # Judge compress or decompress.
     is_support = is_zipfile(obj_path)
+
+    # Execute.
     if is_support:
         decompress(obj_path, build_dir)
     else:
         compress(obj_path, build_dir)
```

## reytool/rdata.py

```diff
@@ -5,24 +5,24 @@
 @Time    : 2022-12-05 14:10:42
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's data methods.
 """
 
 
-from typing import Any, List, Tuple, Dict, Iterable, Literal, Optional, Union, Type
+from typing import Any, List, Tuple, Dict, Iterable, Literal, Optional, Union, Type, NoReturn, overload
 from pandas import DataFrame, ExcelWriter
 
 # Version compatible of package sqlalchemy.
 try:
     from sqlalchemy import CursorResult
 except ImportError:
     from sqlalchemy.engine.cursor import LegacyCursorResult as CursorResult
 
-from .rbasic import is_iterable, check_least_one, to_type
+from .rbasic import is_iterable, check_least_one, check_most_one, to_type
 from .rdatetime import time_to_str
 
 
 def to_table(
     data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]],
     fields: Optional[Iterable] = None
 ) -> List[Dict]:
@@ -37,29 +37,39 @@
         - Iterable : Use values in Iterable.
 
     Returns
     -------
     Table in List[Dict] format.
     """
 
-    data_type = type(data)
-    if data_type == CursorResult:
+    # Convert.
+
+    ## From CursorResult object.
+    if type(data) == CursorResult:
         if fields == None:
             fields = data.keys()
-        data_table = [dict(zip(fields, [val for val in row])) for row in data]
-    elif data_type == DataFrame:
+        data_table = [
+            dict(zip(fields, row))
+            for row in data
+        ]
+
+    ## From DataFrame object.
+    elif type(data) == DataFrame:
         data_df = data.copy()
         if fields != None:
             data_df.columns = fields
         data_df = data_df.where(data.notnull(), None)
         data_table = data_df.to_dict("records")
+
+    ## From other object.
     else:
         data_df = DataFrame(data, columns=fields)
         data_df = data_df.where(data.notnull(), None)
         data_table = data_df.to_dict("records")
+
     return data_table
 
 def to_df(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> DataFrame:
     """
     Fetch data to table of DataFrame object.
 
     Parameters
@@ -70,26 +80,33 @@
         - Iterable : Use values in Iterable.
 
     Returns
     -------
     DataFrame object.
     """
 
-    data_type = type(data)
-    if data_type == CursorResult:
+    # Convert.
+
+    ## From CursorResult object.
+    if type(data) == CursorResult:
         if fields == None:
             fields = data.keys()
         data_df = DataFrame(data, columns=fields)
-    elif data_type == DataFrame:
+
+    ## From DataFrame object.
+    elif type(data) == DataFrame:
         data_df = data.copy()
         if fields != None:
             data_df.columns = fields
         return data_df
+
+    ## From other object.
     else:
         data_df = DataFrame(data, columns=fields)
+
     return data_df
 
 def to_json(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> str:
     """
     Fetch data to JSON string.
 
     Parameters
@@ -100,16 +117,20 @@
         - Iterable : Use values in Iterable.
 
     Returns
     -------
     JSON string.
     """
 
+    # Handle parameters.
     data_df = to_df(data, fields)
+
+    # Convert.
     data_json = data_df.to_json(orient="records", force_ascii=False)
+
     return data_json
 
 def to_sql(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> str:
     """
     Fetch data to SQL string.
 
     Parameters
@@ -120,21 +141,23 @@
         - Iterable : Use values in Iterable.
 
     Returns
     -------
     SQL string.
     """
 
-    data_type = type(data)
-    if data_type == CursorResult:
+    # Get fields of table.
+    if type(data) == CursorResult:
         if fields == None:
             fields = data.keys()
     else:
         data = to_table(data, fields)
         fields = data[0].keys()
+
+    # Generate SQL.
     sql_rows_values = [
         [
             repr(time_to_str(val, "%Y-%m-%d %H:%M:%S"))
             if val != None
             else "NULL"
             for val in row
         ]
@@ -148,14 +171,15 @@
         [
             "%s AS `%s`" % (val, key)
             for key, val in list(zip(fields, sql_rows_values[0]))
         ]
     )
     sql_rows[0] = sql_row_first
     data_sql = " UNION ALL ".join(sql_rows)
+
     return data_sql
 
 def to_html(data: Union[CursorResult, DataFrame, List[Dict], Iterable[Iterable]], fields: Optional[Iterable] = None) -> str:
     """
     Fetch data to HTML string.
 
     Parameters
@@ -166,16 +190,20 @@
         - Iterable : Use values in Iterable.
 
     Returns
     -------
     HTML string.
     """
 
+    # Handle parameters.
     data_df = to_df(data, fields)
+
+    # Convert.
     data_html = data_df.to_html(col_space=50, index=False, justify="center")
+
     return data_html
 
 def to_csv(
     data: Union[CursorResult, DataFrame, Iterable[Dict], Iterable],
     path: str = "table.csv",
     fields: Optional[Iterable] = None
 ) -> DataFrame:
@@ -187,16 +215,20 @@
     data : Data.
     path : File save path.
     fields : Table fields.
         - None : Infer.
         - Iterable : Use values in Iterable.
     """
 
+    # Handle parameters.
     data_df = to_df(data, fields)
+
+    # Save file.
     data_df.to_csv(path, mode="a")
+
     return data_df
 
 def to_excel(
     data: Union[CursorResult, DataFrame, Iterable[Dict], Iterable],
     path: str = "table.xlsx",
     group_field: Optional[str] = None,
     sheets_set: Dict[Union[str, int], Dict[Literal["name", "index", "filter"], Union[str, int, List[str]]]] = {}
@@ -216,16 +248,19 @@
         - Parameter 'filter' : Filter sheet fields.
 
     Returns
     -------
     Sheet name and sheet data.
     """
 
+    # Handle parameters.
     if type(data) != DataFrame:
         data = to_df(data)
+
+    # Generate sheets.
     if group_field == None:
         data_group = (("Sheet1", data),)
     else:
         data_group = data.groupby(group_field)
     sheets_table_before = []
     sheets_table_after = []
     for index, sheet_table in enumerate(data_group):
@@ -246,14 +281,16 @@
         if "index" in sheet_set:
             sheets_table_before.append((sheet_set["index"], (sheet_name, sheet_df)))
         else:
             sheets_table_after.append((sheet_name, sheet_df))
     sort_func = lambda item: item[0]
     sheets_table_before.sort(key=sort_func)
     sheets_table = [sheet_table for sheet_index, sheet_table in sheets_table_before] + sheets_table_after
+
+    # Save file.
     excel = ExcelWriter(path)
     for sheet_name, sheet_df in sheets_table:
         sheet_df.to_excel(excel, sheet_name, index=False)
     excel.close()
     return sheets_table
 
 def count(
@@ -271,84 +308,139 @@
     surface : Whether is surface recursion.
 
     Returns
     -------
     Count data.
     """
 
-    data_type = type(data)
+    # Count Element.
     count_value["total"] += 1
-    count_value["types"][data_type] = count_value["types"].get(data_type, 0) + 1
-    if data_type == dict:
+    count_value["types"][type(data)] = count_value["types"].get(type(data), 0) + 1
+
+    # Recursion.
+    if type(data) == dict:
         for element in data.values():
             count(element, count_value, False)
     elif is_iterable(data):
         for element in data:
             count(element, count_value, False)
     else:
         count_value["size"] = count_value["size"] + 1
+
+    # End Recursion and return.
     if surface:
+
+        ## Sort by count.
         sorted_func = lambda key: count_value["types"][key]
         sorted_key = sorted(count_value["types"], key=sorted_func, reverse=True)
         count_value["types"] = {key: count_value["types"][key] for key in sorted_key}
+
         return count_value
 
 def flatten(data: Any, flattern_data: List = []) -> List:
     """
     Flatten data.
+
+    Parameters
+    ----------
+    data : Data.
+    flattern_data : Recursion cumulative data.
+
+    Returns
+    -------
+    Data after flatten.
     """
 
-    data_type = type(data)
-    if data_type == dict:
+    # Flatten.
+
+    ## Recursion dict object.
+    if type(data) == dict:
         for element in data.values():
             _ = flatten(element, flattern_data)
+
+    ## Recursion iterator.
     elif is_iterable(data):
         for element in data:
             _ = flatten(element, flattern_data)
+
+    ## Other.
     else:
         flattern_data.append(data)
+
     return flattern_data
 
-def split(data: Iterable, bin_size: Optional[int] = None, share: int = 2) -> List[List]:
+@overload
+def split(data: Iterable, share: Optional[int] = None, bin_size: Optional[int] = None) -> List[List]: ...
+
+@overload
+def split(share: None, bin_size: None) -> NoReturn: ...
+
+@overload
+def split(share: int, bin_size: int) -> NoReturn: ...
+
+def split(data: Iterable, share: Optional[int] = None, bin_size: Optional[int] = None) -> List[List]:
     """
     Split data into multiple data.
+
+    Parameters
+    ----------
+    data : Data.
+    share : Number of splie share.
+    bin_size : Size of each bin.
+
+    Returns
+    -------
+    Split data.
     """
 
-    check_least_one(bin_size, share)
+    # Check parameters.
+    check_least_one(share, bin_size)
+    check_most_one(share, bin_size)
 
+    # Handle parameters.
     data = list(data)
+
+    # Split.
     data_len = len(data)
     _data = []
     _data_len = 0
-    if bin_size == None:
+
+    ## by number of share.
+    if share != None:
         average = data_len / share
         for n in range(share):
             bin_size = int(average * (n + 1)) - int(average * n)
             _data = data[_data_len:_data_len + bin_size]
             _data.append(_data)
             _data_len += bin_size
-    else:
+
+    ## By size of bin.
+    elif bin_size != None:
         while True:
             _data = data[_data_len:_data_len + bin_size]
             _data.append(_data)
             _data_len += bin_size
             if _data_len > data_len:
                 break
+
     return _data
 
-def de_dup(data: Iterable) -> List:
+def distinct(data: Iterable) -> List:
     """
     De duplication of data.
 
     Parameters
     ----------
     data : Data.
 
     Returns
     -------
     List after de duplication.
     """
 
+    # Handle parameters.
     data = to_type(data, tuple)
+
+    # Delete duplicate.
     data_de_dup = list(set(data))
     data_de_dup.sort(key=data.index)
     return data_de_dup
```

## reytool/rdatabase.py

```diff
@@ -5,350 +5,340 @@
 @Time    : 2022-12-05 14:10:02
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's database methods.
 """
 
 
-from typing import Any, List, Dict, Iterable, Optional, Literal, Union
-import re
-from sqlalchemy import create_engine, text
-from sqlalchemy.engine.base import Engine, Connection, Transaction
+from typing import Any, List, Dict, Iterable, Optional, Literal, Union, ClassVar, NoReturn, overload
+from re import findall
+from sqlalchemy import create_engine as sqlalchemy_create_engine, text
+from sqlalchemy.engine.base import Engine, Connection
+from sqlalchemy.engine.url import URL
 from sqlalchemy.sql.elements import TextClause
 
+from .rbasic import get_first_notnull
+from .rdata import to_table
+from .rmonkey import add_result_more_fetch, support_row_index_by_field
+from . import roption
+from .rregular import res
+from .rtext import rprint
+from .rwrap import runtime
+
 # Version compatible of package sqlalchemy.
 try:
     from sqlalchemy import CursorResult
 except ImportError:
     from sqlalchemy.engine.cursor import LegacyCursorResult as CursorResult
 
-from .rbasic import get_first_notnull, error
-from .rdata import to_table, to_df, to_json, to_sql, to_html, to_csv, to_excel
-from .roption import print_default_frame_full
-from .rtext import rprint
-from .rdatetime import now
-from .rwrap import runtime
 
+# Add more methods to CursorResult object of sqlalchemy package.
+add_result_more_fetch()
+
+# Support Row object index by field name.
+support_row_index_by_field()
 
-def monkey_patch_more_fetch() -> None:
+class REngine(object):
     """
-    Add more methods to CursorResult object of sqlalchemy package.
+    Rey's database Engine type, based on the package sqlalchemy.
     """
 
-    # Fetch SQL result to table in List[Dict] format.
-    CursorResult.fetch_table = to_table
+    # Values to be converted to "NULL".
+    null_values: ClassVar[List] = ["", " ", b"", [], (), {}, set()]
 
-    # Fetch SQL result to DataFrame object.
-    CursorResult.fetch_df = to_df
-
-    # Fetch SQL result to JSON string.
-    CursorResult.fetch_json = to_json
-
-    # Fetch SQL result to SQL string.
-    CursorResult.fetch_sql = to_sql
-
-    # Fetch SQL result to HTML string.
-    CursorResult.fetch_sql = to_html
-
-    # Fetch SQL result to save csv format file.
-    CursorResult.fetch_csv = to_csv
+    @overload
+    def __init__(
+        self,
+        username: Optional[str] = None,
+        password: Optional[str] = None,
+        host: Optional[str] = None,
+        port: Optional[str] = None,
+        database: Optional[str] = None,
+        drivername: Optional[str] = None,
+        url: Optional[Union[str, URL]] = None,
+        engine: Optional[Union[Engine, Connection]] = None,
+        recycle: int = 28800,
+        **query: str
+    ) -> None: ...
+
+    @overload
+    def __init__(self, username: None, url: None, engine: None) -> NoReturn: ...
 
-    # Fetch SQL result to save excel file.
-    CursorResult.fetch_excel = to_excel
+    @overload
+    def __init__(self, password: None, url: None, engine: None) -> NoReturn: ...
 
-monkey_patch_more_fetch()
+    @overload
+    def __init__(self, host: None, url: None, engine: None) -> NoReturn: ...
 
-class RConnect(object):
-    """
-    Rey's database connection type, based on the package sqlalchemy.
-    """
+    @overload
+    def __init__(self, port: None, url: None, engine: None) -> NoReturn: ...
 
-    # Values to be converted to None.
-    none_values: List = ["", " ", b"", [], (), {}, set()]
-    
     def __init__(
         self,
-        user: Optional[str] = None,
+        username: Optional[str] = None,
         password: Optional[str] = None,
         host: Optional[str] = None,
         port: Optional[str] = None,
         database: Optional[str] = None,
-        charset: Optional[str] = None,
-        autocommit: bool = True,
-        conn: Optional[Union[Engine, Connection]] = None,
-        recreate_ms: int = 7_200_000
+        drivername: Optional[str] = None,
+        url: Optional[Union[str, URL]] = None,
+        engine: Optional[Union[Engine, Connection]] = None,
+        recycle: int = -1,
+        **query: str
     ) -> None:
         """
-        Set database connection parameters.
+        Create database Engine object and set parameters.
 
         Parameters
         ----------
-        user : Server user name.
+        username : Server user name.
         password : Server password.
         host : Server host.
         port : Server port.
         database : Database name in the server.
-        charset : Coding charset.
-        autocommit : Whether the auto commit for execution.
-        conn : Existing connection object, will get parameters from it, but preferred input parameters.
-        recreate_ms : Connection object recreate interval millisecond.
-        """
-
-        # Get parameters from existing connection object.
-        if type(conn) == Connection:
-            conn = conn.engine
-        if type(conn) == Engine:
-            user = get_first_notnull(user, conn.url.username)
-            password = get_first_notnull(password, conn.url.password)
-            host = get_first_notnull(host, conn.url.host)
-            port = get_first_notnull(port, conn.url.port)
-            database = get_first_notnull(database, conn.url.database)
-            charset = get_first_notnull(charset, conn.url.query.get("charset"))
-            conn = conn.connect()
-
-        # Set parameters.
-        self.user = user
-        self.password = password
-        self.host = host
-        self.port = port
-        self.database = database
-        self.charset = charset
-        self.autocommit = autocommit
-        self.conn = conn
-        self.begin = None
-        self.conn_timestamp = now("timestamp")
-        self.recreate_ms = recreate_ms
+        drivername : Database backend and driver name.
+        url: Server server URL, will get parameters from it, but preferred input parameters.
+        engine : Using existing Engine or Connection object.
+        recycle : Connection object recycling seconds.
+            - Literal[-1] : No recycling.
+            - int : Use this recycling seconds.
+
+        query : Server parameters.
+        """
+
+        # From existing Engine object.
+        if engine != None:
+
+            ## Extract Engine object from Connection boject.
+            if type(engine) == Connection:
+                engine = engine.engine
+
+            ## Extract parameters and save.
+            self.drivername = engine.url.drivername
+            self.username = engine.url.username
+            self.password = engine.url.password
+            self.host = engine.url.host
+            self.port = engine.url.port
+            self.database = engine.url.database
+            self.query = dict(engine.url.query)
+            self.recycle = engine.pool._recycle
 
-    def commit(self) -> None:
-        """
-        Commit cumulative executions.
-        """
+            ## Save Engine object.
+            self.engine = engine
 
-        # Commit.
-        if self.begin != None:
-            self.begin.commit()
-            self.begin = None
+        # From parameters create.
+        else:
 
-    def rollback(self) -> None:
-        """
-        Rollback cumulative executions.
-        """
+            ## Extract parameters from URL of str object.
+            if type(url) == str:
+                pattern = "^([\w\+]+)://(\w+):(\w+)@(\d+\.\d+\.\d+\.\d+):(\d+)[/]?(\w+)?[\?]?([\w&=]+)?$"
+                url_params = res(url, pattern)
+                if url_params == None:
+                    raise ValueError("the value of parameter 'url' is incorrect")
+                else:
+                    url_drivername, url_username, url_password, url_host, url_port, url_database, url_query_str = url_params
+                    if url_query_str != None:
+                        pattern = "(\w+)=(\w+)"
+                        url_query_findall = findall(pattern, url_query_str)
+                        url_query = {key: val for key, val in url_query_findall}
+
+            ## Extract parameters from URL of URL object.
+            elif type(url) == URL:
+                url_drivername = url.drivername
+                url_username = url.username
+                url_password = url.password
+                url_host = url.host
+                url_port = url.port
+                url_database = url.database
+                url_query = dict(url.query)
 
-        # Rollback.
-        if self.begin != None:
-            self.begin.rollback()
-            self.begin = None
+            else:
+                url_drivername, url_username, url_password, url_host, url_port, url_database, url_query = (
+                    None, None, None, None, None, None, {}
+                )
+
+            ## Set parameters by priority.
+            self.drivername = get_first_notnull(drivername, url_drivername)
+            self.username = get_first_notnull(username, url_username, default="error")
+            self.password = get_first_notnull(password, url_password, default="error")
+            self.host = get_first_notnull(host, url_host, default="error")
+            self.port = get_first_notnull(port, url_port, default="error")
+            self.database = get_first_notnull(database, url_database)
+            self.query = get_first_notnull(query, url_query, default={"charset": "utf8"}, null_values=[{}])
+            self.recycle = recycle
 
-    def close(self) -> None:
+            ## Create Engine object.
+            self.engine = self.create_engine()
+
+    def url(self) -> str:
         """
-        Close database connection.
+        Generate server URL.
+
+        Returns
+        -------
+        Server URL.
         """
 
-        # Close.
-        if self.conn != None:
-            self.conn.close()
-            self.conn = None
-        self.begin = None
+        # Generate URL.
+        _url = f"{self.drivername}://{self.username}:{self.password}@{self.host}:{self.port}"
 
-    def connect(
-        self,
-        user: Optional[str] = None,
-        password: Optional[str] = None,
-        host: Optional[str] = None,
-        port: Optional[Union[str, int]] = None,
-        database: Optional[str] = None,
-        charset: Optional[str] = None
-    ) -> Connection:
-        """
-        Get database connection object.
+        # Add database path.
+        if self.database != None:
+            _url = f"{_url}/{self.database}"
 
-        Parameters
-        ----------
-        user : Server user name.
-        password : Server password.
-        host : Server host.
-        port : Server port.
-        database : Database name in the server.
-        charset : Coding charset.
+        # Add Server parameters.
+        if self.query != {}:
+            query = "&".join(
+                [
+                    "%s=%s" % (key, val)
+                    for key, val in self.query.items()
+                ]
+            )
+            _url = f"{_url}?{query}"
+
+        return _url
+
+    def create_engine(self) -> Engine:
+        """
+        Create database Engine object.
 
         Returns
         -------
-        Connection object.
+        Engine object.
         """
 
-        # Check whether the connection object is invalid.
-        if self.conn != None \
-            and (
-                now("timestamp") > self.conn_timestamp + self.recreate_ms \
-                or self.conn.closed
-            ):
-            self.close()
-
-        # Judge whether existing connection objects can be reused.
-        elif self.conn != None \
-            and (user == None or self.conn.engine.url.username == user) \
-            and (password == None or self.conn.engine.url.password == password) \
-            and (host == None or self.conn.engine.url.host == host) \
-            and (port == None or self.conn.engine.url.port == port) \
-            and (database == None or self.conn.engine.url.database == database) \
-            and (charset == None or self.conn.engine.url.query["charset"] == charset):
-            return self.conn
-
-        # Get parameters by priority.
-        user: str = get_first_notnull(user, self.user, default="error")
-        password: str = get_first_notnull(password, self.password, default="error")
-        host: str = get_first_notnull(host, self.host, default="error")
-        port: Union[str, int] = get_first_notnull(port, self.port, default="error")
-        database: str = get_first_notnull(database, self.database, default="error")
-        charset: str = get_first_notnull(charset, self.charset, default="utf8")
-
-        # Create connection object.
-        try:
-            url = f"mysql+mysqldb://{user}:{password}@{host}:{port}/{database}?charset={charset}"
-            engine = create_engine(url)
-        except ModuleNotFoundError:
-            url = f"mysql+pymysql://{user}:{password}@{host}:{port}/{database}?charset={charset}"
-            engine = create_engine(url)
-        conn = engine.connect()
-
-        # Save connection object.
-        self.conn = conn
-        self.conn_timestamp = now("timestamp")
+        # Handle parameters.
+        if self.drivername == None:
+            drivernames = ("mysql+mysqldb", "mysql+pymysql")
+        else:
+            drivernames = (self.drivername,)
 
-        return conn
+        # Create Engine object.
+        for drivername in drivernames:
+            self.drivername = drivername
+            url = self.url()
+            try:
+                engine = sqlalchemy_create_engine(url, pool_recycle=self.recycle)
+                return engine
+            except ModuleNotFoundError:
+                pass
+
+        # Throw error.
+        drivernames_str = " and ".join(
+            [
+                dirvername.split("+", 1)[-1]
+                for dirvername in drivernames
+            ]
+        )
+        raise ModuleNotFoundError("module %s not fund" % drivernames_str)
 
-    def file_data_by_sql(
+    def fill_data(
         self,
+        data: Union[Dict, List[Dict]],
         sql: Union[str, TextClause],
-        params: Union[Dict, List[Dict]],
-        fill_field: bool = True,
-        none_values: List = none_values
     ) -> List[Dict]:
         """
-        Fill missing parameters according to contents of sqlClause object of sqlalchemy module, and filter out empty Dict.
+        Fill missing data according to contents of sqlClause object of sqlalchemy module, and filter out empty Dict.
 
         Parameters
         ----------
+        data : Data set for filling sqlalchemy.text.
         sql : SQL in sqlalchemy.text format or return of sqlalchemy.text.
-        params : Parameters set for filling sqlalchemy.text.
-        fill_field : Whether fill missing fields.
-        none_values : Values to be converted to None.
 
         Returns
         -------
-        Filled parameters.
+        Filled data.
         """
 
         # Handle parameters.
-        if type(params) == dict:
-            params = [params]
+        if type(data) == dict:
+            data = [data]
 
         # Filter out empty Dict.
-        params = [
+        data = [
             param
-            for param in params
+            for param in data
             if param != {}
         ]
 
         # Extract fill field names.
         if type(sql) == TextClause:
             sql = sql.text
         pattern = "(?<!\\\):(\w+)"
-        sql_keys = re.findall(pattern, sql)
+        sql_keys = findall(pattern, sql)
 
-        # Fill.
-        for param in params:
+        # Fill data.
+        for param in data:
             for key in sql_keys:
-                if fill_field:
-                    val = param.get(key)
-                else:
-                    val = param[key]
-                if val in none_values:
+                val = param.get(key)
+                if val in self.null_values:
                     val = None
                 param[key] = val
 
-        return params
+        return data
 
     def execute(
         self,
         sql: Union[str, TextClause],
-        params: Optional[Union[List[Dict], Dict]] = None,
-        database: Optional[str] = None,
-        fill_field: bool = True,
-        none_values: List = none_values,
-        autocommit: Optional[bool] = None,
+        data: Optional[Union[List[Dict], Dict]] = None,
         report: bool = False,
-        **kw_params: Any
+        **kwdata: Any
     ) -> CursorResult:
         """
         Execute SQL.
 
         Parameters
         ----------
         sql : SQL in sqlalchemy.text format or return of sqlalchemy.text.
-        params : Parameters set for filling sqlalchemy.text.
-        database : Database name.
-        fill_field : Whether fill missing fields.
-        none_values : Values to be converted to None.
-        autocommit : Whether the auto commit for execution.
+        data : Data set for filling sqlalchemy.text.
         report : Whether print SQL and SQL runtime.
-        kw_params : Keyword parameters for filling sqlalchemy.text.
+        kwdata : Keyword data for filling sqlalchemy.text.
 
         Returns
         -------
         CursorResult object of alsqlchemy package.
         """
 
-        # Get parameters by priority.
-        autocommit = get_first_notnull(autocommit, self.autocommit, default=True)
-
         # Handle parameters.
         if type(sql) == str:
             sql = text(sql)
-        if params != None:
-            if type(params) == dict:
-                params = [params]
+        if data != None:
+            if type(data) == dict:
+                data = [data]
             else:
-                params = params.copy()
-            for param in params:
-                param.update(kw_params)
+                data = data.copy()
+            for param in data:
+                param.update(kwdata)
         else:
-            params = [kw_params]
-        params = self.file_data_by_sql(sql, params, fill_field, none_values)
-
-        # Get Connection object.
-        conn = self.connect(database=database)
-
-        # Get Transaction object.
-        if self.begin == None:
-            self.begin = conn.begin()
+            data = [kwdata]
+        data = self.fill_data(data, sql)
 
         # Execute SQL.
-        if report:
-            result, report_runtime = runtime(conn.execute, sql, params, _ret_report=True)
-            report_info = "%s\nRow Count: %d" % (report_runtime, result.rowcount)
-            if params != None:
-                rprint(report_info, sql, title="SQL", frame=print_default_frame_full)
-            else:
-                rprint(report_info, sql, params, title="SQL", frame=print_default_frame_full)
-        else:
-            result = conn.execute(sql, params)
-
-        # Commit execute.
-        if autocommit:
-            self.commit()
+        with self.engine.connect() as conn:
+            with conn.begin():
+                if report:
+                    result, report_runtime = runtime(conn.execute, sql, data, _ret_report=True)
+                    report_info = "%s\nRow Count: %d" % (report_runtime, result.rowcount)
+                    if data == []:
+                        rprint(report_info, sql, title="SQL", frame=roption.print_default_frame_full)
+                    else:
+                        rprint(report_info, sql, data, title="SQL", frame=roption.print_default_frame_full)
+                else:
+                    result = conn.execute(sql, data)
 
         return result
 
     def execute_select(
             self,
             table: str,
             database: Optional[str] = None,
             fields: Optional[Union[str, Iterable]] = None,
             where: Optional[str] = None,
+            group: Optional[str] = None,
+            having: Optional[str] = None,
             order: Optional[str] = None,
             limit: Optional[Union[int, str, Iterable[Union[int, str]]]] = None,
             report: bool = False
         ) -> CursorResult:
         """
         Execute select SQL.
 
@@ -358,75 +348,96 @@
         database : Database name.
         fields : Select clause content.
             - None : Is 'SELECT *'.
             - str : Join as 'SELECT str'.
             - Iterable[str] : Join as 'SELECT \`str\`, ...'.
 
         where : 'WHERE' clause content, join as 'WHERE str'.
+        group : 'GROUP BY' clause content, join as 'GROUP BY str'.
+        having : 'HAVING' clause content, join as 'HAVING str'.
         order : 'ORDER BY' clause content, join as 'ORDER BY str'.
         limit : 'LIMIT' clause content.
             - Union[int, str] : Join as 'LIMIT int/str'.
             - Iterable[Union[str, int]] with length of 1 or 2 : Join as 'LIMIT int/str, ...'.
 
         report : Whether print SQL and SQL runtime.
 
         Returns
         -------
         CursorResult object of alsqlchemy package.
         """
 
         # Handle parameters.
-        sqls = []
         if database == None:
             _database = self.database
         else:
             _database = database
+
+        # Generate SQL.
+        sqls = []
+
+        ## Part 'SELECT' syntax.
         if fields == None:
             fields = "*"
         elif type(fields) != str:
             fields = ",".join(["`%s`" % field for field in fields])
+        sql_select = f"SELECT {fields}"
+        sqls.append(sql_select)
 
-        # Generate SQL.
-        select_sql = (
-            f"SELECT {fields}\n"
-            f"FROM `{_database}`.`{table}`"
-        )
-        sqls.append(select_sql)
+        ## Part 'FROM' syntax.
+        sql_from =  f"FROM `{_database}`.`{table}`"
+        sqls.append(sql_from)
+
+        ## Part 'WHERE' syntax.
         if where != None:
-            where_sql = "WHERE %s" % where
-            sqls.append(where_sql)
+            sql_where = "WHERE %s" % where
+            sqls.append(sql_where)
+
+        ## Part 'GROUP BY' syntax.
+        if group != None:
+            sql_group = "GROUP BY %s" % group
+            sqls.append(sql_group)
+
+        ## Part 'GROUP BY' syntax.
+        if having != None:
+            sql_having = "HAVING %s" % having
+            sqls.append(sql_having)
+
+        ## Part 'ORDER BY' syntax.
         if order != None:
-            order_sql = "ORDER BY %s" % order
-            sqls.append(order_sql)
+            sql_order = "ORDER BY %s" % order
+            sqls.append(sql_order)
+
+        ## Part 'LIMIT' syntax.
         if limit != None:
-            list_type = type(limit)
-            if list_type in [str, int]:
-                limit_sql = f"LIMIT {limit}"
+            if type(limit) in [str, int]:
+                sql_limit = f"LIMIT {limit}"
             else:
                 if len(limit) in [1, 2]:
                     limit_content = ",".join([str(val) for val in limit])
-                    limit_sql = "LIMIT %s" % limit_content
+                    sql_limit = "LIMIT %s" % limit_content
                 else:
-                    error("The length of the limit parameter value must be 1 or 2", ValueError)
-            sqls.append(limit_sql)
+                    raise ValueError("The length of the parameter 'limit' value must be 1 or 2")
+            sqls.append(sql_limit)
+
         sql = "\n".join(sqls)
 
         # Execute SQL.
-        result = self.execute(sql, database=database, report=report)
+        result = self.execute(sql, report=report)
 
         return result
 
     def execute_update(
         self,
         data: Union[CursorResult, List[Dict], Dict],
         table: str,
         database: Optional[str] = None,
         where_fields: Optional[Union[str, Iterable[str]]] = None,
         report: bool = False
-    ) -> Union[None, CursorResult]:
+    ) -> Optional[CursorResult]:
         """
         Update the data of table in the datebase.
 
         Parameters
         ----------
         data : Updated data.
         table : Table name.
@@ -441,29 +452,28 @@
         Returns
         -------
         None or CursorResult object.
             - None : When the data is empty.
             - CursorResult object : When the data is not empty.
         """
 
-        # If data is empty, not execute.
-        if data in ({}, [], [{}]):
-            return
-
         # Handle parameters.
-        data_type = type(data)
-        if data_type == CursorResult:
+        if type(data) == CursorResult:
             data = to_table(data)
-        elif data_type == dict:
+        elif type(data) == dict:
             data = [data]
         if database == None:
             _database = self.database
         else:
             _database = database
 
+        # If data is empty, not execute.
+        if data in ([], [{}]):
+            return
+
         # Generate SQL.
         data_flatten = {}
         sqls = []
         if where_fields == None:
             no_where = True
         else:
             no_where = False
@@ -493,26 +503,26 @@
                 f"SET {set_content}\n"
                 f"WHERE {where_content}"
             )
             sqls.append(sql)
         sqls = ";\n".join(sqls)
 
         # Execute SQL.
-        result = self.execute(sqls, data_flatten, database, once=False, report=report)
+        result = self.execute(sqls, data_flatten, report)
 
         return result
 
     def execute_insert(
         self,
         data: Union[CursorResult, List[Dict], Dict],
         table: str,
         database: Optional[str] = None,
         duplicate_method: Optional[Literal["ignore", "update"]] = None,
         report: bool = False
-    ) -> Union[None, CursorResult]:
+    ) -> Optional[CursorResult]:
         """
         Insert the data of table in the datebase.
 
         Parameters
         ----------
         data : Updated data.
         table : Table name.
@@ -527,29 +537,28 @@
         Returns
         -------
         None or CursorResult object.
             - None : When the data is empty.
             - CursorResult object : When the data is not empty.
         """
 
-        # If data is empty, not execute.
-        if data in ({}, [], [{}]):
-            return
-
         # Handle parameters.
-        data_type = type(data)
-        if data_type == CursorResult:
+        if type(data) == CursorResult:
             data = self.to_table(data)
-        elif data_type == dict:
+        elif type(data) == dict:
             data = [data]
         if database == None:
             _database = self.database
         else:
             _database = database
 
+        # If data is empty, not execute.
+        if data in ([], [{}]):
+            return
+
         # Generate SQL.
         fields = list({key for row in data for key in row})
         fields_str = ",".join(["`%s`" % field for field in fields])
         fields_str_position = ",".join([":" + field for field in fields])
         if duplicate_method == "ignore":
             sql = (
                 f"INSERT IGNORE INTO `{_database}`.`{table}`({fields_str})\n"
@@ -566,10 +575,121 @@
         else:
             sql = (
                 f"INSERT INTO `{_database}`.`{table}`({fields_str})\n"
                 f"VALUES({fields_str_position})"
             )
 
         # Execute SQL.
-        result = self.execute(sql, data, database, report=report)
+        result = self.execute(sql, data, report)
+
+        return result
+
+    def connect(self):
+        """
+        Create database Connection object.
+        """
+
+        rconnection = RConnection(
+            self.engine.connect(),
+            self
+        )
+
+        return rconnection
+
+class RConnection(REngine):
+    """
+    Rey's database Connection type, based on the package sqlalchemy.
+    """
+
+    def __init__(self, connection: Connection, rengine: REngine) -> None:
+        """
+        Create database Connection object and set parameters.
+
+        Parameters
+        ----------
+        connection : Connection object.
+        rengine : REngine object.
+        """
+
+        self.connection = connection
+        self.rengine = rengine
+        self.begin = None
+
+    def execute(
+        self,
+        sql: Union[str, TextClause],
+        data: Optional[Union[List[Dict], Dict]] = None,
+        report: bool = False,
+        **kwdata: Any
+    ) -> CursorResult:
+        """
+        Execute SQL.
+
+        Parameters
+        ----------
+        sql : SQL in sqlalchemy.text format or return of sqlalchemy.text.
+        data : Data set for filling sqlalchemy.text.
+        report : Whether print SQL and SQL runtime.
+        kwdata : Keyword data for filling sqlalchemy.text.
+
+        Returns
+        -------
+        CursorResult object of alsqlchemy package.
+        """
+
+        # Handle parameters.
+        if type(sql) == str:
+            sql = text(sql)
+        if data != None:
+            if type(data) == dict:
+                data = [data]
+            else:
+                data = data.copy()
+            for param in data:
+                param.update(kwdata)
+        else:
+            data = [kwdata]
+        data = self.fill_data(data, sql)
+
+        # Get Transaction object.
+        if self.begin == None:
+            self.begin = self.connection.begin()
+
+        # Execute SQL.
+        if report:
+            result, report_runtime = runtime(self.connection.execute, sql, data, _ret_report=True)
+            report_info = "%s\nRow Count: %d" % (report_runtime, result.rowcount)
+            if data == []:
+                rprint(report_info, sql, title="SQL", frame=roption.print_default_frame_full)
+            else:
+                rprint(report_info, sql, data, title="SQL", frame=roption.print_default_frame_full)
+        else:
+            result = self.connection.execute(sql, data)
+
+        return result
+
+    def commit(self) -> None:
+        """
+        Commit cumulative executions.
+        """
+
+        # Commit.
+        if self.begin != None:
+            self.begin.commit()
+            self.begin = None
+
+    def rollback(self) -> None:
+        """
+        Rollback cumulative executions.
+        """
+
+        # Rollback.
+        if self.begin != None:
+            self.begin.rollback()
+            self.begin = None
+
+    def __del__(self) -> None:
+        """
+        Close database connection.
+        """
 
-        return result
+        self.connection.close()
```

## reytool/rdatetime.py

```diff
@@ -5,40 +5,61 @@
 @Time    : 2022-12-05 14:11:50
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's time methods.
 """
 
 
-from typing import Any, Tuple, Dict, Literal, Optional, Union
+from typing import Any, Tuple, Dict, Literal, Optional, Union, overload
 import time
 import datetime
 from pandas import DataFrame, concat as pd_concat
 
-from .rbasic import error, check_param, is_number_str
+from .rbasic import check_target, is_number_str
+from .rcommon import digits
 from .rregular import re_search
 from .rtext import rprint
 
 
+@overload
+def now(
+    format: Literal["datetime", "date", "time", "timestamp", "datetime_str", "date_str", "time_str"] = "datetime_str"
+) -> Union[datetime.datetime, datetime.date, datetime.time, int, str]: ...
+
+@overload
+def now(format: Literal["datatime"]) -> datetime.datetime: ...
+
+@overload
+def now(format: Literal["date"]) -> datetime.date: ...
+
+@overload
+def now(format: Literal["time"]) -> datetime.time: ...
+
+@overload
+def now(format: Literal["datetime_str", "date_str", "time_str"]) -> str: ...
+
+@overload
+def now(format: Literal["timestamp"]) -> int: ...
+
 def now(
     format: Literal["datetime", "date", "time", "datetime_str", "date_str", "time_str", "timestamp"] = "datetime_str"
-) -> Union[str, int, datetime.datetime, datetime.date, datetime.time]:
+) -> Union[datetime.datetime, datetime.date, datetime.time, str, int]:
     """
     Get current time string or intger or object.
 
     Parameters
     ----------
     format : Format type.
         - Literal['datetime'] : Return datetime object of datetime package.
         - Literal['date'] : Return date object of datetime package.
         - Literal['time'] : Return time object of datetime package.
         - Literal['datetime_str'] : Return string in format '%Y-%m-%d %H:%M:%S'.
         - Literal['date_str'] : Return string in format '%Y-%m-%d'.
         - Literal['time_str'] : Return string in foramt '%H:%M:%S'.
-        - Literal['timestamp'] : Return timestamp in milliseconds.
+        - Literal['timestamp'] : Return time stamp in milliseconds.
 
     Returns
     -------
     Time string or object of datetime package.
     """
 
     # Return time object by parameter format.
@@ -53,325 +74,432 @@
     elif format == "date_str":
         return datetime.datetime.now().strftime("%Y-%m-%d")
     elif format == "time_str":
         return datetime.datetime.now().strftime("%H:%M:%S")
     elif format == "timestamp":
         return int(time.time() * 1000)
 
+@overload
 def time_to_str(
-        time_obj: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta],
-        format_str: Optional[str] = None,
-        throw_error: bool = False
-    ) -> Union[str, Any]:
+    object_: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any],
+    format: Optional[str] = None,
+    throw_error: bool = False
+) -> Union[str, Any]: ...
+
+@overload
+def time_to_str(object_: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int]) -> str: ...
+
+@overload
+def time_to_str(object_: Any) -> Any: ...
+
+def time_to_str(
+    object_: Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any],
+    format: Optional[str] = None,
+    throw_error: bool = False
+) -> Union[str, Any]:
     """
-    Format time object of datetime package as string
+    Format time object of 'datetime' package to string
 
     Parameters
     ----------
-    time_obj : Of datetime package.
-    format_str : Format string.
+    object_ : Object of 'datetime' package or int.
+    format : Format string.
         - None : Automatic by type.
-            * Parameter time_obj is datetime.datetime : Is '%Y-%m-%d %H:%M:%S'.
-            * Parameter time_obj is datetime.date : Is '%Y-%m-%d'.
-            * Parameter time_obj is datetime.time : Is '%H:%M:%S'.
-            * Parameter time_obj is datetime.timedelta : Is f'{days} %H:%M:%S'.
-        - str : Format by str.
+            * Parameter 'object_' is datetime.datetime : Is '%Y-%m-%d %H:%M:%S'.
+            * Parameter 'object_' is datetime.date : Is '%Y-%m-%d'.
+            * Parameter 'object_' is datetime.time : Is '%H:%M:%S'.
+            * Parameter 'object_' is datetime.timedelta : Is f'{days} %H:%M:%S'.
+            * Parameter 'object_' is time stamp : Is '%Y-%m-%d %H:%M:%S'.
+        - str : Format by this value.
 
-    throw_error : Whether throw error, when parameter time_obj value error, otherwise return original value.
+    throw_error : Whether throw error, when parameter 'object_' value error, otherwise return original value.
 
     Returns
     -------
     String after foramt or original value.
     """
 
+    # Check parameters.
+    if throw_error:
+        check_target(object_, datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int)
+
     # Convert to time string.
-    obj_type = type(time_obj)
-    if obj_type == datetime.datetime:
-        if format_str == None:
-            string = str(time_obj)[:19]
+
+    ## From datetime object.
+    if type(object_) == datetime.datetime:
+        if format == None:
+            string = str(object_)[:19]
         else:
-            string = time_obj.strftime(format_str)
-    elif obj_type == datetime.date:
-        if format_str == None:
-            string = str(time_obj)[:10]
+            string = object_.strftime(format)
+
+    ## From date object.
+    elif type(object_) == datetime.date:
+        if format == None:
+            string = str(object_)[:10]
         else:
-            string = time_obj.strftime(format_str)
-    elif obj_type == datetime.time:
-        if format_str == None:
-            string = str(time_obj)[:8]
+            string = object_.strftime(format)
+
+    ## From time object.
+    elif type(object_) == datetime.time:
+        if format == None:
+            string = str(object_)[:8]
         else:
-            string = time_obj.strftime(format_str)
-    elif obj_type == datetime.timedelta:
-        if format_str == None:
-            string = str(time_obj)
+            string = object_.strftime(format)
+
+    ## From timedelta object.
+    elif type(object_) == datetime.timedelta:
+        if format == None:
+            string = str(object_)
             if "day" in string:
                 day, char, string = string.split(" ")
             else:
                 day = "0"
             if string[1] == ":":
                 string = "0" + string
             string = "%s %s" % (day, string[:8])
         else:
-            seconds = time_obj.seconds
-            time_obj = time.gmtime(seconds)
-            string = time.strftime(format_str, time_obj)
+            seconds = object_.microseconds / 1000_000
+            datetime_obj = datetime.datetime.fromtimestamp(seconds)
+            string = datetime_obj.strftime(format)
+
+    ## From int object.
+    elif type(object_) == int:
+        int_len = len(str(object_))
+        if int_len > 10:
+            divisor = 10 ** (int_len - 10)
+            seconds = object_ / divisor
+        else:
+            seconds = object_
+        datetime_obj = datetime.datetime.fromtimestamp(seconds)
+        if format == None:
+            format = "%Y-%m-%d %H:%M:%S"
+        string = datetime_obj.strftime(format)
+
+    ## From other object.
     else:
-        if throw_error:
-            check_param(time_obj, datetime.datetime, datetime.date, datetime.time, datetime.timedelta)
-        return time_obj
+        return object_
 
     return string
 
+@overload
 def str_to_time(
-        string: str,
-        to_type: Optional[Literal["datetime", "date", "time", "timedelta", "timestamp"]] = None,
-        format_str: Optional[str] = None,
-        throw_error: bool = False
-    ) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any]:
+    string: Union[str, Any],
+    type_: Optional[Literal["datetime", "date", "time", "timedelta", "timestamp"]] = None,
+    format: Optional[str] = None,
+    throw_error: bool = False
+) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any]: ...
+
+@overload
+def str_to_time(type_: Literal["datetime"]) -> Union[datetime.datetime, Any]: ...
+
+@overload
+def str_to_time(type_: Literal["date"]) -> Union[datetime.date, Any]: ...
+
+@overload
+def str_to_time(type_: Literal["time"]) -> Union[datetime.time, Any]: ...
+
+@overload
+def str_to_time(type_: Literal["timedelta"]) -> Union[datetime.timedelta, Any]: ...
+
+@overload
+def str_to_time(type_: Literal["timestamp"]) -> Union[int, Any]: ...
+
+@overload
+def str_to_time(type_: None) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, Any]: ...
+
+def str_to_time(
+    string: Union[str, Any],
+    type_: Optional[Literal["datetime", "date", "time", "timedelta", "timestamp"]] = None,
+    format: Optional[str] = None,
+    throw_error: bool = False
+) -> Union[datetime.datetime, datetime.date, datetime.time, datetime.timedelta, int, Any]:
     """
-    Format string as time object of datetime package
+    Format string to time object of datetime package
 
     Parameters
     ----------
     string : Time string.
-    to_type : Format type.
+    type_ : Format type.
         - None : Automatic judgment.
         - Literal['datetime'] : Return datetime object of datetime package.
         - Literal['date'] : Return date object of datetime package.
         - Literal['time'] : Return time object of datetime package.
         - Literal['timedelta'] : Return timedelta object of datetime package.
-        - Literal['timestamp'] : Return timestamp in milliseconds.
+        - Literal['timestamp'] : Return time stamp in milliseconds.
 
-    format_str : Format string.
+    format : Format string.
         - None : Default format method.
-            * Parameter to_type is 'datetime' : Is '%Y-%m-%d %H:%M:%S'.
-            * Parameter to_type is 'date' : Is '%Y-%m-%d'.
-            * Parameter to_type is 'time' : Is '%H:%M:%S'.
-            * Parameter to_type is 'timedelta' : Is 'days %H:%M:%S'.
-            * Parameter to_type is 'timestamp' : Is '%Y-%m-%d %H:%M:%S'.
-            * Parameter to_type is None : automatic judgment.
-        - str : Format by str.
+            * Parameter 'type_' is 'datetime' : Is '%Y-%m-%d %H:%M:%S'.
+            * Parameter 'type_' is 'date' : Is '%Y-%m-%d'.
+            * Parameter 'type_' is 'time' : Is '%H:%M:%S'.
+            * Parameter 'type_' is 'timedelta' : Is 'days %H:%M:%S'.
+            * Parameter 'type_' is 'timestamp' : Is '%Y-%m-%d %H:%M:%S'.
+            * Parameter 'type_' is None : automatic judgment.
+        - str : Format by this value.
 
-    throw_error : Whether throw error, when parameter time_obj value error, otherwise return original value.
+    throw_error : Whether throw error, when parameter 'time_obj' value error, otherwise return original value.
 
     Returns
     -------
-    Time object of datetime package or timestamp or original value.
+    Time object of datetime package or time stamp or original value.
     """
 
+    # Check parameters.
+    if type(string) != str:
+        return string
+
     # Get time format by automatic judgment.
-    if to_type == None:
+    if type_ == None:
         str_len = len(string)
         if "年" == string[4:5]:
             if str_len > 11:
-                format_str = "%Y年%m月%d日 %H时%M分%S秒"
-                to_type = "datetime"
+                format = "%Y年%m月%d日 %H时%M分%S秒"
+                type_ = "datetime"
             else:
-                format_str = "%Y年%m月%d日"
-                to_type = "date"
+                format = "%Y年%m月%d日"
+                type_ = "date"
         elif "时" in string[1:3]:
-            format_str = "%H时%M分%S秒"
-            to_type = "time"
+            format = "%H时%M分%S秒"
+            type_ = "time"
         elif " " in string and "-" not in string:
-            format_str = "%H:%M:%S"
-            to_type = "timedelta"
+            format = "%H:%M:%S"
+            type_ = "timedelta"
         elif str_len == 19:
-            format_str = "%Y-%m-%d %H:%M:%S"
-            to_type = "datetime"
+            format = "%Y-%m-%d %H:%M:%S"
+            type_ = "datetime"
         elif str_len == 14:
-            format_str = "%Y%m%d%H%M%S"
-            to_type = "datetime"
+            format = "%Y%m%d%H%M%S"
+            type_ = "datetime"
         elif str_len == 10:
-            format_str = "%Y-%m-%d"
-            to_type = "date"
+            format = "%Y-%m-%d"
+            type_ = "date"
         elif str_len == 8:
             if string[2] == ":":
-                format_str = "%H:%M:%S"
-                to_type = "time"
+                format = "%H:%M:%S"
+                type_ = "time"
             else:
-                format_str = "%Y%m%d"
-                to_type = "date"
+                format = "%Y%m%d"
+                type_ = "date"
         elif str_len == 6:
-            format_str = "%H%M%S"
-            to_type = "time"
+            format = "%H%M%S"
+            type_ = "time"
         elif str_len == 4:
-            format_str = "%Y"
-            to_type = "date"
+            format = "%Y"
+            type_ = "date"
         else:
             return string
 
-    # Get time format by parameter to_type.
+    # Get time format by parameter 'type_'.
     else:
-        if format_str == None:
+        if format == None:
             format_dir = {
                 "datetime": "%Y-%m-%d %H:%M:%S",
                 "date": "%Y-%m-%d",
                 "time": "%H:%M:%S",
                 "timestamp": "%Y-%m-%d %H:%M:%S",
                 "timedelta": "%H:%M:%S"
             }
-            format_str = format_dir[to_type]
+            format = format_dir[type_]
 
     # Additional processing timedelta type.
-    if to_type == "timedelta":
+    if type_ == "timedelta":
         if " " in string:
             strings = string.split(" ")
             day_str, string = strings[0], strings[-1]
         else:
             day = "0"
         try:
             day = int(day_str)
         except ValueError:
             if throw_error:
-                error("failed to format string as time object")
+                raise ValueError("failed to format string as time object")
             return string
 
     # Convert to time type.
     try:
-        time_obj = datetime.datetime.strptime(string, format_str)
+        time_obj = datetime.datetime.strptime(string, format)
     except ValueError:
         if throw_error:
-            error("failed to format string as time object")
+            raise ValueError("failed to format string as time object")
         return string
-    if to_type == "date":
+    if type_ == "date":
         time_obj = time_obj.date()
-    elif to_type == "time":
+    elif type_ == "time":
         time_obj = time_obj.time()
-    elif to_type == "timestamp":
+    elif type_ == "timestamp":
         time_obj = int(time_obj.timestamp() * 1000)
-    elif to_type == "timedelta":
+    elif type_ == "timedelta":
         second = time_obj.second
         second += day * 86400
         time_obj = datetime.timedelta(seconds=second)
+
     return time_obj
 
-def is_sql_time(content: Union[str, int], return_value: bool = False) -> Union[bool, Tuple[int, int, int, int, int, int]]:
+@overload
+def is_sql_time(content: Union[str, int], return_datatime: bool = False) -> Union[bool, datetime.datetime]: ...
+
+@overload
+def is_sql_time(return_datatime: Literal[False]) -> bool: ...
+
+@overload
+def is_sql_time(return_datatime: Literal[True]) -> datetime.datetime: ...
+
+def is_sql_time(
+    content: Union[str, int],
+    return_datatime: bool = False
+) -> Union[bool, datetime.datetime]:
     """
     Judge whether it conforms to SQL time format.
 
     Parameters
     ----------
     content : Judge object.
-    return_value : Whether return value.
-    
+    return_datatime : Whether return datetime object.
+
     Returns
     -------
     Judgment result or transformed values.
     """
 
-    content_type = type(content)
-    if content_type == str:
+    # Extract number string.
+
+    ## From str object.
+    if type(content) == str:
         content_len = len(content)
         if content_len < 5:
             return False
         if is_number_str(content[4]):
             if content_len == 8:
                 datetimes_str = [content[0:4], content[4:6], content[6:8], None, None, None]
             else:
                 pattern = "^(\d{2}|\d{4})(\d{2})(\d{1,2})(\d{0,2})(\d{0,2})(\d{0,2})$"
                 result = re_search(pattern, content)
                 datetimes_str = list(result)
         else:
             pattern = "^(\d{2}|\d{4})[\W_](\d{2})[\W_](\d{2})[\W_]?(\d{2})?[\W_]?(\d{2})?[\W_]?(\d{2})?$"
             result = re_search(pattern, content)
             datetimes_str = list(result)
-    elif content_type == int:
+
+    ## From int object.
+    elif type(content) == int:
         content = str(content)
         content_len = len(content)
         if content_len < 3:
             return False
         elif content_len <= 8:
             pattern = r"^(\d{0,4}?)(\d{1,2}?)(\d{2})$"
             result = re_search(pattern, content)
             datetimes_str = list(result)
             datetimes_str += [None, None, None]
         else:
             pattern = r"^(\d{0,4}?)(\d{1,2})(\d{2})(\d{2})(\d{2})(\d{2})$"
             result = re_search(pattern, content)
             datetimes_str = list(result)
+
+    # Judge.
     year_len = len(datetimes_str[0])
     datetimes_str[0] = "2000"[0:4-year_len] + datetimes_str[0]
+    year, month, day, hour, minute, second = [
+        0 if int_str in ["", None] else int(int_str)
+        for int_str in datetimes_str
+    ]
     try:
-        year, month, day, hour, minute, second = [
-            0 if int_str in ["", None] else int(int_str)
-            for int_str in datetimes_str
-        ]
         datetime.datetime(year, month, day, hour, minute, second)
-        if return_value:
-            return year, month, day, hour, minute, second
-        return True
     except ValueError:
-        pass
-    return False
+        return False
+
+    # Return datatime object.
+    if return_datatime:
+        return datetime.datetime(year, month, day, hour, minute, second)
+
+    return True
 
-class rdatetimeMark():
+class RDateTimeMark():
     """
-    Rey's time mark type.
+    Rey's date time mark type.
     """
 
     def __init__(self) -> None:
         """
         Mark now time.
         """
 
+        # Marking.
         self.mark()
 
     def mark(self) -> Dict[
         Literal["index", "timestamp", "datetime", "datetime_str", "interval_timestamp", "interval_timedelta", "interval_timedelta_str"],
         Optional[Union[str, float, datetime.datetime, datetime.timedelta]]
     ]:
         """
         Mark now time and return mark time information.
 
         Returns
         -------
         Mark time information.
         """
 
+        # Compatible with first marking.
         if "record" not in self.__dir__():
             self.record = []
+
+        # Get parametes.
         record_len = len(self.record)
         mark_info = {
             "index": record_len,
             "timestamp": now("timestamp"),
             "datetime": now("datetime"),
             "datetime_str": now(),
         }
+
+        # Marking.
+
+        ## First.
         if record_len == 0:
             mark_info["interval_timestamp"] = None
             mark_info["interval_timedelta"] = None
             mark_info["interval_timedelta_str"] = None
+
+        ## Non first.
         else:
             last_datetime = self.record[-1]["datetime"]
             last_timestamp = self.record[-1]["timestamp"]
             mark_info["interval_timestamp"] = mark_info["timestamp"] - last_timestamp
             mark_info["interval_timedelta"] = mark_info["datetime"] - last_datetime
             mark_info["interval_timedelta_str"] = time_to_str(mark_info["interval_timedelta"])
+
         self.record.append(mark_info)
+
         return mark_info
 
     def report(self) -> DataFrame:
         """
         Print and return mark time information.
 
         Returns
         -------
         DataFrame object of pandas package with mark time information.
         """
 
+        # Get parameters.
         data = [
             {
                 "timestamp": row["timestamp"],
                 "datetime": row["datetime_str"],
                 "interval": row["interval_timedelta_str"]
             }
             for row in self.record
         ]
+
+        # Generate report.
         report_df = DataFrame(data)
         interval_timedelta = self.record[-1]["datetime"] - self.record[0]["datetime"]
         interval = time_to_str(interval_timedelta)
         sum_df = DataFrame({"interval": interval}, index = ["sum"])
         report_df = pd_concat([report_df, sum_df])
         report_df.fillna("-", inplace=True)
+
+        # Report.
         title = "Time Mark"
         rprint(report_df, title=title)
+
         return report_df
```

## reytool/remail.py

```diff
@@ -20,59 +20,73 @@
 class REmail(object):
     """
     Rey's E-mail type.
     """
 
     def __init__(
         self,
-        email_user: Optional[str] = None,
-        email_password: Optional[str] = None,
-        title: Optional[str] = None,
-        text: Optional[str] = None,
-        attachment: Optional[Dict[str, Union[str, bytes]]] = None,
-        to_email: Optional[Union[str, Iterable]] = None,
-        cc_email: Optional[Union[str, Iterable]] = None,
-        display_from_email: Optional[str] = None,
-        display_to_email: Optional[Union[str, Iterable]] = None,
-        display_cc_email: Optional[Union[str, Iterable]] = None
+        email_username: str,
+        email_password: str,
+        display_from_email: Optional[str] = None
     ) -> None:
         """
         Set E-mail attribute.
+
+        Parameters
+        ----------
+        email_username : E-mail user name.
+        email_password : E-mail password.
+        display_from_email : Displayed from E-mail.
+            - None : Not set.
+            - str : Set this value.
         """
 
-        self.email_user = email_user
+        # Set parameters.
+        self.email_username = email_username
         self.email_password = email_password
-        self.title = title
-        self.text = text
-        self.attachment = attachment
-        self.to_email = to_email
-        self.cc_email = cc_email
         self.display_from_email = display_from_email
-        self.display_to_email = display_to_email
-        self.display_cc_email = display_cc_email
 
     def create_email(
         self,
-        title: Optional[str] = None,
         text: Optional[str] = None,
+        title: Optional[str] = None,
         attachment: Optional[Dict[str, Union[str, bytes]]] = None,
         display_from_email: Optional[str] = None,
-        display_to_email: Optional[Union[str, Iterable]] = None,
-        display_cc_email: Optional[Union[str, Iterable]] = None
+        display_to_email: Optional[Union[str, Iterable[str]]] = None,
+        display_cc_email: Optional[Union[str, Iterable[str]]] = None
     ) -> str:
         """
         Create string in E-mail format.
+
+        Parameters
+        ----------
+        text : E-mail text.
+        title : E-mail title.
+        attachment : E-mail attachment.
+            - Dict[str, str] : File name and path.
+            - Dict[str, bytes] : File name and stream.
+
+        display_from_email : Displayed from E-mail.
+        display_to_email : Displayed to E-mail.
+            - str : Set this value.
+            - Iterable[str] : Set multiple values.
+
+        display_cc_email : Displayed cc E-mail.
+            - str : Set this value.
+            - Iterable[str] : Set multiple values.
+
+        Returns
+        -------
+        String in E-mail format.
         """
 
-        title = get_first_notnull(title, self.title)
-        text = get_first_notnull(text, self.text)
-        attachment = get_first_notnull(attachment, self.attachment)
-        display_from_email = get_first_notnull(display_from_email, self.display_from_email, self.email_user)
-        display_to_email = get_first_notnull(display_to_email, self.display_to_email, self.to_email)
-        display_cc_email = get_first_notnull(display_cc_email, self.display_cc_email, self.cc_email)
+        # Get parameters by priority.
+        display_from_email = get_first_notnull(display_from_email, self.display_from_email, self.email_username)
+
+        # Create E-mail object.
         mime = MIMEMultipart()
         if title != None:
             mime["subject"] = title
         if text != None:
             mime_text = MIMEText(text)
             mime.attach(mime_text)
         if attachment != None:
@@ -91,53 +105,77 @@
             else:
                 mime["to"] = ",".join(display_to_email)
         if display_cc_email != None:
             if type(display_cc_email) == str:
                 mime["cc"] = display_cc_email
             else:
                 mime["cc"] = ",".join(display_cc_email)
+
+        # Create string in E-mail format.
         email_str = mime.as_string()
+
         return email_str
-        
+
     def send_email(
         self,
-        email_user: Optional[str] = None,
-        email_password: Optional[str] = None,
-        title: Optional[str] = None,
+        to_email: Union[str, Iterable[str]],
         text: Optional[str] = None,
+        title: Optional[str] = None,
         attachment: Optional[Dict[str, Union[str, bytes]]] = None,
-        to_email: Optional[Union[str, Iterable]] = None,
-        cc_email: Optional[Union[str, Iterable]] = None,
+        cc_email: Optional[Union[str, Iterable[str]]] = None,
         display_from_email: Optional[str] = None,
-        display_to_email: Optional[Union[str, Iterable]] = None,
-        display_cc_email: Optional[Union[str, Iterable]] = None
+        display_to_email: Optional[Union[str, Iterable[str]]] = None,
+        display_cc_email: Optional[Union[str, Iterable[str]]] = None
     ) -> None:
         """
         Send E-mail.
+
+        Parameters
+        ----------
+        to_email : To E-mail.
+            - str : Set this value.
+            - Iterable[str] : Set multiple values.
+
+        text : E-mail text.
+        title : E-mail title.
+        attachment : E-mail attachment.
+            - Dict[str, str] : File name and path.
+            - Dict[str, bytes] : File name and stream.
+
+        cc_email : Cc E-mail.
+            - str : Set this value.
+            - Iterable[str] : Set multiple values.
+
+        display_from_email : Displayed from E-mail.
+        display_to_email : Displayed to E-mail.
+            - str : Set this value.
+            - Iterable[str] : Set multiple values.
+
+        display_cc_email : Displayed cc E-mail.
+            - str : Set this value.
+            - Iterable[str] : Set multiple values.
         """
 
-        email_user = get_first_notnull(email_user, self.email_user, default="error")
-        email_password = get_first_notnull(email_password, self.email_password, default="error")
-        title = get_first_notnull(title, self.title)
-        text = get_first_notnull(text, self.text)
-        attachment = get_first_notnull(attachment, self.attachment)
-        to_email = get_first_notnull(to_email, self.to_email, default="error")
-        cc_email = get_first_notnull(cc_email, self.cc_email)
-        display_from_email = get_first_notnull(display_from_email, self.display_from_email, email_user)
-        display_to_email = get_first_notnull(display_to_email, self.display_to_email, to_email)
-        display_cc_email = get_first_notnull(display_cc_email, self.display_cc_email, cc_email)
-        
+        # Get parameters by priority.
+        display_from_email = get_first_notnull(display_from_email, self.display_from_email, self.email_username)
+        display_to_email = get_first_notnull(display_to_email, to_email)
+        display_cc_email = get_first_notnull(display_cc_email, cc_email)
+
+        # Handle parameters.
         if type(to_email) == str:
             to_email = [to_email]
         if cc_email != None:
             if type(cc_email) == str:
-                to_email.append(cc_email)
-            else:
-                to_email.extend(cc_email)
+                cc_email = [cc_email]
+            to_email.extend(cc_email)
+
+        # Create string in E-mail format.
         email_str = self.create_email(title, text, attachment, display_from_email, display_to_email, display_cc_email)
-        server_domain_name = email_user.split("@")[-1]
+
+        # Send E-mail.
+        server_domain_name = self.email_username.split("@")[-1]
         server_host = "smtp." + server_domain_name
         server_port = 25
         smtp = SMTP(server_host, server_port)
-        smtp.login(email_user, email_password)
-        smtp.sendmail(email_user, to_email, email_str)
+        smtp.login(self.email_username, self.email_password)
+        smtp.sendmail(self.email_username, to_email, email_str)
         smtp.quit()
```

## reytool/rmultitask.py

```diff
@@ -55,14 +55,15 @@
 
     Examples
     --------
     Get value.
     >>> results = [future.result() for future in Generator]
     """
 
+    # Handle parameters.
     if thread_name == None:
         thread_name = func.__name__
     params_lens = {len(param) for param in args}
     params_lens -= {1}
     min_param_len = min(params_lens)
     args = [
         list(param) * min_param_len
@@ -85,15 +86,23 @@
         args = [[]] * min_param_len
     if kwargs:
         kwargs = zip(*kwargs)
         kwargs = [dict(param) for param in kwargs]
     else:
         kwargs = [{}] * min_param_len
     params = zip(args, kwargs)
+
+    # Create thread pool.
     thread_pool = ThreadPoolExecutor(max_workers, thread_name)
+
+    # Add progress bar.
     if to_tqdm:
         tqdm_desc = "ThreadPool " + thread_name
         obj_tqdm = tqdm(desc=tqdm_desc, total=min_param_len)
         func = update_tqdm(func, obj_tqdm, _execute=False)
+
+    # Start thread pool.
     tasks = [thread_pool.submit(func, *args, **kwargs) for args, kwargs in params]
+
+    # Return generator.
     obj_tasks = as_completed(tasks, timeout)
     return obj_tasks
```

## reytool/rregular.py

```diff
@@ -5,20 +5,20 @@
 @Time    : 2022-12-11 23:25:36
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's regular methods.
 """
 
 
-from typing import Tuple, Optional, Union
+from typing import List, Tuple, Optional, Union, Literal, overload
 import re
 from re import RegexFlag
 
 
-def re_search(pattern: str, text: str, mode: Optional[RegexFlag] = None) -> Union[str, None, Tuple[Union[None, str], ...]]:
+def re_search(pattern: str, text: str, mode: Optional[RegexFlag] = None) -> Optional[Union[str, Tuple[Optional[str], ...]]]:
     """
     Regular matching text.
 
     Parameters
     ----------
     pattern : Regular pattern.
     text : Match text.
@@ -30,25 +30,43 @@
     -------
     Matching result.
         - When match to and not use group, then return string.
         - When match to and use group, then return tuple with value string or None.
         - When no match, then return.
     """
 
+    # Search.
     if mode == None:
         obj_re = re.search(pattern, text)
     else:
         obj_re = re.search(pattern, text, mode)
+
+    # Return result.
     if obj_re != None:
         result = obj_re.groups()
         if result == ():
             result = obj_re[0]
         return result
 
-def res(text: str, *patterns: str, return_first: bool = True) -> Union[str, None, Tuple[Union[None, str], ...]]:
+@overload
+def res(text: str, *patterns: str, return_first: bool = True) -> Union[
+    Optional[Union[str, Tuple[Optional[str], ...]]],
+    List[Optional[Union[str, Tuple[Optional[str], ...]]]]
+]: ...
+
+@overload
+def res(return_first: Literal[True]) -> Optional[Union[str, Tuple[Optional[str], ...]]]: ...
+
+@overload
+def res(return_first: Literal[False]) -> List[Optional[Union[str, Tuple[Optional[str], ...]]]]: ...
+
+def res(text: str, *patterns: str, return_first: bool = True) -> Union[
+    Optional[Union[str, Tuple[Optional[str], ...]]],
+    List[Optional[Union[str, Tuple[Optional[str], ...]]]]
+]:
     """
     Batch regular matching text.
 
     Parameters
     ----------
     text : Match text.
     pattern : Regular pattern.
@@ -58,15 +76,20 @@
     -------
     Matching result.
         - When match to and not use group, then return string.
         - When match to and use group, then return tuple with value string or None.
         - When no match, then return.
     """
 
+    # Search.
+
+    ## Return first result.
     if return_first:
         for pattern in patterns:
             result = re_search(pattern, text)
             if result != None:
                 return result
+
+    ## Return all result.
     else:
         result = [re_search(pattern, text) for pattern in patterns]
         return result
```

## reytool/rrequest.py

```diff
@@ -10,15 +10,15 @@
 
 
 from typing import List, Dict, Tuple, Literal, Optional, Union
 import requests
 from requests import Response, JSONDecodeError
 from faker import Faker
 
-from .rbasic import error, get_first_notnull
+from .rbasic import get_first_notnull
 from . import roption
 
 
 # Global variable Faker object.
 fake: Faker = Faker("zh_CN")
 
 def fake_headers() -> Dict:
@@ -26,16 +26,18 @@
     Fake request headers.
 
     Returns
     -------
     Fake request headers.
     """
 
+    # Generate.
     headers = {}
     headers['user_agent'] = fake.android_platform_token()
+
     return headers
 
 def check_response(
         response: Response,
         code_fields: Optional[List] = None,
         success_codes: Optional[List] = None,
         throw_error: bool = True
@@ -57,39 +59,45 @@
     throw_error : Whether throw error.
 
     Returns
     -------
     Response code and Response message
     """
 
+    # Get parameters by priority.
     code_fields = get_first_notnull(code_fields, roption.code_fields)
     success_codes = get_first_notnull(success_codes, roption.success_codes)
 
+    # Check.
+
+    ## Check request code.
     reponse_code = response.status_code
     if reponse_code not in success_codes:
         check_info = reponse_code, response.text
         if throw_error:
-            error(check_info)
+            raise AssertionError(reponse_code, response.text)
         return check_info
-    else:
-        try:
-            response_data = response.json()
-        except JSONDecodeError:
-            return 200, "success"
-        if type(response_data) == dict:
-            for field in code_fields:
-                if field in response_data:
-                    code = response_data[field]
-                    if code in success_codes:
-                        break
-                    else:
-                        check_info = code, response_data
-                        if throw_error:
-                            error(check_info)
-                        return check_info
+
+    ## Check route code.
+    try:
+        response_data = response.json()
+    except JSONDecodeError:
+        return 200, "success"
+    if type(response_data) == dict:
+        for field in code_fields:
+            if field in response_data:
+                code = response_data[field]
+                if code in success_codes:
+                    break
+                else:
+                    check_info = code, response_data
+                    if throw_error:
+                        raise AssertionError(code, response_data)
+                    return check_info
+
     return 200, "success"
 
 def request(
     url: str,
     data: Optional[Dict] = None,
     json: Optional[Dict] = None,
     headers: Optional[Union[Dict, Literal["fake"]]] = None,
@@ -137,25 +145,32 @@
         - None : Use option of module roption.
         - List : Use this value.
 
     Returns
     -------
     Response object of requests package.
     """
-    
+
+    # Get parameters by priority.
     code_fields = get_first_notnull(code_fields, roption.code_fields)
     success_codes = get_first_notnull(success_codes, roption.success_codes)
 
+    # Handle parameters.
     if method == None:
         if data == None and json == None:
             method = "get"
         else:
             method = "post"
     if headers == "fake":
         headers = fake_headers()
+
+    # Request.
     if method == "get":
         response = requests.get(url, data=data, json=json, headers=headers, timeout=timeout, proxies=proxies)
     elif method == "post":
         response = requests.post(url, data=data, json=json, headers=headers, timeout=timeout, proxies=proxies)
+
+    # Check.
     if check:
         check_response(response, code_fields, success_codes)
+
     return response
```

## reytool/rtext.py

```diff
@@ -9,96 +9,91 @@
 """
 
 
 from typing import Any, List, Literal, Optional
 import pprint
 from urwid import old_str_util
 
-from .rbasic import error, get_first_notnull, get_name
+from .rbasic import get_first_notnull, get_name
+from .rmonkey import modify_format_width_judgment
 from . import roption
 
 
-def monkey_patch_format() -> None:
-    """
-    Based on module pprint.pformat, modify the chinese width judgment.
-    """
-    
-    def _format(_self, object, stream, indent, allowance, context, level):
-        objid = id(object)
-        if objid in context:
-            stream.write(pprint._recursion(object))
-            _self._recursive = True
-            _self._readable = False
-            return
-        rep = _self._repr(object, context, level)
-        max_width = _self._width - indent - allowance
-        width = get_width(rep)
-        if width > max_width:
-            p = _self._dispatch.get(type(object).__repr__, None)
-            if p is not None:
-                context[objid] = 1
-                p(_self, object, stream, indent, allowance, context, level + 1)
-                del context[objid]
-                return
-            elif isinstance(object, dict):
-                context[objid] = 1
-                _self._pprint_dict(object, stream, indent, allowance,
-                                context, level + 1)
-                del context[objid]
-                return
-        stream.write(rep)
+# Based on module pprint.pformat, modify the chinese width judgment.
+modify_format_width_judgment()
 
-    # Modify the chinese width judgment.
-    pprint.PrettyPrinter._format = _format
+def split_text(text: str, man_len: int, by_width: bool = False) -> List[str]:
+    """
+    Split text by max length or not greater than display width.
 
-monkey_patch_format()
+    Parameters
+    ----------
+    text : Text.
+    man_len : max length.
+    by_width : Whether by char displayed width count length.
 
-def split_text(text: str, length: int, by_width: bool = False) -> List:
-    """
-    Split text by length or not greater than display width.
+    Returns
+    -------
+    Split text.
     """
 
+    # Split.
     texts = []
+
+    ## By char displayed width.
     if by_width:
         str_group = []
         str_width = 0
         for char in text:
             char_width = get_width(char)
             str_width += char_width
-            if str_width > length:
+            if str_width > man_len:
                 string = "".join(str_group)
                 texts.append(string)
                 str_group = [char]
                 str_width = char_width
             else:
                 str_group.append(char)
         string = "".join(str_group)
         texts.append(string)
+
+    ## By char number.
     else:
         test_len = len(text)
-        split_n = test_len // length
-        if test_len % length:
+        split_n = test_len // man_len
+        if test_len % man_len:
             split_n += 1
         for n in range(split_n):
-            start_indxe = length * n
-            end_index = length * (n + 1)
+            start_indxe = man_len * n
+            end_index = man_len * (n + 1)
             text_group = text[start_indxe:end_index]
             texts.append(text_group)
+
     return texts
 
 def get_width(text: str) -> int:
     """
     Get text display width.
+
+    Parameters
+    ----------
+    text : Text.
+
+    Returns
+    -------
+    Text display width.
     """
-    
+
+    # Get width.
     total_width = 0
     for char in text:
         char_unicode = ord(char)
         char_width = old_str_util.get_width(char_unicode)
         total_width += char_width
+
     return total_width
 
 def fill_width(text: str, char: str, width: int, align: Literal["left", "right", "center"] = "right") -> str:
     """
     Text fill character by display width.
 
     Parameters
@@ -106,37 +101,41 @@
     text : Fill text.
     char : Fill character.
     width : Fill width.
     align : Align orientation.
         - Literal['left'] : Fill right, align left.
         - Literal['right'] : Fill left, align right.
         - Literal['center'] : Fill both sides, align center.
-    
+
     Returns
     -------
     Text after fill.
     """
 
+    # Check parameters.
     if get_width(char) != 1:
-        error("parameter char value error", ValueError)
+        raise ValueError("parameter 'char' value error")
+
+    # Fill width.
     text_width = get_width(text)
     fill_width = width - text_width
     if fill_width > 0:
         if align == "left":
             new_text = "%s%s" % (char * fill_width, text)
         elif align == "right":
             new_text = "%s%s" % (text, char * fill_width)
         elif align == "center":
             fill_width_left = int(fill_width / 2)
             fill_width_right = fill_width - fill_width_left
             new_text = "%s%s%s" % (char * fill_width_left, text, char * fill_width_right)
         else:
-            error("parameter align value error", ValueError)
+            raise ValueError("parameter 'align' value error")
     else:
         new_text = text
+
     return new_text
 
 def print_frame(
     *contents: Any,
     title: Optional[str] = None,
     width: Optional[int] = None,
     frame: Optional[Literal["full", "half", "plain"]] = None
@@ -159,20 +158,26 @@
         - None : Use option of module roption.
         - Literal["full", "half", "plain"] : Use this value.
             * Literal['full'] : Build with symbol '═╡╞─║╟╢╔╗╚╝', and content not can exceed the frame.
                 When throw error, then frame is 'half' type.
             * Literal['half'] : Build with symbol '═╡╞─', and content can exceed the frame.
             * Literal['plain'] : Build with symbol '=|-', and content can exceed the frame.
     """
-    
+
+    # Get parameters by priority.
     width = get_first_notnull(width, roption.print_width)
     frame = get_first_notnull(frame, roption.print_default_frame_full)
 
+    # Handle parameters.
     if title == None or len(title) > width - 6:
         title = ""
+
+    # Generate frame.
+
+    ## Full type.
     if frame == "full":
         if title != "":
             title = f"╡ {title} ╞"
         width_in = width - 2
         _contents = []
         try:
             for content in contents:
@@ -191,28 +196,34 @@
             frame_bottom = "═" * width
             _contents = contents
         else:
             frame_top = "╔%s╗" % fill_width(title, "═", width_in, "center")
             # frame_split = "╠%s╣" % ("═" * width_in)
             frame_split = "╟%s╢" % ("─" * width_in)
             frame_bottom = "╚%s╝" % ("═" * width_in)
+
+    ## Half type.
     elif frame == "half":
         if title != "":
             title = f"╡ {title} ╞"
         frame_top = fill_width(title, "═", width, "center")
         frame_split = "─" * width
         frame_bottom = "═" * width
         _contents = contents
+
+    ## Plain type.
     elif frame == "plain":
         if title != "":
             title = f"| {title} |"
         frame_top = fill_width(title, "=", width, "center")
         frame_split = "-" * width
         frame_bottom = "=" * width
         _contents = contents
+
+    # Print.
     print(frame_top)
     for index, content in enumerate(_contents):
         if index != 0:
             print(frame_split)
         print(content)
     print(frame_bottom)
 
@@ -244,28 +255,34 @@
                 When throw error, then frame is 'half' type.
             * Literal['half'] : Build with symbol '═╡╞─', and content can exceed the frame.
             * Literal['plain'] : Build with symbol '=|-', and content can exceed the frame.
     
     format : Whether format data of type list or tuple or dict or set.
     """
 
+    # Get parameters by priority.
     width = get_first_notnull(width, roption.print_width)
     frame = get_first_notnull(frame, roption.print_default_frame_full)
 
+    # Handle parameters.
     if title == None:
         titles = get_name(contents)
         if titles != None:
             titles = [title if title[:1] != "'" else "" for title in titles]
             if set(titles) != {""}:
                 title = " │ ".join(titles)
+
+    # Format contents.
     if format:
         if frame == "full":
             _width = width - 2
         else:
             _width = width
         contents = [
             pprint.pformat(content, width=_width, sort_dicts=False)
             if type(content) in [list, tuple, dict, set]
             else content
             for content in contents
         ]
+
+    # Print.
     print_frame(*contents, title=title, width=width, frame=frame)
```

## reytool/rwrap.py

```diff
@@ -5,22 +5,22 @@
 @Time    : 2022-12-05 14:12:25
 @Author  : Rey
 @Contact : reyxbo@163.com
 @Explain : Rey's decorators.
 """
 
 
-from typing import Any, Tuple, Callable, Optional, Union
+from typing import Any, Tuple, Callable, Optional, Union, Literal, overload
 from tqdm import tqdm as tqdm_tqdm
 from threading import Thread
 from functools import wraps as functools_wraps
 
 from .rcommon import exc
 from .rtext import print_frame
-from .rdatetime import rdatetimeMark, now
+from .rdatetime import RDateTimeMark, now
 
 
 def wrap_frame(decorator: Callable) -> Callable:
     """
     Decorative frame.
 
     Parameters
@@ -53,57 +53,64 @@
 
     Decoration function method five.
     >>> def func(): ...
     >>> func = wrap_func(func, param_a, param_c=1, _execute=False)
     >>> func_ret = func(param_b, param_d=2)
     """
 
+    # Decorate Decorator.
     @functools_wraps(decorator)
     def wrap(func: Callable, *args: Any, _execute: Optional[bool] = None, **kwargs: Any) -> Union[Callable, Any]:
         """
         Decorative shell.
 
         Parameters
         ----------
         _execute : Whether execute function, otherwise decorate function.
-            - None : When parameter *args or **kwargs have values, then True, otherwise False.
+            - None : When parameter 'args' or 'kwargs' have values, then True, otherwise False.
             - bool : Use this value.
         
         Returns
         -------
         Function after decoration or return of function.
         """
 
+        # Handle parameters.
         if _execute == None:
-            if args or kwargs:
+            if args != () or kwargs != {}:
                 _execute = True
             else:
                 _execute = False
 
+        # Direct execution.
         if _execute:
             func_ret = decorator(func, *args, **kwargs)
             return func_ret
-        
-        else:
-            @functools_wraps(func)
-            def wrap_sub(*_args: object, **_kwargs: object) -> object:
-                """
-                Decorative sub shell.
-                """
 
-                func_ret = decorator(func, *args, *_args, **kwargs, **_kwargs)
-                return func_ret
-            return wrap_sub
+        # Decorate function.
+        @functools_wraps(func)
+        def wrap_sub(*_args: object, **_kwargs: object) -> object:
+            """
+            Decorative sub shell.
+            """
+
+            # Decorate function.
+            func_ret = decorator(func, *args, *_args, **kwargs, **_kwargs)
+
+            return func_ret
+
+        return wrap_sub
+
     return wrap
 
 def wraps(*wrap_funcs: Callable) -> Callable:
     """
     Batch decorate.
 
-    parameters
+    Parameters
     ----------
     wrap_funcs : Decorator function.
 
     Retuens
     -------
     Function after decoration.
 
@@ -125,35 +132,52 @@
 
     >>> def func(): ...
     >>> func = print_funtime(func)
     >>> func = state_thread(func)
     >>> func_ret = func()
     """
 
+    # Sequential decorate.
     def func(): ...
     for wrap_func in wrap_funcs:
-        
+
+        ## One shell.
         @functools_wraps(func)
         def wrap(func: Callable) -> Callable:
             """
             Decorative shell
             """
 
+            ## Two shell.
             @functools_wraps(func)
             def wrap_sub(*args: object, **kwargs: object) -> object:
                 """
                 Decorative sub shell
                 """
 
+                # Decorate.
                 func_ret = wrap_func(func, *args, _execute=True, **kwargs)
+
                 return func_ret
+
             return wrap_sub
+
         func = wrap
+
     return wrap
 
+@overload
+def runtime(func: Callable, *args: Any, _ret_report: bool = False, **kwargs: Any) -> Union[Any, Tuple[Any, str]]: ...
+
+@overload
+def runtime(_ret_report: Literal[False]) -> Any: ...
+
+@overload
+def runtime(_ret_report: Literal[True]) -> Union[Any, Tuple[Any, str]]: ...
+
 @wrap_frame
 def runtime(func: Callable, *args: Any, _ret_report: bool = False, **kwargs: Any) -> Union[Any, Tuple[Any, str]]:
     """
     Print or return runtime report of the function.
 
     Parameters
     ----------
@@ -163,29 +187,39 @@
     kwargs : Keyword parameter of input parameter decorated function.
 
     Returns
     -------
     Function run result or runtime report.
     """
 
-    rtm = rdatetimeMark()
+    # Run function and marking time.
+    rtm = RDateTimeMark()
     func_ret = func(*args, **kwargs)
     rtm.mark()
+
+    # Generate report.
     runtime = rtm.record[-1]["interval_timestamp"] / 1000
     report = "Start: %s -> Spend: %ss -> End: %s" % (
         rtm.record[0]["datetime_str"],
         runtime,
         rtm.record[1]["datetime_str"]
     )
     title = func.__name__
+
+    # Return report.
     if _ret_report:
         return func_ret, report
-    else:
-        print_frame(report, title=title)
-        return func_ret
+
+    # Print report.
+    print_frame(report, title=title)
+
+    return func_ret
+
+@overload
+def start_thread(func: Callable, *args: Any, _daemon: bool = True, **kwargs: Any) -> Thread: ...
 
 @wrap_frame
 def start_thread(func: Callable, *args: Any, _daemon: bool = True, **kwargs: Any) -> Thread:
     """
     Function start in thread.
 
     Parameters
@@ -196,47 +230,68 @@
     kwargs : Keyword parameter of input parameter decorated function.
 
     Returns
     -------
     Thread object.
     """
 
+    # Handle parameters.
     thread_name = "%s_%d" % (func.__name__, now("timestamp"))
+
+    # Create thread.
     thread = Thread(target=func, name=thread_name, args=args, kwargs=kwargs)
     thread.daemon = _daemon
+
+    # Start thread.
     thread.start()
+
     return thread
 
+@overload
+def try_exc(func: Callable, *args: Any, **kwargs: Any) -> Optional[Any]: ...
+
 @wrap_frame
-def try_exc(
-    func: Callable,
-    *args: Any,
-    **kwargs: Any
-) -> Union[None, Any]:
+def try_exc(func: Callable, *args: Any, **kwargs: Any) -> Optional[Any]:
     """
     Execute function with 'try' syntax and print error information.
 
     Parameters
     ----------
     func : Function to be decorated.
     args : Position parameter of input parameter decorated function.
     kwargs : Keyword parameter of input parameter decorated function.
 
     Returns
     -------
     Function run result or no return.
     """
 
+    # Run function.
     try:
         func_ret = func(*args, **kwargs)
-        return func_ret
+
+    # Print error information.
     except:
         func_name = func.__name__
         exc(func_name)
 
+    # Return function result.
+    else:
+        return func_ret
+
+@overload
+def update_tqdm(
+    func: Callable,
+    tqdm: tqdm_tqdm,
+    *args: Any,
+    _desc: Optional[str] = None,
+    _step: Union[int, float] = 1,
+    **kwargs: Any
+) -> Any: ...
+
 @wrap_frame
 def update_tqdm(
     func: Callable,
     tqdm: tqdm_tqdm,
     *args: Any,
     _desc: Optional[str] = None,
     _step: Union[int, float] = 1,
@@ -261,12 +316,18 @@
     kwargs : Keyword parameter of input parameter decorated function.
 
     Returns
     -------
     Function run result or no return.
     """
 
+    # Set description.
     if _desc != None:
         tqdm.set_description(_desc)
+
+    # Run function.
     func_ret = func(*args, **kwargs)
+
+    # Update progress bar.
     tqdm.update(_step)
+
     return func_ret
```

## reyworm/__init__.py

```diff
@@ -1,17 +1,17 @@
 # !/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 """
 @Time    : 2023-02-19 18:59:26
 @Author  : Rey
 @Contact : reyxbo@163.com
-@Explain : Rey's personal worm set
+@Explain : Rey's personal worm set.
 """
 
 
 from typing import Final
 
 from .rtranslate import translate
 
 
-__version__: Final[str] = "0.2"
+__version__: Final[str] = "0.3"
```

## reyworm/rtranslate.py

```diff
@@ -1,15 +1,15 @@
 # !/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 """
 @Time    : 2022-12-08 17:08:41
 @Author  : Rey
 @Contact : reyxbo@163.com
-@Explain : Rey's translate methods
+@Explain : Rey's translate methods.
 """
 
 
 from reytool.rrequest import request
 
 
 def translate_baidu(text: str) -> str:
```

## Comparing `reyworm-0.2.dist-info/RECORD` & `reyworm-0.3.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-reyflask/__init__.py,sha256=ZlMh4Y6YOLrlf-BRgnZddisKTe-sPtwgscK89CvIFA4,238
-reytool/__init__.py,sha256=nMyFwpisErCiiE3tVZeTHUTWOTHZas7CRT3rQZB-o0I,694
-reytool/rbasic.py,sha256=fY2EhRSVS8qDbQW_1qahLm75O8isRmp-i02c7koo2-k,9362
-reytool/rcommon.py,sha256=ME1OU5OMbl956fCyozDcM1Zx4RfnceD9Q1OC5ZPy0L8,8474
-reytool/rcompress.py,sha256=KCEocVuU1YT0amVkR7aL1usCeJkZ0A3ILeaiGw1kWLo,3237
-reytool/rdata.py,sha256=8IIvofWDwC5bxIPTwnthk2JJDmINbF9SQgNtPWx4wmE,10168
-reytool/rdatabase.py,sha256=RUZwRdVQ3k_W3mwTuotRkGFevL-Y6OAbvfWsA0lpG1U,18856
-reytool/rdatetime.py,sha256=C1JUc1jWa6CambeeSkT1EKf5tflf-qcyQmc2bXwSs4M,13294
-reytool/remail.py,sha256=ORlUjTvFyeUYnkt-ossEAF9nvqyIfjaR_8nKviJCI2I,5750
-reytool/rmultitask.py,sha256=5kxit-117mJO8efJMwKuNqTv5dAeOICfL4jCquyDuCU,2917
+reyapi/__init__.py,sha256=oLg8eO0Uj4DES9_kLq8SH2Q-DfoOC40_LgOmI7drIwE,237
+reytool/__init__.py,sha256=DzIuo2bV2TS148INYvzUCiK56oD9alohp92c5XG9Uxo,715
+reytool/rbasic.py,sha256=iETANaSMmXCyb4dkwjidfIahk87m6cSRtzYvpqey45U,9517
+reytool/rcommon.py,sha256=21KWXntOPYWRbq7fb_QZDBgalwFveqGm_tzSXxV0-Qg,8690
+reytool/rcompress.py,sha256=NNJP5sJ4DJM7Is_6liI_9UWm4o9QrImhYucGLxmR90g,3271
+reytool/rdata.py,sha256=QC6Zi-xTveJbrVkbyxzN8QgROIEA1FlUpC64lhpTFUo,11618
+reytool/rdatabase.py,sha256=YLRKDT8qvbSs-bNnsXPmS-gslgSeJXmrd0SvKVUuS0w,22241
+reytool/rdatetime.py,sha256=jnTCFid3-SPt29WeSEutiEsepubEZw04e16oQKxzyVw,16545
+reytool/remail.py,sha256=RC4nEWPrE5jRB_FBiR7h3a73t1tPUIe5FUZKk1z1FTk,6097
+reytool/rmonkey.py,sha256=l4KT3nuxjkDmkkEoRoW8BmK-zNjgXaDx1osrHuZOGQ8,4045
+reytool/rmultitask.py,sha256=Ez7dadQbl7lgYx9E62OXfpGuoCNdGiz2Ul3tL6IqpMg,3054
 reytool/roption.py,sha256=tneCpHg1LWBuIaDdNcWjzuIKsPVDlJ9fuf4dDPQB_p0,786
-reytool/rregular.py,sha256=0adOc63zlbNun_ISPyy92EmdgCvXonVfLTd-vHLyb2g,1963
-reytool/rrequest.py,sha256=hXitfV66e7Ispx61JaQ10Sp0_mr7QiWSOGnkT8ra68A,4974
-reytool/rtext.py,sha256=aK2ubWuBFPh6bgHr8aTUqc0inVQhmeqhluR2BP2Kn9Q,9217
-reytool/rwrap.py,sha256=uI2pcZnuWGrlfIk16MhcS6UEqaT2Y5sB3WulsBUT_Xs,7151
-reyworm/__init__.py,sha256=pF8Z3UPf8KXNLNbBTNG7T30bZSYchvh01tQUAfD3_BE,274
-reyworm/rtranslate.py,sha256=sXWTdurAcOY5WHIJP8qDF5dvy0YUUAN5DQqXQT03xGA,1206
-reyworm-0.2.dist-info/METADATA,sha256=vBkeY69jAZhpikDdYh38LraQamL935V6Aq3X6NVf7pg,201
-reyworm-0.2.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-reyworm-0.2.dist-info/top_level.txt,sha256=i2taGRPTvCu-yWjP649Nh71sw-XUOgjJueDYMsKdceg,8
-reyworm-0.2.dist-info/RECORD,,
+reytool/rregular.py,sha256=T2v_xiAWNOlbBnoO0kK3sO9uxQHqcFUudYSphuK0ob8,2607
+reytool/rrequest.py,sha256=8PCpmxwLD2CQzbgh2bbNPrdPe6ZIawCDGmUNtfhq5pc,5173
+reytool/rtext.py,sha256=60nAKAaTu0sMZ8oqz_QbpX4RXJdh8xsqsA7TkrLCGJI,8813
+reytool/rwrap.py,sha256=Z33X_DlNE_Pcbtrrqm63xS1ajgDGhaZS5UAczs9WFNg,8402
+reyworm/__init__.py,sha256=LgZ-tpXKdOU_x82EAltlxh5r6zP3fa9MeUbZTZm35s8,275
+reyworm/rtranslate.py,sha256=iAb85phTI5lUjri4xop8oAiJuKwRtU8tQHNQEN85N98,1207
+reyworm-0.3.dist-info/METADATA,sha256=-TOkLHfRu6xlAQCQs1lM3xreFp_OZsYtqgzv7grKU2c,202
+reyworm-0.3.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+reyworm-0.3.dist-info/top_level.txt,sha256=i2taGRPTvCu-yWjP649Nh71sw-XUOgjJueDYMsKdceg,8
+reyworm-0.3.dist-info/RECORD,,
```

