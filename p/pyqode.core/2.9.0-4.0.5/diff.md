# Comparing `tmp/pyqode.core-2.9.0-py2.py3-none-any.whl.zip` & `tmp/pyqode.core-4.0.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,102 +1,110 @@
-Zip file size: 436001 bytes, number of entries: 100
--rw-r--r--  2.0 unx      305 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0-py3.5-nspkg.pth
--rw-r--r--  2.0 unx     1929 b- defN 16-Feb-28 13:19 pyqode/core/icons.py
--rw-r--r--  2.0 unx     2496 b- defN 16-Feb-28 13:19 pyqode/core/share.py
--rw-r--r--  2.0 unx     5002 b- defN 16-Apr-19 15:11 pyqode/core/cache.py
--rw-r--r--  2.0 unx      700 b- defN 16-Apr-19 15:11 pyqode/core/__init__.py
--rw-r--r--  2.0 unx     1408 b- defN 16-Feb-28 13:19 pyqode/core/_designer_plugins/__init__.py
--rw-r--r--  2.0 unx      361 b- defN 16-Feb-28 13:19 pyqode/core/_designer_plugins/code_edit_plugin.py
--rw-r--r--  2.0 unx      377 b- defN 16-Feb-28 13:19 pyqode/core/_designer_plugins/errors_table_plugin.py
--rw-r--r--  2.0 unx      405 b- defN 16-Feb-28 13:19 pyqode/core/_designer_plugins/interactive_console_plugin.py
--rw-r--r--  2.0 unx      369 b- defN 16-Feb-28 13:19 pyqode/core/_designer_plugins/tab_widget_plugin.py
--rw-r--r--  2.0 unx      227 b- defN 16-Feb-28 13:19 pyqode/core/_forms/__init__.py
--rw-r--r--  2.0 unx     2976 b- defN 16-Feb-28 13:19 pyqode/core/_forms/dlg_encodings_ui.py
--rw-r--r--  2.0 unx     2762 b- defN 16-Feb-28 13:19 pyqode/core/_forms/dlg_goto_line_ui.py
--rw-r--r--  2.0 unx     6090 b- defN 16-Feb-28 13:19 pyqode/core/_forms/dlg_preferred_encodings_editor_ui.py
--rw-r--r--  2.0 unx     1658 b- defN 16-Feb-28 13:19 pyqode/core/_forms/dlg_unsaved_files_ui.py
--rw-r--r--  2.0 unx     3481 b- defN 16-Feb-28 13:19 pyqode/core/_forms/pnl_encoding_ui.py
--rw-r--r--  2.0 unx     1461 b- defN 16-Feb-28 13:19 pyqode/core/_forms/pnl_read_only_ui.py
--rw-r--r--  2.0 unx     2788 b- defN 16-Feb-28 13:19 pyqode/core/_forms/popup_open_files_ui.py
--rw-r--r--  2.0 unx  1159367 b- defN 16-Feb-28 13:19 pyqode/core/_forms/pyqode_core_rc.py
--rw-r--r--  2.0 unx    11404 b- defN 16-Feb-28 13:19 pyqode/core/_forms/search_panel_ui.py
--rw-r--r--  2.0 unx     1174 b- defN 16-Feb-28 13:19 pyqode/core/api/__init__.py
--rw-r--r--  2.0 unx     5199 b- defN 16-Feb-28 13:19 pyqode/core/api/encodings.py
--rw-r--r--  2.0 unx     1206 b- defN 16-Feb-28 13:19 pyqode/core/api/manager.py
--rw-r--r--  2.0 unx     3662 b- defN 16-Feb-28 13:19 pyqode/core/api/mode.py
--rw-r--r--  2.0 unx     3799 b- defN 16-Feb-28 13:19 pyqode/core/api/panel.py
--rw-r--r--  2.0 unx    13286 b- defN 16-Feb-28 13:19 pyqode/core/api/syntax_highlighter.py
--rw-r--r--  2.0 unx    38429 b- defN 16-Feb-28 13:19 pyqode/core/api/utils.py
--rw-r--r--  2.0 unx     6812 b- defN 16-Apr-14 16:57 pyqode/core/api/decoration.py
--rw-r--r--  2.0 unx    14195 b- defN 16-Apr-14 16:59 pyqode/core/api/client.py
--rw-r--r--  2.0 unx    46372 b- defN 16-Apr-16 11:02 pyqode/core/api/code_edit.py
--rw-r--r--  2.0 unx    13342 b- defN 16-Apr-21 15:43 pyqode/core/api/folding.py
--rw-r--r--  2.0 unx     3868 b- defN 16-Feb-28 13:19 pyqode/core/backend/__init__.py
--rw-r--r--  2.0 unx     8151 b- defN 16-Feb-28 13:19 pyqode/core/backend/workers.py
--rw-r--r--  2.0 unx     7537 b- defN 16-Apr-12 16:21 pyqode/core/backend/server.py
--rw-r--r--  2.0 unx      347 b- defN 16-Feb-28 13:19 pyqode/core/dialogs/__init__.py
--rw-r--r--  2.0 unx     7402 b- defN 16-Feb-28 13:19 pyqode/core/dialogs/encodings.py
--rw-r--r--  2.0 unx     1499 b- defN 16-Feb-28 13:19 pyqode/core/dialogs/goto.py
--rw-r--r--  2.0 unx     2043 b- defN 16-Feb-28 13:19 pyqode/core/dialogs/unsaved_files.py
--rw-r--r--  2.0 unx      827 b- defN 16-Feb-28 13:19 pyqode/core/managers/__init__.py
--rw-r--r--  2.0 unx     8564 b- defN 16-Feb-28 13:19 pyqode/core/managers/backend.py
--rw-r--r--  2.0 unx     2995 b- defN 16-Feb-28 13:19 pyqode/core/managers/modes.py
--rw-r--r--  2.0 unx    11472 b- defN 16-Feb-28 13:19 pyqode/core/managers/panels.py
--rw-r--r--  2.0 unx    15661 b- defN 16-Apr-12 17:25 pyqode/core/managers/file.py
--rw-r--r--  2.0 unx     1766 b- defN 16-Apr-14 16:57 pyqode/core/managers/decorations.py
--rw-r--r--  2.0 unx     1663 b- defN 16-Feb-28 13:19 pyqode/core/modes/__init__.py
--rw-r--r--  2.0 unx     4517 b- defN 16-Feb-28 13:19 pyqode/core/modes/autocomplete.py
--rw-r--r--  2.0 unx     1929 b- defN 16-Feb-28 13:19 pyqode/core/modes/autoindent.py
--rw-r--r--  2.0 unx     1897 b- defN 16-Feb-28 13:19 pyqode/core/modes/backspace.py
--rw-r--r--  2.0 unx     2729 b- defN 16-Feb-28 13:19 pyqode/core/modes/caret_line_highlight.py
--rw-r--r--  2.0 unx     2040 b- defN 16-Feb-28 13:19 pyqode/core/modes/case_converter.py
--rw-r--r--  2.0 unx     2862 b- defN 16-Feb-28 13:19 pyqode/core/modes/cursor_history.py
--rw-r--r--  2.0 unx     6254 b- defN 16-Feb-28 13:19 pyqode/core/modes/extended_selection.py
--rw-r--r--  2.0 unx     7267 b- defN 16-Feb-28 13:19 pyqode/core/modes/filewatcher.py
--rw-r--r--  2.0 unx     6218 b- defN 16-Feb-28 13:19 pyqode/core/modes/indenter.py
--rw-r--r--  2.0 unx     2626 b- defN 16-Feb-28 13:19 pyqode/core/modes/line_highlighter.py
--rw-r--r--  2.0 unx     9836 b- defN 16-Feb-28 13:19 pyqode/core/modes/matcher.py
--rw-r--r--  2.0 unx     6184 b- defN 16-Feb-28 13:19 pyqode/core/modes/occurences.py
--rw-r--r--  2.0 unx     2856 b- defN 16-Feb-28 13:19 pyqode/core/modes/outline.py
--rw-r--r--  2.0 unx     2705 b- defN 16-Feb-28 13:19 pyqode/core/modes/right_margin.py
--rw-r--r--  2.0 unx     3317 b- defN 16-Apr-10 14:33 pyqode/core/modes/zoom.py
--rw-r--r--  2.0 unx    12321 b- defN 16-Apr-14 16:59 pyqode/core/modes/checker.py
--rw-r--r--  2.0 unx    24172 b- defN 16-Apr-14 19:57 pyqode/core/modes/code_completion.py
--rw-r--r--  2.0 unx     4846 b- defN 16-Apr-16 11:19 pyqode/core/modes/wordclick.py
--rw-r--r--  2.0 unx    14333 b- defN 16-Apr-16 18:38 pyqode/core/modes/pygments_sh.py
--rw-r--r--  2.0 unx      621 b- defN 16-Feb-28 13:19 pyqode/core/panels/__init__.py
--rw-r--r--  2.0 unx     4447 b- defN 16-Feb-28 13:19 pyqode/core/panels/checker.py
--rw-r--r--  2.0 unx     3441 b- defN 16-Feb-28 13:19 pyqode/core/panels/global_checker.py
--rw-r--r--  2.0 unx     4208 b- defN 16-Feb-28 13:19 pyqode/core/panels/line_number.py
--rw-r--r--  2.0 unx     8021 b- defN 16-Feb-28 13:19 pyqode/core/panels/marker.py
--rw-r--r--  2.0 unx     2579 b- defN 16-Feb-28 13:19 pyqode/core/panels/read_only.py
--rw-r--r--  2.0 unx     8070 b- defN 16-Apr-10 14:04 pyqode/core/panels/encodings.py
--rw-r--r--  2.0 unx    24067 b- defN 16-Apr-19 15:11 pyqode/core/panels/search_and_replace.py
--rw-r--r--  2.0 unx    32014 b- defN 16-Apr-19 17:14 pyqode/core/panels/folding.py
--rw-r--r--  2.0 unx      290 b- defN 16-Feb-28 13:19 pyqode/core/styles/__init__.py
--rw-r--r--  2.0 unx     2109 b- defN 16-Feb-28 13:19 pyqode/core/styles/darcula.py
--rw-r--r--  2.0 unx     2067 b- defN 16-Feb-28 13:19 pyqode/core/styles/qt.py
--rw-r--r--  2.0 unx      254 b- defN 16-Feb-28 13:19 pyqode/core/tools/__init__.py
--rw-r--r--  2.0 unx     1134 b- defN 16-Feb-28 13:19 pyqode/core/tools/console.py
--rw-r--r--  2.0 unx     2355 b- defN 16-Feb-28 13:19 pyqode/core/widgets/__init__.py
--rw-r--r--  2.0 unx     6785 b- defN 16-Feb-28 13:19 pyqode/core/widgets/code_edits.py
--rw-r--r--  2.0 unx     7287 b- defN 16-Feb-28 13:19 pyqode/core/widgets/encodings.py
--rw-r--r--  2.0 unx     5822 b- defN 16-Feb-28 13:19 pyqode/core/widgets/errors_table.py
--rw-r--r--  2.0 unx     2011 b- defN 16-Feb-28 13:19 pyqode/core/widgets/file_icons_provider.py
--rw-r--r--  2.0 unx     9676 b- defN 16-Feb-28 13:19 pyqode/core/widgets/outline.py
--rw-r--r--  2.0 unx     1934 b- defN 16-Feb-28 13:19 pyqode/core/widgets/preview.py
--rw-r--r--  2.0 unx     4093 b- defN 16-Feb-28 13:19 pyqode/core/widgets/prompt_line_edit.py
--rw-r--r--  2.0 unx      961 b- defN 16-Feb-28 13:19 pyqode/core/widgets/tab_bar.py
--rw-r--r--  2.0 unx    16303 b- defN 16-Feb-28 13:19 pyqode/core/widgets/tabs.py
--rw-r--r--  2.0 unx    30138 b- defN 16-Apr-10 14:56 pyqode/core/widgets/filesystem_treeview.py
--rw-r--r--  2.0 unx    15410 b- defN 16-Apr-10 14:15 pyqode/core/widgets/interactive.py
--rw-r--r--  2.0 unx     6960 b- defN 16-Apr-10 14:42 pyqode/core/widgets/menu_recents.py
--rw-r--r--  2.0 unx    59828 b- defN 16-Apr-21 15:43 pyqode/core/widgets/splittable_tab_widget.py
--rw-r--r--  2.0 unx     3049 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/DESCRIPTION.rst
--rw-r--r--  2.0 unx      231 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx     1703 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/metadata.json
--rw-r--r--  2.0 unx        7 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/namespace_packages.txt
--rw-r--r--  2.0 unx        7 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/top_level.txt
--rw-r--r--  2.0 unx      110 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/WHEEL
--rw-r--r--  2.0 unx     4184 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/METADATA
--rw-r--r--  2.0 unx     9077 b- defN 16-Apr-21 16:49 pyqode.core-2.9.0.dist-info/RECORD
-100 files, 1826999 bytes uncompressed, 421715 bytes compressed:  76.9%
+Zip file size: 472638 bytes, number of entries: 108
+-rw-r--r--  2.0 unx      701 b- defN 23-Apr-18 13:32 pyqode/core/__init__.py
+-rw-r--r--  2.0 unx     5990 b- defN 23-Apr-18 13:32 pyqode/core/cache.py
+-rw-r--r--  2.0 unx     2095 b- defN 23-Apr-18 13:32 pyqode/core/icons.py
+-rw-r--r--  2.0 unx     2496 b- defN 23-Apr-18 13:32 pyqode/core/share.py
+-rw-r--r--  2.0 unx     1402 b- defN 23-Apr-18 13:32 pyqode/core/_designer_plugins/__init__.py
+-rw-r--r--  2.0 unx      361 b- defN 23-Apr-18 13:32 pyqode/core/_designer_plugins/code_edit_plugin.py
+-rw-r--r--  2.0 unx      377 b- defN 23-Apr-18 13:32 pyqode/core/_designer_plugins/errors_table_plugin.py
+-rw-r--r--  2.0 unx      405 b- defN 23-Apr-18 13:32 pyqode/core/_designer_plugins/interactive_console_plugin.py
+-rw-r--r--  2.0 unx      369 b- defN 23-Apr-18 13:32 pyqode/core/_designer_plugins/tab_widget_plugin.py
+-rw-r--r--  2.0 unx      227 b- defN 23-Apr-18 13:32 pyqode/core/_forms/__init__.py
+-rw-r--r--  2.0 unx     2971 b- defN 23-Apr-18 13:32 pyqode/core/_forms/dlg_encodings_ui.py
+-rw-r--r--  2.0 unx     2756 b- defN 23-Apr-18 13:32 pyqode/core/_forms/dlg_goto_line_ui.py
+-rw-r--r--  2.0 unx     6085 b- defN 23-Apr-18 13:32 pyqode/core/_forms/dlg_preferred_encodings_editor_ui.py
+-rw-r--r--  2.0 unx     1652 b- defN 23-Apr-18 13:32 pyqode/core/_forms/dlg_unsaved_files_ui.py
+-rw-r--r--  2.0 unx     3476 b- defN 23-Apr-18 13:32 pyqode/core/_forms/pnl_encoding_ui.py
+-rw-r--r--  2.0 unx     1455 b- defN 23-Apr-18 13:32 pyqode/core/_forms/pnl_read_only_ui.py
+-rw-r--r--  2.0 unx     2782 b- defN 23-Apr-18 13:32 pyqode/core/_forms/popup_open_files_ui.py
+-rw-r--r--  2.0 unx  1159362 b- defN 23-Apr-18 13:32 pyqode/core/_forms/pyqode_core_rc.py
+-rw-r--r--  2.0 unx    11399 b- defN 23-Apr-18 13:32 pyqode/core/_forms/search_panel_ui.py
+-rw-r--r--  2.0 unx     1174 b- defN 23-Apr-18 13:32 pyqode/core/api/__init__.py
+-rw-r--r--  2.0 unx    14552 b- defN 23-Apr-18 13:32 pyqode/core/api/client.py
+-rw-r--r--  2.0 unx    53733 b- defN 23-Apr-18 13:32 pyqode/core/api/code_edit.py
+-rw-r--r--  2.0 unx     9308 b- defN 23-Apr-18 13:32 pyqode/core/api/decoration.py
+-rw-r--r--  2.0 unx     5199 b- defN 23-Apr-18 13:32 pyqode/core/api/encodings.py
+-rw-r--r--  2.0 unx    13923 b- defN 23-Apr-18 13:32 pyqode/core/api/folding.py
+-rw-r--r--  2.0 unx     1206 b- defN 23-Apr-18 13:32 pyqode/core/api/manager.py
+-rw-r--r--  2.0 unx     3662 b- defN 23-Apr-18 13:32 pyqode/core/api/mode.py
+-rw-r--r--  2.0 unx     5657 b- defN 23-Apr-18 13:32 pyqode/core/api/panel.py
+-rw-r--r--  2.0 unx    14003 b- defN 23-Apr-18 13:32 pyqode/core/api/syntax_highlighter.py
+-rw-r--r--  2.0 unx    41668 b- defN 23-Apr-18 13:32 pyqode/core/api/utils.py
+-rw-r--r--  2.0 unx     3868 b- defN 23-Apr-18 13:32 pyqode/core/backend/__init__.py
+-rw-r--r--  2.0 unx     7535 b- defN 23-Apr-18 13:32 pyqode/core/backend/server.py
+-rw-r--r--  2.0 unx     9895 b- defN 23-Apr-18 13:32 pyqode/core/backend/workers.py
+-rw-r--r--  2.0 unx      347 b- defN 23-Apr-18 13:32 pyqode/core/dialogs/__init__.py
+-rw-r--r--  2.0 unx     7396 b- defN 23-Apr-18 13:32 pyqode/core/dialogs/encodings.py
+-rw-r--r--  2.0 unx     1493 b- defN 23-Apr-18 13:32 pyqode/core/dialogs/goto.py
+-rw-r--r--  2.0 unx     2032 b- defN 23-Apr-18 13:32 pyqode/core/dialogs/unsaved_files.py
+-rw-r--r--  2.0 unx      827 b- defN 23-Apr-18 13:32 pyqode/core/managers/__init__.py
+-rw-r--r--  2.0 unx    12934 b- defN 23-Apr-18 13:32 pyqode/core/managers/backend.py
+-rw-r--r--  2.0 unx     2651 b- defN 23-Apr-18 13:32 pyqode/core/managers/decorations.py
+-rw-r--r--  2.0 unx    15486 b- defN 23-Apr-18 13:32 pyqode/core/managers/file.py
+-rw-r--r--  2.0 unx     2249 b- defN 23-Apr-18 13:32 pyqode/core/managers/modes.py
+-rw-r--r--  2.0 unx    10670 b- defN 23-Apr-18 13:32 pyqode/core/managers/panels.py
+-rw-r--r--  2.0 unx     2033 b- defN 23-Apr-18 13:32 pyqode/core/modes/__init__.py
+-rw-r--r--  2.0 unx     4924 b- defN 23-Apr-18 13:32 pyqode/core/modes/autocomplete.py
+-rw-r--r--  2.0 unx     2240 b- defN 23-Apr-18 13:32 pyqode/core/modes/autoindent.py
+-rw-r--r--  2.0 unx     9277 b- defN 23-Apr-18 13:32 pyqode/core/modes/backspace.py
+-rw-r--r--  2.0 unx     3062 b- defN 23-Apr-18 13:32 pyqode/core/modes/breakpoint.py
+-rw-r--r--  2.0 unx     5690 b- defN 23-Apr-18 13:32 pyqode/core/modes/calltips.py
+-rw-r--r--  2.0 unx     2723 b- defN 23-Apr-18 13:32 pyqode/core/modes/caret_line_highlight.py
+-rw-r--r--  2.0 unx     1996 b- defN 23-Apr-18 13:32 pyqode/core/modes/case_converter.py
+-rw-r--r--  2.0 unx    14809 b- defN 23-Apr-18 13:32 pyqode/core/modes/checker.py
+-rw-r--r--  2.0 unx    27374 b- defN 23-Apr-18 13:32 pyqode/core/modes/code_completion.py
+-rw-r--r--  2.0 unx     6068 b- defN 23-Apr-18 13:32 pyqode/core/modes/comments.py
+-rw-r--r--  2.0 unx     2976 b- defN 23-Apr-18 13:32 pyqode/core/modes/cursor_history.py
+-rw-r--r--  2.0 unx     7594 b- defN 23-Apr-18 13:32 pyqode/core/modes/extended_selection.py
+-rw-r--r--  2.0 unx     7520 b- defN 23-Apr-18 13:32 pyqode/core/modes/filewatcher.py
+-rw-r--r--  2.0 unx     1709 b- defN 23-Apr-18 13:32 pyqode/core/modes/image_annotations.py
+-rw-r--r--  2.0 unx     7151 b- defN 23-Apr-18 13:32 pyqode/core/modes/indenter.py
+-rw-r--r--  2.0 unx     2620 b- defN 23-Apr-18 13:32 pyqode/core/modes/line_highlighter.py
+-rw-r--r--  2.0 unx     1927 b- defN 23-Apr-18 13:32 pyqode/core/modes/line_sorter.py
+-rw-r--r--  2.0 unx    10408 b- defN 23-Apr-18 13:32 pyqode/core/modes/matcher.py
+-rw-r--r--  2.0 unx     6447 b- defN 23-Apr-18 13:32 pyqode/core/modes/occurences.py
+-rw-r--r--  2.0 unx     2850 b- defN 23-Apr-18 13:32 pyqode/core/modes/outline.py
+-rw-r--r--  2.0 unx    14766 b- defN 23-Apr-18 13:32 pyqode/core/modes/pygments_sh.py
+-rw-r--r--  2.0 unx     2712 b- defN 23-Apr-18 13:32 pyqode/core/modes/right_margin.py
+-rw-r--r--  2.0 unx     1832 b- defN 23-Apr-18 13:32 pyqode/core/modes/spellchecker_mode.py
+-rw-r--r--  2.0 unx     4840 b- defN 23-Apr-18 13:32 pyqode/core/modes/wordclick.py
+-rw-r--r--  2.0 unx     3039 b- defN 23-Apr-18 13:32 pyqode/core/modes/zoom.py
+-rw-r--r--  2.0 unx      833 b- defN 23-Apr-18 13:32 pyqode/core/panels/__init__.py
+-rw-r--r--  2.0 unx     3566 b- defN 23-Apr-18 13:32 pyqode/core/panels/change_extension.py
+-rw-r--r--  2.0 unx     5771 b- defN 23-Apr-18 13:32 pyqode/core/panels/checker.py
+-rw-r--r--  2.0 unx     7939 b- defN 23-Apr-18 13:32 pyqode/core/panels/encodings.py
+-rw-r--r--  2.0 unx    30707 b- defN 23-Apr-18 13:32 pyqode/core/panels/folding.py
+-rw-r--r--  2.0 unx     3361 b- defN 23-Apr-18 13:32 pyqode/core/panels/global_checker.py
+-rw-r--r--  2.0 unx     1756 b- defN 23-Apr-18 13:32 pyqode/core/panels/image_annotations.py
+-rw-r--r--  2.0 unx     4233 b- defN 23-Apr-18 13:32 pyqode/core/panels/line_number.py
+-rw-r--r--  2.0 unx     1782 b- defN 23-Apr-18 13:32 pyqode/core/panels/margin.py
+-rw-r--r--  2.0 unx     8015 b- defN 23-Apr-18 13:32 pyqode/core/panels/marker.py
+-rw-r--r--  2.0 unx     2299 b- defN 23-Apr-18 13:32 pyqode/core/panels/read_only.py
+-rw-r--r--  2.0 unx    25998 b- defN 23-Apr-18 13:32 pyqode/core/panels/search_and_replace.py
+-rw-r--r--  2.0 unx      290 b- defN 23-Apr-18 13:32 pyqode/core/styles/__init__.py
+-rw-r--r--  2.0 unx     2109 b- defN 23-Apr-18 13:32 pyqode/core/styles/darcula.py
+-rw-r--r--  2.0 unx     2067 b- defN 23-Apr-18 13:32 pyqode/core/styles/qt.py
+-rw-r--r--  2.0 unx      254 b- defN 23-Apr-18 13:32 pyqode/core/tools/__init__.py
+-rw-r--r--  2.0 unx     1134 b- defN 23-Apr-18 13:32 pyqode/core/tools/console.py
+-rw-r--r--  2.0 unx     2515 b- defN 23-Apr-18 13:32 pyqode/core/widgets/__init__.py
+-rw-r--r--  2.0 unx     5160 b- defN 23-Apr-18 13:32 pyqode/core/widgets/_pty.py
+-rw-r--r--  2.0 unx     6785 b- defN 23-Apr-18 13:32 pyqode/core/widgets/code_edits.py
+-rw-r--r--  2.0 unx     7301 b- defN 23-Apr-18 13:32 pyqode/core/widgets/encodings.py
+-rw-r--r--  2.0 unx     5816 b- defN 23-Apr-18 13:32 pyqode/core/widgets/errors_table.py
+-rw-r--r--  2.0 unx     2005 b- defN 23-Apr-18 13:32 pyqode/core/widgets/file_icons_provider.py
+-rw-r--r--  2.0 unx    30870 b- defN 23-Apr-18 13:32 pyqode/core/widgets/filesystem_treeview.py
+-rw-r--r--  2.0 unx    15526 b- defN 23-Apr-18 13:32 pyqode/core/widgets/interactive.py
+-rw-r--r--  2.0 unx     6954 b- defN 23-Apr-18 13:32 pyqode/core/widgets/menu_recents.py
+-rw-r--r--  2.0 unx     9670 b- defN 23-Apr-18 13:32 pyqode/core/widgets/outline.py
+-rw-r--r--  2.0 unx    56914 b- defN 23-Apr-18 13:32 pyqode/core/widgets/output_window.py
+-rw-r--r--  2.0 unx     1928 b- defN 23-Apr-18 13:32 pyqode/core/widgets/preview.py
+-rw-r--r--  2.0 unx     3432 b- defN 23-Apr-18 13:32 pyqode/core/widgets/prompt_line_edit.py
+-rw-r--r--  2.0 unx      476 b- defN 23-Apr-18 13:32 pyqode/core/widgets/pty_wrapper.py
+-rw-r--r--  2.0 unx    73573 b- defN 23-Apr-18 13:32 pyqode/core/widgets/splittable_tab_widget.py
+-rw-r--r--  2.0 unx      955 b- defN 23-Apr-18 13:32 pyqode/core/widgets/tab_bar.py
+-rw-r--r--  2.0 unx    16197 b- defN 23-Apr-18 13:32 pyqode/core/widgets/tabs.py
+-rw-r--r--  2.0 unx     2329 b- defN 23-Apr-18 13:32 pyqode/core/widgets/terminal.py
+-rw-r--r--  2.0 unx     1119 b- defN 23-Apr-18 13:32 pyqode_core-4.0.5.dist-info/LICENSE
+?rw-r--r--  2.0 unx       81 b- defN 16-Jan-01 00:00 pyqode_core-4.0.5.dist-info/WHEEL
+?rw-r--r--  2.0 unx     1476 b- defN 16-Jan-01 00:00 pyqode_core-4.0.5.dist-info/METADATA
+?rw-r--r--  2.0 unx     9655 b- defN 16-Jan-01 00:00 pyqode_core-4.0.5.dist-info/RECORD
+108 files, 1969267 bytes uncompressed, 457318 bytes compressed:  76.8%
```

## zipnote {}

```diff
@@ -1,20 +1,17 @@
-Filename: pyqode.core-2.9.0-py3.5-nspkg.pth
-Comment: 
-
-Filename: pyqode/core/icons.py
+Filename: pyqode/core/__init__.py
 Comment: 
 
-Filename: pyqode/core/share.py
+Filename: pyqode/core/cache.py
 Comment: 
 
-Filename: pyqode/core/cache.py
+Filename: pyqode/core/icons.py
 Comment: 
 
-Filename: pyqode/core/__init__.py
+Filename: pyqode/core/share.py
 Comment: 
 
 Filename: pyqode/core/_designer_plugins/__init__.py
 Comment: 
 
 Filename: pyqode/core/_designer_plugins/code_edit_plugin.py
 Comment: 
@@ -57,51 +54,51 @@
 
 Filename: pyqode/core/_forms/search_panel_ui.py
 Comment: 
 
 Filename: pyqode/core/api/__init__.py
 Comment: 
 
-Filename: pyqode/core/api/encodings.py
+Filename: pyqode/core/api/client.py
 Comment: 
 
-Filename: pyqode/core/api/manager.py
+Filename: pyqode/core/api/code_edit.py
 Comment: 
 
-Filename: pyqode/core/api/mode.py
+Filename: pyqode/core/api/decoration.py
 Comment: 
 
-Filename: pyqode/core/api/panel.py
+Filename: pyqode/core/api/encodings.py
 Comment: 
 
-Filename: pyqode/core/api/syntax_highlighter.py
+Filename: pyqode/core/api/folding.py
 Comment: 
 
-Filename: pyqode/core/api/utils.py
+Filename: pyqode/core/api/manager.py
 Comment: 
 
-Filename: pyqode/core/api/decoration.py
+Filename: pyqode/core/api/mode.py
 Comment: 
 
-Filename: pyqode/core/api/client.py
+Filename: pyqode/core/api/panel.py
 Comment: 
 
-Filename: pyqode/core/api/code_edit.py
+Filename: pyqode/core/api/syntax_highlighter.py
 Comment: 
 
-Filename: pyqode/core/api/folding.py
+Filename: pyqode/core/api/utils.py
 Comment: 
 
 Filename: pyqode/core/backend/__init__.py
 Comment: 
 
-Filename: pyqode/core/backend/workers.py
+Filename: pyqode/core/backend/server.py
 Comment: 
 
-Filename: pyqode/core/backend/server.py
+Filename: pyqode/core/backend/workers.py
 Comment: 
 
 Filename: pyqode/core/dialogs/__init__.py
 Comment: 
 
 Filename: pyqode/core/dialogs/encodings.py
 Comment: 
@@ -114,111 +111,138 @@
 
 Filename: pyqode/core/managers/__init__.py
 Comment: 
 
 Filename: pyqode/core/managers/backend.py
 Comment: 
 
-Filename: pyqode/core/managers/modes.py
+Filename: pyqode/core/managers/decorations.py
 Comment: 
 
-Filename: pyqode/core/managers/panels.py
+Filename: pyqode/core/managers/file.py
 Comment: 
 
-Filename: pyqode/core/managers/file.py
+Filename: pyqode/core/managers/modes.py
 Comment: 
 
-Filename: pyqode/core/managers/decorations.py
+Filename: pyqode/core/managers/panels.py
 Comment: 
 
 Filename: pyqode/core/modes/__init__.py
 Comment: 
 
 Filename: pyqode/core/modes/autocomplete.py
 Comment: 
 
 Filename: pyqode/core/modes/autoindent.py
 Comment: 
 
 Filename: pyqode/core/modes/backspace.py
 Comment: 
 
+Filename: pyqode/core/modes/breakpoint.py
+Comment: 
+
+Filename: pyqode/core/modes/calltips.py
+Comment: 
+
 Filename: pyqode/core/modes/caret_line_highlight.py
 Comment: 
 
 Filename: pyqode/core/modes/case_converter.py
 Comment: 
 
+Filename: pyqode/core/modes/checker.py
+Comment: 
+
+Filename: pyqode/core/modes/code_completion.py
+Comment: 
+
+Filename: pyqode/core/modes/comments.py
+Comment: 
+
 Filename: pyqode/core/modes/cursor_history.py
 Comment: 
 
 Filename: pyqode/core/modes/extended_selection.py
 Comment: 
 
 Filename: pyqode/core/modes/filewatcher.py
 Comment: 
 
+Filename: pyqode/core/modes/image_annotations.py
+Comment: 
+
 Filename: pyqode/core/modes/indenter.py
 Comment: 
 
 Filename: pyqode/core/modes/line_highlighter.py
 Comment: 
 
+Filename: pyqode/core/modes/line_sorter.py
+Comment: 
+
 Filename: pyqode/core/modes/matcher.py
 Comment: 
 
 Filename: pyqode/core/modes/occurences.py
 Comment: 
 
 Filename: pyqode/core/modes/outline.py
 Comment: 
 
-Filename: pyqode/core/modes/right_margin.py
-Comment: 
-
-Filename: pyqode/core/modes/zoom.py
+Filename: pyqode/core/modes/pygments_sh.py
 Comment: 
 
-Filename: pyqode/core/modes/checker.py
+Filename: pyqode/core/modes/right_margin.py
 Comment: 
 
-Filename: pyqode/core/modes/code_completion.py
+Filename: pyqode/core/modes/spellchecker_mode.py
 Comment: 
 
 Filename: pyqode/core/modes/wordclick.py
 Comment: 
 
-Filename: pyqode/core/modes/pygments_sh.py
+Filename: pyqode/core/modes/zoom.py
 Comment: 
 
 Filename: pyqode/core/panels/__init__.py
 Comment: 
 
+Filename: pyqode/core/panels/change_extension.py
+Comment: 
+
 Filename: pyqode/core/panels/checker.py
 Comment: 
 
+Filename: pyqode/core/panels/encodings.py
+Comment: 
+
+Filename: pyqode/core/panels/folding.py
+Comment: 
+
 Filename: pyqode/core/panels/global_checker.py
 Comment: 
 
-Filename: pyqode/core/panels/line_number.py
+Filename: pyqode/core/panels/image_annotations.py
 Comment: 
 
-Filename: pyqode/core/panels/marker.py
+Filename: pyqode/core/panels/line_number.py
 Comment: 
 
-Filename: pyqode/core/panels/read_only.py
+Filename: pyqode/core/panels/margin.py
 Comment: 
 
-Filename: pyqode/core/panels/encodings.py
+Filename: pyqode/core/panels/marker.py
 Comment: 
 
-Filename: pyqode/core/panels/search_and_replace.py
+Filename: pyqode/core/panels/read_only.py
 Comment: 
 
-Filename: pyqode/core/panels/folding.py
+Filename: pyqode/core/panels/search_and_replace.py
 Comment: 
 
 Filename: pyqode/core/styles/__init__.py
 Comment: 
 
 Filename: pyqode/core/styles/darcula.py
 Comment: 
@@ -231,71 +255,71 @@
 
 Filename: pyqode/core/tools/console.py
 Comment: 
 
 Filename: pyqode/core/widgets/__init__.py
 Comment: 
 
+Filename: pyqode/core/widgets/_pty.py
+Comment: 
+
 Filename: pyqode/core/widgets/code_edits.py
 Comment: 
 
 Filename: pyqode/core/widgets/encodings.py
 Comment: 
 
 Filename: pyqode/core/widgets/errors_table.py
 Comment: 
 
 Filename: pyqode/core/widgets/file_icons_provider.py
 Comment: 
 
-Filename: pyqode/core/widgets/outline.py
+Filename: pyqode/core/widgets/filesystem_treeview.py
 Comment: 
 
-Filename: pyqode/core/widgets/preview.py
+Filename: pyqode/core/widgets/interactive.py
 Comment: 
 
-Filename: pyqode/core/widgets/prompt_line_edit.py
+Filename: pyqode/core/widgets/menu_recents.py
 Comment: 
 
-Filename: pyqode/core/widgets/tab_bar.py
+Filename: pyqode/core/widgets/outline.py
 Comment: 
 
-Filename: pyqode/core/widgets/tabs.py
+Filename: pyqode/core/widgets/output_window.py
 Comment: 
 
-Filename: pyqode/core/widgets/filesystem_treeview.py
+Filename: pyqode/core/widgets/preview.py
 Comment: 
 
-Filename: pyqode/core/widgets/interactive.py
+Filename: pyqode/core/widgets/prompt_line_edit.py
 Comment: 
 
-Filename: pyqode/core/widgets/menu_recents.py
+Filename: pyqode/core/widgets/pty_wrapper.py
 Comment: 
 
 Filename: pyqode/core/widgets/splittable_tab_widget.py
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/DESCRIPTION.rst
-Comment: 
-
-Filename: pyqode.core-2.9.0.dist-info/entry_points.txt
+Filename: pyqode/core/widgets/tab_bar.py
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/metadata.json
+Filename: pyqode/core/widgets/tabs.py
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/namespace_packages.txt
+Filename: pyqode/core/widgets/terminal.py
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/top_level.txt
+Filename: pyqode_core-4.0.5.dist-info/LICENSE
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/WHEEL
+Filename: pyqode_core-4.0.5.dist-info/WHEEL
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/METADATA
+Filename: pyqode_core-4.0.5.dist-info/METADATA
 Comment: 
 
-Filename: pyqode.core-2.9.0.dist-info/RECORD
+Filename: pyqode_core-4.0.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyqode/core/icons.py

```diff
@@ -4,29 +4,32 @@
     - icon from theme (linux only)
     - icon from qrc
     - icon from qtawesome
 
 qtawesome is an optional dependency, it is disabled by default.
 If your application use qtawesome, just set ``USE_QTAWESOME`` to True.
 """
-from pyqode.qt import QtGui
+from qtpy import QtGui
 try:
     import qtawesome as qta
 except ImportError:
     qta = None
 
 #: This flag controls qtawesome icons should be preferred to theme/qrc icons.
 USE_QTAWESOME = False
 
 #: Default options used for rendering an icon from qtawesome.
 #: Options cannot be changed after the icon has been rendered so make sure
 #: to setup those options at startup (i.e. before you create any icon).
 QTA_OPTIONS = {
     'color': '',
-    'color_disabled': ''
+    'color_disabled': '',
+    'color_info': '#4040DD',
+    'color_warning': '#DDDD40',
+    'color_error': '#DD4040'
 }
 
 
 def icon(theme_name='', path='', qta_name='', qta_options=None, use_qta=None):
     """
     Creates an icon from qtawesome, from theme or from path.
 
@@ -50,8 +53,10 @@
     else:
         if theme_name and path:
             ret_val = QtGui.QIcon.fromTheme(theme_name, QtGui.QIcon(path))
         elif theme_name:
             ret_val = QtGui.QIcon.fromTheme(theme_name)
         elif path:
             ret_val = QtGui.QIcon(path)
-    return ret_val
+    if ret_val is None:
+        ret_val = QtGui.QIcon.fromTheme('image-missing')
+    return ret_val
```

## pyqode/core/cache.py

```diff
@@ -16,15 +16,15 @@
 We do not store editor styles and settings here. Those kind of settings are
 better handled at the application level.
 
 """
 import json
 import locale
 import logging
-from pyqode.qt import QtCore
+from qtpy import QtCore
 
 try:
     from future.builtins import open
     from future.builtins import str
 except:
     pass  # python 3.2 not supported
 
@@ -134,22 +134,53 @@
             # changed in pyqode 2.6.3, now we store the cursor position
             # instead of the line and column  (faster)
             pos = 0
         return pos
 
     def set_cursor_position(self, path, position):
         """
-        Cache encoding for the specified file path.
+        Cache cursor position for the specified file path.
 
         :param path: path of the file to cache
         :param position: cursor position to cache
         """
         try:
             map = json.loads(self._settings.value('cachedCursorPosition'))
         except TypeError:
             map = {}
         map[path] = position
         self._settings.setValue('cachedCursorPosition', json.dumps(map))
+        
+    def get_color(self, file_path):
+        """
+        Gets the color for file_path. This color is shown in the tab bar.
+
+        :param file_path: path of the file in the cache
+        :return: Cached color or None
+        """
+        try:
+            colors = json.loads(self._settings.value('cachedColor'))
+        except TypeError:
+            colors = {}
+        return colors.get(file_path, None)
+
+    def set_color(self, path, color):
+        """
+        Cache the color for the specified file path.
+
+        :param path: path of the file to cache
+        :param color: color to cache. If None, then the color is cleared.
+        """
+        try:
+            colors = json.loads(self._settings.value('cachedColor'))
+        except TypeError:
+            colors = {}
+        if color is None:
+            if path in colors:
+                del colors[path]
+        else:
+            colors[path] = color
+        self._settings.setValue('cachedColor', json.dumps(colors))
 
 
 def _logger():
-    return logging.getLogger(__name__)
+    return logging.getLogger(__name__)
```

## pyqode/core/__init__.py

```diff
@@ -6,20 +6,21 @@
 It contains the base classes for both the backend and the frontend and provides
 a series of modes and panels that might be useful for any kind of code editor
 widget, i.e. pyqode.core is a generic code editor widget.
 """
 import logging
 
 
-__version__ = '2.9.0'
+__version__ = '4.0.5'
 
 
 logging.addLevelName(1, "PYQODEDEBUGCOMM")
 logging.addLevelName(5, "PYQODEDEBUG")
 
+
 try:
     # check if application code is using gettext
     _('')
 except NameError:
     # install a null translation
     import gettext
     gettext.NullTranslations().install()
```

## pyqode/core/_designer_plugins/__init__.py

```diff
@@ -1,11 +1,11 @@
 """
 This packages contains the various qt designer plugins
 """
-from pyqode.qt import QtDesigner
+from qtpy import QtDesigner
 
 
 class WidgetPlugin(QtDesigner.QPyDesignerCustomWidgetPlugin):
     """
     Base class for writing a designer plugins.
 
     To write a plugin, inherit from this class and define implement at least:
@@ -55,8 +55,8 @@
     def toolTip(self):
         return ''
 
     def whatsThis(self):
         return ''
 
     def createWidget(self, parent):
-        return self.klass()(parent)
+        return self.klass()(parent)
```

## pyqode/core/_forms/dlg_encodings_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/dlg_encodings.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Dialog(object):
     def setupUi(self, Dialog):
         Dialog.setObjectName("Dialog")
         Dialog.resize(614, 160)
         self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
         self.verticalLayout.setObjectName("verticalLayout")
```

## pyqode/core/_forms/dlg_goto_line_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/dlg_goto_line.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Dialog(object):
     def setupUi(self, Dialog):
         Dialog.setObjectName("Dialog")
         Dialog.resize(277, 126)
         self.gridLayout = QtWidgets.QGridLayout(Dialog)
         self.gridLayout.setObjectName("gridLayout")
@@ -50,8 +50,8 @@
     def retranslateUi(self, Dialog):
 
         Dialog.setWindowTitle(_("Go to line"))
         self.label.setText(_("You are here:"))
         self.lblCurrentLine.setText(_("1"))
         self.label_3.setText(_("You want to go:"))
         self.label_4.setText(_("You can\'t go further than:"))
-        self.lblLineCount.setText(_("1"))
+        self.lblLineCount.setText(_("1"))
```

## pyqode/core/_forms/dlg_preferred_encodings_editor_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/dlg_preferred_encodings_editor.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Dialog(object):
     def setupUi(self, Dialog):
         Dialog.setObjectName("Dialog")
         Dialog.resize(827, 600)
         Dialog.setMinimumSize(QtCore.QSize(700, 600))
         self.verticalLayout_2 = QtWidgets.QVBoxLayout(Dialog)
```

## pyqode/core/_forms/dlg_unsaved_files_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/dlg_unsaved_files.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Dialog(object):
     def setupUi(self, Dialog):
         Dialog.setObjectName("Dialog")
         Dialog.resize(717, 301)
         self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
         self.verticalLayout.setObjectName("verticalLayout")
@@ -31,8 +31,8 @@
         self.buttonBox.accepted.connect(Dialog.accept)
         self.buttonBox.rejected.connect(Dialog.reject)
         QtCore.QMetaObject.connectSlotsByName(Dialog)
 
     def retranslateUi(self, Dialog):
 
         Dialog.setWindowTitle(_("Dialog"))
-        self.label.setText(_("The following files have unsaved changes:"))
+        self.label.setText(_("The following files have unsaved changes:"))
```

## pyqode/core/_forms/pnl_encoding_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/pnl_encoding.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Form(object):
     def setupUi(self, Form):
         Form.setObjectName("Form")
         Form.resize(964, 169)
         self.horizontalLayout_2 = QtWidgets.QHBoxLayout(Form)
         self.horizontalLayout_2.setObjectName("horizontalLayout_2")
```

## pyqode/core/_forms/pnl_read_only_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/pnl_read_only.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Form(object):
     def setupUi(self, Form):
         Form.setObjectName("Form")
         Form.resize(964, 67)
         self.horizontalLayout_2 = QtWidgets.QHBoxLayout(Form)
         self.horizontalLayout_2.setObjectName("horizontalLayout_2")
@@ -26,8 +26,8 @@
 
         self.retranslateUi(Form)
         QtCore.QMetaObject.connectSlotsByName(Form)
 
     def retranslateUi(self, Form):
 
         Form.setWindowTitle(_("Form"))
-        self.lblDescription.setText(_("<html><head/><body><p>The file you opened is read-only.</p><p>Use &quot;save as&quot; or change the file\'s permission to edit the document...</p></body></html>"))
+        self.lblDescription.setText(_("<html><head/><body><p>The file you opened is read-only.</p><p>Use &quot;save as&quot; or change the file\'s permission to edit the document...</p></body></html>"))
```

## pyqode/core/_forms/popup_open_files_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/popup_open_files.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_Dialog(object):
     def setupUi(self, Dialog):
         Dialog.setObjectName("Dialog")
         Dialog.resize(640, 320)
         self.gridLayout = QtWidgets.QGridLayout(Dialog)
         self.gridLayout.setContentsMargins(0, 0, 0, 0)
@@ -52,8 +52,8 @@
 
         Dialog.setWindowTitle(_("Dialog"))
         self.groupBox.setTitle(_("Open files"))
         self.checkBox.setText(_("Sort alphabetically"))
         item = self.tableWidget.horizontalHeaderItem(0)
         item.setText(_("Filename"))
         item = self.tableWidget.horizontalHeaderItem(1)
-        item.setText(_("Path"))
+        item.setText(_("Path"))
```

## pyqode/core/_forms/pyqode_core_rc.py

```diff
@@ -2,15 +2,15 @@
 
 # Resource object code
 #
 # Created by: The Resource Compiler for PyQt5 (Qt v5.5.1)
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore
+from qtpy import QtCore
 
 qt_resource_data = b"\
 \x00\x00\x05\x35\
 \x89\
 \x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
 \x00\x00\x20\x00\x00\x00\x20\x08\x06\x00\x00\x00\x73\x7a\x7a\xf4\
 \x00\x00\x00\x20\x63\x48\x52\x4d\x00\x00\x7a\x26\x00\x00\x80\x84\
```

## pyqode/core/_forms/search_panel_ui.py

```diff
@@ -2,15 +2,15 @@
 
 # Form implementation generated from reading ui file '/home/colin/dev/pyQode/pyqode.core/forms/search_panel.ui'
 #
 # Created by: PyQt5 UI code generator 5.5.1
 #
 # WARNING! All changes made in this file will be lost!
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 class Ui_SearchPanel(object):
     def setupUi(self, SearchPanel):
         SearchPanel.setObjectName("SearchPanel")
         SearchPanel.resize(884, 90)
         SearchPanel.setStyleSheet("")
         self.verticalLayout = QtWidgets.QVBoxLayout(SearchPanel)
```

## pyqode/core/api/panel.py

```diff
@@ -1,13 +1,13 @@
 """
 This module contains the panel API.
 """
 import logging
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtWidgets, QtGui
+from qtpy import QtWidgets, QtGui
 
 
 def _logger():
     """ Returns module's logger """
     return logging.getLogger(__name__)
 
 
@@ -16,14 +16,17 @@
     Base class for editor panels.
 
     A panel is a mode and a QWidget.
 
     .. note:: Use enabled to disable panel actions and setVisible to change the
         visibility of the panel.
     """
+
+    _use_syntax_theme = False
+
     class Position(object):
         """
         Enumerates the possible panel positions
         """
         #: Top margin
         TOP = 0
         #: Left margin
@@ -62,18 +65,18 @@
         #: in the panels menu of the notepad example).
         self.dynamic = dynamic
         #: Panel order into the zone it is installed to. This value is
         #: automatically set when installing the panel but it can be changed
         #: later (negative values can also be used).
         self.order_in_zone = -1
         self._scrollable = False
-        self._background_brush = None
-        self._foreground_pen = None
         #: Position in the editor (top, left, right, bottom)
         self.position = -1
+        self._cached_background_brush = None
+        self._cached_foreground_pen = None
 
     def on_install(self, editor):
         """
         Extends :meth:`pyqode.core.api.Mode.on_install` method to set the
         editor instance as the parent widget.
 
         .. warning:: Don't forget to call **super** if you override this
@@ -83,35 +86,84 @@
         :type editor: pyqode.core.api.CodeEdit
         """
         Mode.on_install(self, editor)
         self.setParent(editor)
         self.setPalette(QtWidgets.QApplication.instance().palette())
         self.setFont(QtWidgets.QApplication.instance().font())
         self.editor.panels.refresh()
-        self._background_brush = QtGui.QBrush(QtGui.QColor(
-            self.palette().window().color()))
-        self._foreground_pen = QtGui.QPen(QtGui.QColor(
-            self.palette().windowText().color()))
+
+    @property
+    def _background_brush(self):
+
+        """
+        Gives the brush that is used to draw the background. The panel can
+        adopt the syntax theme, so that it blends in with the editor, which
+        looks best for example for line numbers, or it can adopt the
+        application theme, which looks best for example for the search panel.
+        The brush is cached for performance.
+        """
+
+        if self._cached_background_brush is not None:
+            return self._cached_background_brush
+        if not self._use_syntax_theme:
+            self._cached_background_brush = QtGui.QBrush(
+                QtGui.QColor(self.palette().window().color())
+            )
+        else:
+            try:
+                self._color_scheme = \
+                    self.editor.syntax_highlighter.color_scheme
+            except AttributeError:
+                # There is no syntax highlighter to adopt the theme from
+                self._use_syntax_theme = False
+                return self._background_brush
+            self._cached_background_brush = \
+                self._color_scheme.formats['background'].background()
+        return self._cached_background_brush
+
+    @property
+    def _foreground_pen(self):
+
+        """
+        Gives the pen that is used to draw the foreground. The panel can
+        adopt the syntax theme, so that it blends in with the editor, which
+        looks best for example for line numbers, or it can adopt the
+        application theme, which looks best for example for the search panel.
+        The pen is cached for performance.
+        """
+
+        if self._cached_foreground_pen is not None:
+            return self._cached_foreground_pen
+        if not self._use_syntax_theme:
+            self._cached_foreground_pen = QtGui.QPen(
+                QtGui.QColor(self.palette().windowText().color())
+            )
+        else:
+            try:
+                self._color_scheme = \
+                    self.editor.syntax_highlighter.color_scheme
+            except AttributeError:
+                # There is no syntax highlighter to adopt the theme from
+                self._use_syntax_theme = False
+                return self._foreground_pen
+        self._cached_foreground_pen = \
+            self._color_scheme.formats['normal'].foreground()
+        return self._cached_foreground_pen
 
     def paintEvent(self, event):
-        # Fills the panel background using QPalette
-        if self.isVisible():
-            # fill background
-            self._background_brush = QtGui.QBrush(QtGui.QColor(
-                self.palette().window().color()))
-            self._foreground_pen = QtGui.QPen(QtGui.QColor(
-                self.palette().windowText().color()))
-            painter = QtGui.QPainter(self)
-            painter.fillRect(event.rect(), self._background_brush)
+
+        if not self.isVisible():
+            return
+        QtGui.QPainter(self).fillRect(event.rect(), self._background_brush)
 
     def setVisible(self, visible):
         """
         Shows/Hides the panel
 
         Automatically call CodeEdit.refresh_panels.
 
         :param visible: Visible state
         """
         _logger().log(5, '%s visibility changed', self.name)
         super(Panel, self).setVisible(visible)
         if self.editor:
-            self.editor.panels.refresh()
+            self.editor.panels.refresh()
```

## pyqode/core/api/syntax_highlighter.py

```diff
@@ -6,15 +6,15 @@
 import time
 import weakref
 from pygments.styles import get_style_by_name, get_all_styles
 from pygments.token import Token, Punctuation
 from pygments.util import ClassNotFound
 from pyqode.core.api.mode import Mode
 from pyqode.core.api.utils import drift_color
-from pyqode.qt import QtGui, QtCore, QtWidgets
+from qtpy import QtGui, QtCore, QtWidgets
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 #: A sorted list of available pygments styles, for convenience
@@ -48,15 +48,15 @@
     # any docstring (python docstring, c++ doxygen comment,...)
     "docstring": Token.Literal.String.Doc,
     # any number
     "number": Token.Number,
     # any instance variable
     "instance": Token.Name.Variable,
     # whitespace color
-    "whitespace": Token.Text.Whitespace,
+    "whitespace": Token.Comment,
     # any tag name (e.g. shinx doctags,...)
     'tag': Token.Name.Tag,
     # self paramter (or this in other languages)
     'self': Token.Name.Builtin.Pseudo,
     # python decorators
     'decorator': Token.Name.Decorator,
     # colors of punctuation characters
@@ -250,14 +250,15 @@
     def refresh_editor(self, color_scheme):
         """
         Refresh editor settings (background and highlight colors) when color
         scheme changed.
 
         :param color_scheme: new color scheme.
         """
+        self.editor._auto_reset_stylesheet = False
         self.editor.background = color_scheme.background
         self.editor.foreground = color_scheme.formats[
             'normal'].foreground().color()
         self.editor.whitespaces_foreground = color_scheme.formats[
             'whitespace'].foreground().color()
         try:
             mode = self.editor.modes.get('CaretLineHighlighterMode')
@@ -268,47 +269,61 @@
             mode.refresh()
         try:
             mode = self.editor.panels.get('FoldingPanel')
         except KeyError:
             pass
         else:
             mode.refresh_decorations(force=True)
+        self.editor._auto_reset_stylesheet = True
         self.editor._reset_stylesheet()
 
     def __init__(self, parent, color_scheme=None):
         """
         :param parent: parent document (QTextDocument)
         :param color_scheme: color scheme to use.
         """
         QtGui.QSyntaxHighlighter.__init__(self, parent)
         Mode.__init__(self)
         if not color_scheme:
             color_scheme = ColorScheme('qt')
         self._color_scheme = color_scheme
-        self._spaces_ptrn = QtCore.QRegExp(r'[ \t]+')
+        self._spaces_ptrn = QtCore.QRegularExpression(r'[ \t]+')
         #: Fold detector. Set it to a valid FoldDetector to get code folding
         #: to work. Default is None
         self.fold_detector = None
-        self.WHITESPACES = QtCore.QRegExp(r'\s+')
+        self.WHITESPACES = QtCore.QRegularExpression(r'\s+')
+        self._in_rehighlight = False
 
     def on_state_changed(self, state):
         if self._on_close:
             return
         if state:
             self.setDocument(self.editor.document())
         else:
             self.setDocument(None)
 
-    def _highlight_whitespaces(self, text):
-        index = self.WHITESPACES.indexIn(text, 0)
-        while index >= 0:
-            index = self.WHITESPACES.pos(0)
-            length = len(self.WHITESPACES.cap(0))
-            self.setFormat(index, length, self.formats['whitespace'])
-            index = self.WHITESPACES.indexIn(text, index + length)
+    def _highlight_whitespaces(self, text, fmt=None):
+        text_len = len(text)
+        if fmt is None:
+            fmt = self.formats['whitespace']
+        # This is a reimplementation from the previous regexp solution to
+        # finding whitespace, because using str.find() is much faster, which
+        # is important when highlighting large blocks. The logic is that we
+        # first find all the spaces, then all the tabs, and apply the
+        # whitespace style to them.
+        for ch in (' ', '\t'):
+            start = text.find(ch)
+            while start >= 0:
+                end = start + 1
+                while end < text_len:
+                    if text[end] != ch:
+                        break
+                    end += 1
+                self.setFormat(start, end - start, fmt)
+                start = text.find(ch, end)
 
     @staticmethod
     def _find_prev_non_blank_block(current_block):
         previous_block = (current_block.previous()
                           if current_block.blockNumber() else None)
         # find the previous non-blank block
         while (previous_block and previous_block.blockNumber() and
@@ -346,25 +361,27 @@
         """
         raise NotImplementedError()
 
     def rehighlight(self):
         """
         Rehighlight the entire document, may be slow.
         """
+        self._in_rehighlight = True
         start = time.time()
         QtWidgets.QApplication.setOverrideCursor(
             QtGui.QCursor(QtCore.Qt.WaitCursor))
         try:
             super(SyntaxHighlighter, self).rehighlight()
         except RuntimeError:
             # cloned widget, no need to rehighlight the same document twice ;)
             pass
         QtWidgets.QApplication.restoreOverrideCursor()
         end = time.time()
         _logger().debug('rehighlight duration: %fs' % (end - start))
+        self._in_rehighlight = False
 
     def on_install(self, editor):
         super(SyntaxHighlighter, self).on_install(editor)
         self.refresh_editor(self.color_scheme)
         self.document().setParent(editor)
         self.setParent(editor)
```

## pyqode/core/api/utils.py

```diff
@@ -2,28 +2,29 @@
 """
 This module contains utility functions/classes.
 """
 import functools
 import logging
 import weakref
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 def _logger():
     """ Returns module logger """
     return logging.getLogger(__name__)
 
 
 class memoized(object):
     """
     Decorator. Caches a function's return value each time it is called.
     If called later with the same arguments, the cached value is returned
     (not reevaluated).
     """
+
     def __init__(self, func):
         self.func = func
         self.cache = {}
 
     def __call__(self, *args):
         try:
             if args in self.cache:
@@ -72,14 +73,15 @@
     restarted for the new request.
 
     We use this to implement a cooldown effect that prevents jobs from being
     executed while the IDE is not idle.
 
     A job is a simple callable.
     """
+
     def __init__(self, delay=500):
         """
         :param delay: Delay to wait before running the job. This delay applies
         to all requests and cannot be changed afterwards.
         """
         self._timer = QtCore.QTimer()
         self.delay = delay
@@ -151,15 +153,15 @@
         :param line: Number of the line to go to (0 based)
         :param column: Optional column number. Default is 0 (start of line).
         :param move: True to move the cursor. False will return the cursor
                      without setting it on the editor.
         :return: The new text cursor
         :rtype: QtGui.QTextCursor
         """
-        text_cursor = self._move_cursor_to(line)
+        text_cursor = self.move_cursor_to(line)
         if column:
             text_cursor.movePosition(text_cursor.Right, text_cursor.MoveAnchor,
                                      column)
         if move:
             block = text_cursor.block()
             # unfold parent fold trigger if the block is collapsed
             try:
@@ -177,61 +179,71 @@
 
     def selected_text(self):
         """
         Returns the selected text.
         """
         return self._editor.textCursor().selectedText()
 
-    def word_under_cursor(self, select_whole_word=False, text_cursor=None):
+    def word_under_cursor(
+        self,
+        select_whole_word=False,
+        text_cursor=None,
+        from_start=True
+    ):
         """
         Gets the word under cursor using the separators defined by
         :attr:`pyqode.core.api.CodeEdit.word_separators`.
 
         .. note: Instead of returning the word string, this function returns
             a QTextCursor, that way you may get more information than just the
             string. To get the word, just call ``selectedText`` on the returned
             value.
 
         :param select_whole_word: If set to true the whole word is selected,
          else the selection stops at the cursor position.
         :param text_cursor: Optional custom text cursor (e.g. from a
             QTextDocument clone)
+        :param from_start: If set to true the word is selected from the start,
+        else from the cursor position.
         :returns: The QTextCursor that contains the selected word.
         """
         editor = self._editor
         if not text_cursor:
             text_cursor = editor.textCursor()
         word_separators = editor.word_separators
         end_pos = start_pos = text_cursor.position()
         # select char by char until we are at the original cursor position.
-        while not text_cursor.atStart():
+        while from_start and not text_cursor.atStart():
             text_cursor.movePosition(
                 text_cursor.Left, text_cursor.KeepAnchor, 1)
             try:
                 char = text_cursor.selectedText()[0]
-                word_separators = editor.word_separators
-                selected_txt = text_cursor.selectedText()
-                if (selected_txt in word_separators and
-                        (selected_txt != "n" and selected_txt != "t") or
-                        char.isspace()):
-                    break  # start boundary found
             except IndexError:
                 break  # nothing selectable
+            word_separators = editor.word_separators
+            selected_txt = text_cursor.selectedText()
+            if (selected_txt in word_separators and
+                    (selected_txt != "\n" and selected_txt != "\t") or
+                    char.isspace()):
+                break  # start boundary found
             start_pos = text_cursor.position()
             text_cursor.setPosition(start_pos)
         if select_whole_word:
-            # select the resot of the word
+            # select the rest of the word
             text_cursor.setPosition(end_pos)
             while not text_cursor.atEnd():
                 text_cursor.movePosition(text_cursor.Right,
                                          text_cursor.KeepAnchor, 1)
-                char = text_cursor.selectedText()[0]
+                try:
+                    char = text_cursor.selectedText()[0]
+                except IndexError:
+                    break  # nothing selectable
                 selected_txt = text_cursor.selectedText()
                 if (selected_txt in word_separators and
-                        (selected_txt != "n" and selected_txt != "t") or
+                        (selected_txt != "\n" and selected_txt != "\t") or
                         char.isspace()):
                     break  # end boundary found
                 end_pos = text_cursor.position()
                 text_cursor.setPosition(end_pos)
         # now that we habe the boundaries, we can select the text
         text_cursor.setPosition(start_pos)
         text_cursor.setPosition(end_pos, text_cursor.KeepAnchor)
@@ -287,27 +299,42 @@
         Gets the text of the specified line
 
         :param line_nbr: The line number of the text to get
 
         :return: Entire line's text
         :rtype: str
         """
+
+        # Under some (apparent) race conditions, this function can be called
+        # with a None line number. This should be fixed in a better way, but
+        # for now we return an empty string to avoid crashes.
+        if line_nbr is None:
+            return ''
         doc = self._editor.document()
         block = doc.findBlockByNumber(line_nbr)
         return block.text()
 
     def previous_line_text(self):
         """
         Gets the previous line text (relative to the current cursor pos).
         :return: previous line text (str)
         """
         if self.current_line_nbr():
             return self.line_text(self.current_line_nbr() - 1)
         return ''
 
+    def next_line_text(self):
+        """
+        Gets the next line text (relative to the current cursor pos).
+        :return: next line text (str)
+        """
+        if self.current_line_nbr():
+            return self.line_text(self.current_line_nbr() + 1)
+        return ''
+
     def current_line_text(self):
         """
         Returns the text of the current line.
 
         :return: Text of the current line
         """
         return self.line_text(self.current_line_nbr())
@@ -317,15 +344,15 @@
         Replace an entire line with ``new_text``.
 
         :param line_nbr: line number of the line to change.
         :param new_text: The replacement text.
 
         """
         editor = self._editor
-        text_cursor = self._move_cursor_to(line_nbr)
+        text_cursor = self.move_cursor_to(line_nbr)
         text_cursor.select(text_cursor.LineUnderCursor)
         text_cursor.insertText(new_text)
         editor.setTextCursor(text_cursor)
 
     def remove_last_line(self):
         """
         Removes the last line of the document.
@@ -379,15 +406,15 @@
         if self.line_text(self.line_count() - 1):
             editor.appendPlainText('')
 
         # restore cursor and scrollbars
         text_cursor = editor.textCursor()
         doc = editor.document()
         assert isinstance(doc, QtGui.QTextDocument)
-        text_cursor = self._move_cursor_to(pos[0])
+        text_cursor = self.move_cursor_to(pos[0])
         text_cursor.movePosition(text_cursor.StartOfLine,
                                  text_cursor.MoveAnchor)
         cpos = text_cursor.position()
         text_cursor.select(text_cursor.LineUnderCursor)
         if text_cursor.selectedText():
             text_cursor.setPosition(cpos)
             offset = pos[1] - eaten
@@ -411,58 +438,71 @@
             on the editor.
         :return: QTextCursor
         """
         if line is None:
             line = self.current_line_nbr()
         return self.select_lines(line, line, apply_selection=apply_selection)
 
-    def _move_cursor_to(self, line):
+    def move_cursor_to(self, line):
         cursor = self._editor.textCursor()
         block = self._editor.document().findBlockByNumber(line)
         cursor.setPosition(block.position())
         return cursor
 
-    def select_lines(self, start=0, end=-1, apply_selection=True):
+    def select_lines(self, start=0, end=-1, apply_selection=True,
+                     select_blocks=False):
         """
         Selects entire lines between start and end line numbers.
 
         This functions apply the selection and returns the text cursor that
         contains the selection.
 
         Optionally it is possible to prevent the selection from being applied
         on the code editor widget by setting ``apply_selection`` to False.
 
         :param start: Start line number (0 based)
         :param end: End line number (0 based). Use -1 to select up to the
             end of the document
         :param apply_selection: True to apply the selection before returning
          the QTextCursor.
+        :param select_blocks: True to operate on blocks rather than visual
+         lines.
         :returns: A QTextCursor that holds the requested selection
         """
         editor = self._editor
         if end == -1:
             end = self.line_count() - 1
         if start < 0:
             start = 0
-        text_cursor = self._move_cursor_to(start)
+        text_cursor = self.move_cursor_to(start)
+        if select_blocks:
+            move_start = text_cursor.StartOfBlock
+            move_end = text_cursor.EndOfBlock
+            move_up = text_cursor.PreviousBlock
+            move_down = text_cursor.NextBlock
+        else:
+            move_start = text_cursor.StartOfLine
+            move_end = text_cursor.EndOfLine
+            move_up = text_cursor.Up
+            move_down = text_cursor.Down
         if end > start:  # Going down
-            text_cursor.movePosition(text_cursor.Down,
+            text_cursor.movePosition(move_down,
                                      text_cursor.KeepAnchor, end - start)
-            text_cursor.movePosition(text_cursor.EndOfLine,
+            text_cursor.movePosition(move_end,
                                      text_cursor.KeepAnchor)
         elif end < start:  # going up
             # don't miss end of line !
-            text_cursor.movePosition(text_cursor.EndOfLine,
+            text_cursor.movePosition(move_end,
                                      text_cursor.MoveAnchor)
-            text_cursor.movePosition(text_cursor.Up,
+            text_cursor.movePosition(move_up,
                                      text_cursor.KeepAnchor, start - end)
-            text_cursor.movePosition(text_cursor.StartOfLine,
+            text_cursor.movePosition(move_start,
                                      text_cursor.KeepAnchor)
         else:
-            text_cursor.movePosition(text_cursor.EndOfLine,
+            text_cursor.movePosition(move_end,
                                      text_cursor.KeepAnchor)
         if apply_selection:
             editor.setTextCursor(text_cursor)
         return text_cursor
 
     def selection_range(self):
         """
@@ -559,21 +599,45 @@
 
     def get_right_character(self, cursor=None):
         """
         Gets the character that is on the right of the text cursor.
 
         :param cursor: QTextCursor that defines the position where the search
             will start.
+            
+        :return: A single character or None if the cursor is at the end of the
+            document.
         """
-        next_char = self.get_right_word(cursor=cursor)
-        if len(next_char):
-            next_char = next_char[0]
-        else:
-            next_char = None
-        return next_char
+
+        if cursor is None:
+            cursor = self._editor.textCursor()
+        if cursor.atEnd():
+            return
+        cursor.clearSelection()
+        cursor.movePosition(cursor.Right, cursor.KeepAnchor, 1)
+        return cursor.selectedText()
+
+    def get_left_character(self, cursor=None):
+        """
+        Gets the character that is on the left of the text cursor.
+
+        :param cursor: QTextCursor that defines the position where the search
+            will start.
+            
+        :return: A single character or None if the cursor is at the start of
+            the document.
+        """
+
+        if cursor is None:
+            cursor = self._editor.textCursor()
+        if cursor.atStart():
+            return
+        cursor.clearSelection()
+        cursor.movePosition(cursor.Left, cursor.KeepAnchor, 1)
+        return cursor.selectedText()
 
     def insert_text(self, text, keep_position=True):
         """
         Inserts text at the cursor position.
 
         :param text: text to insert
         :param keep_position: Flag that specifies if the cursor position must
@@ -680,15 +744,15 @@
             pos = len(cursor_or_block.text()) - 1
             layout = cursor_or_block.layout()
         elif isinstance(cursor_or_block, QtGui.QTextCursor):
             b = cursor_or_block.block()
             pos = cursor_or_block.position() - b.position()
             layout = b.layout()
         if layout is not None:
-            additional_formats = layout.additionalFormats()
+            additional_formats = layout.formats()
             sh = self._editor.syntax_highlighter
             if sh:
                 ref_formats = sh.color_scheme.formats
                 for r in additional_formats:
                     if r.start <= pos < (r.start + r.length):
                         for fmt_type in formats:
                             is_user_obj = (r.format.objectType() ==
@@ -1002,27 +1066,30 @@
         block.setUserState(state)
 
 
 class ParenthesisInfo(object):
     """
     Stores information about a parenthesis in a line of code.
     """
+
     def __init__(self, pos, char):
         #: Position of the parenthesis, expressed as a number of character
         self.position = pos
         #: The parenthesis character, one of "(", ")", "{", "}", "[", "]"
         self.character = char
 
 
-def get_block_symbol_data(editor, block):
+def get_block_symbol_data(editor, block, opening=True, closing=True):
     """
     Gets the list of ParenthesisInfo for specific text block.
 
     :param editor: Code edit instance
     :param block: block to parse
+    :param opening: indicates whether opening symbols should be included
+    :param closing: indicates whether closing symbols should be included
     """
     def list_symbols(editor, block, character):
         """
         Retuns  a list of symbols found in the block text
 
         :param editor: code edit instance
         :param block: block to parse
@@ -1030,34 +1097,62 @@
         """
         text = block.text()
         symbols = []
         cursor = QtGui.QTextCursor(block)
         cursor.movePosition(cursor.StartOfBlock)
         pos = text.find(character, 0)
         cursor.movePosition(cursor.Right, cursor.MoveAnchor, pos)
-
         while pos != -1:
             if not TextHelper(editor).is_comment_or_string(cursor):
                 # skips symbols in string literal or comment
                 info = ParenthesisInfo(pos, character)
                 symbols.append(info)
-            pos = text.find(character, pos + 1)
-            cursor.movePosition(cursor.StartOfBlock)
-            cursor.movePosition(cursor.Right, cursor.MoveAnchor, pos)
+            next_pos = text.find(character, pos + 1)
+            cursor.movePosition(
+                cursor.Right,
+                cursor.MoveAnchor,
+                next_pos - pos
+            )
+            pos = next_pos
         return symbols
+    
+    def quick_list_symbols(editor, block, character):
+        """
+        Retuns  a list of symbols found in the block text. This is a faster
+        version of the function above, to make sure that performance is ok
+        with large blocks.
 
-    parentheses = sorted(
-        list_symbols(editor, block, '(') + list_symbols(editor, block, ')'),
-        key=lambda x: x.position)
-    square_brackets = sorted(
-        list_symbols(editor, block, '[') + list_symbols(editor, block, ']'),
-        key=lambda x: x.position)
-    braces = sorted(
-        list_symbols(editor, block, '{') + list_symbols(editor, block, '}'),
-        key=lambda x: x.position)
+        :param editor: code edit instance
+        :param block: block to parse
+        :param character: character to look for.
+        """
+        text = block.text()
+        symbols = []
+        pos = text.find(character, 0)
+        while pos != -1:
+            symbols.append(ParenthesisInfo(pos, character))
+            pos = text.find(character, pos + 1)
+        return symbols
+    
+    if block.length() > 100:  # Starts to become sluggish
+        list_symbols = quick_list_symbols
+    parentheses = []
+    square_brackets = []
+    braces = []
+    if opening:
+        parentheses += list_symbols(editor, block, '(')
+        square_brackets += list_symbols(editor, block, '[')
+        braces += list_symbols(editor, block, '{')
+    if closing:
+        parentheses += list_symbols(editor, block, ')')
+        square_brackets += list_symbols(editor, block, ']')
+        braces += list_symbols(editor, block, '}')
+    parentheses = sorted(parentheses, key=lambda x: x.position)
+    square_brackets = sorted(square_brackets, key=lambda x: x.position)
+    braces = sorted(braces, key=lambda x: x.position)
     return parentheses, square_brackets, braces
 
 
 def keep_tc_pos(func):
     """
     Cache text cursor position and restore it when the wrapped
     function exits.
```

## pyqode/core/api/decoration.py

```diff
@@ -1,12 +1,13 @@
 """
 This module contains the text decoration API.
 
 """
-from pyqode.qt import QtWidgets, QtCore, QtGui
+from pyqode.core import icons
+from qtpy import QtWidgets, QtCore, QtGui
 
 
 class TextDecoration(QtWidgets.QTextEdit.ExtraSelection):
     """
     Helper class to quickly create a text decoration. The text decoration is an
     utility class that adds a few utility methods to QTextEdit.ExtraSelection.
 
@@ -34,18 +35,19 @@
 
     def __init__(self, cursor_or_bloc_or_doc, start_pos=None, end_pos=None,
                  start_line=None, end_line=None, draw_order=0, tooltip=None,
                  full_width=False):
         """
         Creates a text decoration.
 
-        .. note:: start_pos/end_pos and start_line/end_line pairs let you
-            easily specify the selected text. You should use one pair or the
-            other or they will conflict between each others. If you don't
-            specify any values, the selection will be based on the cursor.
+        .. note:: The start_pos is relative to the start of the document if
+            start_line is not specified, and relative to the start of the line
+            if it is. The end_pos is relative to the end_line if it is
+            specified, to the start_line if it is specified (but end_line is
+            not), and the start of the document otherwise.
 
         :param cursor_or_bloc_or_doc: Reference to a valid
             QTextCursor/QTextBlock/QTextDocument
         :param start_pos: Selection start position
         :param end_pos: Selection end position
         :param start_line: Selection start line.
         :param end_line: Selection end line.
@@ -53,47 +55,85 @@
             appear on top of the lowest values.
         :param tooltip: An optional tooltips that will be automatically shown
             when the mouse cursor hover the decoration.
         :param full_width: True to select the full line width.
 
         .. note:: Use the cursor selection if startPos and endPos are none.
         """
-        super(TextDecoration, self).__init__()
+        super().__init__()
         self.signals = self.Signals()
         self.draw_order = draw_order
         self.tooltip = tooltip
         self.cursor = QtGui.QTextCursor(cursor_or_bloc_or_doc)
         if full_width:
             self.set_full_width(full_width)
-        if start_pos is not None:
-            self.cursor.setPosition(start_pos)
-        if end_pos is not None:
-            self.cursor.setPosition(end_pos, QtGui.QTextCursor.KeepAnchor)
-        if start_line is not None:
+        if start_line is not None or end_line is not None:
+            # If a start or end line is provided, then we calculate from the
+            # start of the text
             self.cursor.movePosition(self.cursor.Start, self.cursor.MoveAnchor)
-            self.cursor.movePosition(self.cursor.Down, self.cursor.MoveAnchor,
-                                     start_line)
+        if start_line is not None:
+            # If start_line is provided, move the anchor to the start of that
+            # line
+            self.cursor.movePosition(
+                self.cursor.NextBlock, self.cursor.MoveAnchor,
+                start_line)
+            # If start_pos is provided (in addition to start_line), move the
+            # anchor to the correct character within the line.
+            if start_pos is not None:
+                self.cursor.movePosition(
+                    self.cursor.NextCharacter, self.cursor.MoveAnchor,
+                    start_pos)
+        elif start_pos is not None:
+            # If no start_line is provided, but a start_pos is provided, then
+            # we set the anchor to start_pos, which then has an absolute
+            # meaning in terms of characters from the start.
+            self.cursor.setPosition(start_pos, self.cursor.MoveAnchor)
         if end_line is not None:
-            self.cursor.movePosition(self.cursor.Down, self.cursor.KeepAnchor,
-                                     end_line - start_line)
+            # If end_line is provided, move the cursor to the start of that
+            # line while keeping the anchor
+            self.cursor.movePosition(
+                self.cursor.NextBlock, self.cursor.KeepAnchor,
+                end_line - start_line)
+        if start_line is not None or end_line is not None:
+            if end_pos is not None:
+                # If either a start or an endline is provided, and an end_pos
+                # is also provided, then we move the cursor to the end pos,
+                # while keeping the anchor.
+                print(self.cursor.position())
+                print(self.cursor.block().position())
+                print(self.cursor.positionInBlock())
+                print(f'moving cursor right {end_pos - self.cursor.positionInBlock()} characters')
+                self.cursor.movePosition(
+                    self.cursor.NextCharacter, self.cursor.KeepAnchor,
+                    end_pos - self.cursor.positionInBlock())
+        elif end_pos is not None:
+            # No start or endline was provided, but end_pos is provided,
+            # then we set the anchor to end_pos, which then has an absolute
+            # meanin gin terms of characters from the start.
+            self.cursor.setPosition(end_pos, self.cursor.KeepAnchor)
+        print('done!')
+        self.character = self.cursor.selectedText()
 
-    def contains_cursor(self, cursor):
+    def contains_cursor(self, cursor, margin=0):
         """
         Checks if the textCursor is in the decoration
 
         :param cursor: The text cursor to test
         :type cursor: QtGui.QTextCursor
+        :param margin: A margin to match also cursor that are just next to
+            the decoration.
+        :type margin: int
 
         :returns: True if the cursor is over the selection
         """
         start = self.cursor.selectionStart()
         end = self.cursor.selectionEnd()
         if cursor.atBlockEnd():
             end -= 1
-        return start <= cursor.position() <= end
+        return start - margin <= cursor.position() <= end + margin
 
     def set_as_bold(self):
         """ Uses bold text """
         self.format.setFontWeight(QtGui.QFont.Bold)
 
     def set_foreground(self, color):
         """ Sets the foreground color.
@@ -145,47 +185,55 @@
         :param clear: True to clear any previous selection. Default is True.
         :type clear: bool
         """
         if clear:
             self.cursor.clearSelection()
         self.format.setProperty(QtGui.QTextFormat.FullWidthSelection, flag)
 
-    def set_as_underlined(self, color=QtCore.Qt.blue):
+    def set_as_underlined(self, color=None):
         """
         Underlines the text
 
         :param color: underline color.
         """
+        if color is None:
+            color = QtGui.QColor(icons.QTA_OPTIONS['color_info'])
         self.format.setUnderlineStyle(
             QtGui.QTextCharFormat.SingleUnderline)
         self.format.setUnderlineColor(color)
 
-    def set_as_spell_check(self, color=QtCore.Qt.blue):
+    def set_as_spell_check(self, color=None):
         """ Underlines text as a spellcheck error.
 
         :param color: Underline color
         :type color: QtGui.QColor
         """
+        if color is None:
+            color = QtGui.QColor(icons.QTA_OPTIONS['color_info'])
         self.format.setUnderlineStyle(
             QtGui.QTextCharFormat.SpellCheckUnderline)
         self.format.setUnderlineColor(color)
 
-    def set_as_error(self, color=QtCore.Qt.red):
+    def set_as_error(self, color=None):
         """ Highlights text as a syntax error.
 
         :param color: Underline color
         :type color: QtGui.QColor
         """
+        if color is None:
+            color = QtGui.QColor(icons.QTA_OPTIONS['color_error'])
         self.format.setUnderlineStyle(
             QtGui.QTextCharFormat.WaveUnderline)
         self.format.setUnderlineColor(color)
 
-    def set_as_warning(self, color=QtGui.QColor("orange")):
+    def set_as_warning(self, color=None):
         """
         Highlights text as a syntax warning
 
         :param color: Underline color
         :type color: QtGui.QColor
         """
+        if color is None:
+            color = QtGui.QColor(icons.QTA_OPTIONS['color_warning'])
         self.format.setUnderlineStyle(
             QtGui.QTextCharFormat.WaveUnderline)
         self.format.setUnderlineColor(color)
```

## pyqode/core/api/client.py

```diff
@@ -1,22 +1,23 @@
 """
 This module contains the client socket API. This API is exposed to the
 user throught the backend manager (
 :class:`pyqode.core.managers.BackendManager`)
 
 """
+import os
 import locale
 import json
 import logging
 import socket
 import struct
 import sys
 import uuid
 from weakref import ref
-from pyqode.qt import QtCore, QtNetwork
+from qtpy import QtCore, QtNetwork
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 #: log level for communication
@@ -176,15 +177,14 @@
     #: backend manager
     finished = QtCore.Signal(QtNetwork.QTcpSocket)
 
     def __init__(self, parent, port, worker_class_or_function, args,
                  on_receive=None):
         super(JsonTcpClient, self).__init__(parent)
         self._port = port
-
         self._worker = worker_class_or_function
         self._args = args
         self._header_complete = False
         self._header_buf = bytes()
         self._to_read = 0
         self._data_buf = bytes()
         if on_receive:
@@ -194,15 +194,15 @@
                 # unbound method (i.e. free function)
                 self._callback = ref(on_receive)
         else:
             self._callback = None
         self.is_connected = False
         self._closed = False
         self.connected.connect(self._on_connected)
-        self.error.connect(self._on_error)
+        self.errorOccurred.connect(self._on_error)
         self.disconnected.connect(self._on_disconnected)
         self.readyRead.connect(self._on_ready_read)
         self._connect()
 
     def close(self):
         self._closed = True  # fix issue with QTimer.singleShot
         super(JsonTcpClient, self).close()
@@ -344,32 +344,40 @@
     Extends QProcess with methods to easily manipulate the backend process.
 
     Also logs everything that is written to the process' stdout/stderr.
     """
     def __init__(self, parent):
         super(BackendProcess, self).__init__(parent)
         self.started.connect(self._on_process_started)
-        self.error.connect(self._on_process_error)
+        self.errorOccurred.connect(self._on_process_error)
         self.finished.connect(self._on_process_finished)
         self.readyReadStandardOutput.connect(self._on_process_stdout_ready)
         self.readyReadStandardError.connect(self._on_process_stderr_ready)
         self.running = False
         self.starting = True
         self._srv_logger = logging.getLogger('pyqode.backend')
+        if 'PYQODE_BACKEND_LOGGING_LEVEL' in os.environ:
+            self._srv_logger.setLevel(
+                int(os.environ['PYQODE_BACKEND_LOGGING_LEVEL'])
+            )
         self._prevent_logs = False
         self._encoding = locale.getpreferredencoding()
 
     def _on_process_started(self):
         """ Logs process started """
         comm('backend process started')
+        if self is None:
+            return
         self.starting = False
         self.running = True
 
     def _on_process_error(self, error):
         """ Logs process error """
+        if self is None:
+            return
         if error not in PROCESS_ERROR_STRING:
             error = -1
         if not self._prevent_logs:
             _logger().warning(PROCESS_ERROR_STRING[error])
 
     def _on_process_finished(self, exit_code):
         """ Logs process exit status """
@@ -389,17 +397,19 @@
         except TypeError:
             output = bytes(o.data()).decode(self._encoding)
         for line in output.splitlines():
             self._srv_logger.log(1, line)
 
     def _on_process_stderr_ready(self):
         """ Logs process output (stderr) """
-        if not self:
+        try:
+            o = self.readAllStandardError()
+        except (TypeError, RuntimeError):
+            # widget already deleted
             return
-        o = self.readAllStandardError()
         try:
             output = bytes(o).decode(self._encoding)
         except TypeError:
             output = bytes(o.data()).decode(self._encoding)
         for line in output.splitlines():
             self._srv_logger.error(line)
```

## pyqode/core/api/code_edit.py

```diff
@@ -18,15 +18,15 @@
 from pyqode.core.managers import BackendManager
 from pyqode.core.managers import FileManager
 from pyqode.core.managers import ModesManager
 from pyqode.core.managers import TextDecorationsManager
 from pyqode.core.managers import PanelsManager
 # ensure pyqode resource have been imported and are ready to be used.
 from pyqode.core._forms import pyqode_core_rc
-from pyqode.qt import QtWidgets, QtCore, QtGui
+from qtpy import QtWidgets, QtCore, QtGui
 
 
 def _logger():
     """ Returns module's logger """
     return logging.getLogger(__name__)
 
 
@@ -179,15 +179,16 @@
         return self._font_family
 
     @font_name.setter
     def font_name(self, value):
         if value == "":
             value = self._DEFAULT_FONT
         self._font_family = value
-        self._reset_stylesheet()
+        if self._auto_reset_stylesheet:
+            self._reset_stylesheet()
         for c in self.clones:
             c.font_name = value
 
     @property
     def zoom_level(self):
         """
         Gets/Sets the editor zoom level.
@@ -213,43 +214,46 @@
             property has changed.
         """
         return self._font_size
 
     @font_size.setter
     def font_size(self, value):
         self._font_size = value
-        self._reset_stylesheet()
+        if self._auto_reset_stylesheet:
+            self._reset_stylesheet()
         for c in self.clones:
             c.font_size = value
 
     @property
     def background(self):
         """
         The editor background color (QColor)
         """
         return self._background
 
     @background.setter
     def background(self, value):
         self._background = value
-        self._reset_stylesheet()
+        if self._auto_reset_stylesheet:
+            self._reset_stylesheet()
         for c in self.clones:
             c.background = value
 
     @property
     def foreground(self):
         """
         The editor foreground color (QColor)
         """
         return self._foreground
 
     @foreground.setter
     def foreground(self, value):
         self._foreground = value
-        self._reset_stylesheet()
+        if self._auto_reset_stylesheet:
+            self._reset_stylesheet()
         for c in self.clones:
             c.foreground = value
 
     @property
     def whitespaces_foreground(self):
         """
         The editor white spaces' foreground color. White spaces are highlighted
@@ -271,15 +275,16 @@
         The editor selection's background color.
         """
         return self._sel_background
 
     @selection_background.setter
     def selection_background(self, value):
         self._sel_background = value
-        self._reset_stylesheet()
+        if self._auto_reset_stylesheet:
+            self._reset_stylesheet()
         for c in self.clones:
             c.selection_background = value
 
     @property
     def selection_foreground(self):
         """
         The editor selection's foreground color.
@@ -430,29 +435,31 @@
         :param create_default_actions: True to create the action for the
             standard shortcuts (copy, paste, delete, undo, redo,...).
             Non-standard actions will always get created. If you would like
             to prevent the context menu from showing, just set the
             :attr:`show_menu_enabled` to False.
         """
         super(CodeEdit, self).__init__(parent)
+        self._auto_reset_stylesheet = False
         self.installEventFilter(self)
         self.clones = []
+        self._closed = False
         self._show_ctx_mnu = True
         self._default_font_size = 10
         self._backend = BackendManager(self)
         self._file = FileManager(self)
         self._modes = ModesManager(self)
         self._panels = PanelsManager(self)
         self._decorations = TextDecorationsManager(self)
         self.document().modificationChanged.connect(self._emit_dirty_changed)
 
         self._word_separators = [
             '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '+', '{',
             '}', '|', ':', '"', "'", "<", ">", "?", ",", ".", "/", ";", '[',
-            ']', '\\', '\n', '\t', '=', '-', ' '
+            ']', '\\', '\n', '\t', '=', '-', ' ', u'\u2029'
         ]
         self._save_on_focus_out = False
         self._use_spaces_instead_of_tabs = True
         self._whitespaces_foreground = None
         self._sel_background = None
         self._show_whitespaces = False
         self._foreground = None
@@ -498,14 +505,16 @@
         self.cursorPositionChanged.connect(self.update)
         self.selectionChanged.connect(self.update)
 
         self.setMouseTracking(True)
         self.setCenterOnScroll(True)
         self.setLineWrapMode(self.NoWrap)
         self.setCursorWidth(2)
+        self._auto_reset_stylesheet = True
+        self._reset_stylesheet()
 
     def __repr__(self):
         return '%s(path=%r)' % (self.__class__.__name__, self.file.path)
 
     def split(self):
         """
         Split the code editor widget, return a clone of the widget ready to
@@ -520,14 +529,15 @@
         """
         # cache cursor position so that the clone open at the current cursor
         # pos
         l, c = TextHelper(self).cursor_position()
         clone = self.clone()
         self.link(clone)
         TextHelper(clone).goto_line(l, c)
+        clone.verticalScrollBar().setValue(self.verticalScrollBar().value())
         self.clones.append(clone)
         return clone
 
     def clone(self):
         """
         Clone ourselves, return an instance of the same class, using the
         default QWidget constructor.
@@ -543,26 +553,33 @@
 
         :param clone: clone to link.
         """
         clone.file._path = self.file.path
         clone.file._encoding = self.file.encoding
         clone.file._mimetype = self.file.mimetype
         clone.setDocument(self.document())
-        for original_mode, mode in zip(list(self.modes), list(clone.modes)):
-            mode.enabled = original_mode.enabled
-            mode.clone_settings(original_mode)
-        for original_panel, panel in zip(
-                list(self.panels), list(clone.panels)):
-            panel.enabled = original_panel.isEnabled()
-            panel.clone_settings(original_panel)
+        for original_mode in self.modes:
+            try:
+                clone_mode = clone.modes.get(original_mode.name)
+            except KeyError:
+                continue
+            clone_mode.enabled = original_mode.enabled
+            clone_mode.clone_settings(original_mode)
+        for original_panel in self.panels:
+            try:
+                clone_panel = clone.panels.get(original_panel.name)
+            except KeyError:
+                continue
+            clone_panel.enabled = original_panel.isEnabled()
+            clone_panel.clone_settings(original_panel)
             if not original_panel.isVisible():
-                panel.setVisible(False)
+                clone_panel.setVisible(False)
         clone.use_spaces_instead_of_tabs = self.use_spaces_instead_of_tabs
         clone.tab_length = self.tab_length
-        clone.save_on_focus_out = self.save_on_focus_out
+        clone._save_on_focus_out = self._save_on_focus_out
         clone.show_whitespaces = self.show_whitespaces
         clone.font_name = self.font_name
         clone.font_size = self.font_size
         clone.zoom_level = self.zoom_level
         clone.background = self.background
         clone.foreground = self.foreground
         clone.whitespaces_foreground = self.whitespaces_foreground
@@ -576,14 +593,17 @@
         Closes the editor, stops the backend and removes any installed
         mode/panel.
 
         This is also where we cache the cursor position.
 
         :param clear: True to clear the editor content before closing.
         """
+        if self._closed:
+            return
+        self._closed = True
         if self._tooltips_runner:
             self._tooltips_runner.cancel_requests()
             self._tooltips_runner = None
         self.decorations.clear()
         self.modes.clear()
         self.panels.clear()
         self.backend.stop()
@@ -628,15 +648,19 @@
         """
         self.file.mimetype = mime_type
         self.file._encoding = encoding
         self._original_text = txt
         self._modified_lines.clear()
         import time
         t = time.time()
+        if hasattr(self, 'syntax_highlighter'):
+            self.syntax_highlighter._in_rehighlight = True
         super(CodeEdit, self).setPlainText(txt)
+        if hasattr(self, 'syntax_highlighter'):
+            self.syntax_highlighter._in_rehighlight = False
         _logger().log(5, 'setPlainText duration: %fs' % (time.time() - t))
         self.new_text_set.emit()
         self.redoAvailable.emit(False)
         self.undoAvailable.emit(False)
 
     def add_action(self, action, sub_menu='Advanced'):
         """
@@ -647,15 +671,15 @@
             'Advanced' by default. If None or empty, the action will be added
             at the root of the submenu.
         """
         if sub_menu:
             try:
                 mnu = self._sub_menus[sub_menu]
             except KeyError:
-                mnu = QtWidgets.QMenu(sub_menu)
+                mnu = QtWidgets.QMenu(sub_menu, self)
                 self.add_menu(mnu)
                 self._sub_menus[sub_menu] = mnu
             finally:
                 mnu.addAction(action)
         else:
             self._actions.append(action)
         action.setShortcutContext(QtCore.Qt.WidgetShortcut)
@@ -752,172 +776,254 @@
 
     def menus(self):
         """
         Returns the list of sub context menus.
         """
         return self._menus
 
-    @QtCore.Slot()
     def delete(self):
         """ Deletes the selected text """
         self.textCursor().removeSelectedText()
 
-    @QtCore.Slot()
     def goto_line(self):
         """
         Shows the *go to line dialog* and go to the selected line.
         """
         helper = TextHelper(self)
         line, result = DlgGotoLine.get_line(
             self, helper.current_line_nbr(), helper.line_count())
         if not result:
             return
         return helper.goto_line(line, move=True)
 
-    @QtCore.Slot()
     def rehighlight(self):
         """
         Calls ``rehighlight`` on the installed syntax highlighter mode.
         """
         if self.syntax_highlighter:
             self.syntax_highlighter.rehighlight()
 
-    @QtCore.Slot()
     def reset_zoom(self):
         """
         Resets the zoom level.
         """
         self._zoom_level = 0
         self._reset_stylesheet()
 
-    @QtCore.Slot()
     def zoom_in(self, increment=1):
         """
         Zooms in the editor (makes the font bigger).
 
         :param increment: zoom level increment. Default is 1.
         """
+        # When called through an action, the first argument is a bool
+        if isinstance(increment, bool):
+            increment = 1
         self.zoom_level += increment
         TextHelper(self).mark_whole_doc_dirty()
         self._reset_stylesheet()
 
-    @QtCore.Slot()
     def zoom_out(self, decrement=1):
         """
         Zooms out the editor (makes the font smaller).
 
         :param decrement: zoom level decrement. Default is 1. The value is
             given as an absolute value.
         """
+        # When called through an action, the first argument is a bool
+        if isinstance(decrement, bool):
+            decrement = 1
         self.zoom_level -= decrement
         # make sure font size remains > 0
         if self.font_size + self.zoom_level <= 0:
             self.zoom_level = -self._font_size + 1
         TextHelper(self).mark_whole_doc_dirty()
         self._reset_stylesheet()
 
-    @QtCore.Slot()
     def duplicate_line(self):
         """
         Duplicates the line under the cursor. If multiple lines are selected,
         only the last one is duplicated.
         """
         cursor = self.textCursor()
-        assert isinstance(cursor, QtGui.QTextCursor)
-        has_selection = True
+        orig_pos = cursor.position()
         if not cursor.hasSelection():
-            cursor.select(cursor.LineUnderCursor)
+            cursor.select(cursor.BlockUnderCursor)
             has_selection = False
-        line = cursor.selectedText()
-        line = '\n'.join(line.split('\u2029'))
+        else:
+            # Select the full lines, in case one of the lines was only partly
+            # selected. Except when the cursor is at the start of an otherwise
+            # unselected line, because that feels unintuitive.
+            has_selection = True
+            start = cursor.selectionStart()
+            end = cursor.selectionEnd()
+            if cursor.atBlockStart():
+                end -= 1
+            cursor.setPosition(start, cursor.MoveAnchor)
+            cursor.movePosition(cursor.StartOfBlock, cursor.MoveAnchor)
+            cursor.setPosition(end, cursor.KeepAnchor)
+            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+        line = cursor.selectedText().replace('\u2029', '\n')
+        if has_selection or not line.startswith('\n'):
+            line = '\n' + line
         end = cursor.selectionEnd()
         cursor.setPosition(end)
         cursor.beginEditBlock()
-        cursor.insertText('\n')
         cursor.insertText(line)
         cursor.endEditBlock()
         if has_selection:
+            # Restore the original multiline selection
             pos = cursor.position()
             cursor.setPosition(end + 1)
             cursor.setPosition(pos, cursor.KeepAnchor)
+        else:
+            # Restore the original cursor position, but one line down
+            cursor.setPosition(orig_pos + len(line))
         self.setTextCursor(cursor)
 
-    @QtCore.Slot()
     def indent(self):
         """
         Indents the text cursor or the selection.
 
         Emits the :attr:`pyqode.core.api.CodeEdit.indent_requested`
         signal, the :class:`pyqode.core.modes.IndenterMode` will
         perform the actual indentation.
         """
         self.indent_requested.emit()
 
-    @QtCore.Slot()
     def un_indent(self):
         """
         Un-indents the text cursor or the selection.
 
         Emits the :attr:`pyqode.core.api.CodeEdit.unindent_requested`
         signal, the :class:`pyqode.core.modes.IndenterMode` will
         perform the actual un-indentation.
         """
         self.unindent_requested.emit()
 
     def eventFilter(self, obj, event):
         if obj == self and event.type() == QtCore.QEvent.KeyPress:
             if event.key() == QtCore.Qt.Key_X and \
-                    int(event.modifiers()) == QtCore.Qt.ControlModifier:
+                    event.modifiers() == QtCore.Qt.ControlModifier:
                 self.cut()
                 return True
             if event.key() == QtCore.Qt.Key_C and \
-                    int(event.modifiers()) == QtCore.Qt.ControlModifier:
+                    event.modifiers() == QtCore.Qt.ControlModifier:
                 self.copy()
                 return True
         return False
 
     def cut(self):
         """
-        Cuts the selected text or the whole line if no text was selected.
+        Cuts the selected text or the whole line if no text was selected. When
+        cutting a full line that consists of only whitespace, the line is only
+        deleted, to avoid overwriting the clipboard with whitespace.
         """
+
         tc = self.textCursor()
-        helper = TextHelper(self)
         tc.beginEditBlock()
-        no_selection = False
-        if not helper.current_line_text():
-            tc.deleteChar()
+        if not tc.hasSelection():
+            # Select the full line
+            tc.movePosition(tc.StartOfBlock)
+            tc.movePosition(tc.EndOfBlock, tc.KeepAnchor)
+            if tc.atEnd():
+                # If we're at the end of the document, select the previous
+                # newline. This will make the cursor jump up, which is why we
+                # don't do it otherwise.
+                tc.movePosition(tc.StartOfBlock)
+                tc.movePosition(tc.Left)
+                tc.movePosition(tc.Right, tc.KeepAnchor)
+                tc.movePosition(tc.EndOfBlock, tc.KeepAnchor)
+            else:
+                # Else select the next newline. This will avoid the cursor
+                # from jumping.
+                tc.movePosition(tc.Right, tc.KeepAnchor)
+            from_selection = False
+        else:
+            from_selection = True
+        if from_selection or tc.selectedText().strip():
+            need_cut = True
         else:
-            if not self.textCursor().hasSelection():
-                no_selection = True
-                TextHelper(self).select_whole_line()
-            super(CodeEdit, self).cut()
-            if no_selection:
-                tc.deleteChar()
+            tc.removeSelectedText()
+            need_cut = False
         tc.endEditBlock()
         self.setTextCursor(tc)
+        super(CodeEdit, self).cut()
 
     def copy(self):
         """
         Copy the selected text to the clipboard. If no text was selected, the
         entire line is copied (this feature can be turned off by
         setting :attr:`select_line_on_copy_empty` to False.
         """
         if self.select_line_on_copy_empty and not self.textCursor().hasSelection():
             TextHelper(self).select_whole_line()
         super(CodeEdit, self).copy()
 
+    def swapLineUp(self):
+        self.__swapLine(True)
+
+    def swapLineDown(self):
+        self.__swapLine(False)
+
+    def __swapLine(self, up):
+        has_selection = self.textCursor().hasSelection()
+        helper = TextHelper(self)
+        # Remember the cursor position so that we can restore it later
+        line, column = helper.cursor_position()
+        # Check the range that we're going to move and verify that it stays
+        # within the document boundaries
+        start_index, end_index = helper.selection_range()
+        if up:
+            start_index -= 1
+            if start_index < 0:
+                return
+        else:
+            end_index += 1
+            if end_index >= helper.line_count():
+                return
+        # Select the current lines and the line that will be swapped, turn
+        # them into a list, and then perform the swap on this list
+        helper.select_lines(start_index, end_index, select_blocks=True)
+        lines = helper.selected_text().replace(u'\u2029', u'\n').split(u'\n')
+        if up:
+            lines = lines[1:] + [lines[0]]
+        else:
+            lines = [lines[-1]] + lines[:-1]
+        # Replace the selected text by the swapped text in a single undo action
+        cursor = self.textCursor()
+        cursor.beginEditBlock()
+        cursor.insertText(u'\n'.join(lines))
+        cursor.endEditBlock()
+        self.setTextCursor(cursor)
+        if has_selection:
+            # If text was originally selected, select the range again
+            if up:
+                helper.select_lines(start_index, end_index - 1,
+                                    select_blocks=True)
+            else:
+                helper.select_lines(start_index + 1, end_index,
+                                    select_blocks=True)
+        else:
+            # Else restore cursor position, while moving with the swap
+            helper.goto_line(line - 1 if up else line + 1, column)
+
     def resizeEvent(self, e):
         """
         Overrides resize event to resize the editor's panels.
 
         :param e: resize event
         """
         super(CodeEdit, self).resizeEvent(e)
         self.panels.resize()
 
+    def closeEvent(self, e):
+        self.close()
+        super(CodeEdit, self).closeEvent(e)
+
     def paintEvent(self, e):
         """
         Overrides paint event to update the list of visible blocks and emit
         the painted event.
 
         :param e: paint event
         """
@@ -945,17 +1051,17 @@
                 self.indent()
                 event.accept()
             elif event.key() == QtCore.Qt.Key_Backtab and \
                     event.modifiers() == QtCore.Qt.NoModifier:
                 self.un_indent()
                 event.accept()
             elif event.key() == QtCore.Qt.Key_Home and \
-                    int(event.modifiers()) & QtCore.Qt.ControlModifier == 0:
+                    event.modifiers() & QtCore.Qt.ControlModifier == 0:
                 self._do_home_key(
-                    event, int(event.modifiers()) & QtCore.Qt.ShiftModifier)
+                    event, event.modifiers() & QtCore.Qt.ShiftModifier)
             if not event.isAccepted():
                 event.setAccepted(initial_state)
                 super(CodeEdit, self).keyPressEvent(event)
         new_state = event.isAccepted()
         event.setAccepted(state)
         self.post_key_pressed.emit(event)
         event.setAccepted(new_state)
@@ -990,15 +1096,15 @@
         :param event: QFocusEvent
         """
         self.focused_in.emit(event)
         super(CodeEdit, self).focusInEvent(event)
 
     def focusOutEvent(self, event):
         # Saves content if save_on_focus_out is True.
-        if self.save_on_focus_out and self.dirty and self.file.path:
+        if self._save_on_focus_out and self.dirty and self.file.path:
             self.file.save()
         super(CodeEdit, self).focusOutEvent(event)
 
     def mousePressEvent(self, event):
         """
         Overrides mousePressEvent to emits mouse_pressed signal
 
@@ -1009,17 +1115,31 @@
         self.mouse_pressed.emit(event)
         if event.button() == QtCore.Qt.LeftButton:
             cursor = self.cursorForPosition(event.pos())
             for sel in self.decorations:
                 if sel.cursor.blockNumber() == cursor.blockNumber():
                     if sel.contains_cursor(cursor):
                         sel.signals.clicked.emit(sel)
-        if not event.isAccepted():
-            event.setAccepted(initial_state)
+        if event.isAccepted():
+            return
+        event.setAccepted(initial_state)
+        if event.button() == QtCore.Qt.RightButton:
             super(CodeEdit, self).mousePressEvent(event)
+            return
+        # When line wrapping is enabled, the cursor is always placed on the
+        # first line. This appears to a bug in Qt, not in PyQode. The
+        # workaround below checks if cursor is actually moved to the target
+        # position. If not, the cursor is explicitly moved to it.
+        target_pos = self.cursorForPosition(event.pos()).positionInBlock()
+        super(CodeEdit, self).mousePressEvent(event)
+        cursor = self.textCursor()
+        actual_pos = cursor.positionInBlock()
+        if target_pos > actual_pos:
+            cursor.movePosition(cursor.Right, n=target_pos - actual_pos)
+            self.setTextCursor(cursor)
 
     def mouseReleaseEvent(self, event):
         """
         Emits mouse_released signal.
 
         :param event: QMouseEvent
         """
@@ -1078,15 +1198,15 @@
     def showEvent(self, event):
         """ Overrides showEvent to update the viewport margins """
         super(CodeEdit, self).showEvent(event)
         self.panels.refresh()
 
     def setReadOnly(self, read_only):
         if read_only != self.isReadOnly():
-            super().setReadOnly(read_only)
+            super(CodeEdit, self).setReadOnly(read_only)
             from pyqode.core.panels import ReadOnlyPanel
             try:
                 panel = self.panels.get(ReadOnlyPanel)
             except KeyError:
                 self.panels.append(
                     ReadOnlyPanel(), ReadOnlyPanel.Position.TOP)
             else:
@@ -1094,15 +1214,15 @@
 
     def get_context_menu(self):
         """
         Gets the editor context menu.
 
         :return: QMenu
         """
-        mnu = QtWidgets.QMenu()
+        mnu = QtWidgets.QMenu(self)
         mnu.addActions(self._actions)
         mnu.addSeparator()
         for menu in self._menus:
             mnu.addMenu(menu)
         return mnu
 
     def _show_context_menu(self, point):
@@ -1125,15 +1245,16 @@
         else:
             options.setFlags(
                 options.flags() & ~QtGui.QTextOption.ShowTabsAndSpaces)
         doc.setDefaultTextOption(options)
 
     def _init_actions(self, create_standard_actions):
         """ Init context menu action """
-        menu_advanced = QtWidgets.QMenu(_('Advanced'))
+        menu_advanced = QtWidgets.QMenu(_('Advanced'), self)
+        menu_advanced.setIcon(icons.icon(qta_name='fa.file-text'))
         self.add_menu(menu_advanced)
         self._sub_menus = {
             'Advanced': menu_advanced
         }
         if create_standard_actions:
             # Undo
             action = QtWidgets.QAction(_('Undo'), self)
@@ -1178,18 +1299,35 @@
                 'edit-paste', ':/pyqode-icons/rc/edit-paste.png',
                 'fa.paste'))
             action.triggered.connect(self.paste)
             self.add_action(action, sub_menu=None)
             self.action_paste = action
         # duplicate line
         action = QtWidgets.QAction(_('Duplicate line'), self)
+        action.setIcon(icons.icon(qta_name='fa.copy'))
         action.setShortcut('Ctrl+D')
         action.triggered.connect(self.duplicate_line)
         self.add_action(action, sub_menu=None)
         self.action_duplicate_line = action
+        # swap line up
+        action = QtWidgets.QAction(_('Swap line up'), self)
+        action.setIcon(icons.icon(qta_name='fa.arrow-up'))
+        action.setShortcut(QtGui.QKeySequence(
+            QtCore.Qt.AltModifier | QtCore.Qt.Key_Up))
+        action.triggered.connect(self.swapLineUp)
+        self.add_action(action, sub_menu=None)
+        self.action_swap_line_up = action
+        # swap line down
+        action = QtWidgets.QAction(_('Swap line down'), self)
+        action.setIcon(icons.icon(qta_name='fa.arrow-down'))
+        action.setShortcut(QtGui.QKeySequence(
+            QtCore.Qt.AltModifier | QtCore.Qt.Key_Down))
+        action.triggered.connect(self.swapLineDown)
+        self.add_action(action, sub_menu=None)
+        self.action_swap_line_down = action
         # select all
         action = QtWidgets.QAction(_('Select all'), self)
         action.setShortcut(QtGui.QKeySequence.SelectAll)
         action.triggered.connect(self.selectAll)
         self.action_select_all = action
         self.add_action(self.action_select_all, sub_menu=None)
         self.add_separator(sub_menu=None)
@@ -1248,33 +1386,38 @@
         block = self.firstVisibleBlock()
         block_nbr = block.blockNumber()
         top = int(self.blockBoundingGeometry(block).translated(
             self.contentOffset()).top())
         bottom = top + int(self.blockBoundingRect(block).height())
         ebottom_top = 0
         ebottom_bottom = self.height()
+        first_block = True
         while block.isValid():
             visible = (top >= ebottom_top and bottom <= ebottom_bottom)
-            if not visible:
+            if not visible and not first_block:
                 break
-            if block.isVisible():
+            first_block = False
+            if visible and block.isVisible():
                 self._visible_blocks.append((top, block_nbr, block))
             block = block.next()
             top = bottom
             bottom = top + int(self.blockBoundingRect(block).height())
             block_nbr = block.blockNumber()
 
     def _on_text_changed(self):
         """ Adjust dirty flag depending on editor's content """
         if not self._cleaning:
             ln = TextHelper(self).cursor_position()[0]
             self._modified_lines.add(ln)
 
+
     def _reset_stylesheet(self):
         """ Resets stylesheet"""
+        # This function is called very often during initialization, which
+        # impacts performance. This is a hack to avoid this.
         self.setFont(QtGui.QFont(self._font_family,
                                  self._font_size + self._zoom_level))
         flg_stylesheet = hasattr(self, '_flg_stylesheet')
         if QtWidgets.QApplication.instance().styleSheet() or flg_stylesheet:
             self._flg_stylesheet = True
             # On Window, if the application once had a stylesheet, we must
             # keep on using a stylesheet otherwise strange colors appear
@@ -1305,25 +1448,37 @@
             p.setColor(QtGui.QPalette.HighlightedText,
                        self.selection_foreground)
             self.setPalette(p)
         self.repaint()
 
     def _do_home_key(self, event=None, select=False):
         """ Performs home key action """
-        # get nb char to first significative char
-        delta = (self.textCursor().positionInBlock() -
-                 TextHelper(self).line_indent())
         cursor = self.textCursor()
         move = QtGui.QTextCursor.MoveAnchor
         if select:
             move = QtGui.QTextCursor.KeepAnchor
-        if delta > 0:
-            cursor.movePosition(QtGui.QTextCursor.Left, move, delta)
+        indent = TextHelper(self).line_indent()
+        # Scenario 1: We're on an unindented block. In that case, we jump back
+        # to the start of the visible line, but not all the way to the back of
+        # the block. This is what you would expect when working with text and
+        # line wrapping is enabled.
+        if not indent:
+            cursor.movePosition(QtGui.QTextCursor.StartOfLine, move)
         else:
-            cursor.movePosition(QtGui.QTextCursor.StartOfBlock, move)
+            delta = self.textCursor().positionInBlock() - indent
+            # Scenario 2: We're on an indented block. In that case, we move
+            # back to the indented position. This is what you would expect when
+            # working with code.
+            if delta > 0:
+                cursor.movePosition(QtGui.QTextCursor.Left, move, delta)
+            # Scenario 3: We're on an indented block, but we're already at the
+            # start of the indentation. In that case, we jump back to the
+            # beginning of the block.
+            else:
+                cursor.movePosition(QtGui.QTextCursor.StartOfBlock, move)
         self.setTextCursor(cursor)
         if event:
             event.accept()
 
     def _emit_dirty_changed(self, state):
         self.dirty_changed.emit(state)
         for c in self.clones:
```

## pyqode/core/api/folding.py

```diff
@@ -130,14 +130,28 @@
         :param prev_block: first previous **non-blank** block or None if this
             is the first line of the document
         :param block: The block to process.
         :return: Fold level
         """
         raise NotImplementedError
 
+    def require_rehighlight(self, from_block, to_block):
+        """
+        Indicates whether the entire document should be rehighlighted by the
+        syntax highlighter. This can be necessary in case a block is edited in
+        such a way that it changes the folding structure throughout the
+        document.
+        
+        :param from_block: The block before a key press. This is a block
+            number, block text tuple.
+        :param to_block: The block after a key press. This is a block
+            number, block text tuple.
+        """
+        return False
+    
 
 class IndentFoldDetector(FoldDetector):
     """
     Simple fold detector based on the line indentation level
     """
 
     def detect_fold_level(self, prev_block, block):
```

## pyqode/core/backend/workers.py

```diff
@@ -12,28 +12,27 @@
     This module should keep its dependencies as low as possible and fully
     supports python2 syntax. This is badly needed since the server might be run
     with a python2 interpreter. We don't want to force the user to install all
     the pyqode dependencies twice (if the user choose to run the server with
     python2, which might happen in pyqode.python to support python2 syntax).
 
 """
-import logging
+import os
 import re
 import sys
 import traceback
 
 
 def echo_worker(data):
     """
     Example of worker that simply echoes back the received data.
 
     :param data: Request data dict.
     :returns: True, data
     """
-    print('echo worker running')
     return data
 
 
 class CodeCompletionWorker(object):
     """
     This is the worker associated with the code completion mode.
 
@@ -62,15 +61,16 @@
         and have the expected signature::
 
             def complete(self, code, line, column, path, encoding, prefix):
                 pass
 
         """
 
-        def complete(self, code, line, column, path, encoding, prefix):
+        def complete(self, code, line, column, path,
+                     encoding, prefix, triggered_by_symbol):
             """
             Returns a list of completions.
 
             A completion is dictionary with the following keys:
 
                 - 'name': name of the completion, this the text displayed and
                   inserted when the user select a completion in the list
@@ -79,14 +79,16 @@
 
             :param code: code string
             :param line: line number (0 based)
             :param column: column number (0 based)
             :param path: file path
             :param encoding: file encoding
             :param prefix: completion prefix (text before cursor)
+            :param triggered_by_symbol: True if the completion was triggered
+                by typing a completion character such as '.'
 
             :returns: A list of completion dicts as described above.
             :rtype: list
             """
             raise NotImplementedError()
 
     def __call__(self, data):
@@ -97,19 +99,27 @@
         code = data['code']
         line = data['line']
         column = data['column']
         path = data['path']
         encoding = data['encoding']
         prefix = data['prefix']
         req_id = data['request_id']
+        triggered_by_symbol = data['triggered_by_symbol']
         completions = []
         for prov in CodeCompletionWorker.providers:
             try:
                 results = prov.complete(
-                    code, line, column, path, encoding, prefix)
+                    code,
+                    line,
+                    column,
+                    path,
+                    encoding,
+                    prefix,
+                    triggered_by_symbol
+                )
                 completions.append(results)
                 if len(completions):
                     break
             except:
                 sys.stderr.write('Failed to get completions from provider %r'
                                  % prov)
                 exc1, exc2, exc3 = sys.exc_info()
@@ -240,7 +250,50 @@
             'case_sensitive': True to match case, False to ignore case
         }
     :return: list of occurrence positions in text
     """
     return list(findalliter(
         data['string'], data['sub'], regex=data['regex'],
         whole_word=data['whole_word'], case_sensitive=data['case_sensitive']))
+
+
+_image_annotations = {}
+
+
+def _meaningful_code(code):
+    """Strips code of comments and trailing whitespace. This avoids image
+    annotations from vanishing after trivial changes to the code. Markdown
+    images (# ![]) are preserverd because they are part of captured output.
+    """
+    code = code.replace('# ![]', '![]')
+    code = re.sub(r'(?m)#.*\n?', '\n', code)
+    code = '\n'.join([line.rstrip() for line in code.splitlines()])
+    return code
+
+
+def image_annotations(data):
+    """Returns a list of image annotations."""
+    haystack = _meaningful_code(data['code'])
+    ret_val = []
+    for needle, paths in _image_annotations.get(data['path'], {}).items():
+        n_match = 0
+        for path in paths:
+            if n_match > 2:  # Not more than two matches
+                break
+            if not os.path.exists(path):
+                continue
+            prev_pos = 0
+            while True:
+                pos = haystack.find(_meaningful_code(needle), prev_pos)
+                if pos < 0:
+                    break
+                prev_pos = pos + 1
+                line = haystack[:pos].count('\n')
+                ret_val.append(('Image', 0, line, None, None, None, path))
+                n_match += 1
+    return ret_val
+
+
+def set_image_annotations(data):
+    """Sets the image annotation data."""
+    global _image_annotations
+    _image_annotations = data
```

## pyqode/core/backend/server.py

```diff
@@ -167,15 +167,15 @@
         self.timeout = HEARTBEAT_DELAY
         self._Handler.srv = self
         socketserver.TCPServer.__init__(
             self, ('127.0.0.1', int(args.port)), self._Handler)
         print('started on 127.0.0.1:%d' % int(args.port))
         print('running with python %d.%d.%d' % (sys.version_info[:3]))
         self._heartbeat_thread = threading.Thread(target=self.heartbeat)
-        self._heartbeat_thread.setDaemon(True)
+        self._heartbeat_thread.daemon = True
         self._heartbeat_thread.start()
 
     def reset_heartbeat(self):
         self.last_time = time.time()
         self.elapsed_time = 0
 
     def heartbeat(self):
```

## pyqode/core/dialogs/encodings.py

```diff
@@ -2,15 +2,15 @@
 This module contains some dialogs to help you manage encodings in
 you application.
 
 """
 import locale
 from pyqode.core import icons
 from pyqode.core.api import encodings
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
 from pyqode.core.cache import Cache
 from pyqode.core._forms import dlg_preferred_encodings_editor_ui
 
 
 class DlgPreferredEncodingsEditor(QtWidgets.QDialog):
     """
     This dialog is used to edit the preferred encodings that appears in
@@ -173,8 +173,8 @@
         return dlg.ui.comboBoxEncodings.current_encoding
 
 
 if __name__ == '__main__':
     import sys
     app = QtWidgets.QApplication(sys.argv)
     new_encoding = DlgEncodingsChoice.choose_encoding(None, __file__, 'utf-8')
-    print(new_encoding)
+    print(new_encoding)
```

## pyqode/core/dialogs/goto.py

```diff
@@ -1,12 +1,12 @@
 """
 This module contains the go to line dialog.
 """
 from pyqode.core._forms import dlg_goto_line_ui
-from pyqode.qt import QtWidgets
+from qtpy import QtWidgets
 
 
 class DlgGotoLine(QtWidgets.QDialog, dlg_goto_line_ui.Ui_Dialog):
     """
     Goto line dialog.
     """
     def __init__(self, parent, current_line, line_count):
@@ -35,8 +35,8 @@
 
         :returns: tuple(line, status) status is False if the dialog has been
             rejected.
         """
         dlg = DlgGotoLine(parent, current_line + 1, line_count)
         if dlg.exec_() == dlg.Accepted:
             return dlg.spinBox.value() - 1, True
-        return current_line, False
+        return current_line, False
```

## pyqode/core/dialogs/unsaved_files.py

```diff
@@ -1,13 +1,13 @@
 """
 This module contains the unsaved files dialog.
 """
-from pyqode.qt.QtWidgets import QDialog
+from qtpy.QtWidgets import QDialog
 from pyqode.core._forms.dlg_unsaved_files_ui import Ui_Dialog
-from pyqode.qt import QtWidgets, QtCore
+from qtpy import QtWidgets, QtCore
 
 
 class DlgUnsavedFiles(QDialog, Ui_Dialog):
     """
     This dialog shows the list of unsaved file in the CodeEditTabWidget.
 
     Use can choose to:
@@ -50,8 +50,8 @@
         if nb_items == 0:
             self.bt_save_all.setText(_("Save"))
             self.bt_save_all.setEnabled(False)
         else:
             self.bt_save_all.setEnabled(True)
             self.bt_save_all.setText(_("Save selected"))
             if nb_items == self.listWidget.count():
-                self.bt_save_all.setText(_("Save all"))
+                self.bt_save_all.setText(_("Save all"))
```

## pyqode/core/managers/backend.py

```diff
@@ -1,15 +1,15 @@
 """
 This module contains the backend controller
 """
 import logging
 import socket
 import sys
-from pyqode.qt import QtCore
-
+import string
+from qtpy import QtCore
 from pyqode.core.api.client import JsonTcpClient, BackendProcess
 from pyqode.core.api.manager import Manager
 from pyqode.core.backend import NotRunning, echo_worker
 
 
 def _logger():
     return logging.getLogger(__name__)
@@ -32,42 +32,46 @@
     exposes an API to easily control the backend:
 
         - start
         - stop
         - send_request
 
     """
-    LAST_PORT = None
-    LAST_PROCESS = None
-    SHARE_COUNT = 0
+    LAST_PORT = {}
+    LAST_PROCESS = {}
+    SHARE_COUNT = {}
+    MAX_SHARE_COUNT = 10
+    share_id_count = 0
+    HEARTBEAT_INTERVAL = 5000
 
     def __init__(self, editor):
         super(BackendManager, self).__init__(editor)
         self._process = None
         self._sockets = []
         self.server_script = None
         self.interpreter = None
         self.args = None
         self._shared = False
+        self._share_id = None
         self._heartbeat_timer = QtCore.QTimer()
-        self._heartbeat_timer.setInterval(1000)
+        self._heartbeat_timer.setInterval(BackendManager.HEARTBEAT_INTERVAL)
         self._heartbeat_timer.timeout.connect(self._send_heartbeat)
         self._heartbeat_timer.start()
 
     @staticmethod
     def pick_free_port():
         """ Picks a free port """
         test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         test_socket.bind(('127.0.0.1', 0))
         free_port = int(test_socket.getsockname()[1])
         test_socket.close()
         return free_port
 
     def start(self, script, interpreter=sys.executable, args=None,
-              error_callback=None, reuse=False):
+              error_callback=None, reuse=False, share_id=None):
         """
         Starts the backend process.
 
         The backend is a python script that starts a
         :class:`pyqode.core.backend.JsonServer`. You must write the backend
         script so that you can apply your own backend configuration.
 
@@ -84,118 +88,207 @@
         :param args: list of additional command line args to use to start
             the backend process.
         :param reuse: True to reuse an existing backend process. WARNING: to
             use this, your application must have one single server script. If
             you're creating an app which supports multiple programming
             languages you will need to merge all backend scripts into one
             single script, otherwise the wrong script might be picked up).
-        """
+        :param share_id: Used to separate different backend types that should
+            be shared, for example for example for different languages. When
+            the maximum number of shares is exceeded, a new backend process is
+            started automatically.
+        """
+        # If no share id is specified, we generate a new unique share id.
+        if share_id is None:
+            share_id = 'unique{}'.format(BackendManager.share_id_count)
+            BackendManager.share_id_count += 1
+        # Else we suffix the share id with a number, and make sure that no
+        # backend process is shared more than the maximum number of share
+        # counts. This is necessary, because otherwise too many sockets will
+        # interfere with each other. If the share id is already suffixed, this
+        # is a restart that should use the original share id.
+        elif share_id[-1] not in string.digits:
+            i = 1
+            while len(BackendManager.SHARE_COUNT.get(
+                '{}{}'.format(share_id, i), []
+            )) >= BackendManager.MAX_SHARE_COUNT:
+                i += 1
+            share_id = '{}{}'.format(share_id, i)
+        self._share_id = share_id
         self._shared = reuse
-        if reuse and BackendManager.SHARE_COUNT:
-            self._port = BackendManager.LAST_PORT
-            self._process = BackendManager.LAST_PROCESS
-            BackendManager.SHARE_COUNT += 1
+        self.server_script = script
+        self.interpreter = interpreter
+        self.args = args
+        # If the current share id doesn't exist yet, register it.
+        if self._share_id not in BackendManager.SHARE_COUNT:
+            comm('new share_id: {}'.format(self._share_id))
+            BackendManager.SHARE_COUNT[self._share_id] = []
+        # The current editor doesn't count as being one of the users of the
+        # backend, so remove any references to this editor.
+        BackendManager.SHARE_COUNT[self._share_id] = [
+            id_ for id_ in BackendManager.SHARE_COUNT[self._share_id]
+            if id_ != self._editor
+        ]
+        # If we want to re-use existing backends, and a backend process is
+        # already running, re-use it. We register the editor, so that we
+        # can know, later on, if the backend was already stopped for this
+        # editor, in case the editor is closed multiple times.
+        if reuse and BackendManager.SHARE_COUNT[self._share_id]:
+            self._port = BackendManager.LAST_PORT[self._share_id]
+            self._process = BackendManager.LAST_PROCESS[self._share_id]
+            BackendManager.SHARE_COUNT[self._share_id].append(self._editor)
+            comm('re-using share_id: {} ({})'.format(
+                self._share_id,
+                len(BackendManager.SHARE_COUNT[self._share_id])
+            ))
+            return
+        if self.running:
+            comm('stopping share_id: {}'.format(self._share_id))
+            self.stop()
+        backend_script = script.replace('.pyc', '.py')
+        self._port = self.pick_free_port()
+        if hasattr(sys, "frozen") and not backend_script.endswith('.py'):
+            # frozen backend script on windows/mac does not need an
+            # interpreter
+            program = backend_script
+            pgm_args = [str(self._port)]
         else:
-            if self.running:
-                self.stop()
-            self.server_script = script
-            self.interpreter = interpreter
-            self.args = args
-            backend_script = script.replace('.pyc', '.py')
-            self._port = self.pick_free_port()
-            if hasattr(sys, "frozen") and not backend_script.endswith('.py'):
-                # frozen backend script on windows/mac does not need an
-                # interpreter
-                program = backend_script
-                pgm_args = [str(self._port)]
-            else:
-                program = interpreter
-                pgm_args = [backend_script, str(self._port)]
-            if args:
-                pgm_args += args
-            self._process = BackendProcess(self.editor)
-            if error_callback:
-                self._process.error.connect(error_callback)
-            self._process.start(program, pgm_args)
-
-            if reuse:
-                BackendManager.LAST_PROCESS = self._process
-                BackendManager.LAST_PORT = self._port
-                BackendManager.SHARE_COUNT += 1
-            comm('starting backend process: %s %s', program,
-                 ' '.join(pgm_args))
-            self._heartbeat_timer.start()
+            program = interpreter
+            pgm_args = [backend_script, str(self._port)]
+        if args:
+            pgm_args += args
+        self._process = BackendProcess(self.editor)
+        if error_callback:
+            self._process.error.connect(error_callback)
+        self._process.start(program, pgm_args)
+        if reuse:
+            BackendManager.LAST_PROCESS[self._share_id] = self._process
+            BackendManager.LAST_PORT[self._share_id] = self._port
+            BackendManager.SHARE_COUNT[self._share_id].append(self._editor)
+        comm('starting share_id: {} (PID={})'.format(
+            self._share_id, self._process.processId()
+        ))
+        self._heartbeat_timer.start()
+
+    def suspend(self):
+        """
+        Stops the backend process in such a way that it can be restarted with
+        resume().
+        """
+        comm('suspending share_id: {}'.format(self._share_id))
+        self.stop()
+
+    def resume(self):
+        """
+        Resumes a stopped backend process.
+        """
+        comm('resuming share_id: {}'.format(self._share_id))
+        self.start(
+            self.server_script,
+            interpreter=self.interpreter,
+            args=self.args,
+            reuse=self._shared,
+            share_id=self._share_id
+        )
 
     def stop(self):
         """
         Stops the backend process.
         """
         if self._process is None:
+            comm('no process to stop for share_id: {}'.format(self._share_id))
             return
         if self._shared:
-            BackendManager.SHARE_COUNT -= 1
-            if BackendManager.SHARE_COUNT:
+            # Remove the current editor from the list of editors that are using
+            # this shared backend
+            if self._editor in BackendManager.SHARE_COUNT[self._share_id]:
+                BackendManager.SHARE_COUNT[self._share_id].remove(self._editor)
+            # There are still editors using this backend, don't close
+            if BackendManager.SHARE_COUNT[self._share_id]:
+                comm('not yet stopping share_id: {} ({})'.format(
+                    self._share_id,
+                    len(BackendManager.SHARE_COUNT[self._share_id])
+                ))
                 return
-        comm('stopping backend process')
+        comm('stopping share_id: {} ({})'.format(
+            self._share_id,
+            len(BackendManager.SHARE_COUNT[self._share_id])
+        ))
         # close all sockets
         for s in self._sockets:
             s._callback = None
             s.close()
-
         self._sockets[:] = []
         # prevent crash logs from being written if we are busy killing
         # the process
         self._process._prevent_logs = True
-        while self._process.state() != self._process.NotRunning:
+        while True:
+            try:
+                running = self._process.state() != self._process.NotRunning
+            except RuntimeError:
+                # Under some (hard to reproduce) conditions, the underlying
+                # process object is already deleted at this pont, resulting
+                # in a RuntimeError.
+                break
+            if not running:
+                break
             self._process.waitForFinished(1)
             if sys.platform == 'win32':
                 # Console applications on Windows that do not run an event
                 # loop, or whose event loop does not handle the WM_CLOSE
                 # message, can only be terminated by calling kill().
                 self._process.kill()
             else:
                 self._process.terminate()
         self._process._prevent_logs = False
         self._heartbeat_timer.stop()
-        comm('backend process terminated')
+        comm('stopped share_id: {}'.format(self._share_id))
 
     def send_request(self, worker_class_or_function, args, on_receive=None):
         """
         Requests some work to be done by the backend. You can get notified of
         the work results by passing a callback (on_receive).
 
         :param worker_class_or_function: Worker class or function
         :param args: worker args, any Json serializable objects
         :param on_receive: an optional callback executed when we receive the
             worker's results. The callback will be called with one arguments:
             the results of the worker (object)
-
-        :raise: backend.NotRunning if the backend process is not running.
         """
         if not self.running:
+            if not BackendManager.SHARE_COUNT.get(self._share_id, []):
+                comm('not restarting unused share_id: {}'.format(
+                    self._share_id)
+                )
+                self._heartbeat_timer.stop()
+                return
+            comm('restarting share_id: {}'.format(self._share_id))
             try:
                 # try to restart the backend if it crashed.
-                self.start(self.server_script, interpreter=self.interpreter,
-                           args=self.args)
-            except AttributeError:
-                pass  # not started yet
-            finally:
-                # caller should try again, later
-                raise NotRunning()
-        else:
-            comm('sending request, worker=%r' % worker_class_or_function)
-            # create a socket, the request will be send as soon as the socket
-            # has connected
-            socket = JsonTcpClient(
-                self.editor, self._port, worker_class_or_function, args,
-                on_receive=on_receive)
-            socket.finished.connect(self._rm_socket)
-            self._sockets.append(socket)
-            # restart heartbeat timer
-            self._heartbeat_timer.start()
+                self.start(
+                    self.server_script,
+                    interpreter=self.interpreter,
+                    args=self.args,
+                    reuse=self._shared,
+                    share_id=self._share_id
+                )
+            except AttributeError as e:
+                comm('failed to restart share_id: {}, Exception: {}'.format(
+                    self._share_id, e
+                ))
+            return
+        # create a socket, the request will be send as soon as the socket
+        # has connected
+        socket = JsonTcpClient(
+            self.editor, self._port, worker_class_or_function, args,
+            on_receive=on_receive)
+        socket.finished.connect(self._rm_socket)
+        self._sockets.append(socket)
+        # restart heartbeat timer
+        self._heartbeat_timer.start()
 
     def _send_heartbeat(self):
         try:
             self.send_request(echo_worker, {'heartbeat': True})
         except NotRunning:
             self._heartbeat_timer.stop()
 
@@ -237,8 +330,8 @@
         Returns the backend process exit status or None if the
         process is till running.
 
         """
         if self.running:
             return None
         else:
-            return self._process.exitCode()
+            return self._process.exitCode()
```

## pyqode/core/managers/modes.py

```diff
@@ -46,33 +46,17 @@
 
     def clear(self):
         """
         Removes all modes from the editor. All modes are removed from list
         and deleted.
 
         """
-        import sys
         while len(self._modes):
             key = sorted(list(self._modes.keys()))[0]
-            mode = self.remove(key)
-            refcount = sys.getrefcount(mode)
-            if refcount > 2:
-                try:
-                    import objgraph
-                except ImportError:
-                    _logger().warning(
-                        'potential memory leak detected on mode %r...\n'
-                        'Install the objgraph package to know what objects are'
-                        ' holding references the mode.' % mode)
-                else:
-                    _logger().warning(
-                        'potential memory leak detected on mode: %r.\n'
-                        'see stderr for a backrefs dot graph...' % mode)
-                    objgraph.show_backrefs([mode], output=sys.stderr)
-            del mode
+            self.remove(key)
 
     def get(self, name_or_klass):
         """
         Gets a mode by name (or class)
 
         :param name_or_klass: The name or the class of the mode to get
         :type name_or_klass: str or type
```

## pyqode/core/managers/panels.py

```diff
@@ -76,36 +76,20 @@
         return self._panels[panel.position].pop(panel.name, None)
 
     def clear(self):
         """
         Removes all panel from the editor.
 
         """
-        import sys
         for i in range(4):
             while len(self._panels[i]):
                 key = sorted(list(self._panels[i].keys()))[0]
                 panel = self.remove(key)
                 panel.setParent(None)
                 panel.deleteLater()
-                refcount = sys.getrefcount(panel)
-                if refcount > 2:
-                    try:
-                        import objgraph
-                    except ImportError:
-                        _logger().warning(
-                            'potential memory leak detected on panel: %r\n'
-                            'Install the objgraph package to know what objects'
-                            ' are holding references the panel...', panel)
-                    else:
-                        _logger().warning(
-                            'potential memory leak detected on panel: %r\n'
-                            'see stderr for a backrefs dot graph...', panel)
-                        objgraph.show_backrefs([panel], output=sys.stderr)
-                del panel
 
     def get(self, name_or_klass):
         """
         Gets a specific panel instance.
 
         :param name_or_klass: Name or class of the panel to retrieve.
         :return: The specified panel instance.
@@ -121,21 +105,21 @@
                 return panel
         raise KeyError(name_or_klass)
 
     def keys(self):
         """
         Returns the list of installed panel names.
         """
-        return self._modes.keys()
+        return self._panels.keys()
 
     def values(self):
         """
         Returns the list of installed panels.
         """
-        return self._modes.values()
+        return self._panels.values()
 
     def __iter__(self):
         lst = []
         for zone, zone_dict in self._panels.items():
             for name, panel in zone_dict.items():
                 lst.append(panel)
         return iter(lst)
```

## pyqode/core/managers/file.py

```diff
@@ -9,15 +9,15 @@
     pass  # python 3.2 not supported
 import locale
 import logging
 import mimetypes
 import os
 from pyqode.core.api.manager import Manager
 from pyqode.core.api.utils import TextHelper
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
 from pyqode.core.cache import Cache
 
 
 # needed on windows
 mimetypes.add_type('text/x-python', '.py')
 mimetypes.add_type('text/xml', '.ui')
 
@@ -236,19 +236,17 @@
                 pass
             else:
                 encoding = cached_encoding
         enable_modes = os.path.getsize(path) < self._limit
         for m in self.editor.modes:
             if m.enabled:
                 m.enabled = enable_modes
-        if not enable_modes:
-            self.editor.modes.clear()
         # open file and get its content
         try:
-            with open(path, 'Ur', encoding=encoding) as file:
+            with open(path, 'r', encoding=encoding) as file:
                 content = file.read()
                 if self.autodetect_eol:
                     self._eol = file.newlines
                     if isinstance(self._eol, tuple):
                         self._eol = self._eol[0]
                     if self._eol is None:
                         # empty file has no newlines
@@ -398,38 +396,37 @@
             with open(tmp_path, 'wb') as file:
                 file.write(self._get_text(fallback_encoding))
         except (IOError, OSError) as e:
             self._rm(tmp_path)
             self.saving = False
             self.editor.text_saved.emit(str(path))
             raise e
-        else:
-            # cache update encoding
-            Cache().set_file_encoding(path, encoding)
-            self._encoding = encoding
-            # remove path and rename temp file, if safe save is on
-            if self.safe_save:
-                self._rm(path)
-                os.rename(tmp_path, path)
-                self._rm(tmp_path)
-            # reset dirty flags
-            self.editor.document().setModified(False)
-            # remember path for next save
-            self._path = os.path.normpath(path)
-            self.editor.text_saved.emit(str(path))
-            self.saving = False
-            _logger().debug('file saved: %s', path)
-            self._check_for_readonly()
+        # cache update encoding
+        Cache().set_file_encoding(path, encoding)
+        self._encoding = encoding
+        # remove path and rename temp file, if safe save is on
+        if self.safe_save:
+            self._rm(path)
+            os.rename(tmp_path, path)
+            self._rm(tmp_path)
+        # reset dirty flags
+        self.editor.document().setModified(False)
+        # remember path for next save
+        self._path = os.path.normpath(path)
+        self.editor.text_saved.emit(str(path))
+        self.saving = False
+        _logger().debug('file saved: %s', path)
+        self._check_for_readonly()
 
-            # restore file permission
-            if st_mode:
-                try:
-                    os.chmod(path, st_mode)
-                except (ImportError, TypeError, AttributeError):
-                    pass
+        # restore file permission
+        if st_mode:
+            try:
+                os.chmod(path, st_mode)
+            except (ImportError, TypeError, AttributeError):
+                pass
 
     def close(self, clear=True):
         """
         Close the file open in the editor:
             - clear editor content
             - reset file attributes to their default values
```

## pyqode/core/managers/decorations.py

```diff
@@ -10,32 +10,54 @@
 
 
 class TextDecorationsManager(Manager):
     """
     Manages the collection of TextDecoration that have been set on the editor
     widget.
     """
+    
     def __init__(self, editor):
         super(TextDecorationsManager, self).__init__(editor)
         self._decorations = []
+        self.editor.textChanged.connect(self._remove_decoration_around_cursor)
+        
+    def _remove_decoration_around_cursor(self):
+        """Removes the decorations around the cursor. This is necessary when
+        the text changes, because otherwise the decorations get dragged along
+        with the cursor during typing.
+        """
+        cursor = self.editor.textCursor()
+        to_remove = [
+            d for d in self._decorations
+            if d.contains_cursor(cursor, margin=1)
+        ]
+        for decoration in to_remove:
+            self.remove(decoration)
 
-    def append(self, decoration):
+    def append(self, decoration, set_on_editor=True):
         """
         Adds a text decoration on a CodeEdit instance
 
         :param decoration: Text decoration to add
         :type decoration: pyqode.core.api.TextDecoration
         """
         if decoration not in self._decorations:
             self._decorations.append(decoration)
             self._decorations = sorted(
                 self._decorations, key=lambda sel: sel.draw_order)
-            self.editor.setExtraSelections(self._decorations)
+            if set_on_editor:
+                self.editor.setExtraSelections(self._decorations)
             return True
         return False
+    
+    def set_on_editor(self):
+        """Sets the decorations on the editor. We don't do this after each
+        decoration (but after each batch) to improve performance.
+        """
+        self.editor.setExtraSelections(self._decorations)
 
     def remove(self, decoration):
         """
         Removes a text decoration from the editor.
 
         :param decoration: Text decoration to remove
         :type decoration: pyqode.core.api.TextDecoration
```

## pyqode/core/modes/__init__.py

```diff
@@ -4,53 +4,65 @@
 
 """
 from .autocomplete import AutoCompleteMode
 from .autoindent import AutoIndentMode
 from .backspace import SmartBackSpaceMode
 from .caret_line_highlight import CaretLineHighlighterMode
 from .case_converter import CaseConverterMode
+from .line_sorter import LineSorterMode
+from .calltips import CalltipsMode
 from .checker import CheckerMode
 from .checker import CheckerMessage
 from .checker import CheckerMessages
+from .comments import CommentsMode
 from .cursor_history import CursorHistoryMode
 from .code_completion import CodeCompletionMode
 from .extended_selection import ExtendedSelectionMode
 from .filewatcher import FileWatcherMode
 from .indenter import IndenterMode
 from .line_highlighter import LineHighlighterMode
 from .matcher import SymbolMatcherMode
 from .occurences import OccurrencesHighlighterMode
 from .outline import OutlineMode
 from .right_margin import RightMarginMode
 from .pygments_sh import PygmentsSH
 from .wordclick import WordClickMode
 from .zoom import ZoomMode
+from .spellchecker_mode import SpellCheckerMode
+from .image_annotations import ImageAnnotationsMode
+from .breakpoint import BreakpointMode
 # for backward compatibility
 from ..api.syntax_highlighter import PYGMENTS_STYLES
 from .pygments_sh import PygmentsSH as PygmentsSyntaxHighlighter
 
 
 __all__ = [
     'AutoCompleteMode',
     'AutoIndentMode',
+    'BreakpointMode',
     'CaretLineHighlighterMode',
     'CaseConverterMode',
     'CheckerMode',
     'CheckerMessage',
     'CheckerMessages',
     'CodeCompletionMode',
+    'CommentsMode',
     'CursorHistoryMode',
     'ExtendedSelectionMode',
     'FileWatcherMode',
     'IndenterMode',
+    'ImageAnnotationsMode',
     'LineHighlighterMode',
+    'LineSorterMode',
     'OccurrencesHighlighterMode',
     'OutlineMode',
     'PygmentsSH',
     'PygmentsSyntaxHighlighter',
     'PYGMENTS_STYLES',
     'RightMarginMode',
     'SmartBackSpaceMode',
+    'SpellCheckerMode',
     'SymbolMatcherMode',
     'WordClickMode',
     'ZoomMode',
+    
 ]
```

## pyqode/core/modes/autocomplete.py

```diff
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
 """ Contains the AutoCompleteMode """
 import logging
-from pyqode.qt import QtCore, QtGui
+from qtpy import QtCore, QtGui
 from pyqode.core.api import TextHelper
 from pyqode.core.api.mode import Mode
 
 
 class AutoCompleteMode(Mode):
     """ Automatically complete quotes and parentheses
 
@@ -14,95 +14,111 @@
 
         - " -> "
         - ' -> '
         - ( -> )
         - [ -> ]
         - { -> }
     """
-    #: Auto complete mapping, maps input key with completion text.
-    MAPPING = {'"': '"', "'": "'", "(": ")", "{": "}", "[": "]"}
-    #: The format to use for each symbol in mapping when there is a selection
-    SELECTED_QUOTES_FORMATS = {key: '%s%s%s' for key in MAPPING.keys()}
-    #: The format to use for each symbol in mapping when there is no selection
-    QUOTES_FORMATS = {key: '%s' for key in MAPPING.keys()}
-
     def __init__(self):
         super(AutoCompleteMode, self).__init__()
+        #: Auto complete mapping, maps input key with completion text.
+        self.MAPPING = {'"': '"', "'": "'", "(": ")", "{": "}", "[": "]"}
+        self.AVOID_DUPLICATES = ')', ']', '}'
+        #: The format to use for each symbol in mapping when there is a selection
+        self.SELECTED_QUOTES_FORMATS = {
+            key: '%s%s%s'
+            for key in self.MAPPING.keys()
+        }
+        #: The format to use for each symbol in mapping when there is no selection
+        self.QUOTES_FORMATS = {key: '%s' for key in self.MAPPING.keys()}
         self.logger = logging.getLogger(__name__)
         self._ignore_post = False
 
     def on_state_changed(self, state):
         if state:
             self.editor.post_key_pressed.connect(self._on_post_key_pressed)
             self.editor.key_pressed.connect(self._on_key_pressed)
         else:
             self.editor.post_key_pressed.disconnect(self._on_post_key_pressed)
             self.editor.key_pressed.disconnect(self._on_key_pressed)
+        self._helper = TextHelper(self.editor)
 
     def _on_post_key_pressed(self, event):
-        if not event.isAccepted() and not self._ignore_post:
-            txt = event.text()
-            trav = self.editor.textCursor()
-            assert isinstance(trav, QtGui.QTextCursor)
-            trav.movePosition(trav.Left, trav.MoveAnchor, 2)
-            literal = TextHelper(self.editor).is_comment_or_string(trav)
-            if not literal:
-                next_char = TextHelper(self.editor).get_right_character()
-                if txt in self.MAPPING:
-                    to_insert = self.MAPPING[txt]
-                    if (not next_char or next_char in self.MAPPING.keys() or
-                            next_char in self.MAPPING.values() or
-                            next_char.isspace()):
-                        TextHelper(self.editor).insert_text(
-                            self.QUOTES_FORMATS[txt] % to_insert)
-        self._ignore_post = False
+        if event.isAccepted() or self._ignore_post:
+            self._ignore_post = False
+            return
+        txt = event.text()
+        if txt not in self.MAPPING:
+            return
+        to_insert = self.MAPPING[txt]
+        if to_insert == txt:
+            # For quotes (characters that map onto themselves), we don't
+            # autocomplete if there's already an even number of characters.
+            # This avoids over-autocompleting quotes that are already balanced.
+            cursor = self.editor.textCursor()
+            before_cursor = cursor.block().text()[:cursor.positionInBlock()]
+            if not before_cursor.count(to_insert) % 2:
+                return
+        next_char = self._helper.get_right_character()
+        if (not next_char or next_char in self.MAPPING.keys() or
+                next_char in self.MAPPING.values() or
+                next_char.isspace()):
+            self._helper.insert_text(
+                self.QUOTES_FORMATS[txt] % to_insert
+            )
 
     def _on_key_pressed(self, event):
+        if event.isAccepted():
+            return
         txt = event.text()
         cursor = self.editor.textCursor()
-        from pyqode.qt import QtGui
-        assert isinstance(cursor, QtGui.QTextCursor)
+        next_char = self._helper.get_right_character()
         if cursor.hasSelection():
             # quoting of selected text
-            if event.text() in self.MAPPING.keys():
-                first = event.text()
-                last = self.MAPPING[event.text()]
+            if txt in self.MAPPING.keys():
+                closing_char = self.MAPPING[txt]
+                cursor.beginEditBlock()
                 cursor.insertText(
-                    self.SELECTED_QUOTES_FORMATS[event.text()] % (
-                        first, cursor.selectedText(), last))
+                    txt + cursor.selectedText() + closing_char
+                )
+                # Don't duplocate the closing character
+                if self._helper.get_right_character(cursor) == closing_char:
+                    cursor.insertText('')
+                else:
+                    cursor.movePosition(cursor.Left, cursor.MoveAnchor, 1)
                 self.editor.setTextCursor(cursor)
+                cursor.endEditBlock()
                 event.accept()
-            else:
-                self._ignore_post = True
+            self._ignore_post = True
             return
-        next_char = TextHelper(self.editor).get_right_character()
-        self.logger.debug('next char: %s', next_char)
         ignore = False
         if event.key() == QtCore.Qt.Key_Backspace:
-            # get the character that will get deleted
-            tc = self.editor.textCursor()
-            pos = tc.position()
-            tc.movePosition(tc.Left)
-            tc.movePosition(tc.Right, tc.KeepAnchor)
-            del_char = tc.selectedText()
-            if del_char in self.MAPPING and \
-                    self.MAPPING[del_char] == next_char:
-                tc.beginEditBlock()
-                tc.movePosition(tc.Right, tc.KeepAnchor)
-                tc.insertText('')
-                tc.setPosition(pos - 2)
-                tc.endEditBlock()
-                self.editor.setTextCursor(tc)
-                ignore = True
-        elif txt and next_char == txt and next_char in self.MAPPING:
+            # If we're in between two quotes, a backspace will delete both
+            # quotes.
+            del_char = self._helper.get_left_character()
+            if (
+                del_char in self.MAPPING and
+                self.MAPPING[del_char] == next_char
+            ):
+                # First select the previous and next character and replace it
+                # by an empty string. Then move the cursor one position back.
+                cursor.beginEditBlock()
+                cursor.movePosition(cursor.Left, cursor.MoveAnchor, 1)
+                cursor.movePosition(cursor.Right, cursor.KeepAnchor, 2)
+                cursor.deleteChar()
+                cursor.endEditBlock()
+                self.editor.setTextCursor(cursor)
+                event.accept()
+                return
+        elif (
+            # If the next character is already a character that we just
+            # autocompleted, then ignore the key press
+            txt and next_char == txt and (
+                next_char in self.MAPPING or
+                txt in self.AVOID_DUPLICATES
+            )
+        ):
             ignore = True
-        elif event.text() == ')' or event.text() == ']' or event.text() == '}':
-            # if typing the same symbol twice, the symbol should not be written
-            # and the cursor moved just after the char
-            # e.g. if you type ) just before ), the cursor will just move after
-            # the existing )
-            if next_char == event.text():
-                ignore = True
         if ignore:
             event.accept()
-            TextHelper(self.editor).clear_selection()
-            TextHelper(self.editor).move_right()
+            self._helper.clear_selection()
+            self._helper.move_right()
```

## pyqode/core/modes/autoindent.py

```diff
@@ -1,33 +1,47 @@
 # -*- coding: utf-8 -*-
 """ Contains the automatic generic indenter """
 from pyqode.core.api import TextHelper
 from pyqode.core.api.mode import Mode
-from pyqode.qt.QtCore import Qt
+from qtpy.QtCore import Qt
 
 
 class AutoIndentMode(Mode):
     """ Indents text automatically.
     Generic indenter mode that indents the text when the user press RETURN.
 
     You can customize this mode by overriding
     :meth:`pyqode.core.modes.AutoIndentMode._get_indent`
     """
     def __init__(self):
         super(AutoIndentMode, self).__init__()
 
+    @property
+    def _indent_char(self):
+
+        if self.editor.use_spaces_instead_of_tabs:
+            return ' '
+        return '\t'
+
+    @property
+    def _single_indent(self):
+
+        if self.editor.use_spaces_instead_of_tabs:
+            return self.editor.tab_length * ' '
+        return '\t'
+
     def _get_indent(self, cursor):
         """
         Return the indentation text (a series of spaces or tabs)
 
         :param cursor: QTextCursor
 
         :returns: Tuple (text before new line, text after new line)
         """
-        indent = TextHelper(self.editor).line_indent() * ' '
+        indent = TextHelper(self.editor).line_indent() * self._indent_char
         return "", indent
 
     def on_state_changed(self, state):
         if state is True:
             self.editor.key_pressed.connect(self._on_key_pressed)
         else:
             self.editor.key_pressed.disconnect(self._on_key_pressed)
@@ -48,8 +62,8 @@
                 cursor.movePosition(cursor.WordRight, cursor.KeepAnchor)
                 txt = cursor.selectedText()
                 if txt.startswith(' '):
                     new_txt = txt.replace(" ", '')
                     if len(txt) > len(new_txt):
                         cursor.insertText(new_txt)
                 cursor.endEditBlock()
-                event.accept()
+                event.accept()
```

## pyqode/core/modes/backspace.py

```diff
@@ -1,51 +1,234 @@
 """
 This module contains the smart backspace mode
 """
-from pyqode.qt import QtCore, QtGui
+from qtpy.QtCore import Qt
 from pyqode.core.api import Mode
 
 
 class SmartBackSpaceMode(Mode):
-    """ Improves backspace behaviour.
-
-    When you press backspace and there are spaces on the left of the cursor,
-    those spaces will be deleted (at most tab_len spaces).
-
-    Basically this turns backspace into Shitf+Tab
+    """Improves backspace and delete behaviour. The exact behavior is intended
+    to be as intuitive as possible, but is quite complex and described in more
+    detail in the functions below.
     """
+    
     def on_state_changed(self, state):
         if state:
             self.editor.key_pressed.connect(self._on_key_pressed)
         else:
             self.editor.key_pressed.disconnect(self._on_key_pressed)
 
     def _on_key_pressed(self, event):
-        no_modifiers = int(event.modifiers()) == QtCore.Qt.NoModifier
-        if event.key() == QtCore.Qt.Key_Backspace and no_modifiers:
-            if self.editor.textCursor().atBlockStart():
-                return
-            tab_len = self.editor.tab_length
-            tab_len = self.editor.textCursor().positionInBlock() % tab_len
-            if tab_len == 0:
-                tab_len = self.editor.tab_length
-            # count the number of spaces deletable, stop at tab len
-            spaces = 0
-            cursor = QtGui.QTextCursor(self.editor.textCursor())
-            while spaces < tab_len or cursor.atBlockStart():
-                pos = cursor.position()
-                cursor.movePosition(cursor.Left, cursor.KeepAnchor)
-                char = cursor.selectedText()
-                if char == " ":
-                    spaces += 1
+        if (event.modifiers() != Qt.NoModifier or event.isAccepted()):
+            return
+        key = event.key()
+        if key == Qt.Key_Backspace:
+            do_backspace = True
+            do_delete = False
+        elif key == Qt.Key_Delete:
+            do_delete = True
+            do_backspace = False
+        else:
+            return
+        cursor = self.editor.textCursor()
+        cursor.beginEditBlock()
+        if cursor.hasSelection():
+            cursor.removeSelectedText()
+        elif do_backspace:
+            if cursor.atBlockStart():
+                self._do_backspace_at_block_start(cursor)
+            else:
+                self._do_regular_backspace(cursor)
+        else:
+            if cursor.atBlockEnd():
+                self._do_delete_at_block_end(cursor)
+            else:
+                self._do_regular_delete(cursor)
+        cursor.endEditBlock()
+        self.editor.setTextCursor(cursor)
+        event.accept()
+
+    def _do_delete_at_block_end(self, cursor):
+        """When deleting while the cursor is at the end of a block, the next
+        newline and all subsequent whitespace is deleted.
+        """
+        cursor.deleteChar()
+        while not cursor.atBlockEnd():
+            cursor.movePosition(cursor.Right, cursor.KeepAnchor)
+            if not cursor.selectedText().isspace():
+                cursor.movePosition(cursor.Left)
+                break
+            cursor.removeSelectedText()
+            
+    def _do_regular_delete(self, cursor):
+        
+        """A delete does different things depending on the context.
+        
+        1. If the cursor is in the trailing whitespace of a block, then all
+        trailing whitespace is removed.
+        
+            `x = 1|    ` -> `x = 1|`
+            
+        2. If the cursor is followed by whitespace, then what follows is
+        de-indented by one tab stop, or until the cursor position is reached.
+        
+            `|    x = 1`     -> `|x = 1`
+            ` |   x = 1`     -> ` |x = 1`
+            ` |       x = 1` -> ` |  x = 1`
+            ` |     x = 1` ->   ` |  x = 1`
+            ` |  x = 1`      -> ` |x = 1`
+            
+        3. Else, the next character is deleted:
+        
+            `|x = 1` -> ` = 1`
+        """
+        
+        orig_pos = cursor.position()
+        selected_text, selected_whitespace, selected_entire_block = \
+            self._select_until_block_end(cursor)
+        if selected_whitespace:
+            cursor.removeSelectedText()
+            return
+        cursor.setPosition(orig_pos)
+        # For tab-based indentation, no specific de-indenting logic is
+        # necessary.
+        if not self.editor.use_spaces_instead_of_tabs:
+            cursor.deleteChar()
+            return
+        new_pos = self._move_right_until_non_whitespace(cursor)
+        # If there was no whitespace after, simply delete the next character
+        if orig_pos == new_pos:
+            cursor.setPosition(orig_pos)
+            cursor.deleteChar()
+        # Determine the maximum number of characters to delete
+        n_del = cursor.positionInBlock() % self.editor.tab_length
+        if not n_del:
+            n_del = self.editor.tab_length
+        n_del = min(new_pos - orig_pos, n_del)  # don't delete beyond cursor
+        cursor.movePosition(cursor.Left, cursor.KeepAnchor, n=n_del)
+        cursor.removeSelectedText()
+        cursor.setPosition(orig_pos)
+
+    def _do_backspace_at_block_start(self, cursor):
+        """When backspacing at the start of a block, first delete the previous
+        character, which is the newline that takes the cursor to the previous
+        block. If the cursor was initially at a line of only whitespace, we
+        delete the whitespace so that it's not carried over to the previous
+        block.
+        """
+        if cursor.block().text().isspace():
+            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+            cursor.removeSelectedText()
+        cursor.deletePreviousChar()
+        
+    def _do_regular_backspace(self, cursor):
+        """A backspace does different things depending on the context.
+        
+        If the cursor is in the trailing white space of a block that is not
+        only whitespace, then all trailing whitespace is deleted.
+        
+            `x = 1   |   ` -> `x = 1|`
+        
+        Otherwise, we deindent to the previous tab stop, or until the first non
+        whitespace character, while deleting at least one character even if it
+        is non whitespace.
+        
+            `x = 1|` -> `x = |`
+            `y = 1;     |x = 1` -> `y = 1;  x = 1`
+            
+        If the block is only whitespace, then the trailing whitespace is also
+        deleted:
+        
+            `    |    ` -> `|`
+        """
+        orig_pos = cursor.position()
+        self._move_left_until_non_whitespace(cursor)
+        selected_text, selected_whitespace, selected_entire_block = \
+            self._select_until_block_end(cursor)
+        # If we've selected some whitespace, delete this selection. But not
+        # if the entire line is whitespace, because then we want
+        # to de-indent.
+        if selected_whitespace and not selected_entire_block:
+            cursor.removeSelectedText()
+        # Otherwise, return the cursor to its original position and
+        # fall back to a de-indent-like behavior, such that as many
+        # whitespaces are removed as are necessary to de-indent by one
+        # level.
+        else:
+            cursor.setPosition(orig_pos)
+            # If there's only whitespace on the line, we also remove the
+            # trailing whitespace.
+            if selected_whitespace:
+                cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+                cursor.removeSelectedText()
+            if self.editor.use_spaces_instead_of_tabs:
+                cursor_pos = cursor.positionInBlock()
+                n_del = cursor_pos % self.editor.tab_length
+                ch_del = ' '
+                if not n_del:
+                    n_del = self.editor.tab_length
+                if n_del > cursor_pos:  # Don't delete beyond the line
+                    n_del = cursor_pos
+            else:
+                n_del = 1
+                ch_del = '\t'
+            for i in range(n_del):
+                cursor.movePosition(
+                    cursor.PreviousCharacter,
+                    cursor.KeepAnchor
+                )
+                if cursor.selectedText() == ch_del:
+                    cursor.removeSelectedText()
+                # The first time, we also delete non-whitespace characters.
+                # However, this means that we are not de-indenting, and
+                # therefore we break out of the loop. In other words, this
+                # is a regular backspace.
                 else:
+                    if not i:
+                        cursor.removeSelectedText()
+                    else:
+                        cursor.clearSelection()
+                        cursor.movePosition(cursor.Right)
                     break
-                cursor.setPosition(pos - 1)
-            cursor = self.editor.textCursor()
-            if spaces == 0:
-                return
-            cursor.beginEditBlock()
-            for _ in range(spaces):
-                cursor.deletePreviousChar()
-            cursor.endEditBlock()
-            self.editor.setTextCursor(cursor)
-            event.accept()
+
+    def _move_left_until_non_whitespace(self, cursor):
+        """Moves the cursor left until the first non-whitespace character
+        or until the start of the block.
+        """
+        while not cursor.atBlockStart():
+            cursor.movePosition(
+                cursor.Left,
+                cursor.KeepAnchor
+            )
+            if not cursor.selectedText().isspace():
+                cursor.setPosition(cursor.position() + 1)
+                break
+        cursor.setPosition(cursor.position())
+        return cursor.position()
+    
+    def _move_right_until_non_whitespace(self, cursor):
+        """Moves the cursor right until the first non-whitespace character
+        or until the end of the block.
+        """
+        while not cursor.atBlockEnd():
+            cursor.movePosition(
+                cursor.Right,
+                cursor.KeepAnchor
+            )
+            if not cursor.selectedText().isspace():
+                cursor.setPosition(cursor.position() - 1)
+                break
+        cursor.setPosition(cursor.position())
+        return cursor.position()
+        
+    def _select_until_block_end(self, cursor):
+        """Select all the characters until the end of the block. Returns the
+        selected text, whether this text contains only whitespace (and is not)
+        empty, and whether this text corresponds to the entire block
+        """
+        cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+        selected_text = cursor.selectedText()
+        return (
+            selected_text,
+            selected_text.isspace() and selected_text,
+            cursor.block().text() == selected_text
+        )
```

## pyqode/core/modes/caret_line_highlight.py

```diff
@@ -1,15 +1,15 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the care line highlighter mode
 """
 from pyqode.core.api.decoration import TextDecoration
 from pyqode.core.api.mode import Mode
 from pyqode.core.api.utils import drift_color
-from pyqode.qt import QtGui
+from qtpy import QtGui
 
 
 class CaretLineHighlighterMode(Mode):
     """ Highlights the caret line """
     @property
     def background(self):
         """
@@ -75,8 +75,8 @@
             brush = QtGui.QBrush(color)
             self._decoration = TextDecoration(self.editor.textCursor())
             self._decoration.set_background(brush)
             self._decoration.set_full_width()
             self.editor.decorations.append(self._decoration)
 
     def clone_settings(self, original):
-        self.background = original.background
+        self.background = original.background
```

## pyqode/core/modes/case_converter.py

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 Contains a case converter mode.
 """
 from pyqode.core.api import TextHelper
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
 
 
 class CaseConverterMode(Mode):
     """ Provides context actions for converting case of the selected text.
 
     Converts selected text to lower case or UPPER case.
 
@@ -18,22 +18,20 @@
     """
     def __init__(self):
         Mode.__init__(self)
         self._actions_created = False
         self.action_to_lower = None
         self.action_to_upper = None
 
-    @QtCore.Slot()
     def to_upper(self):
         """
         Converts selected text to upper
         """
         TextHelper(self.editor).selected_text_to_upper()
 
-    @QtCore.Slot()
     def to_lower(self):
         """
         Converts selected text to lower
         """
         TextHelper(self.editor).selected_text_to_lower()
 
     def _create_actions(self):
@@ -53,8 +51,8 @@
 
     def on_state_changed(self, state):
         if state:
             if not self._actions_created:
                 self._create_actions()
             self.editor.add_action(self.menu.menuAction())
         else:
-            self.editor.remove_action(self.menu.menuAction())
+            self.editor.remove_action(self.menu.menuAction())
```

## pyqode/core/modes/cursor_history.py

```diff
@@ -1,9 +1,15 @@
 import weakref
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
+try:
+    # PyQt5
+    from qtpy.QtWidgets import QUndoStack
+except ImportError:
+    # PyQt6
+    from qtpy.QtGui import QUndoStack
 from pyqode.core import api
 
 
 class MoveCursorCommand(QtWidgets.QUndoCommand):
     def __init__(self, new_pos, prev_pos, editor):
         super(MoveCursorCommand, self).__init__(
             '(Goto line %d)' % (new_pos[0] + 1))
@@ -29,15 +35,15 @@
         self._move(*self._prev_pos)
 
 
 class CursorHistoryMode(api.Mode):
     def __init__(self):
         super(CursorHistoryMode, self).__init__()
         self._prev_pos = 0, 0
-        self.undo_stack = QtWidgets.QUndoStack()
+        self.undo_stack = QUndoStack()
         self.undo_stack.setUndoLimit(10)
 
     def on_state_changed(self, state):
         if state:
             menu = QtWidgets.QMenu(self.editor)
             menu.setTitle(_('Cursor history'))
             self.action_undo = self.undo_stack.createUndoAction(self.editor)
```

## pyqode/core/modes/extended_selection.py

```diff
@@ -1,13 +1,15 @@
 """
 This module contains the extended selection mode.
 """
-from pyqode.qt import QtCore, QtWidgets, QtGui
+from qtpy import QtCore, QtWidgets, QtGui
 from pyqode.core.api import Mode, TextHelper
 
+TRIPLE_CLICK_TIMEOUT = 1000
+
 
 class ExtendedSelectionMode(Mode):
     """ Adds extended selection capabilities (Ctrl/Alt + Double click).
 
     This mode adds extended selections capabilities to CodeEdit.
 
     Extended selection is a feature that can be found in the Ulipad editor:
@@ -30,23 +32,23 @@
     """
 
     def __init__(self):
         super(ExtendedSelectionMode, self).__init__()
         self.extended_sel_modifier = QtCore.Qt.ControlModifier
         self.matched_sel_modifier = QtCore.Qt.AltModifier
         self.continuation_characters = ('.',)
-        self.word_sel_shortcut = QtGui.QKeySequence('Ctrl+W')
+        self.word_sel_shortcut = QtGui.QKeySequence('Ctrl+Alt+M')
         self.action_select_word = QtWidgets.QAction(self.editor)
         self.action_select_word.setText(_('Select word'))
         self.action_select_word.setShortcut(self.word_sel_shortcut)
         self.action_select_word.triggered.connect(self.perform_word_selection)
         self.action_select_word.setShortcutContext(
             QtCore.Qt.WidgetShortcut)
 
-        self.extended_sel_shortcut = QtGui.QKeySequence('Ctrl+Shift+W')
+        self.extended_sel_shortcut = QtGui.QKeySequence('Ctrl+Shift+M')
         self.action_select_extended_word = QtWidgets.QAction(self.editor)
         self.action_select_extended_word.setText(_('Select extended word'))
         self.action_select_extended_word.setShortcut(
             self.extended_sel_shortcut)
         self.action_select_extended_word.triggered.connect(
             self.perform_extended_selection)
         self.action_select_extended_word.setShortcutContext(
@@ -109,18 +111,46 @@
 
     def _on_double_click(self, event):
         modifiers = event.modifiers()
         if modifiers & self.extended_sel_modifier:
             self.editor.textCursor().clearSelection()
             self.perform_extended_selection(event=event)
         elif modifiers & self.matched_sel_modifier:
-            # self.editor.textCursor().clearSelection()
             self.perform_matched_selection(event=event)
-        elif int(modifiers) == QtCore.Qt.NoModifier:
+        elif modifiers == QtCore.Qt.NoModifier:
             self.perform_word_selection(event=event)
+            self.editor.mouse_pressed.connect(self._on_triple_click)
+            QtCore.QTimer.singleShot(
+                TRIPLE_CLICK_TIMEOUT,
+                self._disconnect_triple_click
+            )
+            
+    def _on_triple_click(self, event):
+        """Triple-clicking a word leads to selection of a full line. Since
+        there is no triple-click event, this is implement by connecting a
+        single mouse press after a double clicking, and then disconnecting it
+        again after a timeout.
+        """
+        if event.button() != QtCore.Qt.LeftButton:
+            return
+        clicked_pos = self.editor.cursorForPosition(event.pos()).position()
+        cursor = self.editor.textCursor()
+        if cursor.anchor() <= clicked_pos <= cursor.position():
+            self.perform_line_selection()
+            try:
+                self.editor.mouse_pressed.disconnect(self._on_triple_click)
+            except TypeError:  # already disconnected
+                pass
+            event.accept()
+            
+    def _disconnect_triple_click(self):
+        try:
+            self.editor.mouse_pressed.disconnect(self._on_triple_click)
+        except TypeError:  # already disconnected
+            pass
 
     def perform_word_selection(self, event=None):
         """
         Performs word selection
         :param event: QMouseEvent
         """
         self.editor.setTextCursor(
@@ -147,8 +177,11 @@
         if selected and event:
             event.accept()
 
     def perform_line_selection(self):
         """
         Performs line selection (select the entire line).
         """
-        TextHelper(self.editor).select_whole_line()
+        cursor = self._editor.textCursor()
+        cursor.movePosition(cursor.StartOfLine)
+        cursor.movePosition(cursor.EndOfLine, mode=cursor.KeepAnchor)
+        self._editor.setTextCursor(cursor)
```

## pyqode/core/modes/filewatcher.py

```diff
@@ -1,15 +1,15 @@
 # -*- coding: utf-8 -*-
 """
 Contains the mode that control the external changes of file.
 """
 import os
 from pyqode.core.api import TextHelper
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
 from pyqode.core.cache import Cache
 
 
 class FileWatcherMode(Mode, QtCore.QObject):
     """ Watches the current file for external modifications.
 
     FileWatcher mode, check if the opened file has changed externally.
@@ -131,14 +131,16 @@
                 writeable = os.access(self.editor.file.path, os.W_OK)
                 self.editor.setReadOnly(not writeable)
 
     def _notify(self, title, message, expected_action=None):
         """
         Notify user from external event
         """
+        if self.editor is None:
+            return
         inital_value = self.editor.save_on_focus_out
         self.editor.save_on_focus_out = False
         self._flg_notify = True
         dlg_type = (QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
         expected_action = (
             lambda *x: None) if not expected_action else expected_action
         if (self._auto_reload or QtWidgets.QMessageBox.question(
@@ -157,16 +159,20 @@
             """ Inner action: open file """
             # cache cursor position before reloading so that the cursor
             # position is restored automatically after reload has finished.
             # See OpenCobolIDE/OpenCobolIDE#97
             Cache().set_cursor_position(
                 self.editor.file.path,
                 self.editor.textCursor().position())
-            self.editor.file.open(self.editor.file.path)
-            self.file_reloaded.emit()
+            if os.path.exists(self.editor.file.path):
+                self.editor.file.open(self.editor.file.path)
+                self.file_reloaded.emit()
+            else:
+                # file moved just after a change, see OpenCobolIDE/OpenCobolIDE#337
+                self._notify_deleted_file()
 
         args = (_("File changed"),
                 _("The file <i>%s</i> has changed externally.\nDo you want to "
                   "reload it?") % os.path.basename(self.editor.file.path))
         kwargs = {"expected_action": inner_action}
         if self.editor.hasFocus() or self.auto_reload:
             self._notify(*args, **kwargs)
@@ -191,8 +197,8 @@
         Notify user from external file deletion.
         """
         self.file_deleted.emit(self.editor)
         # file deleted, disable file watcher
         self.enabled = False
 
     def clone_settings(self, original):
-        self.auto_reload = original.auto_reload
+        self.auto_reload = original.auto_reload
```

## pyqode/core/modes/indenter.py

```diff
@@ -1,173 +1,187 @@
 # -*- coding: utf-8 -*-
 """
 Contains the default indenter.
 """
-import logging
-from pyqode.core.api import TextHelper
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtGui
-
-
-def _logger():
-    return logging.getLogger(__name__)
-
-
-def debug(msg, *args):
-    return _logger().log(5, msg, *args)
 
 
 class IndenterMode(Mode):
     """ Implements classic indentation/tabulation (Tab/Shift+Tab)
 
     It inserts/removes tabulations (a series of spaces defined by the
     tabLength settings) at the cursor position if there is no selection,
-    otherwise it fully indents/un-indents selected lines.
+    otherwise it fully indents/un-indents selected lines. If the
+    tab_always_indents property is set to True, then tab always indents, even
+    if there is no selection.
 
     To trigger an indentation/un-indentation programatically, you must emit
     :attr:`pyqode.core.api.CodeEdit.indent_requested` or
     :attr:`pyqode.core.api.CodeEdit.unindent_requested`.
     """
     def __init__(self):
+        self.tab_always_indents = False
         super(IndenterMode, self).__init__()
 
+    @property
+    def _indent_char(self):
+        if self.editor.use_spaces_instead_of_tabs:
+            return ' '
+        return '\t'
+
+    @property
+    def _single_indent(self):
+        if self.editor.use_spaces_instead_of_tabs:
+            return self.editor.tab_length * ' '
+        return '\t'
+        
+    @property
+    def _indent_width(self):
+        if self.editor.use_spaces_instead_of_tabs:
+            return self.editor.tab_length
+        return 1
+
     def on_state_changed(self, state):
         if state:
             self.editor.indent_requested.connect(self.indent)
             self.editor.unindent_requested.connect(self.unindent)
         else:
             self.editor.indent_requested.disconnect(self.indent)
             self.editor.unindent_requested.disconnect(self.unindent)
-
-    def indent_selection(self, cursor):
-        """
-        Indent selected text
-
-        :param cursor: QTextCursor
-        """
-        doc = self.editor.document()
-        tab_len = self.editor.tab_length
-        cursor.beginEditBlock()
-        nb_lines = len(cursor.selection().toPlainText().splitlines())
-        c = self.editor.textCursor()
-        if c.atBlockStart() and c.position() == c.selectionEnd():
-            nb_lines += 1
-        block = doc.findBlock(cursor.selectionStart())
-        i = 0
-        # indent every lines
-        while i < nb_lines:
-            nb_space_to_add = tab_len
-            cursor = QtGui.QTextCursor(block)
-            cursor.movePosition(cursor.StartOfLine, cursor.MoveAnchor)
-            if self.editor.use_spaces_instead_of_tabs:
-                for _ in range(nb_space_to_add):
-                    cursor.insertText(" ")
-            else:
-                cursor.insertText('\t')
-            block = block.next()
-            i += 1
-        cursor.endEditBlock()
-
-    def unindent_selection(self, cursor):
-        """
-        Un-indents selected text
-
-        :param cursor: QTextCursor
-        """
-        doc = self.editor.document()
-        tab_len = self.editor.tab_length
-        nb_lines = len(cursor.selection().toPlainText().splitlines())
-        if nb_lines == 0:
-            nb_lines = 1
-        block = doc.findBlock(cursor.selectionStart())
-        assert isinstance(block, QtGui.QTextBlock)
-        i = 0
-        debug('unindent selection: %d lines', nb_lines)
-        while i < nb_lines:
-            txt = block.text()
-            debug('line to unindent: %s', txt)
-            debug('self.editor.use_spaces_instead_of_tabs: %r',
-                  self.editor.use_spaces_instead_of_tabs)
-            if self.editor.use_spaces_instead_of_tabs:
-                indentation = (len(txt) - len(txt.lstrip()))
-            else:
-                indentation = len(txt) - len(txt.replace('\t', ''))
-            debug('unindent line %d: %d spaces', i, indentation)
-            if indentation > 0:
-                c = QtGui.QTextCursor(block)
-                c.movePosition(c.StartOfLine, cursor.MoveAnchor)
-                for _ in range(tab_len):
-                    txt = block.text()
-                    if len(txt) and txt[0] == ' ':
-                        c.deleteChar()
-            block = block.next()
-            i += 1
-        return cursor
-
+            
+    def _select_full_block(self, cursor, anchor, pos):
+        """Selects full blocks of text from the first character of the first
+        block until the last character of the last block, while keeping the
+        order of the position and anchor constant. Returns the new anchor,
+        new position, and a list of selected lines.
+        """
+        cursor.setPosition(anchor)
+        if pos > anchor:
+            cursor.movePosition(cursor.StartOfBlock)
+            cursor.setPosition(pos, cursor.KeepAnchor)
+            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+        else:
+            cursor.movePosition(cursor.EndOfBlock)
+            cursor.setPosition(pos, cursor.KeepAnchor)
+            cursor.movePosition(cursor.StartOfBlock, cursor.KeepAnchor)
+        return (
+            cursor.anchor(),
+            cursor.position(),
+            cursor.selectedText().split(u'\u2029')
+        )
+        
+    def _max_common_indent(self, lines):
+        """Gets the maximum indentation level that is common to all non-empty
+        lines.
+        """
+        max_common_indent = None
+        for line in lines:
+            if not line.strip():  # Ignore empty lines
+                continue
+            stripped_line = line.lstrip(self._indent_char)
+            indent = len(line) - len(stripped_line)
+            max_common_indent = (
+                indent if max_common_indent is None
+                else min(indent, max_common_indent)
+            )
+        return max_common_indent if max_common_indent is not None else 0
+    
+    def _restore_selection(self, cursor, selection, orig_anchor, orig_pos):
+        """Restores a selection based taking into account the order of the
+        original anchor and position, and the length of the new selection.
+        """
+        if orig_anchor > orig_pos:
+            cursor.setPosition(orig_pos + len(selection))
+            cursor.movePosition(
+                cursor.Left,
+                cursor.KeepAnchor,
+                n=len(selection)
+            )
+        else:
+            cursor.setPosition(orig_anchor)
+            cursor.movePosition(
+                cursor.Right,
+                cursor.KeepAnchor,
+                n=len(selection)
+            )
+            
     def indent(self):
-        """
-        Indents text at cursor position.
-        """
         cursor = self.editor.textCursor()
-        assert isinstance(cursor, QtGui.QTextCursor)
-        if cursor.hasSelection():
-            self.indent_selection(cursor)
+        orig_anchor = cursor.anchor()
+        orig_pos = cursor.position()
+        indent_width = self._indent_width
+        indent_char = self._indent_char
+        # If there is no selection, and there is non-whitespace before the
+        # cursor on the current block, then we simply insert the tab at the
+        # cursor position.
+        if not self.tab_always_indents and not cursor.hasSelection():
+            cursor.movePosition(cursor.StartOfBlock, cursor.KeepAnchor)
+            if cursor.selectedText().strip(indent_char):
+                cursor.setPosition(orig_pos)
+                cursor.insertText(self._single_indent)
+                self.editor.setTextCursor(cursor)
+                return
+        cursor.beginEditBlock()
+        # Select from the start of the first block until the end of the last
+        # block.
+        sel_anchor, sel_pos, lines = self._select_full_block(
+            cursor,
+            orig_anchor,
+            orig_pos
+        )
+        # Indent to the next tab stop and replace the selection
+        max_common_indent = self._max_common_indent(lines)
+        indent_width = indent_width - (max_common_indent % indent_width)
+        lines = [indent_char * indent_width + line for line in lines]
+        new_selection = '\n'.join(lines)
+        cursor.insertText(new_selection)
+        if orig_anchor == orig_pos:
+            cursor.setPosition(orig_pos + indent_width)
         else:
-            # simply insert indentation at the cursor position
-            tab_len = self.editor.tab_length
-            cursor.beginEditBlock()
-            if self.editor.use_spaces_instead_of_tabs:
-                nb_space_to_add = tab_len - cursor.positionInBlock() % tab_len
-                cursor.insertText(nb_space_to_add * " ")
-            else:
-                cursor.insertText('\t')
-            cursor.endEditBlock()
-
-    def count_deletable_spaces(self, cursor, max_spaces):
-        # count the number of spaces deletable, stop at tab len
-        max_spaces = abs(max_spaces)
-        if max_spaces > self.editor.tab_length:
-            max_spaces = self.editor.tab_length
-        spaces = 0
-        trav_cursor = QtGui.QTextCursor(cursor)
-        while spaces < max_spaces or trav_cursor.atBlockStart():
-            pos = trav_cursor.position()
-            trav_cursor.movePosition(cursor.Left, cursor.KeepAnchor)
-            char = trav_cursor.selectedText()
-            if char == " ":
-                spaces += 1
-            else:
-                break
-            trav_cursor.setPosition(pos - 1)
-        return spaces
+            self._restore_selection(
+                cursor,
+                new_selection,
+                sel_anchor,
+                sel_pos
+            )
+        cursor.endEditBlock()
+        self.editor.setTextCursor(cursor)
 
     def unindent(self):
-        """
-        Un-indents text at cursor position.
-        """
-
-        debug('unindent')
         cursor = self.editor.textCursor()
-        debug('cursor has selection %r', cursor.hasSelection())
-        if cursor.hasSelection():
-            cursor.beginEditBlock()
-            self.unindent_selection(cursor)
-            cursor.endEditBlock()
-            self.editor.setTextCursor(cursor)
+        orig_anchor = cursor.anchor()
+        orig_pos = cursor.position()
+        orig_pos_in_block = cursor.positionInBlock()
+        indent_width = self._indent_width
+        indent_char = self._indent_char
+        cursor.beginEditBlock()
+        # Select from the start of the first block until the end of the last
+        # block.
+        sel_anchor, sel_pos, lines = self._select_full_block(
+            cursor,
+            orig_anchor,
+            orig_pos
+        )
+        # De-indent to the previous tab stop and replace the selection
+        max_common_indent = self._max_common_indent(lines)
+        deindent_width = max_common_indent % indent_width
+        if not deindent_width and max_common_indent >= indent_width:
+            deindent_width = indent_width
+        lines = [line[deindent_width:] for line in lines]
+        new_selection = '\n'.join(lines)
+        cursor.insertText(new_selection)
+        # If there was no selection, restore the cursor position. Move the
+        # cursor to the left to compensate for the deindentation, but don't
+        # wrap to the previous line.
+        if orig_anchor == orig_pos:
+            cursor.setPosition(
+                orig_pos - min(orig_pos_in_block, deindent_width)
+            )
         else:
-            tab_len = self.editor.tab_length
-            indentation = cursor.positionInBlock()
-            max_spaces = tab_len - (indentation - (indentation % tab_len))
-            spaces = self.count_deletable_spaces(cursor, max_spaces)
-            debug('deleting %d space before cursor' % spaces)
-            cursor.beginEditBlock()
-            if spaces:
-                # delete spaces before cursor
-                for _ in range(spaces):
-                    cursor.deletePreviousChar()
-            else:
-                # un-indent whole line
-                debug('un-indent whole line')
-                cursor = self.unindent_selection(cursor)
-            cursor.endEditBlock()
-            self.editor.setTextCursor(cursor)
-            debug(cursor.block().text())
+            self._restore_selection(
+                cursor,
+                new_selection,
+                sel_anchor,
+                sel_pos
+            )
+        cursor.endEditBlock()
+        self.editor.setTextCursor(cursor)
```

## pyqode/core/modes/line_highlighter.py

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the care line highlighter mode
 """
-from pyqode.qt import QtGui
+from qtpy import QtGui
 
 from pyqode.core.api.decoration import TextDecoration
 from pyqode.core.api.mode import Mode
 
 
 class LineHighlighterMode(Mode):
     """ Highlights a line in the editor."""
@@ -82,8 +82,8 @@
                 self.editor.textCursor(), start_line=self.line)
             self._decoration.set_background(brush)
             self._decoration.set_full_width()
             self._decoration.draw_order = 255
             self.editor.decorations.append(self._decoration)
 
     def clone_settings(self, original):
-        self.background = original.background
+        self.background = original.background
```

## pyqode/core/modes/matcher.py

```diff
@@ -1,15 +1,15 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the symbol matcher mode
 """
-from pyqode.core.api import get_block_symbol_data
+from pyqode.core.api import get_block_symbol_data, utils
 from pyqode.core.api.decoration import TextDecoration
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtGui
+from qtpy import QtGui
 
 
 #: symbols indices in SymbolMatcherMode.SYMBOLS map
 PAREN = 0
 SQUARE = 1
 BRACE = 2
 
@@ -114,39 +114,52 @@
     def __init__(self):
         super(SymbolMatcherMode, self).__init__()
         self._decorations = []
         self._match_background = QtGui.QBrush(QtGui.QColor('#B4EEB4'))
         self._match_foreground = QtGui.QColor('red')
         self._unmatch_background = QtGui.QBrush(QtGui.QColor('transparent'))
         self._unmatch_foreground = QtGui.QColor('red')
+        self._open_symbols = [s[OPEN] for s in self.SYMBOLS.values()]
+        self._close_symbols = [s[CLOSE] for s in self.SYMBOLS.values()]
 
     def _clear_decorations(self):
         for deco in self._decorations:
             self.editor.decorations.remove(deco)
         self._decorations[:] = []
 
-    def symbol_pos(self, cursor, character_type=OPEN, symbol_type=PAREN):
+    def symbol_pos(
+        self,
+        cursor,
+        character_type=OPEN,
+        symbol_type=PAREN,
+        block_position=False
+    ):
         """
         Find the corresponding symbol position (line, column) of the specified
         symbol. If symbol type is PAREN and character_type is OPEN, the
         function will look for '('.
 
         :param cursor: QTextCursor
         :param character_type: character type to look for (open or close char)
         :param symbol_type: symbol type (index in the SYMBOLS map).
+        :param block_position: indicates if the column of return value should
+            be relative to the block (True) or line (False)
         """
         retval = None, None
         original_cursor = self.editor.textCursor()
         self.editor.setTextCursor(cursor)
         block = cursor.block()
         data = get_block_symbol_data(self.editor, block)
         self._match(symbol_type, data, block.position())
         for deco in self._decorations:
             if deco.character == self.SYMBOLS[symbol_type][character_type]:
-                retval = deco.line, deco.column
+                retval = (
+                    deco.line,
+                    deco.block_position if block_position else deco.column
+                )
                 break
         self.editor.setTextCursor(original_cursor)
         self._clear_decorations()
         return retval
 
     def _refresh_decorations(self):
         for deco in self._decorations:
@@ -164,29 +177,28 @@
             self.editor.cursorPositionChanged.connect(self.do_symbols_matching)
         else:
             self.editor.cursorPositionChanged.disconnect(
                 self.do_symbols_matching)
 
     def _match(self, symbol, data, cursor_pos):
         symbols = data[symbol]
+        cursor = self.editor.textCursor()
+        block = cursor.block()
+        pos = cursor.positionInBlock()
         for i, info in enumerate(symbols):
-            pos = (self.editor.textCursor().position() -
-                   self.editor.textCursor().block().position())
             if info.character == self.SYMBOLS[symbol][OPEN] and \
                     info.position == pos:
                 self._create_decoration(
                     cursor_pos + info.position,
-                    self._match_left(
-                        symbol, self.editor.textCursor().block(), i + 1, 0))
+                    self._match_left(symbol, block, i + 1, 0))
             elif info.character == self.SYMBOLS[symbol][CLOSE] and \
                     info.position == pos - 1:
                 self._create_decoration(
                     cursor_pos + info.position,
-                    self._match_right(
-                        symbol, self.editor.textCursor().block(), i - 1, 0))
+                    self._match_right(symbol, block, i - 1, 0))
 
     def _match_left(self, symbol, current_block, i, cpt):
         while current_block.isValid():
             data = get_block_symbol_data(self.editor, current_block)
             parentheses = data[symbol]
             for j in range(i, len(parentheses)):
                 info = parentheses[j]
@@ -227,28 +239,38 @@
         return False
 
     def do_symbols_matching(self):
         """
         Performs symbols matching.
         """
         self._clear_decorations()
-        current_block = self.editor.textCursor().block()
+        th = utils.TextHelper(self.editor)
+        if (
+            th.get_left_character() not in self._close_symbols and
+            th.get_right_character() not in self._open_symbols
+        ):
+            return
+        cursor = self.editor.textCursor()
+        current_block = cursor.block()
         data = get_block_symbol_data(self.editor, current_block)
-        pos = self.editor.textCursor().block().position()
+        pos = current_block.position()
         for symbol in [PAREN, SQUARE, BRACE]:
             self._match(symbol, data, pos)
 
     def _create_decoration(self, pos, match=True):
         cursor = self.editor.textCursor()
-        cursor.setPosition(pos)
-        cursor.movePosition(cursor.NextCharacter, cursor.KeepAnchor)
-        deco = TextDecoration(cursor, draw_order=10)
-        deco.line = cursor.blockNumber()
-        deco.column = cursor.columnNumber()
-        deco.character = cursor.selectedText()
+        deco = TextDecoration(
+            cursor,
+            start_pos=pos,
+            end_pos=pos + 1,
+            draw_order=10
+        )
+        deco.line = deco.cursor.blockNumber()
+        deco.column = deco.cursor.columnNumber()
+        deco.block_position = deco.cursor.positionInBlock()
         deco.match = match
         if match:
             deco.set_foreground(self._match_foreground)
             deco.set_background(self._match_background)
         else:
             deco.set_foreground(self._unmatch_foreground)
             deco.set_background(self._unmatch_background)
@@ -256,8 +278,8 @@
         self.editor.decorations.append(deco)
         return cursor
 
     def clone_settings(self, original):
         self.match_background = original.match_background
         self.match_foreground = original.match_foreground
         self.unmatch_background = original.unmatch_background
-        self.unmatch_foreground = original.unmatch_foreground
+        self.unmatch_foreground = original.unmatch_foreground
```

## pyqode/core/modes/occurences.py

```diff
@@ -1,11 +1,11 @@
 """
 This module contains the occurrences highlighter mode.
 """
-from pyqode.qt import QtGui
+from qtpy import QtGui
 from pyqode.core.api import Mode, DelayJobRunner, TextHelper, TextDecoration
 from pyqode.core.backend import NotRunning
 from pyqode.core.backend.workers import findall
 
 
 class OccurrencesHighlighterMode(Mode):
     """ Highlights occurrences of the word under the text text cursor.
@@ -86,23 +86,33 @@
             for clone in self.editor.clones:
                 try:
                     clone.modes.get(self.__class__).underlined = value
                 except KeyError:
                     # this should never happen since we're working with clones
                     pass
 
+    @property
+    def case_sensitive(self):
+        return self._case_sensitive
+
+    @case_sensitive.setter
+    def case_sensitive(self, value):
+        self._case_sensitive = value
+        self._request_highlight()
+
     def __init__(self):
         super(OccurrencesHighlighterMode, self).__init__()
         self._decorations = []
         #: Timer used to run the search request with a specific delay
         self.timer = DelayJobRunner(delay=1000)
         self._sub = None
         self._background = QtGui.QColor('#CCFFCC')
         self._foreground = None
         self._underlined = False
+        self._case_sensitive = False
 
     def on_state_changed(self, state):
         if state:
             self.editor.cursorPositionChanged.connect(self._request_highlight)
         else:
             self.editor.cursorPositionChanged.disconnect(
                 self._request_highlight)
@@ -130,15 +140,15 @@
             select_whole_word=True).selectedText()
         if not cursor.hasSelection() or cursor.selectedText() == self._sub:
             request_data = {
                 'string': self.editor.toPlainText(),
                 'sub': self._sub,
                 'regex': False,
                 'whole_word': True,
-                'case_sensitive': True
+                'case_sensitive': self.case_sensitive
             }
             try:
                 self.editor.backend.send_request(findall, request_data,
                                                  self._on_results_available)
             except NotRunning:
                 self._request_highlight()
 
@@ -166,8 +176,8 @@
                 self.editor.decorations.append(deco)
                 self._decorations.append(deco)
 
     def clone_settings(self, original):
         self.delay = original.delay
         self.background = original.background
         self.foreground = original.foreground
-        self.underlined = original.underlined
+        self.underlined = original.underlined
```

## pyqode/core/modes/outline.py

```diff
@@ -1,13 +1,13 @@
 import logging
 from pyqode.core.api import Mode
 from pyqode.core.api import DelayJobRunner
 from pyqode.core.backend import NotRunning
 from pyqode.core.share import Definition
-from pyqode.qt import QtCore
+from qtpy import QtCore
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 class OutlineMode(Mode, QtCore.QObject):
@@ -77,8 +77,8 @@
 
     def _on_results_available(self, results):
         if results:
             results = [Definition.from_dict(ddict) for ddict in results]
         self._results = results
         if self._results is not None:
             _logger().log(5, "Document structure changed")
-            self.document_changed.emit()
+            self.document_changed.emit()
```

## pyqode/core/modes/right_margin.py

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the right margin mode.
 """
 from pyqode.core.api import TextHelper
 from pyqode.core.api import Mode
-from pyqode.qt import QtGui
+from qtpy import QtGui
 
 
 class RightMarginMode(Mode):
     """ Displays a right margin at column the specified position.
 
     """
     @property
@@ -71,17 +71,17 @@
 
     def _paint_margin(self, event):
         """ Paints the right margin after editor paint event. """
         font = QtGui.QFont(self.editor.font_name, self.editor.font_size +
                            self.editor.zoom_level)
         metrics = QtGui.QFontMetricsF(font)
         pos = self._margin_pos
-        offset = self.editor.contentOffset().x() + \
-            self.editor.document().documentMargin()
+        offset = int(self.editor.contentOffset().x() + 
+                     self.editor.document().documentMargin())
         x80 = round(metrics.width(' ') * pos) + offset
         painter = QtGui.QPainter(self.editor.viewport())
         painter.setPen(self._pen)
         painter.drawLine(x80, 0, x80, 2 ** 16)
 
     def clone_settings(self, original):
         self.color = original.color
-        self.position = original.position
+        self.position = original.position
```

## pyqode/core/modes/zoom.py

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the ZoomMode which lets you zoom in and out the editor.
 """
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 class ZoomMode(Mode):
     """ Zooms/Unzooms the editor (Ctrl+mouse wheel or Ctrl + 0 to reset).
 
     This mode make it possible to zoom in/out the editor view.
 
@@ -21,73 +21,68 @@
         self.prev_delta = 0
         self.default_font_size = 10
 
     def on_state_changed(self, state):
         if state:
             self.editor.mouse_wheel_activated.connect(
                 self._on_wheel_event)
-            self.editor.key_pressed.connect(self._on_key_pressed)
-            self.mnu_zoom = QtWidgets.QMenu("Zoom")
-            a = self.mnu_zoom.addAction(QtGui.QIcon.fromTheme(
-                'zoom-in'), 'Zoom in')
+            self.mnu_zoom = QtWidgets.QMenu("Zoom", self.editor)
+            # Zoom in
+            a = QtWidgets.QAction(
+                QtGui.QIcon.fromTheme('zoom-in'),
+                'Zoom in',
+                self.editor
+            )
+            a.setShortcutContext(QtCore.Qt.WidgetShortcut)
+            self.mnu_zoom.addAction(a)
             a.setShortcut('Ctrl++')
             a.triggered.connect(self.editor.zoom_in)
-
-            a = self.mnu_zoom.addAction(QtGui.QIcon.fromTheme(
-                'zoom-out'), 'Zoom out')
+            # Zoom out
+            a = QtWidgets.QAction(
+                QtGui.QIcon.fromTheme('zoom-out'),
+                'Zoom out',
+                self.editor
+            )
+            a.setShortcutContext(QtCore.Qt.WidgetShortcut)
+            self.mnu_zoom.addAction(a)
             a.setShortcut('Ctrl+-')
             a.triggered.connect(self.editor.zoom_out)
-
-            a = self.mnu_zoom.addAction(QtGui.QIcon.fromTheme(
-                'zoom-fit-best'), 'Reset zoom')
+            # Reset zoom
+            a = QtWidgets.QAction(
+                QtGui.QIcon.fromTheme('zoom-fit-best'),
+                'Reset zoom',
+                self.editor
+            )
+            a.setShortcutContext(QtCore.Qt.WidgetShortcut)
+            self.mnu_zoom.addAction(a)
             a.setShortcut('Ctrl+0')
             a.triggered.connect(self.editor.reset_zoom)
-
+            # Zoom menu
             a = self.mnu_zoom.menuAction()
-            a.setIcon(QtGui.QIcon.fromTheme('zoom'))
+            a.setIcon(QtGui.QIcon.fromTheme('zoom-in'))
             self.editor.add_action(a, sub_menu=None)
         else:
             self.editor.mouse_wheel_activated.disconnect(
                 self._on_wheel_event)
             self.editor.remove_action(self.mnu_zoom.menuAction(),
                                       sub_menu=None)
-            self.editor.key_pressed.disconnect(self._on_key_pressed)
-
-    def _on_key_pressed(self, event):
-        """
-        Resets editor font size to the default font size
-
-        :param event: wheelEvent
-        :type event: QKeyEvent
-        """
-        if (int(event.modifiers()) & QtCore.Qt.ControlModifier > 0 and
-                not int(event.modifiers()) & QtCore.Qt.ShiftModifier):
-            if event.key() == QtCore.Qt.Key_0:
-                self.editor.reset_zoom()
-                event.accept()
-            if event.key() == QtCore.Qt.Key_Plus:
-                self.editor.zoom_in()
-                event.accept()
-            if event.key() == QtCore.Qt.Key_Minus:
-                self.editor.zoom_out()
-                event.accept()
 
     def _on_wheel_event(self, event):
         """
         Increments or decrements editor fonts settings on mouse wheel event
         if ctrl modifier is on.
 
         :param event: wheel event
         :type event: QWheelEvent
         """
         try:
             delta = event.angleDelta().y()
         except AttributeError:
             # PyQt4/PySide
             delta = event.delta()
-        if int(event.modifiers()) & QtCore.Qt.ControlModifier > 0:
+        if event.modifiers() & QtCore.Qt.ControlModifier:
             if delta < self.prev_delta:
                 self.editor.zoom_out()
                 event.accept()
             else:
                 self.editor.zoom_in()
                 event.accept()
```

## pyqode/core/modes/checker.py

```diff
@@ -1,18 +1,19 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the checker mode, a base class for code checker modes.
 """
 import logging
+from pyqode.core import icons
 from pyqode.core.api import TextBlockUserData
 from pyqode.core.api.decoration import TextDecoration
 from pyqode.core.api.mode import Mode
 from pyqode.core.backend import NotRunning
 from pyqode.core.api.utils import DelayJobRunner
-from pyqode.qt import QtCore, QtGui
+from qtpy import QtCore, QtGui
 
 
 class CheckerMessages(object):
     """
     Enumerates the possible checker message types.
     """
     #: Status value for an information message.
@@ -24,18 +25,14 @@
 
 
 class CheckerMessage(object):
     """
     Holds data for a message displayed by the
     :class:`pyqode.core.modes.CheckerMode`.
     """
-    #: Default colors foreach message status
-    COLORS = {CheckerMessages.INFO: "#4040DD",
-              CheckerMessages.WARNING: "#DDDD40",
-              CheckerMessages.ERROR: "#DD4040"}
 
     @classmethod
     def status_to_string(cls, status):
         """
         Converts a message status to a string.
 
         :param status: Status to convert (p yqode.core.modes.CheckerMessages)
@@ -52,22 +49,23 @@
         """
         Returns the message status as a string.
 
         :return: The status string.
         """
         return self.status_to_string(self.status)
 
-    def __init__(self, description, status, line, col=None, icon=None,
-                 color=None, path=None):
+    def __init__(self, description, status, line, text_range=None, icon=None,
+                 color=None, path=None, block=None, underline=False,
+                 checker_mode=None):
         """
         :param description: The message description (used as a tooltip)
         :param status: The status associated with the message.
         :param line: The message line number
-        :param col: The message start column (at the moment the message ends at
-                    the end of the line).
+        :param text_range: The start and end range of the text. If specified,
+            this overrides the line for the text highlighting.
         :param icon: Unused, we keep it for backward compatiblity.
         :param color: Text decoration color
         :param path: file path. Optional
         """
         assert 0 <= status <= 2
         #: The description of the message, used as a tooltip.
         self.description = description
@@ -76,31 +74,55 @@
         #:    * :const:`pyqode.core.modes.CheckerMessages.WARNING`
         #:    * :const:`pyqode.core.modes.CheckerMessages.ERROR`
         self.status = status
         #: The line of the message
         self.line = line
         #: The start column (used for the text decoration). If the col is None,
         #: the whole line is highlighted.
-        self.col = col
-        #: The color used for the text decoration. If None, the default color
-        #: is used (:const:`pyqode.core.CheckerMessage.COLORS`)
-        self.color = color
-        if self.color is None:
-            self.color = self.COLORS[status]
+        self.text_range = text_range
+        self.color = (
+            color if color is not None
+            else icons.QTA_OPTIONS['color_info']
+            if status == CheckerMessages.INFO
+            else icons.QTA_OPTIONS['color_warning']
+            if status == CheckerMessages.WARNING
+            else icons.QTA_OPTIONS['color_error']
+        )
         self.decoration = None
         self.path = path
         #: store a reference to the associated QTextBlock, for quick acces
-        self.block = None
+        self.block = block
+        self.underline = underline
+        self.checker_mode = checker_mode
 
     def __str__(self):
         return "{0} l{1}".format(self.description, self.line)
 
     def __eq__(self, other):
-        return (self.block == other.block and
-                self.description == other.description)
+        return (
+            self.text_range == other.text_range and
+            self.block == other.block and
+            self.description == other.description and
+            self.path == other.path
+        )
+        
+    def icon(self):
+        return self.checker_mode.message_icon(self)
+        
+    def tooltip(self):
+        return self.checker_mode.message_tooltip(self)
+        
+    def widget(self):
+        return self.checker_mode.message_widget(self)
+        
+    def show_on_panel(self, panel):
+        return self.checker_mode.show_on_panel(panel)
+        
+    def clicked(self, event):
+        self.checker_mode.message_clicked(self, event)
 
 
 def _logger(klass):
     return logging.getLogger('%s [%s]' % (__name__, klass.__name__))
 
 
 class CheckerMode(Mode, QtCore.QObject):
@@ -142,53 +164,84 @@
     def messages(self):
         """
         Returns the entire list of checker messages.
         """
         return self._messages
 
     def __init__(self, worker,
+                 underline=True,
                  delay=500,
                  show_tooltip=True):
         """
         :param worker: The process function or class to call remotely.
+        :param underline: Indicates whether lines should be decorated.
         :param delay: The delay used before running the analysis process when
                       trigger is set to
                       :class:pyqode.core.modes.CheckerTriggers`
         :param show_tooltip: Specify if a tooltip must be displayed when the
                              mouse is over a checker message decoration.
         """
         Mode.__init__(self)
         QtCore.QObject.__init__(self)
         # max number of messages to keep good performances
         self.limit = 200
         self.ignore_rules = []
+        self._extra_info = {}
         self._job_runner = DelayJobRunner(delay=delay)
         self._messages = []
         self._worker = worker
         self._mutex = QtCore.QMutex()
         self._show_tooltip = show_tooltip
         self._pending_msg = []
         self._finished = True
-
+        self._underline = underline
+        self.info_icon = icons.icon(
+            'dialog-info', ':pyqode-icons/rc/dialog-info.png',
+            'fa.info-circle',
+            qta_options={'color': icons.QTA_OPTIONS['color_info']})
+        self.warning_icon = icons.icon(
+            'dialog-warning', ':pyqode-icons/rc/dialog-warning.png',
+            'fa.exclamation-triangle',
+            qta_options={'color': icons.QTA_OPTIONS['color_warning']})
+        self.error_icon = icons.icon(
+            'dialog-error', ':pyqode-icons/rc/dialog-error.png',
+            'fa.exclamation-circle',
+            qta_options={'color': icons.QTA_OPTIONS['color_error']})
+        self._checker_icons = {
+            CheckerMessages.INFO: self.info_icon,
+            CheckerMessages.WARNING: self.warning_icon,
+            CheckerMessages.ERROR: self.error_icon
+        }
+        
     def set_ignore_rules(self, rules):
         """
         Sets the ignore rules for the linter.
 
         Rules are a list of string that the actual linter function will check
         to reject some warnings/errors.
         """
         self.ignore_rules = rules
+        
+    def add_extra_info(self, key, value):
+        """
+        Allows additional info to be passed onto the linter. Things like the
+        language for spell checking.
+        """
+        self._extra_info[key] = value
+        
+    def get_extra_info(self, key):
+        """Gets additional info for the linter."""
+        return self._extra_info[key]
 
     def add_messages(self, messages):
         """
         Adds a message or a list of message.
 
         :param messages: A list of messages or a single message
         """
-        # remove old messages
         if len(messages) > self.limit:
             messages = messages[:self.limit]
         _logger(self.__class__).log(5, 'adding %s messages' % len(messages))
         self._finished = False
         self._new_messages = messages
         self._to_check = list(self._messages)
         self._pending_msg = messages
@@ -210,83 +263,88 @@
                 msg.block = self.editor.document().findBlockByNumber(msg.line)
             if msg not in self._new_messages:
                 self.remove_message(msg)
         self.editor.repaint()
         QtCore.QTimer.singleShot(1, self._remove_batch)
 
     def _add_batch(self):
+        
         if self.editor is None:
             return
         for i in range(10):
             if not len(self._pending_msg):
                 # all pending message added
                 self._finished = True
                 _logger(self.__class__).log(5, 'finished')
+                self.editor.decorations.set_on_editor()
                 self.editor.repaint()
                 return False
             message = self._pending_msg.pop(0)
-            if message.line >= 0:
-                try:
-                    usd = message.block.userData()
-                except AttributeError:
-                    message.block = self.editor.document().findBlockByNumber(
-                        message.line)
-                    usd = message.block.userData()
-                if usd is None:
-                    usd = TextBlockUserData()
-                    message.block.setUserData(usd)
-                # check if the same message already exists
-                if message in usd.messages:
-                    continue
-                self._messages.append(message)
-                usd.messages.append(message)
-                tooltip = None
-                if self._show_tooltip:
-                    tooltip = message.description
-                message.decoration = TextDecoration(
-                    self.editor.textCursor(), start_line=message.line,
-                    tooltip=tooltip, draw_order=3)
-                message.decoration.set_full_width()
-                message.decoration.set_as_error(color=QtGui.QColor(
-                    message.color))
-                self.editor.decorations.append(message.decoration)
+            if message.line < 0:
+                continue
+            usd = message.block.userData()
+            if usd is None:
+                usd = TextBlockUserData()
+                message.block.setUserData(usd)
+            # check if the same message already exists
+            if message in usd.messages:
+                continue
+            self._messages.append(message)
+            usd.messages.append(message)
+            tooltip = None
+            if self._show_tooltip:
+                tooltip = message.description
+            if not message.underline:
+                continue
+            start_pos, end_pos = (
+                message.text_range
+                if message.text_range is not None
+                else (None, None)
+            )
+            message.decoration = TextDecoration(
+                self.editor.textCursor(),
+                start_line=message.line,
+                start_pos=start_pos,
+                end_pos=end_pos,
+                tooltip=tooltip,
+                draw_order=3,
+                full_width=start_pos is None
+            )
+            message.decoration.set_as_error(color=QtGui.QColor(message.color))
+            self.editor.decorations.append(
+                message.decoration,
+                set_on_editor=False
+            )
         QtCore.QTimer.singleShot(1, self._add_batch)
+        self.editor.decorations.set_on_editor()
         self.editor.repaint()
         return True
 
     def remove_message(self, message):
         """
         Removes a message.
 
         :param message: Message to remove
         """
-        import time
-        _logger(self.__class__).log(5, 'removing message %s' % message)
-        t = time.time()
         usd = message.block.userData()
         if usd:
             try:
                 usd.messages.remove(message)
             except (AttributeError, ValueError):
                 pass
         if message.decoration:
             self.editor.decorations.remove(message.decoration)
         self._messages.remove(message)
 
     def clear_messages(self):
         """
         Clears all messages.
         """
-        while len(self._messages):
-            msg = self._messages.pop(0)
-            usd = msg.block.userData()
-            if usd and hasattr(usd, 'messages'):
-                usd.messages[:] = []
-            if msg.decoration:
-                self.editor.decorations.remove(msg.decoration)
+        while self._messages:
+            self.remove_message(self._messages[0])
 
     def on_state_changed(self, state):
         if state:
             self.editor.textChanged.connect(self.request_analysis)
             self.editor.new_text_set.connect(self.clear_messages)
             self.request_analysis()
         else:
@@ -298,17 +356,22 @@
     def _on_work_finished(self, results):
         """
         Display results.
 
         :param status: Response status
         :param results: Response data, messages.
         """
+        
         messages = []
         for msg in results:
             msg = CheckerMessage(*msg)
+            msg.underline = self._underline
+            msg.checker_mode = self
+            if msg.line >= self.editor.blockCount():
+                msg.line = self.editor.blockCount() - 1
             block = self.editor.document().findBlockByNumber(msg.line)
             msg.block = block
             messages.append(msg)
         self.add_messages(messages)
 
     def request_analysis(self):
         """
@@ -335,16 +398,32 @@
         except KeyError:
             max_line_length = 79
         request_data = {
             'code': self.editor.toPlainText(),
             'path': self.editor.file.path,
             'encoding': self.editor.file.encoding,
             'ignore_rules': self.ignore_rules,
-            'max_line_length': max_line_length,
+            'max_line_length': max_line_length
         }
+        request_data.update(self._extra_info)
         try:
             self.editor.backend.send_request(
                 self._worker, request_data, on_receive=self._on_work_finished)
             self._finished = False
         except NotRunning:
             # retry later
             QtCore.QTimer.singleShot(100, self._request)
+    
+    def message_icon(self, msg):
+        return self._checker_icons[msg.status]
+        
+    def message_tooltip(self, msg):
+        return msg.description
+    
+    def message_widget(self, msg):
+        return None
+
+    def show_on_panel(self, panel):
+        return panel.__class__.__name__ == 'CheckerPanel'
+
+    def message_clicked(self, msg, event):
+        pass
```

## pyqode/core/modes/code_completion.py

```diff
@@ -4,56 +4,77 @@
 """
 import logging
 import re
 import sys
 import time
 from pyqode.core.api.mode import Mode
 from pyqode.core.backend import NotRunning
-from pyqode.qt import QtWidgets, QtCore, QtGui
+from qtpy import QtWidgets, QtCore, QtGui
 from pyqode.core.api.utils import TextHelper
 from pyqode.core import backend
 
+NAVIGATION_KEYS = (
+    QtCore.Qt.Key_Backspace,
+    QtCore.Qt.Key_Back,
+    QtCore.Qt.Key_Delete,
+    QtCore.Qt.Key_End,
+    QtCore.Qt.Key_Home,
+    QtCore.Qt.Key_Left,
+    QtCore.Qt.Key_Right,
+    QtCore.Qt.Key_Up,
+    QtCore.Qt.Key_Down,
+    QtCore.Qt.Key_Space
+)
+MIN_WIDTH = 200
+icon_cache = {}
+
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 def debug(msg, *args):
     """
     Log internal debugger messages (user should not see them, even in debug
     mode)
     """
     return _logger().log(5, msg, *args)
 
 
-
 class SubsequenceSortFilterProxyModel(QtCore.QSortFilterProxyModel):
     """
     Performs subsequence matching/sorting (see pyQode/pyQode#1).
     """
     def __init__(self, case, parent=None):
         QtCore.QSortFilterProxyModel.__init__(self, parent)
         self.case = case
 
     def set_prefix(self, prefix):
         self.filter_patterns = []
+        self.filter_patterns_case_sensitive = []
         self.sort_patterns = []
         if self.case == QtCore.Qt.CaseInsensitive:
             flags = re.IGNORECASE
         else:
             flags = 0
         for i in reversed(range(1, len(prefix) + 1)):
             ptrn = '.*%s.*%s' % (prefix[0:i], prefix[i:])
-            self.filter_patterns.append(re.compile(ptrn, flags))
-            ptrn = '%s.*%s' % (prefix[0:i], prefix[i:])
-            self.sort_patterns.append(re.compile(ptrn, flags))
+            try:
+                self.filter_patterns.append(re.compile(ptrn, flags))
+                self.filter_patterns_case_sensitive.append(re.compile(ptrn, 0))
+                ptrn = '%s.*%s' % (prefix[0:i], prefix[i:])
+                self.sort_patterns.append(re.compile(ptrn, flags))
+            except Exception:
+                continue
         self.prefix = prefix
 
     def filterAcceptsRow(self, row, _):
         completion = self.sourceModel().data(self.sourceModel().index(row, 0))
+        if completion is None or self.prefix is None:
+            return False
         if len(completion) < len(self.prefix):
             return False
         if len(self.prefix) == 1:
             try:
                 prefix = self.prefix
                 if self.case == QtCore.Qt.CaseInsensitive:
                     completion = completion.lower()
@@ -61,24 +82,28 @@
                 rank = completion.index(prefix)
                 self.sourceModel().setData(
                     self.sourceModel().index(row, 0), rank, QtCore.Qt.UserRole)
                 return prefix in completion
             except ValueError:
                 return False
         for i, patterns in enumerate(zip(self.filter_patterns,
+                                         self.filter_patterns_case_sensitive,
                                          self.sort_patterns)):
-            pattern, sort_pattern = patterns
+            pattern, pattern_case, sort_pattern = patterns
             match = re.match(pattern, completion)
             if match:
                 # compute rank, the lowest rank the closer it is from the
                 # completion
                 start = sys.maxsize
                 for m in sort_pattern.finditer(completion):
                     start, end = m.span()
                 rank = start + i * 10
+                if re.match(pattern_case, completion):
+                    # favorise completions where case is matched
+                    rank -= 10
                 self.sourceModel().setData(
                     self.sourceModel().index(row, 0), rank, QtCore.Qt.UserRole)
                 return True
         return len(self.prefix) == 0
 
 
 class SubsequenceCompleter(QtWidgets.QCompleter):
@@ -273,20 +298,27 @@
         QtCore.QObject.__init__(self)
         self._current_completion = ""
         self._trigger_key = QtCore.Qt.Key_Space
         self._trigger_len = 1
         self._trigger_symbols = ['.']
         self._case_sensitive = False
         self._completer = None
-        self._filter_mode = self.FILTER_PREFIX
+        self._filter_mode = self.FILTER_FUZZY
         self._last_cursor_line = -1
         self._last_cursor_column = -1
+        self._last_completion_prefix = ''
         self._tooltips = {}
+        self._completions = None
+        self._completion_anchor = None
+        self._completion_rect = None
+        self._char_width = None
         self._show_tooltips = False
         self._request_id = self._last_request_id = 0
+        self._working = False
+        self._stylesheet_initialized = False
 
     def clone_settings(self, original):
         self.trigger_key = original.trigger_key
         self.trigger_length = original.trigger_length
         self.trigger_symbols = original.trigger_symbols
         self.show_tooltips = original.show_tooltips
         self.case_sensitive = original.case_sensitive
@@ -312,18 +344,18 @@
             self._completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
         self._completer.activated.connect(self._insert_completion)
         self._completer.highlighted.connect(
             self._on_selected_completion_changed)
         self._completer.highlighted.connect(self._display_completion_tooltip)
 
     def on_install(self, editor):
+        Mode.on_install(self, editor)
         self._create_completer()
         self._completer.setModel(QtGui.QStandardItemModel())
         self._helper = TextHelper(editor)
-        Mode.on_install(self, editor)
 
     def on_uninstall(self):
         Mode.on_uninstall(self)
         self._completer.popup().hide()
         self._completer = None
 
     def on_state_changed(self, state):
@@ -339,15 +371,15 @@
     #
     # Slots
     #
     def _on_key_pressed(self, event):
         def _handle_completer_events():
             nav_key = self._is_navigation_key(event)
             mod = QtCore.Qt.ControlModifier
-            ctrl = int(event.modifiers() & mod) == mod
+            ctrl = event.modifiers() == mod
             # complete
             if event.key() in [
                     QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return,
                     QtCore.Qt.Key_Tab]:
                 self._insert_completion(self._current_completion)
                 self._hide_popup()
                 event.accept()
@@ -393,19 +425,19 @@
                 self._reset_sync_data()
                 return
             if event.key() == QtCore.Qt.Key_Return:
                 return
             if event.text() in self._trigger_symbols:
                 # symbol trigger, force request
                 self._reset_sync_data()
-                self.request_completion()
+                self.request_completion(triggered_by_symbol=True)
             elif len(word) >= self._trigger_len and event.text() not in \
                     self.editor.word_separators:
                 # Length trigger
-                if int(event.modifiers()) in [
+                if event.modifiers() in [
                         QtCore.Qt.NoModifier, QtCore.Qt.ShiftModifier]:
                     self.request_completion()
                 else:
                     self._hide_popup()
             else:
                 self._reset_sync_data()
         else:
@@ -424,19 +456,29 @@
         """
         self._completer.setWidget(self.editor)
 
     def _on_selected_completion_changed(self, completion):
         self._current_completion = completion
 
     def _insert_completion(self, completion):
-        cursor = self._helper.word_under_cursor(select_whole_word=False)
+        # If the completions ends with the part of the word that follows the
+        # cursor, then the entire word is replaced. This avoid duplicating
+        # parts of words through autocompletion.
+        trailing_text = self._helper.word_under_cursor(
+            select_whole_word=True,
+            from_start=False
+        ).selectedText()
+        cursor = self._helper.word_under_cursor(
+            select_whole_word=completion.endswith(trailing_text)
+        )
         cursor.insertText(completion)
         self.editor.setTextCursor(cursor)
 
     def _on_results_available(self, results):
+        self._working = False
         debug("completion results (completions=%r), prefix=%s",
                         results, self.completion_prefix)
         context = results[0]
         results = results[1:]
         line, column, request_id = context
         debug('request context: %r', context)
         debug('latest context: %r', (self._last_cursor_line,
@@ -459,164 +501,220 @@
     def _is_popup_visible(self):
         return self._completer.popup().isVisible()
 
     def _reset_sync_data(self):
         debug('reset sync data and hide popup')
         self._last_cursor_line = -1
         self._last_cursor_column = -1
+        self._last_completion_prefix = ''
         self._hide_popup()
 
-    def request_completion(self):
+    def request_completion(self, triggered_by_symbol=False):
+        if self._working:
+            return
+        self._working = True
         line = self._helper.current_line_nbr()
         column = self._helper.current_column_nbr() - \
             len(self.completion_prefix)
-        same_context = (line == self._last_cursor_line and
-                        column == self._last_cursor_column)
+        same_context = (
+            line == self._last_cursor_line and
+            column == self._last_cursor_column and
+            self.completion_prefix == self._last_completion_prefix
+        )
         if same_context:
             if self._request_id - 1 == self._last_request_id:
                 # context has not changed and the correct results can be
                 # directly shown
-                debug('request completion ignored, context has not '
-                                'changed')
+                debug('request completion ignored, context has not changed')
                 self._show_popup()
-            else:
-                # same context but result not yet available
-                pass
             return True
+        debug('requesting completion')
+        data = {
+            'code': self.editor.toPlainText(),
+            'line': line,
+            'column': column,
+            'path': self.editor.file.path,
+            'encoding': self.editor.file.encoding,
+            'prefix': self.completion_prefix,
+            'request_id': self._request_id,
+            'triggered_by_symbol': triggered_by_symbol
+        }
+        try:
+            self.editor.backend.send_request(
+                backend.CodeCompletionWorker, args=data,
+                on_receive=self._on_results_available)
+        except NotRunning:
+            _logger().exception('failed to send the completion request')
+            return False
         else:
-            debug('requesting completion')
-            data = {
-                'code': self.editor.toPlainText(),
-                'line': line,
-                'column': column,
-                'path': self.editor.file.path,
-                'encoding': self.editor.file.encoding,
-                'prefix': self.completion_prefix,
-                'request_id': self._request_id
-            }
-            try:
-                self.editor.backend.send_request(
-                    backend.CodeCompletionWorker, args=data,
-                    on_receive=self._on_results_available)
-            except NotRunning:
-                _logger().exception('failed to send the completion request')
-                return False
-            else:
-                debug('request sent: %r', data)
-                self._last_cursor_column = column
-                self._last_cursor_line = line
-                self._request_id += 1
-                return True
+            debug('request sent: %r', data)
+            self._last_cursor_column = column
+            self._last_cursor_line = line
+            self._last_completion_prefix = self.completion_prefix
+            self._request_id += 1
+            return True
 
     def _is_shortcut(self, event):
         """
         Checks if the event's key and modifiers make the completion shortcut
         (Ctrl+Space)
 
         :param event: QKeyEvent
 
         :return: bool
         """
         modifier = (QtCore.Qt.MetaModifier if sys.platform == 'darwin' else
                     QtCore.Qt.ControlModifier)
-        valid_modifier = int(event.modifiers() & modifier) == modifier
+        valid_modifier = event.modifiers() == modifier
         valid_key = event.key() == self._trigger_key
         return valid_key and valid_modifier
 
     def _hide_popup(self):
         """
         Hides the completer popup
         """
         debug('hide popup')
         if (self._completer.popup() is not None and
                 self._completer.popup().isVisible()):
             self._completer.popup().hide()
             self._last_cursor_column = -1
             self._last_cursor_line = -1
+            self._last_completion_prefix = ''
             QtWidgets.QToolTip.hideText()
 
-    def _get_popup_rect(self):
-        cursor_rec = self.editor.cursorRect()
-        char_width = self.editor.fontMetrics().width('A')
-        prefix_len = (len(self.completion_prefix) * char_width)
-        cursor_rec.translate(
-            self.editor.panels.margin_size() - prefix_len,
-            self.editor.panels.margin_size(0) + 5)
+    def _update_popup_rect(self, anchor):
+        """
+        Updates the rectangle of the completer. If the anchor stays the same,
+        only the width of the popup is adjusted. Otherwise, the position is
+        also adjusted. There is a minimum with for the completer, because
+        occasionally the size hint returns 0, even when there are completion
+        entries.
+        
+        :param anchor: the anchor of the cursor, i.e. the start of the
+                       to-be-completed word.
+        """
+        if anchor != self._completion_anchor:
+            self._completion_rect = self.editor.cursorRect()
+            if self._char_width is None:
+                self._char_width = self.editor.fontMetrics().width('_')
+            prefix_len = (len(self.completion_prefix) * self._char_width)
+            self._completion_rect.translate(
+                self.editor.panels.margin_size() - prefix_len,
+                self.editor.panels.margin_size(0) + 5
+            )
+            self._completion_anchor = anchor
         popup = self._completer.popup()
-        width = popup.verticalScrollBar().sizeHint().width()
-        cursor_rec.setWidth(
-            self._completer.popup().sizeHintForColumn(0) + width)
-        return cursor_rec
+        width_hint = max(MIN_WIDTH, popup.sizeHintForColumn(0))
+        self._completion_rect.setWidth(
+            width_hint + popup.verticalScrollBar().sizeHint().width()
+        )
 
     def _show_popup(self, index=0):
         """
         Shows the popup at the specified index.
         :param index: index
         :return:
         """
-        full_prefix = self._helper.word_under_cursor(
-            select_whole_word=False).selectedText()
-        if self._case_sensitive:
-            self._completer.setCaseSensitivity(QtCore.Qt.CaseSensitive)
-        else:
-            self._completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)
-        # set prefix
+        
+        # If the cursor is not at the end of the document, then we check
+        # whether the next character is a word separator If not, then we don't
+        # offer completions, because we don't want to complete in the middle of
+        # a word.
+        ch = self._helper.get_right_character()  # None means end of document
+        if ch is not None and ch not in self.editor.word_separators:
+            return
+        # Get the word that was typed so far
+        text_cursor = self.editor.textCursor()
+        text_cursor.movePosition(text_cursor.Left, text_cursor.MoveAnchor, 1)
+        text_cursor.select(text_cursor.WordUnderCursor)
+        self._update_popup_rect(text_cursor.anchor())
+        word_so_far = text_cursor.selectedText()
+        self._completer.setCaseSensitivity(
+            QtCore.Qt.CaseSensitive
+            if self._case_sensitive
+            else QtCore.Qt.CaseInsensitive
+        )
         self._completer.setCompletionPrefix(self.completion_prefix)
-        cnt = self._completer.completionCount()
-        selected = self._completer.currentCompletion()
-        if (full_prefix == selected) and cnt == 1:
-            debug('user already typed the only completion that we '
-                            'have')
-            self._hide_popup()
+        # Move to the first suggestion that is not the current word, and hide
+        # the popup if no such suggestion exists.
+        for row in range(self._completer.completionCount()):
+            self._completer.setCurrentRow(row)
+            if self._completer.currentCompletion() != word_so_far:
+                break
         else:
-            # show the completion list
-            if self.editor.isVisible():
-                if self._completer.widget() != self.editor:
-                    self._completer.setWidget(self.editor)
-                self._completer.complete(self._get_popup_rect())
-                self._completer.popup().setCurrentIndex(
-                    self._completer.completionModel().index(index, 0))
-                debug(
-                    "popup shown: %r" % self._completer.popup().isVisible())
-            else:
-                debug('cannot show popup, editor is not visible')
+            self._hide_popup()
+            return
+        if not self.editor.isVisible():
+            debug('cannot show popup, editor is not visible')
+            return
+        if self._completer.widget() != self.editor:
+            self._completer.setWidget(self.editor)
+        self._completer.complete(self._completion_rect)
+        # The QCompleter popup doesn't respect the stylesheet. Here we
+        # reconstruct a basic stylesheet and directly apply it. There may be
+        # more elegant solutions, but this works.
+        if not self._stylesheet_initialized:
+            self._completer.popup().setStyleSheet(
+                '''
+                background: {};
+                color: {};
+                font-family: {};
+                font-size: {};
+                '''.format(
+                    self.editor.palette().base().color().name(),
+                    self.editor.palette().text().color().name(),
+                    self.editor.font_name,
+                    self.editor.font_size,
+                )
+            )
+            self._stylesheet_initialized = True
+        self._completer.popup().setCurrentIndex(
+             self._completer.completionModel().index(row, 0)
+        )
 
     def _show_completions(self, completions):
-        debug("showing %d completions" % len(completions))
-        debug('popup state: %r', self._completer.popup().isVisible())
-        t = time.time()
         self._update_model(completions)
-        elapsed = time.time() - t
-        debug("completion model updated: %d items in %f seconds",
-                        self._completer.model().rowCount(), elapsed)
         self._show_popup()
+        
+    def _icon(self, name):
+        if isinstance(name, list):
+            name, fallback = name
+        else:
+            fallback = None
+        if name in icon_cache:
+            return icon_cache[name]
+        if fallback is None:
+            icon = QtGui.QIcon(name)
+        else:
+            icon = QtGui.QIcon.fromTheme(name, self._icon(fallback))
+        icon_cache[name] = icon
+        return icon
 
     def _update_model(self, completions):
         """
         Creates a QStandardModel that holds the suggestion from the completion
         models for the QCompleter
 
         :param completionPrefix:
         """
+        if self._completions == completions:
+            return  # avoid unnecessary updates to avoid flickering
+        self._completions = completions
+        self._completion_anchor = None
         # build the completion model
         cc_model = QtGui.QStandardItemModel()
         self._tooltips.clear()
         for completion in completions:
             name = completion['name']
             item = QtGui.QStandardItem()
             item.setData(name, QtCore.Qt.DisplayRole)
             if 'tooltip' in completion and completion['tooltip']:
                 self._tooltips[name] = completion['tooltip']
             if 'icon' in completion:
-                icon = completion['icon']
-                if isinstance(icon, list):
-                    icon = QtGui.QIcon.fromTheme(icon[0], QtGui.QIcon(icon[1]))
-                else:
-                    icon = QtGui.QIcon(icon)
-                item.setData(QtGui.QIcon(icon),
+                item.setData(self._icon(completion['icon']),
                              QtCore.Qt.DecorationRole)
             cc_model.appendRow(item)
         try:
             self._completer.setModel(cc_model)
         except RuntimeError:
             self._create_completer()
             self._completer.setModel(cc_model)
@@ -632,17 +730,8 @@
         pos = self._completer.popup().pos()
         pos.setX(pos.x() + self._completer.popup().size().width())
         pos.setY(pos.y() - 15)
         QtWidgets.QToolTip.showText(pos, tooltip, self.editor)
 
     @staticmethod
     def _is_navigation_key(event):
-        return (event.key() == QtCore.Qt.Key_Backspace or
-                event.key() == QtCore.Qt.Key_Back or
-                event.key() == QtCore.Qt.Key_Delete or
-                event.key() == QtCore.Qt.Key_End or
-                event.key() == QtCore.Qt.Key_Home or
-                event.key() == QtCore.Qt.Key_Left or
-                event.key() == QtCore.Qt.Key_Right or
-                event.key() == QtCore.Qt.Key_Up or
-                event.key() == QtCore.Qt.Key_Down or
-                event.key() == QtCore.Qt.Key_Space)
+        return event.key() in NAVIGATION_KEYS
```

## pyqode/core/modes/wordclick.py

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the WordClickMode
 """
 from pyqode.core.api.decoration import TextDecoration
 from pyqode.core.api.mode import Mode
-from pyqode.qt import QtCore, QtGui
+from qtpy import QtCore, QtGui
 from pyqode.core.api import TextHelper, DelayJobRunner
 
 
 class WordClickMode(Mode, QtCore.QObject):
     """ Adds support for word click events.
 
     It will highlight the click-able word when the user press control and move
@@ -118,8 +118,8 @@
 
     def _remove_decoration(self):
         """
         Removes the word under cursor's decoration
         """
         if self._deco is not None:
             self.editor.decorations.remove(self._deco)
-            self._deco = None
+            self._deco = None
```

## pyqode/core/modes/pygments_sh.py

```diff
@@ -15,16 +15,16 @@
 from pygments.lexers.agile import PythonLexer
 from pygments.lexers.compiled import CLexer, CppLexer
 from pygments.lexers.dotnet import CSharpLexer
 from pygments.lexers.special import TextLexer
 from pygments.styles import get_style_by_name, get_all_styles
 from pygments.token import Whitespace, Comment, Token
 from pygments.util import ClassNotFound
-from pyqode.qt import QtGui
-from pyqode.qt.QtCore import QRegExp
+from qtpy import QtGui
+from qtpy.QtCore import QRegularExpression, QTimer
 
 from pyqode.core.api.syntax_highlighter import (
     SyntaxHighlighter, ColorScheme, TextBlockUserData)
 
 
 def _logger():
     """ Returns the module's logger """
@@ -170,28 +170,38 @@
         self._init_style()
         self._prev_block = None
 
     def _init_style(self):
         """ Init pygments style """
         self._update_style()
 
+    def clone_settings(self, original):
+
+        # The lexer can be shared between clones.
+        self._lexer = original._lexer
+
     def on_install(self, editor):
         """
         :type editor: pyqode.code.api.CodeEdit
         """
         self._clear_caches()
         self._update_style()
         super(PygmentsSH, self).on_install(editor)
 
     def set_mime_type(self, mime_type):
         """
         Update the highlighter lexer based on a mime type.
 
         :param mime_type: mime type of the new lexer to setup.
         """
+
+        if not mime_type:
+            # Fall back to TextLexer
+            self._lexer = TextLexer()
+            return False
         try:
             self.set_lexer_from_mime_type(mime_type)
         except ClassNotFound:
             _logger().exception('failed to get lexer from mimetype')
             self._lexer = TextLexer()
             return False
         except ImportError:
@@ -216,15 +226,14 @@
             filename = filename[0:len(filename) - 1]
         try:
             self._lexer = get_lexer_for_filename(filename)
         except (ClassNotFound, ImportError):
             print('class not found for url', filename)
             try:
                 m = mimetypes.guess_type(filename)
-                print(m)
                 self._lexer = get_lexer_for_mimetype(m[0])
             except (ClassNotFound, IndexError, ImportError):
                 self._lexer = get_lexer_for_mimetype('text/plain')
         if self._lexer is None:
             _logger().warning('failed to get lexer from filename: %s, using '
                               'plain text instead...', filename)
             self._lexer = TextLexer()
@@ -232,69 +241,71 @@
     def set_lexer_from_mime_type(self, mime, **options):
         """
         Sets the pygments lexer from mime type.
 
         :param mime: mime type
         :param options: optional addtional options.
         """
-        self._lexer = get_lexer_for_mimetype(mime, **options)
-        _logger().debug('lexer for mimetype (%s): %r', mime, self._lexer)
+
+        try:
+            self._lexer = get_lexer_for_mimetype(mime, **options)
+        except (ClassNotFound, ImportError):
+            _logger().debug('class not found for mime {}'.format(mime))
+            self._lexer = get_lexer_for_mimetype('text/plain')
+        else:
+            _logger().debug('lexer for mimetype (%s): %r', mime, self._lexer)
 
     def highlight_block(self, text, block):
         """
         Highlights the block using a pygments lexer.
 
         :param text: text of the block to highlith
         :param block: block to highlight
         """
-        if self.color_scheme.name != self._pygments_style:
-            self._pygments_style = self.color_scheme.name
-            self._update_style()
         original_text = text
-        if self.editor and self._lexer and self.enabled:
-            if block.blockNumber():
-                prev_data = self._prev_block.userData()
-                if prev_data:
-                    if hasattr(prev_data, "syntax_stack"):
-                        self._lexer._saved_state_stack = prev_data.syntax_stack
-                    elif hasattr(self._lexer, '_saved_state_stack'):
-                        del self._lexer._saved_state_stack
-
-            # Lex the text using Pygments
-            index = 0
-            usd = block.userData()
-            if usd is None:
-                usd = TextBlockUserData()
-                block.setUserData(usd)
-            tokens = list(self._lexer.get_tokens(text))
-            for token, text in tokens:
-                length = len(text)
-                fmt = self._get_format(token)
-                if token in [Token.Literal.String, Token.Literal.String.Doc,
-                             Token.Comment]:
-                    fmt.setObjectType(fmt.UserObject)
-                self.setFormat(index, length, fmt)
-                index += length
-
-            if hasattr(self._lexer, '_saved_state_stack'):
-                setattr(usd, "syntax_stack", self._lexer._saved_state_stack)
-                # Clean up for the next go-round.
-                del self._lexer._saved_state_stack
-
-            # spaces
-            text = original_text
-            expression = QRegExp(r'\s+')
-            index = expression.indexIn(text, 0)
-            while index >= 0:
-                index = expression.pos(0)
-                length = len(expression.cap(0))
-                self.setFormat(index, length, self._get_format(Whitespace))
-                index = expression.indexIn(text, index + length)
-
-            self._prev_block = block
+        if not self.editor or not self._lexer or not self.enabled:
+            return
+        if block.blockNumber():
+            prev_data = self._prev_block.userData()
+            if prev_data:
+                if hasattr(prev_data, "syntax_stack"):
+                    self._lexer._saved_state_stack = prev_data.syntax_stack
+                elif hasattr(self._lexer, '_saved_state_stack'):
+                    del self._lexer._saved_state_stack
+
+        # Lex the text using Pygments
+        index = 0
+        usd = block.userData()
+        if usd is None:
+            usd = TextBlockUserData()
+            usd.last_token = None
+            block.setUserData(usd)
+        tokens = list(self._lexer.get_tokens(text))
+        for token, text in tokens:
+            length = len(text)
+            fmt = self._get_format(token)
+            if token in [Token.Literal.String, Token.Literal.String.Doc,
+                         Token.Comment]:
+                fmt.setObjectType(fmt.UserObject)
+            self.setFormat(index, length, fmt)
+            index += length
+        if hasattr(self._lexer, '_saved_state_stack'):
+            setattr(usd, "syntax_stack", self._lexer._saved_state_stack)
+            # Clean up for the next go-round.
+            del self._lexer._saved_state_stack
+        self._prev_block = block
+        # If the current block now ends with a comment but didn't before, or
+        # now doesn't end with a commment but did before, then we request a
+        # rehighlight of the entire document. This is a cheap fix to deal with
+        # multiline comments, which affect lines beyond the current block.
+        if not self._in_rehighlight and token != usd.last_token and \
+                (token == Token.Comment or usd.last_token == Token.Comment):
+            self._in_rehighlight = True
+            QTimer.singleShot(100, self.rehighlight)
+        usd.last_token = token
 
     def _update_style(self):
         """ Sets the style to the specified Pygments style.
         """
         try:
             self._style = get_style_by_name(self._pygments_style)
         except ClassNotFound:
```

## pyqode/core/panels/__init__.py

```diff
@@ -2,25 +2,31 @@
 """
 This package contains the core panels
 """
 from .encodings import EncodingPanel
 from .line_number import LineNumberPanel
 from .marker import Marker
 from .marker import MarkerPanel
+from .margin import MarginPanel
 from .checker import CheckerPanel
 from .folding import FoldingPanel
 from .search_and_replace import SearchAndReplacePanel
 from .global_checker import GlobalCheckerPanel
 from .read_only import ReadOnlyPanel
+from .image_annotations import ImageAnnotationsPanel
+from .change_extension import ChangeExtensionPanel
 
 
 __all__ = [
     'CheckerPanel',
+    'ChangeExtensionPanel',
     'EncodingPanel',
     'FoldingPanel',
     'LineNumberPanel',
     'Marker',
     'MarkerPanel',
     'SearchAndReplacePanel',
     'GlobalCheckerPanel',
-    'ReadOnlyPanel'
+    'ReadOnlyPanel',
+    'MarginPanel',
+    'ImageAnnotationsPanel'
 ]
```

## pyqode/core/panels/checker.py

```diff
@@ -2,117 +2,164 @@
 Checker panels:
 
     - CheckerPanel: draw checker messages in front of each line
     - GlobalCheckerPanel: draw all checker markers as colored rectangle to
       offer a global view of all errors
 """
 from pyqode.core import icons
-from pyqode.core.api import DelayJobRunner, TextHelper, CodeEdit
-from pyqode.core.api.panel import Panel, _logger
-from pyqode.core.modes.checker import CheckerMessages
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from pyqode.core.api import DelayJobRunner, TextHelper
+from pyqode.core.api.panel import Panel
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 class CheckerPanel(Panel):
     """ Shows messages collected by one or more checker modes """
+
+    _use_syntax_theme = True
+    _adjust_vertical_offset = True
+
     def __init__(self):
         super(CheckerPanel, self).__init__()
-        self._previous_line = -1
+        self._visible_markers = []
+        self._tooltip_shown = False
+        self._current_widget = None
         self.scrollable = True
         self._job_runner = DelayJobRunner(delay=100)
         self.setMouseTracking(True)
-        #: Info icon
-        self.info_icon = icons.icon(
-            'dialog-info', ':pyqode-icons/rc/dialog-info.png',
-            'fa.info-circle', qta_options={'color': '#4040DD'})
-        self.warning_icon = icons.icon(
-            'dialog-warning', ':pyqode-icons/rc/dialog-warning.png',
-            'fa.exclamation-triangle', qta_options={'color': '#DDDD40'})
-        self.error_icon = icons.icon(
-            'dialog-error', ':pyqode-icons/rc/dialog-error.png',
-            'fa.exclamation-circle', qta_options={'color': '#DD4040'})
-
+    
     def marker_for_line(self, line):
         """
         Returns the marker that is displayed at the specified line number if
         any.
 
         :param line: The marker line.
 
         :return: Marker of None
         :rtype: pyqode.core.Marker
         """
         block = self.editor.document().findBlockByNumber(line)
         try:
-            return block.userData().messages
+            messages = block.userData().messages
         except AttributeError:
             return []
+        return [msg for msg in messages if msg.show_on_panel(self)]
 
     def sizeHint(self):
         """
         Returns the panel size hint. (fixed with of 16px)
         """
         metrics = QtGui.QFontMetricsF(self.editor.font())
-        size_hint = QtCore.QSize(metrics.height(), metrics.height())
+        size_hint = QtCore.QSize(int(metrics.height()), int(metrics.height()))
         if size_hint.width() > 16:
             size_hint.setWidth(16)
         return size_hint
 
     def on_uninstall(self):
         self._job_runner.cancel_requests()
         super(CheckerPanel, self).on_uninstall()
 
+    def _vertical_offset(self):
+        """Allows the icons to be centered on the line, in case they are
+        smaller than the line height. Can be overridden to have the icons
+        attached to the top of the line.
+        """
+        size_hint = self.sizeHint()
+        return (size_hint.height() - size_hint.width()) // 2
+    
+    def _icon_size(self):
+        """Gets the intended size of the icons."""
+        width = self.sizeHint().width()
+        return QtCore.QSize(width, width)
+    
+    def _multiple_markers_icon(self):
+        """In case there are multiple markers on the same line, show this icon.
+        If None is returned, then the first marker icon is shown.
+        """
+        return icons.icon('list-add', '', 'fa.plus-circle')
+
     def paintEvent(self, event):
+        """Handles the actual drawing of the markers on the panel."""
         super(CheckerPanel, self).paintEvent(event)
         painter = QtGui.QPainter(self)
+        message_count = 0
+        icon_size = self._icon_size()
+        vertical_offset = self._vertical_offset()
+        multiple_markers_icon = self._multiple_markers_icon()
+        self._visible_markers = []
         for top, block_nbr, block in self.editor.visible_blocks:
             user_data = block.userData()
-            if user_data and user_data.messages:
-                for msg in user_data.messages:
-                    icon = self._icon_from_message(msg)
-                    if icon:
-                        rect = QtCore.QRect()
-                        rect.setX(0)
-                        rect.setY(top)
-                        rect.setWidth(self.sizeHint().width())
-                        rect.setHeight(self.sizeHint().height())
-                        icon.paint(painter, rect)
-
-    def _icon_from_message(self, message):
-        icons = {
-            CheckerMessages.INFO: self.info_icon,
-            CheckerMessages.WARNING: self.warning_icon,
-            CheckerMessages.ERROR: self.error_icon
-        }
-        return icons[message.status]
+            if not user_data or not user_data.messages:
+                continue
+            markers = [
+                msg for msg in user_data.messages
+                if msg.show_on_panel(self) and msg.icon()
+            ]
+            if not markers:
+                continue
+            message_count += len(markers)
+            icon = (
+                markers[0].icon()
+                if len(markers) == 1 or multiple_markers_icon is None
+                else multiple_markers_icon
+            )
+            rect = QtCore.QRect()
+            rect.setX(0)
+            actual_icon_size = icon.actualSize(icon_size)
+            rect.setY(top + vertical_offset)
+            rect.setSize(actual_icon_size)
+            icon.paint(painter, rect)
+            self._visible_markers.append((markers, rect))
+        self._message_count(message_count)
 
     def mouseMoveEvent(self, event):
-        # Requests a tooltip if the cursor is currently over a marker.
-        line = TextHelper(self.editor).line_nbr_from_position(event.pos().y())
-        if line:
-            markers = self.marker_for_line(line)
-            text = '\n'.join([marker.description for marker in markers if
-                              marker.description])
-            if len(markers):
-                if self._previous_line != line:
-                    top = TextHelper(self.editor).line_pos_from_number(
-                        markers[0].line)
-                    if top:
-                        self._job_runner.request_job(self._display_tooltip,
-                                                     text, top)
-            else:
-                self._job_runner.cancel_requests()
-            self._previous_line = line
+        if self._tooltip_shown or self._current_widget is not None:
+            return
+        for markers, rect in self._visible_markers:
+            if not rect.contains(event.pos()):
+                continue
+            tooltips = []
+            for marker in markers:
+                widget = marker.widget()
+                if widget is not None:
+                    self._display_widget(widget, rect.top())
+                    return
+                tooltips.append(marker.tooltip())
+            self._job_runner.request_job(
+                self._display_tooltip,
+                '<pre>{}</pre>'.format('\n'.join(tooltips)), rect.top())
+            return
+        self._job_runner.cancel_requests()
+        
+    def mousePressEvent(self, event):
+        for markers, rect in self._visible_markers:
+            if not rect.contains(event.pos()):
+                continue
+            for marker in markers:
+                marker.clicked(event)
+                break
 
     def leaveEvent(self, *args):
         """
         Hide tooltip when leaving the panel region.
         """
-        QtWidgets.QToolTip.hideText()
-        self._previous_line = -1
+        if self._tooltip_shown:
+            QtWidgets.QToolTip.hideText()
+            self._tooltip_shown = False
+        if self._current_widget is not None:
+            self._current_widget.hide()
+            self._current_widget = None
 
     def _display_tooltip(self, tooltip, top):
         """
         Display tooltip at the specified top position.
         """
+        self._tooltip_shown = True
         QtWidgets.QToolTip.showText(self.mapToGlobal(QtCore.QPoint(
-            self.sizeHint().width(), top)), tooltip, self)
+            0, top)), tooltip, self)
+        
+    def _display_widget(self, widget, top):
+        self._current_widget = widget
+        widget.show()
+        widget.move(self.mapToGlobal(QtCore.QPoint(-widget.width(), top)))
+
+    def _message_count(self, n):
+        pass
```

## pyqode/core/panels/global_checker.py

```diff
@@ -1,23 +1,25 @@
 """
 This module contains the GlobalCheckerPanel.
 
 """
 from pyqode.core import modes
 from pyqode.core.api import Panel, TextHelper
-from pyqode.qt import QtCore, QtGui
+from qtpy import QtCore, QtGui
 
 
 class GlobalCheckerPanel(Panel):
     """ Displays all checker messages found in the document.
 
     The user can click on a marker to quickly go the the error line.
 
     """
 
+    _use_syntax_theme = True
+
     def __init__(self):
         super(GlobalCheckerPanel, self).__init__()
         self.scrollable = True
 
     def _draw_messages(self, painter):
         """
         Draw messages from all subclass of CheckerMode currently
@@ -31,16 +33,16 @@
                 checker_modes.append(m)
         for checker_mode in checker_modes:
             for msg in checker_mode.messages:
                 block = msg.block
                 color = QtGui.QColor(msg.color)
                 brush = QtGui.QBrush(color)
                 rect = QtCore.QRect()
-                rect.setX(self.sizeHint().width() / 4)
-                rect.setY(block.blockNumber() * self.get_marker_height())
+                rect.setX(self.sizeHint().width() // 4)
+                rect.setY(int(block.blockNumber() * self.get_marker_height()))
                 rect.setSize(self.get_marker_size())
                 painter.fillRect(rect, brush)
 
     def _draw_visible_area(self, painter):
         """
         Draw the visible area.
 
@@ -49,58 +51,57 @@
         :type painter: QtGui.QPainter
         """
         if self.editor.visible_blocks:
             start = self.editor.visible_blocks[0][-1]
             end = self.editor.visible_blocks[-1][-1]
             rect = QtCore.QRect()
             rect.setX(0)
-            rect.setY(start.blockNumber() * self.get_marker_height())
+            rect.setY(int(start.blockNumber() * self.get_marker_height()))
             rect.setWidth(self.sizeHint().width())
-            rect.setBottom(end.blockNumber() * self.get_marker_height())
+            rect.setBottom(int(end.blockNumber() * self.get_marker_height()))
             if self.editor.background.lightness() < 128:
                 c = self.editor.background.darker(150)
             else:
                 c = self.editor.background.darker(110)
             c.setAlpha(128)
             painter.fillRect(rect, c)
 
     def paintEvent(self, event):
         """
         Pains the messages and the visible area on the panel.
         :param event: paint event infos
         """
-        if self.isVisible():
-            # fill background
-            self._background_brush = QtGui.QBrush(self.editor.background)
-            painter = QtGui.QPainter(self)
-            painter.fillRect(event.rect(), self._background_brush)
-            self._draw_messages(painter)
-            self._draw_visible_area(painter)
+        if not self.isVisible():
+            return
+        Panel.paintEvent(self, event)
+        painter = QtGui.QPainter(self)
+        self._draw_messages(painter)
+        self._draw_visible_area(painter)
 
     def sizeHint(self):
         """
         The panel has a fixed width of 8 pixels.
         """
         return QtCore.QSize(12, 16)
 
     def get_marker_height(self):
         """
         Gets the height of message marker.
         """
-        return self.editor.viewport().height() / TextHelper(
+        return self.editor.viewport().height() // TextHelper(
             self.editor).line_count()
 
     def get_marker_size(self):
         """
         Gets the size of a message marker.
         :return: QSize
         """
         h = self.get_marker_height()
         if h < 1:
             h = 1
-        return QtCore.QSize(self.sizeHint().width() / 2, h)
+        return QtCore.QSize(self.sizeHint().width() // 2, h)
 
     def mousePressEvent(self, event):
         # Moves the editor text cursor to the clicked line.
         height = event.pos().y()
         line = height // self.get_marker_height()
-        TextHelper(self.editor).goto_line(line)
+        TextHelper(self.editor).goto_line(line)
```

## pyqode/core/panels/line_number.py

```diff
@@ -1,18 +1,21 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the line number panel
 """
 from pyqode.core.api.panel import Panel
 from pyqode.core.api.utils import drift_color, TextHelper
-from pyqode.qt import QtCore, QtGui
+from qtpy import QtCore, QtGui
 
 
 class LineNumberPanel(Panel):
     """ Displays the document line numbers. """
+
+    _use_syntax_theme = True
+
     def __init__(self):
         Panel.__init__(self)
         self.scrollable = True
         self._selecting = False
         self._start_line = -1
         self._sel_start = -1
         self._line_color_u = self.palette().color(
@@ -110,8 +113,8 @@
                         (not has_sel and cl == line)):
                     painter.setPen(pen_selected)
                     painter.setFont(bold_font)
                 else:
                     painter.setPen(pen)
                     painter.setFont(font)
                 painter.drawText(-3, top, width, height,
-                                 QtCore.Qt.AlignRight, str(line + 1))
+                                 QtCore.Qt.AlignRight, str(line + 1))
```

## pyqode/core/panels/marker.py

```diff
@@ -3,15 +3,15 @@
 This module contains the marker panel
 """
 import logging
 
 from pyqode.core.api import TextDecoration
 from pyqode.core.api.panel import Panel
 from pyqode.core.api.utils import DelayJobRunner, TextHelper
-from pyqode.qt import QtCore, QtWidgets, QtGui
+from qtpy import QtCore, QtWidgets, QtGui
 
 
 def _logger():
     """ Gets module's logger """
     return logging.getLogger(__name__)
 
 
@@ -242,8 +242,8 @@
         self._previous_line = -1
 
     def _display_tooltip(self, tooltip, top):
         """
         Display tooltip at the specified top position.
         """
         QtWidgets.QToolTip.showText(self.mapToGlobal(QtCore.QPoint(
-            self.sizeHint().width(), top)), tooltip, self)
+            self.sizeHint().width(), top)), tooltip, self)
```

## pyqode/core/panels/read_only.py

```diff
@@ -1,14 +1,14 @@
 """
 Contains a panel to manage unicode decoding/encoding errors.
 
 """
 from pyqode.core.api.panel import Panel
 from pyqode.core.api.decoration import TextDecoration
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 class ReadOnlyPanel(Panel):
     """ Displays a message if the opened file is read-only """
 
     @property
     def color(self):
@@ -64,15 +64,10 @@
         self.ui.setupUi(self)
         self._color = None
         self.color = QtGui.QColor('#8AADD4')
         self._foreground = None
         self.foreground = QtGui.QColor('#FFFFFF')
         self.hide()
 
-    def paintEvent(self, event):
-        """ Fills the panel background. """
-        super(ReadOnlyPanel, self).paintEvent(event)
-        if self.isVisible():
-            # fill background
-            painter = QtGui.QPainter(self)
-            self._background_brush = QtGui.QBrush(self._color)
-            painter.fillRect(event.rect(), self._background_brush)
+    @property
+    def _background_brush(self):
+        return QtGui.QBrush(self._color)
```

## pyqode/core/panels/encodings.py

```diff
@@ -1,14 +1,14 @@
 """
 Contains a panel to manage unicode decoding/encoding errors.
 
 """
 from pyqode.core.api.panel import Panel
 from pyqode.core.api.decoration import TextDecoration
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 class EncodingPanel(Panel):
     """ Displays a warning when an encoding error occured and let you reload.
 
     This panel display a warning in case encoding/decoding error and
     give the user the possibility to try out another encoding, to edit any way
@@ -150,29 +150,24 @@
         self.editor.decorations.append(self._deco)
         cursor = self.editor.textCursor()
         cursor.clearSelection()
         cursor.setPosition(0)
         self.editor.setTextCursor(cursor)
         self.editor.setReadOnly(True)
 
-    def paintEvent(self, event):
-        """ Fills the panel background. """
-        super(EncodingPanel, self).paintEvent(event)
-        if self.isVisible():
-            # fill background
-            painter = QtGui.QPainter(self)
-            self._background_brush = QtGui.QBrush(self._color)
-            painter.fillRect(event.rect(), self._background_brush)
+    @property
+    def _background_brush(self):
+        return QtGui.QBrush(self._color)
 
     def on_install(self, editor):
         super(EncodingPanel, self).on_install(editor)
         if self.__add_ctx_mnu:
             # add context menu
             from pyqode.core.widgets import EncodingsContextMenu
-            EncodingsContextMenu(parent=editor)
+            self._context_menu = EncodingsContextMenu(parent=editor)
 
     def _reload(self):
         self.hide()
         self._rm_deco()
         self.editor.setReadOnly(False)
         self.enable_caret_line(True)
         self.editor.file.reload(self.ui.comboBoxEncodings.current_encoding)
@@ -187,22 +182,27 @@
         if self._deco:
             self.editor.decorations.remove(self._deco)
             self._deco = None
 
     def cancel(self):
         if self.sender():
             self.editor.clear()
+        self.close_panel()
+
+    def close_panel(self):
         self._rm_deco()
         self.enable_caret_line(True)
         self.cancel_requested.emit(self.editor)
         self.hide()
 
     def clone_settings(self, original):
         self.color = original.color
         self.foreground = original.foreground
+        if self.__add_ctx_mnu:
+            self._context_menu._refresh()
 
 
 if __name__ == '__main__':
     import locale
     import sys
     from pyqode.core.api import CodeEdit
 
@@ -218,8 +218,8 @@
     edit.setMinimumSize(800, 600)
     edit.file.open(__file__)
     pnl = EncodingPanel()
     edit.panels.append(pnl, pnl.Position.TOP)
     edit.show()
     simulate_open()
     QtCore.QTimer.singleShot(5000, simulate_save)
-    app.exec_()
+    app.exec_()
```

## pyqode/core/panels/search_and_replace.py

```diff
@@ -1,24 +1,34 @@
 # -*- coding: utf-8 -*-
 """
 This module contains the search and replace panel
 """
 import re
 import sre_constants
 
-from pyqode.qt import QtCore, QtGui, QtWidgets
-
+from qtpy import QtCore, QtGui, QtWidgets
 from pyqode.core import icons
 from pyqode.core._forms.search_panel_ui import Ui_SearchPanel
 from pyqode.core.api.decoration import TextDecoration
 from pyqode.core.api.panel import Panel
 from pyqode.core.api.utils import DelayJobRunner, TextHelper
 from pyqode.core.backend import NotRunning
 from pyqode.core.backend.workers import findall
 
+NAVIGATION_KEYS = (
+    QtCore.Qt.Key_Up,
+    QtCore.Qt.Key_Down,
+    QtCore.Qt.Key_Left,
+    QtCore.Qt.Key_Right,
+    QtCore.Qt.Key_Home,
+    QtCore.Qt.Key_End,
+    QtCore.Qt.Key_PageUp,
+    QtCore.Qt.Key_PageDown,
+)
+
 
 class SearchAndReplacePanel(Panel, Ui_SearchPanel):
     """ Lets the user search and replace text in the current document.
 
     It uses the backend API to search for some text. Search operation is
     performed in a background process (the backend process)..
 
@@ -127,24 +137,28 @@
                     pass
 
     def __init__(self):
         Panel.__init__(self, dynamic=True)
         self.job_runner = DelayJobRunner(delay=500)
         Ui_SearchPanel.__init__(self)
         self.setupUi(self)
+        self.toolButtonClose.clicked.connect(self.on_close)
+        self.actionSearch.triggered.connect(self.on_search)
+        self.actionActionSearchAndReplace.triggered.connect(self.on_search_and_replace)
         self.lineEditReplace.prompt_text = _(' Replace')
         #: Occurrences counter
         self.cpt_occurences = 0
         self._previous_stylesheet = ""
         self._separator = None
         self._decorations = []
         self._occurrences = []
         self._current_occurrence_index = 0
         self._bg = None
         self._fg = None
+        self._working = False
         self._update_buttons(txt="")
         self.lineEditSearch.installEventFilter(self)
         self.lineEditReplace.installEventFilter(self)
         self._init_actions()
         self._init_style()
         self.checkBoxRegex.stateChanged.connect(
             self.checkBoxWholeWords.setDisabled)
@@ -181,15 +195,19 @@
         self.toolButtonNext.setIconSize(icon_size)
 
         icon = icons.icon('window-close', ':/pyqode-icons/rc/close.png',
                           'fa.close')
         self.toolButtonClose.setIcon(icon)
         self.toolButtonClose.setIconSize(icon_size)
 
+    def _build_menu(self):
+        if hasattr(self, 'menu'):
+            return
         self.menu = QtWidgets.QMenu(self.editor)
+        self.menu.setIcon(icons.icon(qta_name='fa.search'))
         self.menu.setTitle(_('Search'))
         self.menu.menuAction().setIcon(self.actionSearch.icon())
         self.menu.addAction(self.actionSearch)
         self.actionSearch.setShortcutContext(QtCore.Qt.WidgetShortcut)
         self.menu.addAction(self.actionActionSearchAndReplace)
         self.actionActionSearchAndReplace.setShortcutContext(
             QtCore.Qt.WidgetShortcut)
@@ -216,14 +234,15 @@
             deco.set_outline(self._outline)
             self.editor.decorations.append(deco)
 
     def on_state_changed(self, state):
         super(SearchAndReplacePanel, self).on_state_changed(state)
         if state:
             # menu
+            self._build_menu()
             self.editor.add_action(self.menu.menuAction())
             # requestSearch slot
             self.editor.textChanged.connect(self.request_search)
             self.lineEditSearch.textChanged.connect(self.request_search)
             self.checkBoxCase.stateChanged.connect(self.request_search)
             self.checkBoxWholeWords.stateChanged.connect(self.request_search)
             self.checkBoxRegex.stateChanged.connect(self.request_search)
@@ -262,38 +281,55 @@
             self.search_finished.disconnect(self._on_search_finished)
 
     def close_panel(self):
         """
         Closes the panel
         """
         self.hide()
+        try:
+            self.editor.key_pressed.disconnect(self._on_key_pressed)
+        except TypeError:
+            # In some race conditions, for example when clicking the close
+            # button and pressing escape almost simultaneously, the signal is
+            # already disconnected
+            pass
         self.lineEditReplace.clear()
         self.lineEditSearch.clear()
+        self.editor.setFocus()
+
+    def _on_key_pressed(self, event):
+
+        if event.isAccepted():
+            return
+        if not self.lineEditSearch.isVisible():
+            return
+        if event.key() == QtCore.Qt.Key_Escape:
+            self.close_panel()
+            event.accept()
 
-    @QtCore.Slot()
-    def on_toolButtonClose_clicked(self):
+    def on_close(self):
         self.close_panel()
 
-    @QtCore.Slot()
-    def on_actionSearch_triggered(self):
+    def on_search(self):
+        self.editor.key_pressed.connect(self._on_key_pressed)
         self.widgetSearch.show()
         self.widgetReplace.hide()
         self.show()
         new_text = self.text_helper.selected_text()
         old_text = self.lineEditSearch.text()
         text_changed = new_text != old_text
         self.lineEditSearch.setText(new_text)
         self.lineEditSearch.selectAll()
         self.lineEditSearch.setFocus()
         self.setFocusPolicy(QtCore.Qt.ClickFocus)
         if not text_changed:
             self.request_search(new_text)
 
-    @QtCore.Slot()
-    def on_actionActionSearchAndReplace_triggered(self):
+    def on_search_and_replace(self):
+        self.editor.key_pressed.connect(self._on_key_pressed)
         self.widgetSearch.show()
         self.widgetReplace.show()
         self.show()
         new_txt = self.text_helper.selected_text()
         old_txt = self.lineEditSearch.text()
         txt_changed = new_txt != old_txt
         self.lineEditSearch.setText(new_txt)
@@ -321,14 +357,15 @@
                 return
             else:
                 self._show_error(None)
 
         if txt is None or isinstance(txt, int):
             txt = self.lineEditSearch.text()
         if txt:
+            self._working = True
             self.job_runner.request_job(
                 self._exec_search, txt, self._search_flags())
         else:
             self.job_runner.cancel_requests()
             self._clear_occurrences()
             self._on_search_finished()
 
@@ -367,82 +404,100 @@
     def select_next(self):
         """
         Selects the next occurrence.
 
         :return: True in case of success, false if no occurrence could be
                  selected.
         """
-        current_occurence = self._current_occurrence()
-        occurrences = self.get_occurences()
-        if not occurrences:
+
+        if self._working:
+            QtCore.QTimer.singleShot(100, self.select_next)
             return
-        current = self._occurrences[current_occurence]
-        cursor_pos = self.editor.textCursor().position()
-        if cursor_pos not in range(current[0], current[1] + 1) or \
-                current_occurence == -1:
-            # search first occurrence that occurs after the cursor position
-            current_occurence = 0
-            for i, (start, end) in enumerate(self._occurrences):
-                if end > cursor_pos:
-                    current_occurence = i
-                    break
-        else:
-            if (current_occurence == -1 or
-                    current_occurence >= len(occurrences) - 1):
-                current_occurence = 0
-            else:
-                current_occurence += 1
-        self._set_current_occurrence(current_occurence)
-        try:
-            cursor = self.editor.textCursor()
-            cursor.setPosition(occurrences[current_occurence][0])
-            cursor.setPosition(occurrences[current_occurence][1],
-                               cursor.KeepAnchor)
-            self.editor.setTextCursor(cursor)
-            return True
-        except IndexError:
-            return False
+        return self._select_match(previous=False)
 
     def select_previous(self):
         """
         Selects previous occurrence.
 
         :return: True in case of success, false if no occurrence could be
                  selected.
         """
+
+        if self._working:
+            QtCore.QTimer.singleShot(100, self.select_previous)
+            return
+        return self._select_match(previous=True)
+        
+    def _select_match(self, previous=False):
+        
         current_occurence = self._current_occurrence()
         occurrences = self.get_occurences()
         if not occurrences:
             return
         current = self._occurrences[current_occurence]
-        cursor_pos = self.editor.textCursor().position()
-        if cursor_pos not in range(current[0], current[1] + 1) or \
-                current_occurence == -1:
-            # search first occurrence that occurs before the cursor position
-            current_occurence = len(self._occurrences) - 1
-            for i, (start, end) in enumerate(self._occurrences):
-                if end >= cursor_pos:
-                    current_occurence = i - 1
-                    break
-        else:
-            if (current_occurence == -1 or
-                    current_occurence == 0):
+        cursor = self.editor.textCursor()
+        cursor_pos = cursor.position()
+        if (
+            cursor_pos not in range(current[0], current[1] + 1) or
+            current_occurence == -1
+        ):
+            if previous:
+                # search first occurrence that occurs before the cursor position
+                current_occurence = len(self._occurrences) - 1
+                for i, (start, end) in enumerate(self._occurrences):
+                    if end >= cursor_pos:
+                        current_occurence = i - 1
+                        break
+            else:
+                # search first occurrence that occurs after the cursor position
+                current_occurence = 0
+                for i, (start, end) in enumerate(self._occurrences):
+                    if end > cursor_pos:
+                        current_occurence = i
+                        break
+        elif previous:
+            if (current_occurence == -1 or current_occurence == 0):
                 current_occurence = len(occurrences) - 1
             else:
                 current_occurence -= 1
+        else:
+            if (
+                current_occurence == -1 or
+                current_occurence >= len(occurrences) - 1
+            ):
+                current_occurence = 0
+            else:
+                current_occurence += 1
         self._set_current_occurrence(current_occurence)
         try:
-            cursor = self.editor.textCursor()
-            cursor.setPosition(occurrences[current_occurence][0])
-            cursor.setPosition(occurrences[current_occurence][1],
-                               cursor.KeepAnchor)
-            self.editor.setTextCursor(cursor)
-            return True
+            selection_start = occurrences[current_occurence][0]
+            selection_end = occurrences[current_occurence][1]
         except IndexError:
             return False
+        cursor.setPosition(selection_start)
+        cursor.setPosition(selection_end, cursor.KeepAnchor)
+        self.editor.setTextCursor(cursor)
+        # This is a hack to fix an apparent bug in Qt. The next key press will
+        # reset the cursor to the first line of the block. To fix this, we 
+        # simulate a left keypress, and then move the cursor as far right as
+        # necessary to get it back to the correct position. This seems to work.
+        QtWidgets.QApplication.sendEvent(
+            self.editor,
+            QtGui.QKeyEvent(
+                QtGui.QKeyEvent.KeyPress,
+                QtCore.Qt.Key_Left,
+                QtCore.Qt.NoModifier
+            )
+        )
+        cursor = self.editor.textCursor()
+        actual_pos = cursor.position()
+        if selection_end > actual_pos:
+            cursor.movePosition(cursor.Right, n=selection_end - actual_pos)
+            self.editor.setTextCursor(cursor)
+        return True
 
     def replace(self, text=None):
         """
         Replaces the selected occurrence.
 
         :param text: The replacement text. If it is None, the lineEditReplace's
                      text is used instead.
@@ -497,34 +552,42 @@
         cursor.beginEditBlock()
         remains = self.replace(text=text)
         while remains:
             remains = self.replace(text=text)
         cursor.endEditBlock()
 
     def eventFilter(self, obj, event):
-        if event.type() == QtCore.QEvent.KeyPress:
-            if (event.key() == QtCore.Qt.Key_Tab or
-                    event.key() == QtCore.Qt.Key_Backtab):
-                return True
-            elif (event.key() == QtCore.Qt.Key_Return or
-                  event.key() == QtCore.Qt.Key_Enter):
-                if obj == self.lineEditReplace:
-                    if event.modifiers() & QtCore.Qt.ControlModifier:
-                        self.replace_all()
-                    else:
-                        self.replace()
-                elif obj == self.lineEditSearch:
-                    if event.modifiers() & QtCore.Qt.ShiftModifier:
-                        self.select_previous()
-                    else:
-                        self.select_next()
-                return True
-            elif event.key() == QtCore.Qt.Key_Escape:
-                self.on_toolButtonClose_clicked()
-        return Panel.eventFilter(self, obj, event)
+        if event.type() != QtCore.QEvent.KeyPress:
+            return Panel.eventFilter(self, obj, event)
+        key = event.key()
+        if key == QtCore.Qt.Key_Tab:
+            self.select_next()
+            return True
+        if key == QtCore.Qt.Key_Backtab:
+            self.select_previous()
+            return True
+        if key in NAVIGATION_KEYS:
+            self.editor.keyPressEvent(event)
+            return True
+        if key in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
+            if obj == self.lineEditReplace:
+                if event.modifiers() & QtCore.Qt.ControlModifier:
+                    self.replace_all()
+                else:
+                    self.replace()
+            elif obj == self.lineEditSearch:
+                if event.modifiers() & QtCore.Qt.ShiftModifier:
+                    self.select_previous()
+                else:
+                    self.select_next()
+            return True
+        if key == QtCore.Qt.Key_Escape:
+            self.on_close()
+            return True
+        return False
 
     def _search_flags(self):
         """
         Returns the user search flag: (regex, case_sensitive, whole_words).
         """
         return (self.checkBoxRegex.isChecked(),
                 self.checkBoxCase.isChecked(),
@@ -569,14 +632,15 @@
         if self.cpt_occurences:
             color = "#00DD00"
         self.labelMatches.setStyleSheet("color: %s" % color)
         if self.lineEditSearch.text() == "":
             self.labelMatches.clear()
 
     def _on_search_finished(self):
+        self._working = False
         self._clear_decorations()
         all_occurences = self.get_occurences()
         occurrences = all_occurences[:self.MAX_HIGHLIGHTED_OCCURENCES]
         for i, occurrence in enumerate(occurrences):
             deco = self._create_decoration(occurrence[0],
                                            occurrence[1])
             self._decorations.append(deco)
@@ -636,8 +700,8 @@
         enable = (txt != self.lineEditSearch.text() and
                   self.cpt_occurences)
         self.toolButtonReplace.setEnabled(enable)
         self.toolButtonReplaceAll.setEnabled(enable)
 
     def clone_settings(self, original):
         self.background = original.background
-        self.foreground = original.foreground
+        self.foreground = original.foreground
```

## pyqode/core/panels/folding.py

```diff
@@ -5,16 +5,27 @@
 import logging
 import os
 import sys
 from pyqode.core.api import TextBlockHelper, folding, TextDecoration, \
     DelayJobRunner
 from pyqode.core.api.folding import FoldScope
 from pyqode.core.api.panel import Panel
-from pyqode.qt import QtCore, QtWidgets, QtGui, PYQT5_API
-from pyqode.core.api.utils import TextHelper, drift_color, keep_tc_pos
+from qtpy import QtCore, QtWidgets, QtGui, PYQT5_API
+from pyqode.core.api.utils import TextHelper, drift_color
+
+NAVIGATION_KEYS = (
+    QtCore.Qt.Key_Up,
+    QtCore.Qt.Key_Down,
+    QtCore.Qt.Key_Left,
+    QtCore.Qt.Key_Right,
+    QtCore.Qt.Key_Home,
+    QtCore.Qt.Key_End,
+    QtCore.Qt.Key_PageUp,
+    QtCore.Qt.Key_PageDown,
+)
 
 
 def _logger():
     """ Gets module's logger """
     return logging.getLogger(__name__)
 
 
@@ -31,14 +42,15 @@
     :mod:`pyqode.core.api.folding`
     """
     #: signal emitted when a fold trigger state has changed, parameters are
     #: the concerned text block and the new state (collapsed or not).
     trigger_state_changed = QtCore.Signal(QtGui.QTextBlock, bool)
     collapse_all_triggered = QtCore.Signal()
     expand_all_triggered = QtCore.Signal()
+    _use_syntax_theme = True
 
     @property
     def native_look(self):
         """
         Defines whether the panel will use native indicator icons and color or
         use custom one.
 
@@ -140,26 +152,31 @@
                     try:
                         clone.modes.get(
                             self.__class__).highlight_caret_scope = value
                     except KeyError:
                         # this should never happen since we're working with
                         # clones
                         pass
+                    
+    @property
+    def fold_detector(self):
+        return self.editor.syntax_highlighter.fold_detector
 
     def __init__(self, highlight_caret_scope=False):
         Panel.__init__(self)
         self._native = True
         self._custom_indicators = (
             ':/pyqode-icons/rc/arrow_right_off.png',
             ':/pyqode-icons/rc/arrow_right_on.png',
             ':/pyqode-icons/rc/arrow_down_off.png',
             ':/pyqode-icons/rc/arrow_down_on.png'
         )
         self._custom_color = QtGui.QColor('gray')
         self._block_nbr = -1
+        self._from_block = None
         self._highlight_caret = False
         self.highlight_caret_scope = highlight_caret_scope
         self._indic_size = 16
         #: the list of deco used to highlight the current fold region (
         #: surrounding regions are darker)
         self._scope_decos = []
         #: the list of folded blocs decorations
@@ -207,15 +224,15 @@
         action.triggered.connect(self._on_action_expand_all_triggered)
         self.context_menu.addAction(action)
         self.editor.add_menu(self.context_menu)
 
     def sizeHint(self):
         """ Returns the widget size hint (based on the editor font size) """
         fm = QtGui.QFontMetricsF(self.editor.font())
-        size_hint = QtCore.QSize(fm.height(), fm.height())
+        size_hint = QtCore.QSize(int(fm.height()), int(fm.height()))
         if size_hint.width() > 16:
             size_hint.setWidth(16)
         return size_hint
 
     def paintEvent(self, event):
         # Paints the fold indicators and the possible fold region background
         # on the folding panel.
@@ -288,15 +305,17 @@
 
         :param rect: The fold zone rect to draw
 
         :param painter: The widget's painter.
         """
         c = self._custom_color
         if self._native:
-            c = self.get_system_bck_color()
+            c = self.editor.syntax_highlighter.color_scheme.formats[
+                'highlight'
+            ].background().color()
         grad = QtGui.QLinearGradient(rect.topLeft(),
                                      rect.topRight())
         if sys.platform == 'darwin':
             grad.setColorAt(0, c.lighter(100))
             grad.setColorAt(1, c.lighter(110))
             outline = c.darker(110)
         else:
@@ -318,53 +337,27 @@
                          rect.bottomRight() -
                          QtCore.QPointF(0, 1))
         painter.drawLine(rect.topLeft() +
                          QtCore.QPointF(0, 1),
                          rect.bottomLeft() -
                          QtCore.QPointF(0, 1))
 
-    @staticmethod
-    def get_system_bck_color():
-        """
-        Gets a system color for drawing the fold scope background.
-        """
-        def merged_colors(colorA, colorB, factor):
-            maxFactor = 100
-            colorA = QtGui.QColor(colorA)
-            colorB = QtGui.QColor(colorB)
-            tmp = colorA
-            tmp.setRed((tmp.red() * factor) / maxFactor +
-                       (colorB.red() * (maxFactor - factor)) / maxFactor)
-            tmp.setGreen((tmp.green() * factor) / maxFactor +
-                         (colorB.green() * (maxFactor - factor)) / maxFactor)
-            tmp.setBlue((tmp.blue() * factor) / maxFactor +
-                        (colorB.blue() * (maxFactor - factor)) / maxFactor)
-            return tmp
-
-        pal = QtWidgets.QApplication.instance().palette()
-        b = pal.window().color()
-        h = pal.highlight().color()
-        return merged_colors(b, h, 50)
-
     def _draw_fold_indicator(self, top, mouse_over, collapsed, painter):
         """
         Draw the fold indicator/trigger (arrow).
 
         :param top: Top position
         :param mouse_over: Whether the mouse is over the indicator
         :param collapsed: Whether the trigger is collapsed or not.
         :param painter: QPainter
         """
         rect = QtCore.QRect(0, top, self.sizeHint().width(),
                             self.sizeHint().height())
         if self._native:
-            if os.environ['QT_API'].lower() not in PYQT5_API:
-                opt = QtGui.QStyleOptionViewItemV2()
-            else:
-                opt = QtWidgets.QStyleOptionViewItem()
+            opt = QtWidgets.QStyleOptionViewItem()
             opt.rect = rect
             opt.state = (QtWidgets.QStyle.State_Active |
                          QtWidgets.QStyle.State_Item |
                          QtWidgets.QStyle.State_Children)
             if not collapsed:
                 opt.state |= QtWidgets.QStyle.State_Open
             if mouse_over:
@@ -622,60 +615,54 @@
 
     def on_state_changed(self, state):
         """
         On state changed we (dis)connect to the cursorPositionChanged signal
         """
         if state:
             self.editor.key_pressed.connect(self._on_key_pressed)
+            self.editor.key_released.connect(self._on_key_released)
             if self._highlight_caret:
                 self.editor.cursorPositionChanged.connect(
                     self._highlight_caret_scope)
                 self._block_nbr = -1
             self.editor.new_text_set.connect(self._clear_block_deco)
         else:
             self.editor.key_pressed.disconnect(self._on_key_pressed)
+            self.editor.key_released.disconnect(self._on_key_released)
             if self._highlight_caret:
                 self.editor.cursorPositionChanged.disconnect(
                     self._highlight_caret_scope)
                 self._block_nbr = -1
             self.editor.new_text_set.disconnect(self._clear_block_deco)
 
     def _on_key_pressed(self, event):
         """
-        Override key press to select the current scope if the user wants
-        to deleted a folded scope (without selecting it).
+        Override key press so that folded blocks are unfolded when they are
+        edited. This avoids inconsistencies when the edits actually change the
+        fold structure.
         """
-        delete_request = event.key() in [QtCore.Qt.Key_Backspace,
-                                         QtCore.Qt.Key_Delete]
-        if event.text() or delete_request:
-            cursor = self.editor.textCursor()
-            if cursor.hasSelection():
-                # change selection to encompass the whole scope.
-                positions_to_check = cursor.selectionStart(), cursor.selectionEnd()
-            else:
-                positions_to_check = (cursor.position(), )
-            for pos in positions_to_check:
-                block = self.editor.document().findBlock(pos)
-                th = TextBlockHelper()
-                if th.is_fold_trigger(block) and th.is_collapsed(block):
-                    self.toggle_fold_trigger(block)
-                    if delete_request and cursor.hasSelection():
-                        scope = FoldScope(self.find_parent_scope(block))
-                        tc = TextHelper(self.editor).select_lines(*scope.get_range())
-                        if tc.selectionStart() > cursor.selectionStart():
-                            start = cursor.selectionStart()
-                        else:
-                            start = tc.selectionStart()
-                        if tc.selectionEnd() < cursor.selectionEnd():
-                            end = cursor.selectionEnd()
-                        else:
-                            end = tc.selectionEnd()
-                        tc.setPosition(start)
-                        tc.setPosition(end, tc.KeepAnchor)
-                        self.editor.setTextCursor(tc)
+        
+        if event.key() in NAVIGATION_KEYS:
+            return
+        block = self.editor.textCursor().block()
+        if (
+            TextBlockHelper.is_collapsed(block) or
+            not block.isVisible()
+        ):
+            self._on_action_toggle()
+        self._from_block = block.blockNumber(), block.text()
+    
+    def _on_key_released(self, event):
+        
+        block = self.editor.textCursor().block()
+        if self.fold_detector and self.fold_detector.require_rehighlight(
+            self._from_block,
+            (block.blockNumber(), block.text())
+        ):
+            self.editor.syntax_highlighter.rehighlight()
 
     @staticmethod
     def _show_previous_blank_lines(block):
         """
         Show the block previous blank lines
         """
         # set previous blank lines visibles
```

## pyqode/core/widgets/__init__.py

```diff
@@ -17,27 +17,30 @@
 
 """
 from pyqode.core.widgets.code_edits import TextCodeEdit, GenericCodeEdit
 from pyqode.core.widgets.encodings import (EncodingsComboBox, EncodingsMenu,
                                            EncodingsContextMenu)
 from pyqode.core.widgets.errors_table import ErrorsTable
 from pyqode.core.widgets.file_icons_provider import FileIconProvider
-from pyqode.core.widgets.interactive import InteractiveConsole
+from pyqode.core.widgets.interactive import InteractiveConsole  # Deprecated
 from pyqode.core.widgets.menu_recents import MenuRecentFiles
 from pyqode.core.widgets.menu_recents import RecentFilesManager
 from pyqode.core.widgets.preview import HtmlPreviewWidget
 from pyqode.core.widgets.tabs import TabWidget
 from pyqode.core.widgets.tab_bar import TabBar
 from pyqode.core.widgets.prompt_line_edit import PromptLineEdit
 from pyqode.core.widgets.outline import OutlineTreeWidget
 from pyqode.core.widgets.splittable_tab_widget import (
     SplittableTabWidget, SplittableCodeEditTabWidget)
 from pyqode.core.widgets.filesystem_treeview import FileSystemTreeView
 from pyqode.core.widgets.filesystem_treeview import FileSystemContextMenu
 from pyqode.core.widgets.filesystem_treeview import FileSystemHelper
+from pyqode.core.widgets.output_window import OutputWindow
+from pyqode.core.widgets.terminal import Terminal
+
 
 __all__ = [
     'ErrorsTable',
     'FileSystemContextMenu',
     'FileSystemTreeView',
     'InteractiveConsole',
     'FileIconProvider',
@@ -51,9 +54,11 @@
     'TextCodeEdit',
     'GenericCodeEdit',
     'PromptLineEdit',
     'OutlineTreeWidget',
     'SplittableTabWidget',
     'SplittableCodeEditTabWidget',
     'TabBar',
-    'HtmlPreviewWidget'
+    'HtmlPreviewWidget',
+    'OutputWindow',
+    'Terminal'
 ]
```

## pyqode/core/widgets/encodings.py

```diff
@@ -1,14 +1,15 @@
 """
 This module contains the encodings related widgets (combox, menus,...)
 """
 import locale
 import logging
+from pyqode.core import icons
 from pyqode.core.api import ENCODINGS_MAP, convert_to_codec_key
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
 from pyqode.core.cache import Cache
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
@@ -97,14 +98,15 @@
         self._current_encoding = convert_to_codec_key(value)
         self._refresh()
 
     def __init__(self, title=_('Encodings'), parent=None,
                  selected_encoding=locale.getpreferredencoding()):
         super(EncodingsMenu, self).__init__(parent)
         self.setTitle(title)
+        self.setIcon(icons.icon(qta_name='fa.file-text'))
         self._group = QtWidgets.QActionGroup(self)
         self._edit_action = None
         self._current_encoding = ''
         self.current_encoding = selected_encoding
 
     def _clear_actions(self):
         for action in self._group.actions():
@@ -115,15 +117,15 @@
     def _refresh(self):
         self._clear_actions()
         for i, encoding in enumerate(sorted(Cache().preferred_encodings)):
             encoding = convert_to_codec_key(encoding)
             try:
                 alias, lang = ENCODINGS_MAP[encoding]
             except KeyError:
-                _logger().warn('KeyError with encoding:', encoding)
+                _logger().warn('KeyError with encoding: %s' % encoding)
             else:
                 action = QtWidgets.QAction('%s (%s)' % (alias, lang), self)
                 action.setData(encoding)
                 action.setCheckable(True)
                 if encoding == self._current_encoding or \
                         convert_to_codec_key(alias) == self._current_encoding:
                     action.setChecked(True)
@@ -136,15 +138,14 @@
         self.addAction(self._edit_action)
 
     def _on_edit_requested(self):
         from pyqode.core.dialogs import DlgPreferredEncodingsEditor
         if DlgPreferredEncodingsEditor.edit_encoding(self):
             self._refresh()
 
-    @QtCore.Slot(QtWidgets.QAction)
     def _on_encoding_triggered(self, action):
         self.reload_requested.emit(action.data())
 
 
 class EncodingsContextMenu(EncodingsMenu):
     """
     Extends the encoding menu to be tightly coupled with a CodeEdit instance
@@ -170,20 +171,18 @@
         self._refresh()
 
     def _refresh(self):
         self._current_encoding = convert_to_codec_key(
             self.parent().file.encoding)
         super(EncodingsContextMenu, self)._refresh()
 
-    @QtCore.Slot(str)
     def _on_reload_requested(self, encoding):
         self._encoding = encoding
         self._timer.start()
 
-    @QtCore.Slot()
     def _reload(self):
         self._timer.stop()
         try:
             self.parent().file.reload(self._encoding)
         except UnicodeDecodeError:
             QtWidgets.QMessageBox.warning(
                 self.parent(), _('Decoding error'),
@@ -191,8 +190,8 @@
         else:
             try:
                 from pyqode.core.panels import EncodingPanel
                 panel = self.parent().panels.get(EncodingPanel)
             except KeyError:
                 pass
             else:
-                panel.cancel()
+                panel.close_panel()
```

## pyqode/core/widgets/errors_table.py

```diff
@@ -1,14 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 Contains a custom QTableWidget for easier displaying of CheckerMessages
 """
 from pyqode.core.api.utils import memoized
 from pyqode.core.modes import CheckerMessage, CheckerMessages
-from pyqode.qt import QtCore, QtWidgets, QtGui
+from qtpy import QtCore, QtWidgets, QtGui
 
 
 COL_TYPE = 0
 COL_FILE_NAME = 1
 COL_LINE_NBR = 2
 COL_MSG = 3
 
@@ -158,8 +158,8 @@
         desc = desc.replace('\r\n', '\n').replace('\r', '\n')
         desc = desc.replace('\n', '<br/>')
         QtWidgets.QMessageBox.information(
             self, _('Message details'),
             _("""<p><b>Description:</b><br/>%s</p>
 <p><b>File:</b><br/>%s</p>
 <p><b>Line:</b><br/>%d</p>
-            """) % (desc, msg.path, msg.line + 1, ))
+            """) % (desc, msg.path, msg.line + 1, ))
```

## pyqode/core/widgets/file_icons_provider.py

```diff
@@ -1,10 +1,10 @@
 import mimetypes
 import sys
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 class FileIconProvider(QtWidgets.QFileIconProvider):
     """
     Provides file/folder icons based on their mimetype.
     """
     plugins = []
@@ -51,8 +51,8 @@
                     FileIconProvider.Folder: QtGui.QIcon.fromTheme('folder'),
                 }
                 try:
                     return map[type_or_info]
                 except KeyError:
                     return super().icon(type_or_info)
         else:
-            return QtWidgets.QFileIconProvider().icon(type_or_info)
+            return QtWidgets.QFileIconProvider().icon(type_or_info)
```

## pyqode/core/widgets/outline.py

```diff
@@ -3,15 +3,15 @@
 outline.
 
 """
 import weakref
 from pyqode.core import icons
 from pyqode.core.panels import FoldingPanel
 from pyqode.core.modes.outline import OutlineMode
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 from pyqode.core.api import TextBlockHelper, TextBlockUserData, TextHelper
 
 
 class OutlineTreeWidget(QtWidgets.QTreeWidget):
     """
     Displays the outline of a CodeEdit.
 
@@ -270,8 +270,8 @@
         for action in self._context_actions:
             mnu.addAction(action)
         mnu.exec_(self.mapToGlobal(pos))
 
     def _on_action_sync_toggled(self, value):
         self.sync_with_editor = value
         if value:
-            self.sync()
+            self.sync()
```

## pyqode/core/widgets/preview.py

```diff
@@ -1,13 +1,13 @@
 """
 This module contains a widget that can show the html preview of an
 editor.
 """
 from weakref import proxy
-from pyqode.qt import QtCore, QtWidgets
+from qtpy import QtCore, QtWidgets
 from pyqode.core.api import DelayJobRunner
 
 
 class HtmlPreviewWidget(QtWidgets.QTextEdit):
     """
     Display html preview of a document as rich text in a QTextEdit.
     """
@@ -51,8 +51,8 @@
             # restore cursor/scrollbar position
             c = self.textCursor()
             c.setPosition(p)
             self.setTextCursor(c)
             self.verticalScrollBar().setValue(v)
         except (TypeError, AttributeError):
             self.setHtml('<center>No preview available...</center>')
-            self.hide_requested.emit()
+            self.hide_requested.emit()
```

## pyqode/core/widgets/prompt_line_edit.py

```diff
@@ -1,17 +1,14 @@
 """
 This module contains the PromptLineEdit widget implementation.
 
 """
 import os
 from pyqode.core import icons
-from pyqode.qt import QtWidgets, QtCore, QtGui
-from pyqode.qt import PYQT5_API
-from pyqode.qt import PYQT4_API
-from pyqode.qt import PYSIDE_API
+from qtpy import QtWidgets, QtCore, QtGui
 
 
 class PromptLineEdit(QtWidgets.QLineEdit):
 
     """
     Extends QLineEdit to show a prompt text and a clear icon
     """
@@ -52,32 +49,17 @@
     @prompt_text.setter
     def prompt_text(self, prompt):
         self._prompt_text = prompt
         self.update()
 
     def paintEvent(self, event):
         super(PromptLineEdit, self).paintEvent(event)
-
-        qt_api = os.environ['QT_API'].lower()
         if self._prompt_text and not self.text() and self.isEnabled():
-            if qt_api in PYQT4_API:
-                from PyQt4.QtGui import QStyleOptionFrameV3
-                option = QStyleOptionFrameV3()
-            elif qt_api in PYSIDE_API:
-                from PySide.QtGui import QStyleOptionFrameV3
-                option = QStyleOptionFrameV3()
-            elif qt_api in PYQT5_API:
-                from PyQt5.QtWidgets import QStyleOptionFrame
-                option = QStyleOptionFrame()
-            else:
-                msg = 'Qt bindings "%s" is not supported' % qt_api
-                raise PythonQtError(msg)
-
+            option = QtWidgets.QStyleOptionFrame()
             self.initStyleOption(option)
-
             left, top, right, bottom = self.getTextMargins()
 
             va = self.style().visualAlignment(
                 self.layoutDirection(), self.alignment())
             rect = self.style().subElementRect(
                 QtWidgets.QStyle.SE_LineEditContents, option, self).adjusted(
                     2, 0, 0, 0).adjusted(left, top, -right, -bottom)
```

## pyqode/core/widgets/tab_bar.py

```diff
@@ -1,11 +1,11 @@
 """
 This module contains the tab bar used in the splittable tab widget.
 """
-from pyqode.qt import QtWidgets, QtCore
+from qtpy import QtWidgets, QtCore
 from pyqode.core.api import DelayJobRunner
 
 
 class TabBar(QtWidgets.QTabBar):
     """
     Tab bar specialized to allow the user to close a tab using mouse middle
     click. Also exposes a double clicked signal.
@@ -22,8 +22,8 @@
         if event.button() == QtCore.Qt.MiddleButton:
             tab = self.tabAt(event.pos())
             self._timer.request_job(
                 self.parentWidget().tabCloseRequested.emit, tab)
 
     def mouseDoubleClickEvent(self, event):
         if event.button() == QtCore.Qt.LeftButton:
-            self.double_clicked.emit()
+            self.double_clicked.emit()
```

## pyqode/core/widgets/tabs.py

```diff
@@ -5,16 +5,16 @@
 """
 import logging
 import os
 
 from pyqode.core.dialogs.unsaved_files import DlgUnsavedFiles
 from pyqode.core.modes.filewatcher import FileWatcherMode
 from pyqode.core.widgets.tab_bar import TabBar
-from pyqode.qt import QtCore, QtWidgets
-from pyqode.qt.QtWidgets import QTabBar, QTabWidget
+from qtpy import QtCore, QtWidgets
+from qtpy.QtWidgets import QTabBar, QTabWidget
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 class TabWidget(QTabWidget):
@@ -76,37 +76,34 @@
             qaction.triggered.connect(slot)
             self._context_mnu.addAction(qaction)
             self.addAction(qaction)
         # keep a list of widgets (to avoid PyQt bug where
         # the C++ class loose the wrapped obj type).
         self._widgets = []
 
-    @QtCore.Slot()
     def close(self):
         """
         Closes the active editor
         """
         self.tabCloseRequested.emit(self.currentIndex())
 
-    @QtCore.Slot()
     def close_others(self):
         """
         Closes every editors tabs except the current one.
         """
         current_widget = self.currentWidget()
         self._try_close_dirty_tabs(exept=current_widget)
         i = 0
         while self.count() > 1:
             widget = self.widget(i)
             if widget != current_widget:
                 self.removeTab(i)
             else:
                 i = 1
 
-    @QtCore.Slot()
     def close_all(self):
         """
         Closes all editors
         """
         if self._try_close_dirty_tabs():
             while self.count():
                 widget = self.widget(0)
@@ -122,15 +119,14 @@
             code_edit._tab_name = code_edit.file.name
         file_name = code_edit.file.name
         if self._name_exists(file_name):
             file_name = self._rename_duplicate_tabs(
                 code_edit, code_edit.file.name, code_edit.file.path)
             code_edit._tab_name = file_name
 
-    @QtCore.Slot()
     def save_current(self, path=None):
         """
         Save current editor content. Leave file to None to erase the previous
         file content. If the current editor's file_path is None and path
         is None, the function will call
         ``QtWidgets.QFileDialog.getSaveFileName`` to get a valid save filename.
 
@@ -159,15 +155,14 @@
                         QtCore.QFileInfo(code_edit.file.path))
                     self.setTabIcon(self.currentIndex(), icon)
             return True
         except AttributeError:  # not an editor widget
             pass
         return False
 
-    @QtCore.Slot()
     def save_all(self):
         """
         Save all editors.
         """
         initial_index = self.currentIndex()
         for i in range(self.count()):
             try:
@@ -455,8 +450,8 @@
 
     def _on_file_deleted(self, editor):
         """
         Removes deleted files from the tab widget.
 
         ;:param editor: CodeEdit to remove
         """
-        self.removeTab(self.indexOf(editor))
+        self.removeTab(self.indexOf(editor))
```

## pyqode/core/widgets/filesystem_treeview.py

```diff
@@ -1,29 +1,29 @@
 """
 This module contains the file system tree view.
 """
 import sys
-import fnmatch
 import locale
 import logging
 import os
 import platform
 import shutil
 import subprocess
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from pathspec import PathSpec
+from qtpy import QtCore, QtGui, QtWidgets
 from pyqode.core import icons
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 def debug(msg, *args):
     return _logger().log(5, msg, *args)
-
+    
 
 class FileSystemTreeView(QtWidgets.QTreeView):
     """
     Extends QtWidgets.QTreeView with a filterable file system model.
 
     To exclude directories or extension, just set
     :attr:`FilterProxyModel.ignored_directories` and
@@ -38,49 +38,63 @@
 
     """
     class FilterProxyModel(QtCore.QSortFilterProxyModel):
         """
         Excludes :attr:`ignored_directories` and :attr:`ignored_extensions`
         from the file system model.
         """
-        def __init__(self):
+        def __init__(self, ignored_patterns):
             super(FileSystemTreeView.FilterProxyModel, self).__init__()
-            #: The list of file extension to exclude
-            self.ignored_patterns = [
-                '*.pyc', '*.pyo', '*.coverage', '.DS_Store', '__pycache__']
+            self.ignored_patterns = [p.strip() for p in ignored_patterns if p.strip()]
             self._ignored_unused = []
+            self._ignore_spec = PathSpec.from_lines(
+                'gitwildmatch',
+                self.ignored_patterns
+            )
 
         def set_root_path(self, path):
             """
             Sets the root path to watch.
             :param path: root path (str).
             """
             self._ignored_unused[:] = []
             self._root = path
             parent_dir = os.path.dirname(path)
             for item in os.listdir(parent_dir):
                 item_path = os.path.join(parent_dir, item)
                 if item_path != path:
                     self._ignored_unused.append(os.path.normpath(item_path))
-
+                    
         def filterAcceptsRow(self, row, parent):
             index0 = self.sourceModel().index(row, 0, parent)
             finfo = self.sourceModel().fileInfo(index0)
             fn = finfo.fileName()
             fp = os.path.normpath(finfo.filePath())
             if os.path.ismount(self._root):
                 return True
             if fp in self._ignored_unused:
                 return False
-            for ptrn in self.ignored_patterns:
-                if fnmatch.fnmatch(fn, ptrn):
-                    return False
+            try:
+                rel_path = os.path.relpath(fp, self._root)
+            except ValueError:
+                return False
+            rel_root = os.path.join('..', os.path.basename(self._root))
+            # We need to accept the root folder and all its parent folders
+            if rel_path == '.' or rel_path == '..':
+                return True
+            # Ignore files and folders that are at the same level as the root
+            # itself. This ensures that these are not added as unwanted
+            # top-level items.
+            if rel_path.startswith('..'):
+                return rel_path.startswith(rel_root)
+            if self._ignore_spec.match_file(rel_path):
+                return False
             debug('accepting %s', finfo.filePath())
             return True
-
+        
     #: signal emitted when the user deleted a file or a directory
     #: Deprecated, use files_deleted instead.
     #: Parameters:
     #: - path (str): path of the file that got deleted
     #: Note that if the removed path is a directory, this signal will be emitted for every file
     #: found recursively in the parent directory
     file_deleted = QtCore.Signal(str)
@@ -176,16 +190,15 @@
     def add_ignore_patterns(self, *patterns):
         """
         Adds an ignore pattern to the list for ignore patterns.
 
         Ignore patterns are used to filter out unwanted files or directories
         from the file system model.
 
-        A pattern is a Unix shell-style wildcards. See :mod:`fnmatch` for a
-        deeper explanation about the shell-style wildcards.
+        Patterns follow the .gitignore style as implemented in pathspec.
         """
         for ptrn in patterns:
             if isinstance(ptrn, list):
                 for p in ptrn:
                     self._ignored_patterns.append(p)
             else:
                 self._ignored_patterns.append(ptrn)
@@ -228,17 +241,15 @@
         if os.path.isfile(path):
             path = os.path.abspath(os.path.join(path, os.pardir))
         self._fs_model_source = QtWidgets.QFileSystemModel()
         self._fs_model_source.setFilter(QtCore.QDir.Dirs | QtCore.QDir.Files |
                                         QtCore.QDir.NoDotAndDotDot |
                                         QtCore.QDir.Hidden)
         self._fs_model_source.setIconProvider(self._icon_provider)
-        self._fs_model_proxy = self.FilterProxyModel()
-        for item in self._ignored_patterns:
-            self._fs_model_proxy.ignored_patterns.append(item)
+        self._fs_model_proxy = self.FilterProxyModel(self._ignored_patterns)
         self._fs_model_proxy.setSourceModel(self._fs_model_source)
         self._fs_model_proxy.set_root_path(path)
         # takes parent of the root path, filter will keep only `path`, that
         # way `path` appear as the top level node of the tree
         self._root_path = os.path.dirname(path)
         self.root_path = path
         self._fs_model_source.directoryLoaded.connect(self._on_path_loaded)
@@ -283,14 +294,18 @@
         :param index: item index - QModelIndex
         :return: QFileInfo
         """
         return self._fs_model_source.fileInfo(
             self._fs_model_proxy.mapToSource(index))
 
     def _show_context_menu(self, point):
+        # Print if the context menu is requested for an empty space, then
+        # we select the root so that the action is applied on the root folder
+        if self.indexAt(point).row() < 0:
+            self.select_path(self.root_path)
         if self.context_menu:
             self.about_to_show_context_menu.emit(
                 FileSystemHelper(self).get_current_path())
             self.context_menu.exec_(self.mapToGlobal(point))
 
     def select_path(self, path):
         if not self.isVisible():
@@ -420,25 +435,27 @@
             try:
                 if os.path.isfile(src):
                     shutil.copy(src, final_dest)
                 else:
                     shutil.copytree(src, final_dest)
             except (IOError, OSError) as e:
                 QtWidgets.QMessageBox.warning(
-                    self.tree_view, _('Failed to copy file'), str(e))
-                _logger().exception('failed to copy %s to %s', src,
+                    self.tree_view, _('Copy failed'), _('Failed to copy "%s" to "%s".\n\n%s' %
+                                                        (src, destination, str(e))))
+                _logger().exception('failed to copy "%s" to "%s', src,
                                     destination)
             else:
                 debug('file copied %s', src)
             if not copy:
                 debug('removing source (cut operation)')
                 if os.path.isfile(src):
                     os.remove(src)
                 else:
                     shutil.rmtree(src)
+                self.tree_view.files_renamed.emit([(src, final_dest)])
 
     @staticmethod
     def _get_files(path):
         """
         Returns the list of files contained in path (recursively).
         """
         ret_val = []
@@ -450,15 +467,15 @@
     def delete(self):
         """
         Deletes the selected items.
         """
         urls = self.selected_urls()
         rep = QtWidgets.QMessageBox.question(
             self.tree_view, _('Confirm delete'),
-            _('Are you sure about deleting the selected files?'),
+            _('Are you sure about deleting the selected files/directories?'),
             QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
             QtWidgets.QMessageBox.Yes)
         if rep == QtWidgets.QMessageBox.Yes:
             deleted_files = []
             for fn in urls:
                 try:
                     if os.path.isfile(fn):
@@ -466,15 +483,16 @@
                         deleted_files.append(fn)
                     else:
                         files = self._get_files(fn)
                         shutil.rmtree(fn)
                         deleted_files += files
                 except OSError as e:
                     QtWidgets.QMessageBox.warning(
-                        self.tree_view, _('Failed to remove %s') % fn, str(e))
+                        self.tree_view, _('Delete failed'),
+                        _('Failed to remove "%s".\n\n%s') % (fn, str(e)))
                     _logger().exception('failed to remove %s', fn)
             self.tree_view.files_deleted.emit(deleted_files)
             for d in deleted_files:
                 debug('%s removed', d)
                 self.tree_view.file_deleted.emit(os.path.normpath(d))
 
     def get_current_path(self):
@@ -499,36 +517,42 @@
     def rename(self):
         """
         Renames the selected item in the tree view
         """
         src = self.get_current_path()
         pardir, name = os.path.split(src)
         new_name, status = QtWidgets.QInputDialog.getText(
-            self.tree_view, _('Rename file'), _('New name:'),
+            self.tree_view, _('Rename '), _('New name:'),
             QtWidgets.QLineEdit.Normal, name)
         if status:
             dest = os.path.join(pardir, new_name)
             old_files = []
             if os.path.isdir(src):
                 old_files = self._get_files(src)
             else:
                 old_files = [src]
-            os.rename(src, dest)
-            if os.path.isdir(dest):
-                new_files = self._get_files(dest)
+            try:
+                os.rename(src, dest)
+            except OSError as e:
+                QtWidgets.QMessageBox.warning(
+                    self.tree_view, _('Rename failed'),
+                    _('Failed to rename "%s" into "%s".\n\n%s') % (src, dest, str(e)))
             else:
-                new_files = [dest]
-            self.tree_view.file_renamed.emit(os.path.normpath(src),
-                                             os.path.normpath(dest))
-            renamed_files = []
-            for old_f, new_f in zip(old_files, new_files):
-                self.tree_view.file_renamed.emit(old_f, new_f)
-                renamed_files.append((old_f, new_f))
-            # emit all changes in one go
-            self.tree_view.files_renamed.emit(renamed_files)
+                if os.path.isdir(dest):
+                    new_files = self._get_files(dest)
+                else:
+                    new_files = [dest]
+                self.tree_view.file_renamed.emit(os.path.normpath(src),
+                                                 os.path.normpath(dest))
+                renamed_files = []
+                for old_f, new_f in zip(old_files, new_files):
+                    self.tree_view.file_renamed.emit(old_f, new_f)
+                    renamed_files.append((old_f, new_f))
+                # emit all changes in one go
+                self.tree_view.files_renamed.emit(renamed_files)
 
     def create_directory(self):
         """
         Creates a directory under the selected directory (if the selected item
         is a file, the parent directory is used).
         """
         src = self.get_current_path()
@@ -541,20 +565,21 @@
                 if i == name:
                     QtWidgets.QMessageBox.critical(
                         self.tree_view, _("Error"), _("Wrong directory name"))
                     return
 
             if os.path.isfile(src):
                 src = os.path.dirname(src)
+            dir_name = os.path.join(src, name)
             try:
-                os.makedirs(os.path.join(src, name), exist_ok=True)
+                os.makedirs(dir_name, exist_ok=True)
             except OSError as e:
                 QtWidgets.QMessageBox.warning(
                     self.tree_view, _('Failed to create directory'),
-                    _('Failed to create directory: %s'), str(e))
+                    _('Failed to create directory: "%s".\n\n%s') % (dir_name, str(e)))
 
     def create_file(self):
         """
         Creates a file under the current directory.
         """
         src = self.get_current_path()
         name, status = QtWidgets.QInputDialog.getText(
@@ -573,15 +598,15 @@
             path = os.path.join(src, name)
             try:
                 with open(path, 'w'):
                     pass
             except OSError as e:
                 QtWidgets.QMessageBox.warning(
                     self.tree_view, _('Failed to create new file'),
-                    _('Failed to create file: %s') % str(e))
+                    _('Failed to create file: "%s".\n\n%s') % (path, str(e)))
             else:
                 self.tree_view.file_created.emit(os.path.normpath(path))
 
 
 class FileSystemContextMenu(QtWidgets.QMenu):
     """
     Default context menu for the file system treeview.
@@ -596,16 +621,16 @@
     .. note:: copy/cut/paste action works only from inside the application
         (e.g. you cannot paste what you copied in the app to the explorer)
 
     """
     _explorer = None
     _command = None
 
-    def __init__(self):
-        super(FileSystemContextMenu, self).__init__()
+    def __init__(self, parent=None):
+        super(FileSystemContextMenu, self).__init__(parent)
         #: Reference to the tree view
         self.tree_view = None
 
     def addAction(self, *args):
         action = super(FileSystemContextMenu, self).addAction(*args)
         if action is None:
             action = args[0]
@@ -758,54 +783,36 @@
     def get_file_explorer_name(cls):
         system = platform.system()
         if system == 'Darwin':
             pgm = 'finder'
         elif system == 'Windows':
             pgm = 'explorer'
         else:
-            pgm = cls.get_file_explorer_command().split(' ')[0]
-            if os.path.isabs(pgm):
-                pgm = os.path.split(pgm)[1]
+            pgm = 'file explorer'
         return pgm.capitalize()
 
     def _on_show_in_explorer_triggered(self):
         path = self.tree_view.helper.get_current_path()
         self.show_in_explorer(path, self.tree_view)
 
     @classmethod
     def get_file_explorer_command(cls):
         if cls._command is None:
             system = platform.system()
             if system == 'Linux':
-                explorer = cls.get_linux_file_explorer()
-                if explorer in ['nautilus', 'dolphin']:
-                    explorer_cmd = '%s --select %s' % (explorer, '%s')
-                else:
-                    explorer_cmd = '%s %s' % (explorer, '%s')
+                explorer_cmd = ['xdg-open', '{}']
             elif system == 'Windows':
-                explorer_cmd = 'explorer /select,%s'
+                explorer_cmd = ['explorer', '/select,{}']
             elif system == 'Darwin':
-                explorer_cmd = 'open -R %s'
+                explorer_cmd = ['open', '-R', '{}']
             cls._command = explorer_cmd
-            return explorer_cmd
-        else:
-            return cls._command
-
-    @classmethod
-    def set_file_explorer_command(cls, command):
-        pgm = command.split(' ')[0]
-        if os.path.isabs(pgm):
-            pgm = os.path.split(pgm)[1]
-        cls._explorer = pgm
-        cls._command = command
+        return cls._command[:]
 
     @classmethod
     def show_in_explorer(cls, path, parent):
-        try:
-            cmd = cls.get_file_explorer_command() % os.path.normpath(path)
-            _logger().info('show file in explorer: %s' % cmd)
-            args = cmd.split(' ')
-            subprocess.Popen(args)
-        except Exception as e:
-            QtWidgets.QMessageBox.warning(
-                parent, _('Open in explorer'),
-                _('Failed to open file in explorer.\n\n%s') % str(e))
+        path = os.path.normpath(path)
+        if os.path.isfile(path):
+            path = os.path.dirname(path)
+        cmd = cls.get_file_explorer_command()
+        cmd[-1] = cmd[-1].format(path)
+        _logger().info('show file in explorer: %s' % cmd)
+        subprocess.Popen(cmd)
```

## pyqode/core/widgets/interactive.py

```diff
@@ -6,17 +6,17 @@
 import locale
 import logging
 import sys
 
 from pyqode.core.api.client import PROCESS_ERROR_STRING
 from pyqode.core.managers.decorations import TextDecorationsManager
 from pyqode.core.managers.panels import PanelsManager
-from pyqode.qt.QtCore import Qt, Signal, QProcess, QProcessEnvironment
-from pyqode.qt.QtWidgets import QTextEdit, QAction, QApplication
-from pyqode.qt.QtGui import QColor, QTextCursor, QFont, QKeySequence
+from qtpy.QtCore import Qt, Signal, QProcess, QProcessEnvironment
+from qtpy.QtWidgets import QTextEdit, QAction, QApplication
+from qtpy.QtGui import QColor, QTextCursor, QFont, QKeySequence
 
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 class InteractiveConsole(QTextEdit):
@@ -32,14 +32,17 @@
 
         - stdout_color: color of the process stdout
         - stdin_color: color of the user inputs. Green by default
         - app_msg_color: color for custom application message (
           process started, process finished)
         - stderr_color: color of the process stderr
 
+    .. deprecated: Since v2.10.0, this widget is deprecated, you should use
+        :class:`pyqode.core.widgets.OutputWindow` instead.
+
     """
     #: Signal emitted when the process has finished.
     process_finished = Signal(int)
     process_started = Signal()
 
     def __init__(self, parent=None):
         super(InteractiveConsole, self).__init__(parent)
@@ -459,13 +462,13 @@
         if self.background_color.lightness() < 128:
             self.stderr_color = QColor('#FF8080')
         else:
             self.stderr_color = QColor('red')
 
 
 if __name__ == '__main__':
-    from pyqode.qt import QtWidgets
+    from qtpy import QtWidgets
     app = QtWidgets.QApplication([])
     console = InteractiveConsole()
     console.start_process('cal')
     console.show()
     app.exec_()
```

## pyqode/core/widgets/menu_recents.py

```diff
@@ -2,15 +2,15 @@
 Provides a menu that display the list of recent files and a RecentFilesManager
 which use your application's QSettings to store the list of recent files.
 
 """
 import sys
 import os
 from pyqode.core import icons
-from pyqode.qt import QtCore, QtGui, QtWidgets
+from qtpy import QtCore, QtGui, QtWidgets
 
 
 class RecentFilesManager(QtCore.QObject):
     """
     Manages a list of recent files. The list of files is stored in your
     application QSettings.
 
@@ -205,8 +205,8 @@
         """
         Emits open_requested when a recent file action has been triggered.
         """
         action = self.sender()
         assert isinstance(action, QtWidgets.QAction)
         path = action.data()
         self.open_requested.emit(path)
-        self.update_actions()
+        self.update_actions()
```

## pyqode/core/widgets/splittable_tab_widget.py

```diff
@@ -1,28 +1,45 @@
 """
 This module contains the splittable tab widget API
 """
 import inspect
 import logging
 import mimetypes
 import os
-import sys
+import io
 import uuid
 import weakref
 
-from pyqode.qt import QtCore, QtWidgets, QtGui
+from qtpy import QtCore, QtWidgets, QtGui
 from pyqode.core.api import utils
+from pyqode.core import icons
+from pyqode.core.cache import Cache
 from pyqode.core.dialogs import DlgUnsavedFiles
 from pyqode.core._forms import popup_open_files_ui
 from .tab_bar import TabBar
 from .code_edits import GenericCodeEdit, TextCodeEdit
 
 from pyqode.core._forms import pyqode_core_rc
 assert pyqode_core_rc
 
+DEFAULT_EXTENSION = '.txt'
+
+# The null translation should be installed when pyqode.core is imported.
+# However, under rare conditions (and hard to reproduce) it's sometimes not
+# available in this module. Therefore, as a temporary bug fix, we also check
+# here whether the translation is installed, and install the null translation
+# if necessary.
+try:
+    # check if application code is using gettext
+    _('')
+except NameError:
+    # install a null translation
+    import gettext
+    gettext.NullTranslations().install()
+
 
 def _logger():
     return logging.getLogger(__name__)
 
 
 class DraggableTabBar(TabBar):
     """
@@ -37,15 +54,44 @@
 
     def __init__(self, parent):
         super(DraggableTabBar, self).__init__(parent)
         self._pos = QtCore.QPoint()
         self.setAcceptDrops(True)
         self.setMouseTracking(True)
         self.setElideMode(QtCore.Qt.ElideNone)
-
+        if self.parent().plus_button:
+            self._plus_button = QtWidgets.QPushButton(
+                icons.icon(qta_name='fa.plus-circle'),
+                None,
+                self.parent()
+            )
+            self._plus_button.setFlat(True)
+            self._plus_button.show()
+            self._plus_button.clicked.connect(self._on_plus_button_clicked)
+            self.parent().last_tab_closed.connect(self._move_plus_button)
+            self.paintEvent = self._custom_paint_event
+        else:
+            self._plus_button = None
+        
+    def _move_plus_button(self):
+        self._plus_button.move(
+            self.mapTo(self.parent(), QtCore.QPoint(
+                max(0, self.geometry().right()),
+                max(0, (self.height() - self._plus_button.height()) // 2)
+            ))
+        )
+        
+    def _on_plus_button_clicked(self):
+        self.parent().parent().create_new_document()
+        
+    def _custom_paint_event(self, event):
+        """Is set as paintEvent when the plus button is shown."""
+        super(DraggableTabBar, self).paintEvent(event)
+        self._move_plus_button()
+        
     def mousePressEvent(self, event):
         if event.button() == QtCore.Qt.LeftButton:
             self._pos = event.pos()  # _pos is a QPoint defined in the header
         super(DraggableTabBar, self).mousePressEvent(event)
 
     def widget_under_mouse(self, event):
         index = self.tabAt(event.pos())
@@ -89,19 +135,29 @@
         formats = m.formats()
         if "action" in formats and m.data("action") == "tab-reordering":
             event.acceptProposedAction()
 
     def dropEvent(self, event):
         # drop a tab in a split (may be the same split or another one).
         m = event.mimeData()
-        index = self.tabAt(event.pos())
+        try:
+            pos = event.position().toPoint()
+        except AttributeError:
+            # PyQt5 fallback
+            pos = event.pos()
+        index = self.tabAt(pos)
         # Tell interested objects that a tab should be moved.
         if m.tab != self.parent().widget(index):
             self.tab_move_request.emit(m.tab, index)
         event.acceptProposedAction()
+        
+    def setVisible(self, visible):
+        if self._plus_button is not None:
+            self._plus_button.setVisible(visible)
+        super(DraggableTabBar, self).setVisible(visible)
 
 
 class BaseTabWidget(QtWidgets.QTabWidget):
     """
     Base tab widget class used by SplittableTabWidget. This tab widget adds a
     context menu to the tab bar that allow the user to:
         - split the current tab (horizontally or vertically)
@@ -126,106 +182,160 @@
     #: **Parameters**:
     #: - old_tab: the old tab instance (before it get closed)
     #: - new_tab: the new tab instance (the one that is detached)
     tab_detached = QtCore.Signal(QtWidgets.QWidget, QtWidgets.QWidget)
 
     _detached_window_class = None
 
-    def __init__(self, parent):
+    def __init__(
+        self,
+        parent,
+        tabs_movable=True,
+        plus_button=True,
+        tab_context_menu=True,
+        empty_context_menu=True,
+    ):
         super(BaseTabWidget, self).__init__(parent)
+        self.plus_button = plus_button
         self._current = None
         self.currentChanged.connect(self._on_current_changed)
         self.tabCloseRequested.connect(self._on_tab_close_requested)
-
         tab_bar = DraggableTabBar(self)
-        tab_bar.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
-        tab_bar.customContextMenuRequested.connect(self._show_tab_context_menu)
-        tab_bar.tab_move_request.connect(self._on_tab_move_request)
+        if tab_context_menu:
+            tab_bar.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
+            tab_bar.customContextMenuRequested.connect(
+                self._show_tab_context_menu
+            )
+        if tabs_movable:
+            tab_bar.tab_move_request.connect(self._on_tab_move_request)
         self.setTabBar(tab_bar)
         self.setAcceptDrops(True)
         self.setUsesScrollButtons(True)
 
         #: A list of additional context menu actions
         self.context_actions = []
-
+        self.a_close = None
+        self.a_close_all = None
+        self._menu_pos = None
+        self._n_pinned = 0  # the number of pinned tabs
+        self._create_tab_bar_menu()
         self.detached_tabs = []
 
     def tab_under_menu(self):
         """
         Returns the tab that sits under the context menu.
         :return: QWidget
         """
-        return self.tabBar().tabAt(self._menu_pos)
+        if self._menu_pos:
+            return self.tabBar().tabAt(self._menu_pos)
+        else:
+            return self.currentIndex()
 
-    @QtCore.Slot()
     def close(self):
         """
         Closes the active editor
         """
         self.tabCloseRequested.emit(self.tab_under_menu())
+        
+    def is_pinned(self, index):
+        """Checks whether the tab at the gives is pinned."""
+        return index < self._n_pinned
+    
+    def _unpinned_range(self):
+        """Gets a range of tabs starting from the first unpinned tab."""
+        return range(self._n_pinned, self.count())
+        
+    def pin(self, tab=None):
+        """Pins a tab. If no tab is specified, then the tab under the last
+        context menu is used.
+        """
+        if tab:
+            i = self.indexOf(tab)
+        else:
+            i = self.tab_under_menu()
+            tab = self.widget(i)
+        if self.is_pinned(i):
+            return
+        tab.unpinned_icon = self.tabIcon(i)
+        tab.unpinned_text = self.tabText(i)
+        self.setTabText(i, None)
+        self.setTabIcon(i, icons.icon(qta_name='fa.map-pin'))
+        self._on_tab_move_request(tab, 0)
+        self._n_pinned += 1
+        self._set_tab_color(i)
+    
+    def unpin(self, tab=None):
+        """Unpins a tab. If no tab is specified, then the tab under the last
+        context menu is used.
+        """
+        if tab:
+            i = self.indexOf(tab)
+        else:
+            i = self.tab_under_menu()
+            tab = self.widget(i)
+        if not self.is_pinned(i):
+            return
+        self.setTabIcon(i, tab.unpinned_icon)
+        self.setTabText(i, tab.unpinned_text)
+        self._n_pinned -= 1
+        self._set_tab_color(i)
 
-    @QtCore.Slot()
     def close_others(self):
         """
         Closes every editors tabs except the current one.
         """
-        current_widget = self.widget(self.tab_under_menu())
-        if self._try_close_dirty_tabs(exept=current_widget):
-            i = 0
-            while self.count() > 1:
-                widget = self.widget(i)
-                if widget != current_widget:
-                    self.remove_tab(i)
-                else:
-                    i = 1
+        self.close_right()
+        self.close_left()
 
-    @QtCore.Slot()
     def close_left(self):
         """
         Closes every editors tabs on the left of the current one.
         """
         current_widget = self.widget(self.tab_under_menu())
         index = self.indexOf(current_widget)
-        if self._try_close_dirty_tabs(tab_range=range(index)):
-            while True:
-                widget = self.widget(0)
+        if self._try_close_dirty_tabs(
+            tab_range=range(self._n_pinned, index),
+        ):
+            while self.count() > self._n_pinned:
+                widget = self.widget(self._n_pinned)
                 if widget != current_widget:
-                    self.remove_tab(0)
+                    self.remove_tab(self._n_pinned)
                 else:
                     break
 
-    @QtCore.Slot()
     def close_right(self):
         """
         Closes every editors tabs on the left of the current one.
         """
         current_widget = self.widget(self.tab_under_menu())
         index = self.indexOf(current_widget)
-        if self._try_close_dirty_tabs(tab_range=range(index + 1, self.count())):
+        index = max(index, self._n_pinned)
+        current_widget = self.widget(index)
+        if self._try_close_dirty_tabs(
+            tab_range = range(index + 1, self.count())
+        ):
             while True:
                 widget = self.widget(self.count() - 1)
                 if widget != current_widget:
                     self.remove_tab(self.count() - 1)
                 else:
                     break
 
-    @QtCore.Slot()
     def close_all(self):
         """
         Closes all editors
         """
-        if self._try_close_dirty_tabs():
-            while self.count():
-                widget = self.widget(0)
-                self.remove_tab(0)
+        if self._try_close_dirty_tabs(tab_range=self._unpinned_range()):
+            while self.count() > self._n_pinned:
+                widget = self.widget(self._n_pinned)
                 self.tab_closed.emit(widget)
+                self.remove_tab(self._n_pinned)
             return True
         return False
 
-    @QtCore.Slot()
     def detach_tab(self):
         tab_index = self.tab_under_menu()
         tab = self.widget(tab_index)
         try:
             open_parameters = tab.open_parameters
         except AttributeError:
             open_parameters = {
@@ -294,73 +404,128 @@
         or not.
 
         :param editor: editor widget to save.
         """
         return True
 
     def _create_tab_bar_menu(self):
-        context_mnu = QtWidgets.QMenu()
-        for name, slot, icon in [
-                (_('Close tab'), self.close, 'document-close'),
-                (_('Close tabs to the left'), self.close_left, 'tab-close-other'),
-                (_('Close tabs to the right'), self.close_right, 'tab-close-other'),
-                (_('Close others tabs'), self.close_others, 'tab-close-other'),
-                (_('Close all tabs'), self.close_all,
-                 'project-development-close-all'),
+        tab = self.widget(self.tab_under_menu())
+        index = self.indexOf(tab)
+        context_mnu = QtWidgets.QMenu(self)
+        if self.is_pinned(index):
+            pin_action = QtWidgets.QAction(_('Unpin'), self)
+            pin_action.triggered.connect(self.unpin)
+            pin_action.setIcon(icons.icon(qta_name='fa.unlock'))
+        else:
+            pin_action = QtWidgets.QAction(_('Pin'), self)
+            pin_action.triggered.connect(self.pin)
+            pin_action.setIcon(icons.icon(qta_name='fa.map-pin'))
+        context_mnu.addAction(pin_action)
+        if not self.is_pinned(index):
+            for name, slot, icon in [
                 (None, None, None),
-                (_('Detach tab'), self.detach_tab, 'tab-detach')]:
-            if name is None and slot is None:
-                qaction = QtWidgets.QAction(self)
-                qaction.setSeparator(True)
-            else:
-                qaction = QtWidgets.QAction(name, self)
-                qaction.triggered.connect(slot)
-                if icon:
-                    qaction.setIcon(QtGui.QIcon.fromTheme(icon))
-            if slot == self.close_left:
-                self.a_close_left = qaction
-            elif slot == self.close_right:
-                self.a_close_right = qaction
-            elif slot == self.close_others:
-                self.a_close_others = qaction
-            elif slot == self.close_all:
-                self.a_close_all = qaction
-            context_mnu.addAction(qaction)
-            self.addAction(qaction)
+                (_('Close tab'), self.close, 'fa.close'),
+                (_('Close tabs to the left'), self.close_left, 'fa.close'),
+                (_('Close tabs to the right'), self.close_right, 'fa.close'),
+                (_('Close other tabs'), self.close_others, 'fa.close'),
+                (_('Close all tabs'), self.close_all, 'fa.close'),
+                (None, None, None),
+            ]:
+                if name is None and slot is None:
+                    qaction = QtWidgets.QAction(self)
+                    qaction.setSeparator(True)
+                else:
+                    qaction = QtWidgets.QAction(name, self)
+                    qaction.triggered.connect(slot)
+                    if icon:
+                        qaction.setIcon(icons.icon(qta_name=icon))
+                if slot == self.close and self.a_close is None:
+                    self.a_close = qaction
+                    self.addAction(self.a_close)
+                elif slot == self.close_left:
+                    self.a_close_left = qaction
+                elif slot == self.close_right:
+                    self.a_close_right = qaction
+                elif slot == self.close_others:
+                    self.a_close_others = qaction
+                elif slot == self.close_all:
+                    self.a_close_all = qaction
+                    self.addAction(self.a_close_all)
+                context_mnu.addAction(qaction)
+        context_mnu.addSeparator()
+        a = context_mnu.addAction(_('Select tab color '))
+        a.setIcon(icons.icon(qta_name='fa.paint-brush'))
+        a.triggered.connect(self._select_tab_color)
         context_mnu.addSeparator()
         menu = QtWidgets.QMenu(_('Split'), context_mnu)
-        menu.setIcon(QtGui.QIcon.fromTheme('split'))
+        menu.setIcon(icons.icon(qta_name='fa.th'))
         a = menu.addAction(_('Split horizontally'))
         a.triggered.connect(self._on_split_requested)
-        a.setIcon(QtGui.QIcon.fromTheme('view-split-left-right'))
+        a.setIcon(icons.icon(qta_name='fa.arrows-h'))
         a = menu.addAction(_('Split vertically'))
-        a.setIcon(QtGui.QIcon.fromTheme('view-split-top-bottom'))
+        a.setIcon(icons.icon(qta_name='fa.arrows-v'))
         a.triggered.connect(self._on_split_requested)
         context_mnu.addMenu(menu)
         context_mnu.addSeparator()
         if self.context_actions:
             context_mnu.addSeparator()
         for action in self.context_actions:
             context_mnu.addAction(action)
-        tab = self.widget(self.tab_under_menu())
-        index = self.indexOf(tab)
-        self.a_close_right.setVisible(0 <= index < self.count() - 1)
-        self.a_close_left.setVisible(0 < index <= self.count() - 1)
-        self.a_close_others.setVisible(self.count() > 1)
-        self.a_close_all.setVisible(self.count() > 1)
+        if not self.is_pinned(index):
+            self.a_close_right.setVisible(0 <= index < self.count() - 1)
+            self.a_close_left.setVisible(0 < index <= self.count() - 1)
+            self.a_close_others.setVisible(self.count() > 1)
+            self.a_close_all.setVisible(self.count() > 1)
         self._context_mnu = context_mnu
         return context_mnu
 
     def _show_tab_context_menu(self, position):
         if self.count():
             self._menu_pos = position
             SplittableTabWidget.tab_under_menu = self.widget(
                 self.tab_under_menu())
-            self._create_tab_bar_menu().popup(self.tabBar().mapToGlobal(
-                position))
+            mnu = self._create_tab_bar_menu()
+            mnu.exec_(self.tabBar().mapToGlobal(position))
+            self._menu_pos = None
+            
+    def _select_tab_color(self):
+        """Selects a color through a selection dialog and applies it to a tab.
+        """
+        color = QtWidgets.QColorDialog.getColor()
+        widget = self.widget(self.tab_under_menu())
+        index = self.indexOf(widget)
+        # If the color selection was cancelled, we clear the color from the
+        # cache and reset the tab color to the default text color
+        if not color.isValid():
+            if widget.file.path:
+                Cache().set_color(widget.file.path, None)
+            self._set_tab_color(index, self.palette().text().color().name())
+            return
+        if widget.file.path:
+            Cache().set_color(widget.file.path, color.name())
+        self._set_tab_color(index, color.name())
+            
+    def _set_tab_color(self, index, color=None):
+        """Sets the color of a tab based on an association between a file path
+        and a color from the cache.
+        """
+        if color is None:
+            color = Cache().get_color(self.widget(index).file.path)
+        if color is None:
+            return
+        if self.is_pinned(index):
+            self.tabBar().setTabIcon(
+                index,
+                icons.icon(
+                    qta_name='fa.map-pin',
+                    qta_options={'color': color}
+                )
+            )
+        else:
+            self.tabBar().setTabTextColor(index, QtGui.QColor(color))
 
     def _collect_dirty_tabs(self, skip=None, tab_range=None):
         """
         Collects the list of dirty tabs
 
         :param skip: Tab to skip (used for close_others).
         """
@@ -408,17 +573,20 @@
         try:
             return widget.file.path
         except AttributeError:
             return ''
 
     def _on_tab_close_requested(self, index):
         widget = self.widget(index)
+        if self.is_pinned(index):
+            self.unpin(widget)
+            return
         dirty = False
         try:
-            if widget.original is None:
+            if widget.original is None and not widget.clones:
                 dirty = widget.dirty
         except AttributeError:
             pass
         if not dirty:
             self.remove_tab(index)
         else:
             # unsaved widget
@@ -433,29 +601,14 @@
                     try:
                         rm = self.save_widget(widget)
                     except OSError:
                         pass
                 if rm:
                     self.remove_tab(index)
 
-        cnt = sys.getrefcount(widget)
-        if cnt > 2:
-            try:
-                import objgraph
-            except ImportError:
-                _logger().warning(
-                    'potential memory leak detected on widget: %r\n'
-                    'Install the objgraph package to know what objects are '
-                    'holding references the editor widget...' % widget)
-            else:
-                _logger().warning('potential memory detected on widget: %r\n'
-                                  'see stderr for a backrefs dot graph...' %
-                                  widget)
-                objgraph.show_backrefs([widget], output=sys.stderr)
-
     @staticmethod
     def _close_widget(widget):
         """
         Closes the given widgets and handles cases where the widget has been
         clone or is a clone of another widget
         """
         if widget is None:
@@ -500,29 +653,34 @@
     def remove_tab(self, index):
         """
         Overrides removeTab to emit tab_closed and last_tab_closed signals.
 
         :param index: index of the tab to remove.
         """
         widget = self.widget(index)
+        if widget is None:
+            return
         try:
             document = widget.document()
         except AttributeError:
             document = None  # not a QPlainTextEdit
         clones = self._close_widget(widget)
         self.tab_closed.emit(widget)
         self.removeTab(index)
         self._restore_original(clones)
         widget._original_tab_widget._tabs.remove(widget)
         if self.count() == 0:
             self.last_tab_closed.emit()
         if SplittableTabWidget.tab_under_menu == widget:
             SplittableTabWidget.tab_under_menu = None
         if not clones:
-            widget.setParent(None)
+            try:
+                widget.setParent(None)
+            except RuntimeError:
+                pass  # Catches some rare race conditions?
         else:
             try:
                 clones[0].syntax_highlighter.setDocument(document)
             except AttributeError:
                 pass  # not a QPlainTextEdit
 
     def _on_split_requested(self):
@@ -540,48 +698,59 @@
 
     def _on_current_changed(self, index):
         tab = self.widget(index)
         if tab:
             tab.setFocus()
 
     def _on_tab_move_request(self, widget, new_index):
+        if widget is None:  # happens in rare conditions
+            return
         parent = widget.parent_tab_widget
         index = parent.indexOf(widget)
+        if self.is_pinned(index):
+            new_index = min(self._n_pinned - 1, new_index)
+        else:
+            new_index = max(self._n_pinned, new_index)
         text = parent.tabText(index)
         icon = parent.tabIcon(index)
         parent.removeTab(index)
         widget.parent_tab_widget = self
-        self.insertTab(new_index, widget, icon, text)
+        new_index = self.insertTab(new_index, widget, icon, text)
         self.setCurrentIndex(new_index)
         widget.setFocus()
         if parent.count() == 0:
             parent.last_tab_closed.emit()
 
     def dragEnterEvent(self, event):
         # Only accept if it's an tab-reordering request
         m = event.mimeData()
         formats = m.formats()
         if "action" in formats and m.data("action") == "tab-reordering":
             event.acceptProposedAction()
 
     def dropEvent(self, event):
         m = event.mimeData()
-        index = self.tabBar().tabAt(event.pos())
+        try:
+            pos = event.position().toPoint()
+        except AttributeError:
+            # PyQt5 fallback
+            pos = event.pos()
+        index = self.tabBar().tabAt(pos)
         # Tell interested objects that a tab should be moved.
         if m.tab != self.widget(index):
             self._on_tab_move_request(m.tab, index)
             event.acceptProposedAction()
 
     def addTab(self, tab, *args):
         """
         Adds a tab to the tab widget, this function set the parent_tab_widget
         attribute on the tab instance.
         """
         tab.parent_tab_widget = self
-        super(BaseTabWidget, self).addTab(tab, *args)
+        return super(BaseTabWidget, self).addTab(tab, *args)
 
 
 class OpenFilesPopup(QtWidgets.QDialog):
     triggered = QtCore.Signal(str)
 
     def __init__(self, parent=None, qsettings=None):
         super(OpenFilesPopup, self).__init__(parent)
@@ -713,45 +882,76 @@
 
     @popup_shortcut.setter
     def popup_shortcut(self, value):
         if hasattr(self, '_action_popup'):
             self._shortcut = value
             self._action_popup.setShortcut(self._shortcut)
 
-    def __init__(self, parent=None, root=True, create_popup=True,
-                 qsettings=None):
+    @property
+    def tab_bar_visible(self):
+        if self.root:
+            return self._tab_bar_visible
+        return self.parent().tab_bar_visible
+
+    @tab_bar_visible.setter
+    def tab_bar_visible(self, visible):
+        self.main_tab_widget.tabBar().setVisible(visible)
+        if self.root:
+            self._tab_bar_visible = visible
+        for splitter in self.child_splitters:
+            splitter.tab_bar_visible = visible
+
+    def __init__(
+        self,
+        parent=None,
+        root=True,
+        create_popup=False,
+        qsettings=None,
+        tabs_movable=True,
+        plus_button=True,
+        tab_context_menu=True,
+        empty_context_menu=True,
+    ):
         super(SplittableTabWidget, self).__init__(parent)
         SplittableTabWidget.tab_widget_klass._detached_window_class = \
             SplittableTabWidget.detached_window_klass
-        if root:
+        self._tab_bar_visible = True
+        if root and create_popup:
             self._action_popup = QtWidgets.QAction(self)
             self._action_popup.setShortcutContext(QtCore.Qt.WindowShortcut)
             self._shortcut = 'Ctrl+T'
             self._action_popup.setShortcut(self._shortcut)
             self._action_popup.triggered.connect(self._show_popup)
             self.addAction(self._action_popup)
             self.popup = OpenFilesPopup(qsettings=qsettings)
             self.popup.setWindowFlags(
                 QtCore.Qt.Popup | QtCore.Qt.FramelessWindowHint)
             self.popup.triggered.connect(self._on_popup_triggered)
         self.child_splitters = []
-        self.main_tab_widget = self.tab_widget_klass(self)
+        self.main_tab_widget = self.tab_widget_klass(
+            self,
+            tabs_movable=tabs_movable,
+            plus_button=plus_button,
+            tab_context_menu=tab_context_menu,
+            empty_context_menu=empty_context_menu
+        )
         self.main_tab_widget.last_tab_closed.connect(
             self._on_last_tab_closed)
         self.main_tab_widget.tab_detached.connect(self.tab_detached.emit)
         self.main_tab_widget.split_requested.connect(self.split)
         self.addWidget(self.main_tab_widget)
         self._parent_splitter = None
         self._current = None
         self.root = root
         if root:
             QtWidgets.QApplication.instance().focusChanged.connect(
                 self._on_focus_changed)
         self._uuid = uuid.uuid1()
         self._tabs = []
+        self.main_tab_widget.tabBar().setVisible(self.tab_bar_visible)
 
     def add_context_action(self, action):
         """
         Adds a custom context menu action
 
         :param action: action to add.
         """
@@ -763,14 +963,15 @@
         """
         Adds a tab to main tab widget.
 
         :param tab: Widget to add as a new tab of the main tab widget.
         :param title: Tab title
         :param icon: Tab icon
         """
+        title = title.replace('&', '&&')  # allow literal & characters
         if icon:
             tab._icon = icon
         if not hasattr(tab, 'clones'):
             tab.clones = []
         if not hasattr(tab, 'original'):
             tab.original = None
         if icon:
@@ -832,38 +1033,40 @@
                 break
         if splitter is None:
             splitter = self.__class__(self, root=False)
             for action in self.main_tab_widget.context_actions:
                 splitter.add_context_action(action)
         return splitter
 
-    def split(self, widget, orientation):
+    def split(self, widget, orientation, index=None):
         """
         Split the the current widget in new SplittableTabWidget.
 
         :param widget: widget to split
         :param orientation: orientation of the splitter
+        :param index: the index of the new splitter, or None to append
         :return: the new splitter
         """
+        self.main_tab_widget.unpin(widget)
         if widget.original:
             base = widget.original
         else:
             base = widget
         clone = base.split()
         if not clone:
             return
-        if orientation == int(QtCore.Qt.Horizontal):
-            orientation = QtCore.Qt.Horizontal
-        else:
-            orientation = QtCore.Qt.Vertical
         self.setOrientation(orientation)
         splitter = self._make_splitter()
         splitter.show()
-        self.addWidget(splitter)
-        self.child_splitters.append(splitter)
+        if index is None:
+            self.addWidget(splitter)
+            self.child_splitters.append(splitter)
+        else:
+            self.insertWidget(index, splitter)
+            self.child_splitters.insert(index, splitter)
         if clone not in base.clones:
             # code editors maintain the list of clones internally but some
             # other widgets (user widgets) might not.
             base.clones.append(clone)
         clone.original = base
         splitter._parent_splitter = self
         splitter.last_tab_closed.connect(self._on_last_child_tab_closed)
@@ -874,14 +1077,20 @@
             icon = None
         # same group of tab splitter (user might have a group for editors and
         # another group for consoles or whatever).
         splitter._uuid = self._uuid
         splitter.add_tab(clone, title=self.main_tab_widget.tabText(
             self.main_tab_widget.indexOf(widget)), icon=icon)
         self.setSizes([1 for i in range(self.count())])
+        # In order for the focus to switch to the newly splitted editor, it
+        # appears that there first needs to be a splitter with a widget in it,
+        # and then first the splitter and then the widget need to explicitly
+        # receive focus. There may be a more elegant way to achieve this.
+        splitter.main_tab_widget.setFocus()
+        clone.setFocus()
         return splitter
 
     def has_children(self):
         """
         Checks if there are children tab widgets.
         :return: True if there is at least one tab in the children tab widget.
         """
@@ -896,21 +1105,28 @@
         got the focus.
         :return: QWidget
         """
         if self._current:
             return self._current()
         return None
 
-    def widgets(self, include_clones=False):
+    def widgets(self, include_clones=False, from_root=False):
         """
         Recursively gets the list of widgets.
 
         :param include_clones: True to retrieve all tabs, including clones,
             otherwise only original widgets are returned.
+        :param from_root: True to get all widgets, rather than only the widgets
+            that are under the current splitter and its child splitters.
         """
+        if from_root and not self.root:
+            return self.parent().widgets(
+                include_clones=include_clones,
+                from_root=True
+            )
         widgets = []
         for i in range(self.main_tab_widget.count()):
             widget = self.main_tab_widget.widget(i)
             try:
                 if widget.original is None or include_clones:
                     widgets.append(widget)
             except AttributeError:
@@ -926,14 +1142,15 @@
             if not self.main_tab_widget.count():
                 self.main_tab_widget.hide()
         else:
             if self.root:
                 # ensure root is visible when there are no children
                 self.show()
                 self.main_tab_widget.show()
+                self._current = None
             else:
                 # hide ourselves (we don't have any other tabs or children)
                 self._remove_from_parent()
         if not self.has_children():
             self.last_tab_closed.emit(self)
 
     def _on_focus_changed(self, old, new):
@@ -964,16 +1181,25 @@
 
     def _on_last_child_tab_closed(self):
         if not self.has_children():
             self.last_tab_closed.emit(self)
             if self.root:
                 self.show()
                 self.main_tab_widget.show()
+                self._current = None
             else:
                 self._remove_from_parent()
+        else:
+            # If a child closed its last tab, but this splitter still has a
+            # tab then we set the focus to that tab. For this to happen we
+            # first need to set the focus to the current splitter, and then to
+            # the widget.
+            self.main_tab_widget.setFocus()
+            if self.main_tab_widget.currentWidget() is not None:
+                self.main_tab_widget.currentWidget().setFocus()
 
     def count(self):
         """
         Returns the number of widgets currently displayed (takes child splits
         into account).
         """
         c = self.main_tab_widget.count()
@@ -986,14 +1212,59 @@
     """
     Tab widget specialised to hold pyqode's code editor widgets.
 
     It will manage the saving of editors
     """
     default_directory = os.path.expanduser('~')
     dirty_changed = QtCore.Signal(bool)
+    
+    def __init__(
+        self,
+        parent,
+        tabs_movable=True,
+        plus_button=True,
+        tab_context_menu=True,
+        empty_context_menu=True,
+    ):
+        super(CodeEditTabWidget, self).__init__(
+            parent,
+            tabs_movable=tabs_movable,
+            plus_button=plus_button,
+            tab_context_menu=tab_context_menu,
+            empty_context_menu=empty_context_menu
+        )
+        if empty_context_menu:
+            self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
+            self.customContextMenuRequested.connect(
+                self._empty_space_context_menu
+            )
+        
+    def _empty_space_context_menu(self, pos):
+        
+        # This function can be triggered when clicking anywhere in the editor
+        # rect. We ignore all clicks that are below the tabBar. That way we
+        # emulate a context meny for the empty space of the tabBar, which is
+        # actually not part of the tabBar at all.
+        if pos.y() >= self.tabBar().height():
+            return
+        menu = QtWidgets.QMenu(self)
+        menu.addAction(
+            icons.icon(qta_name='fa.plus-circle'),
+            _('New document'),
+            self.parent().create_new_document
+        )
+        closed_tabs_menu = self.parent().get_root_splitter().closed_tabs_menu
+        if len(closed_tabs_menu.actions()) > 0:
+            menu.addMenu(closed_tabs_menu)
+        menu.addAction(
+            icons.icon(qta_name='fa.close'),
+            _('Close all tabs'),
+            self.parent().close_all
+        )
+        menu.exec_(self.mapToGlobal(pos))
 
     @classmethod
     @utils.memoized
     def get_filter(cls, mimetype):
         """
         Returns a filter string for the file dialog. The filter is based
         on the mime type.
@@ -1010,15 +1281,17 @@
         Re-implements addTab to connect to the dirty changed signal and setup
         some helper attributes.
 
         :param widget: widget to add
         :param args: optional addtional arguments (name and/or icon).
         """
         widget.dirty_changed.connect(self._on_dirty_changed)
-        super(CodeEditTabWidget, self).addTab(widget, *args)
+        index = super(CodeEditTabWidget, self).addTab(widget, *args)
+        self._set_tab_color(index)
+        return index
 
     def _on_dirty_changed(self, dirty):
         """
         Adds a star in front of a dirtt tab and emits dirty_changed.
         """
         widget = self.sender()
         if isinstance(widget, DraggableTabBar):
@@ -1073,22 +1346,27 @@
             try:
                 _logger().debug('saving %r as %r', editor.file._old_path, path)
             except AttributeError:
                 _logger().debug('saving %r as %r', editor.file.path, path)
             editor.file._path = path
         else:
             path = editor.file.path
-        editor.file.save(path)
-        tw = editor.parent_tab_widget
-        text = tw.tabText(tw.indexOf(editor)).replace('*', '')
-        tw.setTabText(tw.indexOf(editor), text)
-        for clone in [editor] + editor.clones:
-            if clone != editor:
-                tw = clone.parent_tab_widget
-                tw.setTabText(tw.indexOf(clone), text)
+        try:
+            editor.file.save(path)
+        except Exception as e:
+            QtWidgets.QMessageBox.warning(editor, "Failed to save file", 'Failed to save %r.\n\nError="%s"' %
+                                          (path, e))
+        else:
+            tw = editor.parent_tab_widget
+            text = tw.tabText(tw.indexOf(editor)).replace('*', '')
+            tw.setTabText(tw.indexOf(editor), text)
+            for clone in [editor] + editor.clones:
+                if clone != editor:
+                    tw = clone.parent_tab_widget
+                    tw.setTabText(tw.indexOf(clone), text)
         return True
 
     def _get_widget_path(self, editor):
         return editor.file.path
 
 
 class DetachedEditorWindow(QtWidgets.QMainWindow):
@@ -1158,32 +1436,61 @@
     document_opened = QtCore.Signal(object)
 
     #: Store the number of new documents created, for internal use.
     _new_count = 0
 
     CLOSED_TABS_HISTORY_LIMIT = 10
 
-    def __init__(self, parent=None, root=True, qsettings=None):
+    def __init__(
+        self,
+        parent=None,
+        root=True,
+        create_popup=False,
+        qsettings=None,
+        tabs_movable=True,
+        plus_button=True,
+        tab_context_menu=True,
+        empty_context_menu=True,
+        corner_widget=False
+    ):
         SplittableTabWidget.detached_window_klass = DetachedEditorWindow
+        self._corner_widget = corner_widget
         super(SplittableCodeEditTabWidget, self).__init__(
-            parent, root, qsettings=qsettings)
+            parent,
+            root,
+            create_popup=create_popup,
+            qsettings=qsettings,
+            tabs_movable=tabs_movable,
+            plus_button=plus_button,
+            tab_context_menu=tab_context_menu,
+            empty_context_menu=empty_context_menu
+        )
         self.main_tab_widget.tabBar().double_clicked.connect(
             self.tab_bar_double_clicked.emit)
-        if root:
-            self.closed_tabs_history_btn = QtWidgets.QToolButton()
-            self.closed_tabs_history_btn.setAutoRaise(True)
-            self.closed_tabs_history_btn.setIcon(QtGui.QIcon.fromTheme(
-                'user-trash', QtGui.QIcon(':/pyqode-icons/rc/edit-trash.png')))
-            self.closed_tabs_history_btn.setPopupMode(
-                QtWidgets.QToolButton.InstantPopup)
-            self.closed_tabs_menu = QtWidgets.QMenu()
-            self.closed_tabs_history_btn.setMenu(self.closed_tabs_menu)
-            self.closed_tabs_history_btn.setDisabled(True)
-            self.main_tab_widget.setCornerWidget(self.closed_tabs_history_btn)
-            self.main_tab_widget.tab_closed.connect(self._on_tab_closed)
+        if not root:
+            return 
+        # The menu with closed tabs is used by the empty-space context menu
+        # as well as the corner widget, so we always initialize it.
+        self.closed_tabs_menu = QtWidgets.QMenu(
+            _('Re-open closed document'),
+            self
+        )
+        self.closed_tabs_menu.setIcon(icons.icon(qta_name='fa.undo'))
+        self.main_tab_widget.tab_closed.connect(self._on_tab_closed)
+        if not self._corner_widget:
+            return
+        self.closed_tabs_history_btn = QtWidgets.QToolButton()
+        self.closed_tabs_history_btn.setAutoRaise(True)
+        self.closed_tabs_history_btn.setIcon(QtGui.QIcon.fromTheme(
+            'user-trash', QtGui.QIcon(':/pyqode-icons/rc/edit-trash.png')))
+        self.closed_tabs_history_btn.setPopupMode(
+            QtWidgets.QToolButton.InstantPopup)
+        self.closed_tabs_history_btn.setMenu(self.closed_tabs_menu)
+        self.closed_tabs_history_btn.setDisabled(True)
+        self.main_tab_widget.setCornerWidget(self.closed_tabs_history_btn)
 
     @classmethod
     def register_code_edit(cls, code_edit_class):
         """
         Register an additional code edit **class**
 
         .. warning: This method expect a class, not an instance!
@@ -1199,42 +1506,71 @@
             cls.editors[mimetype] = code_edit_class
         _logger().log(5, 'registered editors: %r', cls.editors)
 
     def save_current_as(self):
         """
         Save current widget as.
         """
-        if not self.current_widget():
+        widget = self.current_widget()
+        if not widget:
             return
-        mem = self.current_widget().file.path
-        self.current_widget().file._path = None
-        self.current_widget().file._old_path = mem
+        if widget.original:
+            widget = widget.original
+        mem = widget.file.path
+        old_path = widget.file.path
+        widget.file._path = None
+        widget.file._old_path = mem
         CodeEditTabWidget.default_directory = os.path.dirname(mem)
-        widget = self.current_widget()
         try:
             success = self.main_tab_widget.save_widget(widget)
         except Exception as e:
             QtWidgets.QMessageBox.warning(
                 self, _('Failed to save file as'),
                 _('Failed to save file as %s\nError=%s') % (
                     widget.file.path, str(e)))
             widget.file._path = mem
         else:
             if not success:
                 widget.file._path = mem
             else:
                 CodeEditTabWidget.default_directory = os.path.expanduser('~')
                 self.document_saved.emit(widget.file.path, '')
-
-                # rename tab
-                tw = widget.parent_tab_widget
-                tw.setTabText(tw.indexOf(widget),
-                              os.path.split(widget.file.path)[1])
-
-        return self.current_widget().file.path
+        # Traverse through all splitters and all editors, and change the tab
+        # text whenever the editor is a clone of the current widget or the
+        # current widget itself.
+        if old_path != widget.file.path:
+            current_document = widget.document()
+            for splitter in self.get_all_splitters():
+                for editor in splitter._tabs:
+                    if editor.document() != current_document:
+                        continue
+                    index = splitter.main_tab_widget.indexOf(editor)
+                    splitter.main_tab_widget.setTabText(
+                        index,
+                        widget.file.name
+                    )
+        return widget.file.path
+
+    def get_root_splitter(self):
+        current_splitter = self
+        while not current_splitter.root:
+            current_splitter = current_splitter.parent()
+        return current_splitter
+
+    def get_all_splitters(self, parent_splitter=None):
+        """
+        Gets a flat list of all splitters below parent_splitter. If no
+        parent_splitter is specified, the root splitter is used.
+        """
+        if parent_splitter is None:
+            parent_splitter = self.get_root_splitter()
+        splitters = [parent_splitter]
+        for child_splitter in parent_splitter.child_splitters:
+            splitters += self.get_all_splitters(child_splitter)
+        return splitters
 
     def save_current(self):
         """
         Save current editor. If the editor.file.path is None, a save as dialog
         will be shown.
         """
         if self.current_widget() is not None:
@@ -1246,15 +1582,15 @@
         try:
             encoding = widget.file.encoding
         except AttributeError:
             # not a code edit
             old_content = ''
         else:
             try:
-                with open(path, encoding=encoding) as f:
+                with io.open(path, encoding=encoding) as f:
                     old_content = f.read()
             except OSError:
                 old_content = ''
         if widget.dirty:
             try:
                 self.main_tab_widget.save_widget(widget)
             except Exception as e:
@@ -1284,22 +1620,35 @@
         :param args: Positional arguments that must be forwarded to the editor
             widget constructor.
         :param kwargs: Keyworded arguments that must be forwarded to the editor
             widget constructor.
         :return: Code editor widget instance.
         """
         if mimetype in self.editors.keys():
-            return self.editors[mimetype](
-                *args, parent=self.main_tab_widget, **kwargs)
-        editor = self.fallback_editor(*args, parent=self.main_tab_widget,
-                                      **kwargs)
+            editor = self.editors[mimetype](
+                *args,
+                parent=self.main_tab_widget,
+                **kwargs
+            )
+        else:
+            editor = self.fallback_editor(
+                *args,
+                parent=self.main_tab_widget,
+                **kwargs
+            )
+        try:
+            pygments = editor.modes.get('PygmentsSH')
+        except KeyError:
+            pass
+        else:
+            pygments.set_mime_type(mimetype)
         return editor
 
     def create_new_document(self, base_name='New Document',
-                            extension='.txt', preferred_eol=0,
+                            extension=None, preferred_eol=0,
                             autodetect_eol=True, **kwargs):
         """
         Creates a new document.
 
         The document name will be ``base_name + count + extension``
 
         :param base_name: Base name of the document. An int will be appended.
@@ -1310,14 +1659,16 @@
             used for saving the document unless autodetect_eol is True.
         :param autodetect_eol: If true, automatically detects file EOL and
             use it instead of the preferred EOL when saving files.
         :param kwargs: Keyworded arguments that must be forwarded to the editor
             widget constructor.
         :return: Code editor widget instance.
         """
+        if extension is None:
+            extension = self.default_extension()
         SplittableCodeEditTabWidget._new_count += 1
         name = '%s%d%s' % (base_name, self._new_count, extension)
         tab = self._create_code_edit(
             self.guess_mimetype(name), **kwargs)
         self.editor_created.emit(tab)
         tab.file.autodetect_eol = autodetect_eol
         tab.file.preferred_eol = preferred_eol
@@ -1377,15 +1728,15 @@
             tw.setCurrentIndex(tw.indexOf(w))
             return w
         else:
             assert os.path.exists(original_path)
             name = os.path.split(original_path)[1]
 
             use_parent_dir = False
-            for tab in self.widgets():
+            for tab in self.widgets(include_clones=True, from_root=True):
                 title = QtCore.QFileInfo(tab.file.path).fileName()
                 if title == name:
                     tw = tab.parent_tab_widget
                     new_name = os.path.join(os.path.split(os.path.dirname(
                         tab.file.path))[1], title)
                     tw.setTabText(tw.indexOf(tab), new_name)
                     use_parent_dir = True
@@ -1411,47 +1762,52 @@
             }
             tab.file.clean_trailing_whitespaces = clean_trailing_whitespaces
             tab.file.safe_save = safe_save
             tab.file.restore_cursor = restore_cursor_position
             tab.file.replace_tabs_by_spaces = replace_tabs_by_spaces
             tab.file.autodetect_eol = autodetect_eol
             tab.file.preferred_eol = preferred_eol
-            tab.show_whitespaces = show_whitespaces
+            if show_whitespaces is not None:
+                tab.show_whitespaces = show_whitespaces
             try:
                 tab.file.open(original_path, encoding=encoding)
             except Exception as e:
                 _logger().exception('exception while opening file')
                 tab.close()
                 tab.setParent(None)
                 tab.deleteLater()
                 raise e
             else:
                 tab.setDocumentTitle(name)
                 tab.file._path = original_path
                 icon = self._icon(path)
                 self.add_tab(tab, title=name, icon=icon)
                 self.document_opened.emit(tab)
-
-                for action in self.closed_tabs_menu.actions():
-                    if action.toolTip() == original_path:
-                        self.closed_tabs_menu.removeAction(action)
-                        break
-                self.closed_tabs_history_btn.setEnabled(
-                    len(self.closed_tabs_menu.actions()) > 0)
-
+                # Only the root tab has a corner widget with closed tabs
+                if self.root:
+                    for action in self.closed_tabs_menu.actions():
+                        if action.toolTip() == original_path:
+                            self.closed_tabs_menu.removeAction(action)
+                            break
+                    if self._corner_widget:
+                        self.closed_tabs_history_btn.setEnabled(
+                            len(self.closed_tabs_menu.actions()) > 0
+                        )
                 return tab
 
     def close_document(self, path):
         """
         Closes a text document.
         :param path: Path of the document to close.
         """
         to_close = []
         for widget in self.widgets(include_clones=True):
-            if widget.file.path == path:
+            p = os.path.normpath(os.path.normcase(widget.file.path))
+            path = os.path.normpath(os.path.normcase(path))
+            if p == path:
                 to_close.append(widget)
         for widget in to_close:
             tw = widget.parent_tab_widget
             tw.remove_tab(tw.indexOf(widget))
 
     def rename_document(self, old_path, new_path):
         """
@@ -1463,15 +1819,17 @@
         :param old_path: old path (path of the widget to rename with
             ``new_path``
         :param new_path: new path that will be used to rename the tab.
         """
         to_rename = []
         title = os.path.split(new_path)[1]
         for widget in self.widgets(include_clones=True):
-            if widget.file.path == old_path:
+            p = os.path.normpath(os.path.normcase(widget.file.path))
+            old_path = os.path.normpath(os.path.normcase(old_path))
+            if p == old_path:
                 to_rename.append(widget)
         for widget in to_rename:
             tw = widget.parent_tab_widget
             widget.file._path = new_path
             tw.setTabText(tw.indexOf(widget), title)
 
     def closeEvent(self, event):
@@ -1514,32 +1872,33 @@
     def close_all(self):
         for w in self.widgets(include_clones=True):
             tw = w.parent_tab_widget
             tw.remove_tab(tw.indexOf(w))
 
     def _icon(self, path):
         provider = self.icon_provider_klass()
-        if not os.path.exists(path):
-            return provider.icon(provider.File)
         return provider.icon(QtCore.QFileInfo(path))
 
     def _on_current_changed(self, new):
         old, new = super(
             SplittableCodeEditTabWidget, self)._on_current_changed(new)
         if new:
             new.dirty_changed.connect(self.dirty_changed.emit)
-        self.dirty_changed.emit(new.dirty)
+        if hasattr(new, 'dirty'):  # Only CodeEdit objects have this property
+            self.dirty_changed.emit(new.dirty)
         return old, new
 
-    def split(self, widget, orientation):
+    def split(self, widget, orientation, index=None):
         splitter = super(SplittableCodeEditTabWidget, self).split(
-            widget, orientation)
+            widget, orientation, index=index)
         if splitter:
             splitter.tab_bar_double_clicked.connect(
                 self.tab_bar_double_clicked.emit)
+            splitter.fallback_editor = self.fallback_editor
+        return splitter
 
     def _on_tab_closed(self, tab):
         try:
             path = tab.file.path
             open_params = tab.open_parameters
         except AttributeError:
             pass
@@ -1562,15 +1921,16 @@
                 else:
                     action = QtWidgets.QAction(self._icon(path), filename,
                                                self.closed_tabs_menu)
                     self.closed_tabs_menu.insertAction(before, action)
                 action.setToolTip(path)
                 action.triggered.connect(self._open_closed_path)
                 action.setData(open_params)
-                self.closed_tabs_history_btn.setEnabled(True)
+                if self._corner_widget:
+                    self.closed_tabs_history_btn.setEnabled(True)
                 nb_actions = len(self.closed_tabs_menu.actions())
                 while nb_actions > self.CLOSED_TABS_HISTORY_LIMIT:
                     self.closed_tabs_menu.removeAction(
                         self.closed_tabs_menu.actions()[-1])
                     nb_actions = len(self.closed_tabs_menu.actions())
 
     def _open_closed_path(self):
@@ -1585,9 +1945,17 @@
             safe_save=open_parameters['safe_save'],
             restore_cursor_position=open_parameters['restore_cursor_position'],
             preferred_eol=open_parameters['preferred_eol'],
             autodetect_eol=open_parameters['autodetect_eol'],
             show_whitespaces=open_parameters['show_whitespaces'],
             **open_parameters['kwargs'])
         self.closed_tabs_menu.removeAction(action)
-        self.closed_tabs_history_btn.setEnabled(
-            len(self.closed_tabs_menu.actions()) > 0)
+        if self._corner_widget:
+            self.closed_tabs_history_btn.setEnabled(
+                len(self.closed_tabs_menu.actions()) > 0
+            )
+
+    def default_extension(self):
+        
+        if self.root:
+            return DEFAULT_EXTENSION
+        return self.get_root_splitter().default_extension()
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `pyqode.core-2.9.0.dist-info/RECORD` & `pyqode_core-4.0.5.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,100 +1,108 @@
-pyqode.core-2.9.0-py3.5-nspkg.pth,sha256=6DqPRD4CV4fG0j3i3KcHJaF2xp2U0WE3YFGa6p4sebY,305
-pyqode/core/__init__.py,sha256=lT2M23eCgGCHvH6wszKN-TgIA4S0HTdiuswWsDhNWLo,700
-pyqode/core/cache.py,sha256=uFHYuw2vI3RAT1fVUVtt5ZD-YYciWAq1yvxekQpVbMQ,5002
-pyqode/core/icons.py,sha256=EbLGtvx4dz4fd9gWcIjLMCgCCBrHNjAvNs7BINU9MMc,1929
-pyqode/core/share.py,sha256=RbXOV7Rs5BeaQAVn87vAEu0YS92z0M2HnjgvkGBBky0,2496
-pyqode/core/_designer_plugins/__init__.py,sha256=WWEExS_9tN1EGjbUSUaFLRkc7dxzuNWk5MzKRFLKN_k,1408
-pyqode/core/_designer_plugins/code_edit_plugin.py,sha256=6ZRbmkjX-up2VNHAjRDWQvplDR8Eeq-qy_yO1nHc5Rs,361
-pyqode/core/_designer_plugins/errors_table_plugin.py,sha256=LssFdn2b7CwQ7H8hxso_8oAh1aN0g1EVl00D4agrhrg,377
-pyqode/core/_designer_plugins/interactive_console_plugin.py,sha256=TWKeuoGRwwVB9o-H2L1IN0mF4Fb6VdWQ28n2F8ejtYw,405
-pyqode/core/_designer_plugins/tab_widget_plugin.py,sha256=Zx8H6TQRJOkCOKmA1F_NFlFvGkdQgUQwMNRUJEs-dNU,369
-pyqode/core/_forms/__init__.py,sha256=-cw63O2T-bUq9R1QjWXFceXB3e44EhnYb9snFSrFqOM,227
-pyqode/core/_forms/dlg_encodings_ui.py,sha256=NZNobWHLOtc0yOoh_zs93cWEewLdJaXT36F0ZWyMOMI,2976
-pyqode/core/_forms/dlg_goto_line_ui.py,sha256=IO1Hye59_Gs3siFAYJ3OVaJlnJJSBmLGjIa4r6hC-Hw,2762
-pyqode/core/_forms/dlg_preferred_encodings_editor_ui.py,sha256=lhGfEkUGt_bknysqSYkEaWq5TSADQIlDPArveaBPruI,6090
-pyqode/core/_forms/dlg_unsaved_files_ui.py,sha256=tzytXzASoIdkxd9-XfScfhKjUEH0CYTQqEd_aa8VDd0,1658
-pyqode/core/_forms/pnl_encoding_ui.py,sha256=zqbwbuaBfJ5N1GF0HuZpo6ehzqrYbiaDof2l2ETmOY8,3481
-pyqode/core/_forms/pnl_read_only_ui.py,sha256=VZAVKQ1icCDvJe5bRbMlZA7iUDUf8flkvv-O9pkGtAA,1461
-pyqode/core/_forms/popup_open_files_ui.py,sha256=SBugEWOJtEfTJCiLi4hr4efqst5tdkXkoTJ-OWlIdy8,2788
-pyqode/core/_forms/pyqode_core_rc.py,sha256=59SNplaJRrn0HvB-JiVPa4dk11rRiGUChfVOfvrKuY4,1159367
-pyqode/core/_forms/search_panel_ui.py,sha256=zOEXnMo_bjtWLTIlHxWhG98pN1-ctmUUGwBbDaX5O0o,11404
-pyqode/core/api/__init__.py,sha256=JdnACg2QJ1CqIMTptVX2pHYiSo1cXlKOXLLIwnc4_0c,1174
-pyqode/core/api/client.py,sha256=7dkairFjUPtpNg6g6-Q6fCYGUxZNSD6QlxgvgNYoiaI,14195
-pyqode/core/api/code_edit.py,sha256=z1h-3h4NExixYpqF8G1rF13Hx0nZC0Ey4PBz3FZLJgQ,46372
-pyqode/core/api/decoration.py,sha256=RY169ujtymyT5bp8DEBJ_1MkBL9Hoa78CAyZYSeleOo,6812
-pyqode/core/api/encodings.py,sha256=z_czy-Wu3cxWhs0ypGzQSHIrdu45nO6CFRyncKmlFBI,5199
-pyqode/core/api/folding.py,sha256=MB3y9dYigwfw6oOq8p5OPg36iexRBTHRqAUi7gHtFZM,13342
-pyqode/core/api/manager.py,sha256=uvSuSiuHuYSIdKIDlR95HnMx9XD-EvO-OaICKqaKa9I,1206
-pyqode/core/api/mode.py,sha256=LPKS1RcV95IvgC30foBTWgA-LI3ck5zab8DwyYqTE5g,3662
-pyqode/core/api/panel.py,sha256=nT80JeHdRtScpZ7P664Aax14hnKFRh3ZR2kfGbZR70E,3799
-pyqode/core/api/syntax_highlighter.py,sha256=qcXiT_wOJIfzsp_-fgFyhnaBlYC-fFSrCkOY0O4ozy4,13286
-pyqode/core/api/utils.py,sha256=OIsWFZqC267hAekEsS56vFftQqzcUoc0N5KWglCt2mo,38429
-pyqode/core/backend/__init__.py,sha256=HHY4cDsBLCvdDI1PnplI4lsXmcmBTRyFv3h3TSt8lHQ,3868
-pyqode/core/backend/server.py,sha256=Jyb9NWHGeAqvyfzTT8ZLEp9MeE3ptCxUiLFJPDTi5Dw,7537
-pyqode/core/backend/workers.py,sha256=IYckBc6lbXS8Z_BardWhs3ItuqVdUS2fBcYVQtnWWhU,8151
-pyqode/core/dialogs/__init__.py,sha256=RWt3kUp6e2QMSCSmZtTtKeIkQ_N1pZcyGIahGpaAfus,347
-pyqode/core/dialogs/encodings.py,sha256=iChb8UqPvj4yWt6LSOjPudp-wWSh-yLUsJaSMTgNUF0,7402
-pyqode/core/dialogs/goto.py,sha256=2SLd9atzTJZvqstgPNGlmEYfGTtt98F4UKpUHEp7No8,1499
-pyqode/core/dialogs/unsaved_files.py,sha256=dX74tZkBDjce-OFImkM2Ow0VdIi9-bmObw8En3AmnDI,2043
-pyqode/core/managers/__init__.py,sha256=kgdGYY5RYio1QyG5t17SLfClCtOgjUetT0MbW2xrK3I,827
-pyqode/core/managers/backend.py,sha256=9t480VDOstjvcb8i_PiSEhPlo_msUGP0ne-SBbihhpI,8564
-pyqode/core/managers/decorations.py,sha256=lGVGOOLNVvyapHailWnKy9_uS8C1QyoBBge9IulfThg,1766
-pyqode/core/managers/file.py,sha256=HCk2nVr5_PPG6Bb5vkCSB0S8ScSd5fY-c4DKHoVat0g,15661
-pyqode/core/managers/modes.py,sha256=HJzTP3630cfaA06giygHS9xO1Cmx-lsrlyoSa7cmejo,2995
-pyqode/core/managers/panels.py,sha256=r5mL01eU4iXLa5II-mAGwId0z5sz9YqcbbM16bWrYzE,11472
-pyqode/core/modes/__init__.py,sha256=3lt3I1yV4RjHXjYfreSmcZ6SNyfALGbYup6KLsNYsc0,1663
-pyqode/core/modes/autocomplete.py,sha256=zFXeMAxZ1P53mXP95iDc5TcxoaQzPHngxXioJfnpOmM,4517
-pyqode/core/modes/autoindent.py,sha256=-cIS6gfJS-dgyGMLuo0_kjZNLgAcK6jlXsJ0qZmUP7M,1929
-pyqode/core/modes/backspace.py,sha256=T8H7oO6iuav04SGfsR5-l_QFDCRypH7ApXaH7CWs2PU,1897
-pyqode/core/modes/caret_line_highlight.py,sha256=oDPsVX2HJ_pD1xjanQQQY6BKKD_EzSZchnZya7sWFe0,2729
-pyqode/core/modes/case_converter.py,sha256=baVR-tVjQPsJvPEbdceE0xpXrVtpKQ4xgnViHM4d30o,2040
-pyqode/core/modes/checker.py,sha256=LReDFbTAAv5PmtQreRS36T4vDjM3d3bFKkEUKWzpYwg,12321
-pyqode/core/modes/code_completion.py,sha256=xKAKOVGE9ZpJc1KyQ1VVjUQimBEpIbBGSheu0eXGnoY,24172
-pyqode/core/modes/cursor_history.py,sha256=S0WiygYR8DwqvZwCIjYXOEoVuzn33pZuBqmLQO43uoA,2862
-pyqode/core/modes/extended_selection.py,sha256=EDg3Tdg1YroT9pvjsJ765AuMvZHivh0yJIGTfMrRPxI,6254
-pyqode/core/modes/filewatcher.py,sha256=1CPqm1PZ6n9nbl89br1bX207edZtr7H7rCQ2JxgFe6Y,7267
-pyqode/core/modes/indenter.py,sha256=95gzxdxMQTR7UcfAJ6kKfw4BWj3jg_YfeoR_ygOn1EY,6218
-pyqode/core/modes/line_highlighter.py,sha256=m21rUHom8pQuAFbUurEG4kNQOiJJUc1JBUd6KHZ00IU,2626
-pyqode/core/modes/matcher.py,sha256=ZllH3lD-_QzNpa0r2p7bXyphmr3WzmL8I0Y8IW9eNQ8,9836
-pyqode/core/modes/occurences.py,sha256=Pt6Nb9zi0bt_PUiiVJBTPrILpbPHlaq4GlJ5ygNIRHo,6184
-pyqode/core/modes/outline.py,sha256=kCsU_0AGfLbkTcDWiTsXH_qHMZjWWBEI1XcWSBvAB6E,2856
-pyqode/core/modes/pygments_sh.py,sha256=vNz1tgkxrKlUS-BMFyd2vZgOp2OmrDnxXKLfF2v17g4,14333
-pyqode/core/modes/right_margin.py,sha256=ouBGYoc_qhMHpIq3kLlsWm29c3ta9JbZxXkeFZQ8VYg,2705
-pyqode/core/modes/wordclick.py,sha256=xGUJFbQ0bBjzMSlqbuzINLr99fBtL9d0hYjf46uW_Zc,4846
-pyqode/core/modes/zoom.py,sha256=eyAdLoQ7rIaHulrKHH36uwZa5k7Rlh2K2vp3gYaqE0Y,3317
-pyqode/core/panels/__init__.py,sha256=kN3MmrOaPO6Lu73KwfP7AhDTnLEuqmoNw3C08JxouLg,621
-pyqode/core/panels/checker.py,sha256=rT9vfcaxSaBlwhy1KprNzLjWbG5w3q2dl0_d2SQowow,4447
-pyqode/core/panels/encodings.py,sha256=keX947hcMGevXvTYtlJvwoptB8UXYZYA8XCzsHTjCpI,8070
-pyqode/core/panels/folding.py,sha256=HbOQsegey7aET6pyxy-kMyp4bCcunItG9VgvQA9GSu4,32014
-pyqode/core/panels/global_checker.py,sha256=mua8SRLq06uPCq7X9febM6eJ9KdsZU5wnyhjzGskT98,3441
-pyqode/core/panels/line_number.py,sha256=YheX2a11itfTsnPQA8J89uNzPT2d05IJtuxgQ2PB7yI,4208
-pyqode/core/panels/marker.py,sha256=Tg2Iisd5tYDBsRlMZVz1SJQNxLnVMrKDm--9MGu42jA,8021
-pyqode/core/panels/read_only.py,sha256=VhBPWEQ7BoReadtPcVoXp6EGXjYel71YgWcXHjuFmjQ,2579
-pyqode/core/panels/search_and_replace.py,sha256=uFuIEPalCb1I2F9b2jIWWtHUIxxe4uXtgmLt996VZEs,24067
-pyqode/core/styles/__init__.py,sha256=OpvhlYW5PYrNf1pULFLvj_fy2Vl3jTkLd_iYuJQuCXo,290
-pyqode/core/styles/darcula.py,sha256=xyodd_fRupwqSAygJd3Px-p6KFYPIN2OUFENbBgnOrc,2109
-pyqode/core/styles/qt.py,sha256=kAROh4Z2_Nq3hRoUQUioHWB3aBrlVEqcCrYPVJ0fb1g,2067
-pyqode/core/tools/__init__.py,sha256=7fQi1Q-dVqieAtPHNUOcvttAz6iAC-EjX3MsiXG9C5c,254
-pyqode/core/tools/console.py,sha256=_4W9EgDZalGanL92pKqXtO4K_c-sqwUKS8LEItagCMM,1134
-pyqode/core/widgets/__init__.py,sha256=W9W1WgGayOPuuFdsrA24tAIBXiW7d7rOCXB9tmmMDTE,2355
-pyqode/core/widgets/code_edits.py,sha256=Uh9A7qi6V34mI2qP_pMlglNGqjrrL_s0gODinVHSB0Q,6785
-pyqode/core/widgets/encodings.py,sha256=pPtCjqRSMESzaj4wO008xNR2ikM7Xquk772ALxd9IQg,7287
-pyqode/core/widgets/errors_table.py,sha256=gxWuCBZkFmpdfgK5HOrBKbHADRQc_6WvfSRrOom6P7E,5822
-pyqode/core/widgets/file_icons_provider.py,sha256=2uoIzT2Lz8qUFsUseK4vfIIqGBiDJIWhcVF4j5rkJH0,2011
-pyqode/core/widgets/filesystem_treeview.py,sha256=rOV-huGe3MR2d68HobsW67qXaYdWtplf2rBGaS3s9rc,30138
-pyqode/core/widgets/interactive.py,sha256=AmjXsbc546fQMTGMNtNpIVnudI0BiKlZOOmATmwSB6k,15410
-pyqode/core/widgets/menu_recents.py,sha256=W53qMaSyzvh_2HX5GA7iZ6N05KzHRFl8u0U83SoPQFY,6960
-pyqode/core/widgets/outline.py,sha256=sivl2gZzHeqfXaZ3bURQAOBVfe4Vq5xGCDIXD6xpMmc,9676
-pyqode/core/widgets/preview.py,sha256=skmpwlLn1JxSxPV58qXfWEuI6v-0yd8cXEVtmKwyaxU,1934
-pyqode/core/widgets/prompt_line_edit.py,sha256=odV2urpXYwsRYe0_TCZfkN6791Amvnc2WlP5h0EeIkg,4093
-pyqode/core/widgets/splittable_tab_widget.py,sha256=uPCslmNh_m1U5VlJY0wEFYkvLeH_fbT1qMQ0px64uzU,59828
-pyqode/core/widgets/tab_bar.py,sha256=g5YwCDZV79F7t0IFAbbgyY2uUOaeTnJ5GV4ECSDeRSU,961
-pyqode/core/widgets/tabs.py,sha256=iAOBg2Ec30o-G23L9nVAKvvJmVDBch5B0m_yVeRzYwc,16303
-pyqode.core-2.9.0.dist-info/DESCRIPTION.rst,sha256=tV8iGfqc8Fg_Z9C_QAPeBMyNIBH1Y8clSASHavV0HQI,3049
-pyqode.core-2.9.0.dist-info/METADATA,sha256=Tjzns2IxWB4AuR9hfBL0oCPMnpMsWRQqhOFf_pFOMgk,4184
-pyqode.core-2.9.0.dist-info/RECORD,,
-pyqode.core-2.9.0.dist-info/WHEEL,sha256=o2k-Qa-RMNIJmUdIc7KU6VWR_ErNRbWNlxDIpl7lm34,110
-pyqode.core-2.9.0.dist-info/entry_points.txt,sha256=RsL6dwTQfdV6ylfuK26qs63VBODvC610as6Ay_LAWqU,231
-pyqode.core-2.9.0.dist-info/metadata.json,sha256=OvRISUSSlhEaTcJPytnKqvO9AkRnGppAT2x1MLhX8uE,1703
-pyqode.core-2.9.0.dist-info/namespace_packages.txt,sha256=tBD6CryrPPLMtuE6-xG4KyIbzJeaN5AxVmWS1SdOTOE,7
-pyqode.core-2.9.0.dist-info/top_level.txt,sha256=tBD6CryrPPLMtuE6-xG4KyIbzJeaN5AxVmWS1SdOTOE,7
+pyqode/core/__init__.py,sha256=xLWuC70sl674LrS_mAcQqtPHbF1NXWVoWvU_2xG_1Mk,701
+pyqode/core/cache.py,sha256=9uzbfPULTLeXlHJiQK3QQ6_6Hgeb95ZtIEv9b9d6mr4,5990
+pyqode/core/icons.py,sha256=7dOkaRPFXWpUJgYEdo1dDtlmzX1Fmwj3wRJ5camj6L0,2095
+pyqode/core/share.py,sha256=RbXOV7Rs5BeaQAVn87vAEu0YS92z0M2HnjgvkGBBky0,2496
+pyqode/core/_designer_plugins/__init__.py,sha256=kfxKQBjjzmN7CR6lPhYf9AwdFJOhPtL3enToPcEE-XQ,1402
+pyqode/core/_designer_plugins/code_edit_plugin.py,sha256=6ZRbmkjX-up2VNHAjRDWQvplDR8Eeq-qy_yO1nHc5Rs,361
+pyqode/core/_designer_plugins/errors_table_plugin.py,sha256=LssFdn2b7CwQ7H8hxso_8oAh1aN0g1EVl00D4agrhrg,377
+pyqode/core/_designer_plugins/interactive_console_plugin.py,sha256=TWKeuoGRwwVB9o-H2L1IN0mF4Fb6VdWQ28n2F8ejtYw,405
+pyqode/core/_designer_plugins/tab_widget_plugin.py,sha256=Zx8H6TQRJOkCOKmA1F_NFlFvGkdQgUQwMNRUJEs-dNU,369
+pyqode/core/_forms/__init__.py,sha256=-cw63O2T-bUq9R1QjWXFceXB3e44EhnYb9snFSrFqOM,227
+pyqode/core/_forms/dlg_encodings_ui.py,sha256=fKaYWbCh5sJeZnh83qJTTnVEQD6U2DlQoexn2LQa3n0,2971
+pyqode/core/_forms/dlg_goto_line_ui.py,sha256=-fOYo_WjAwT_uZI1_SBaavOxifK_YAg8O9lJYT-grwQ,2756
+pyqode/core/_forms/dlg_preferred_encodings_editor_ui.py,sha256=bD7xy_fze_ycjSCITymbUFi206flmkxwcQi4qZY5JxA,6085
+pyqode/core/_forms/dlg_unsaved_files_ui.py,sha256=GHVDASNgtX1rRVIyuo94ITQ0lItB8vSzjjymibm-9fw,1652
+pyqode/core/_forms/pnl_encoding_ui.py,sha256=JJDs-wAjE73rfObZnjfEKcVU8ldNwSYG5QEzJc81fu0,3476
+pyqode/core/_forms/pnl_read_only_ui.py,sha256=mNSVMSAd3TMYG8iKz0wTGDRnzeyGqihyV922agOuaWw,1455
+pyqode/core/_forms/popup_open_files_ui.py,sha256=TPH0gx4bAd3FOb3gwjCZXGbMpOWBQK3lIUDkUXnpuF0,2782
+pyqode/core/_forms/pyqode_core_rc.py,sha256=GJ1DL-3r157eegxUHNDWrLZ8WcCrEQN50NgLpbe2sxM,1159362
+pyqode/core/_forms/search_panel_ui.py,sha256=OXoV2KI9NkfhyWAruqSu7GB7AGZYtNCLStFdnS7iOBk,11399
+pyqode/core/api/__init__.py,sha256=JdnACg2QJ1CqIMTptVX2pHYiSo1cXlKOXLLIwnc4_0c,1174
+pyqode/core/api/client.py,sha256=Tm3Gi5X4kCv3GATzzmy51qU7glPALvp3xKddDMYkc70,14552
+pyqode/core/api/code_edit.py,sha256=6XBsTmmrefI0igCYkhBZIAvFqypiPkDcMR8gBG_SHgs,53733
+pyqode/core/api/decoration.py,sha256=Vvrs_q65V7kyeX-c9zuSaS7qt77JOIoBcQ5NLqklUz4,9308
+pyqode/core/api/encodings.py,sha256=z_czy-Wu3cxWhs0ypGzQSHIrdu45nO6CFRyncKmlFBI,5199
+pyqode/core/api/folding.py,sha256=JM9q9p6ZdHuXU8fSbXmkLwpQ0SGpd6vW_jnMLrY0v4c,13923
+pyqode/core/api/manager.py,sha256=uvSuSiuHuYSIdKIDlR95HnMx9XD-EvO-OaICKqaKa9I,1206
+pyqode/core/api/mode.py,sha256=LPKS1RcV95IvgC30foBTWgA-LI3ck5zab8DwyYqTE5g,3662
+pyqode/core/api/panel.py,sha256=p-iN2NIIN_qeOAOkW6cA-qV80jg-9bMFmONaYE2hJYw,5657
+pyqode/core/api/syntax_highlighter.py,sha256=FvlnhvzTJqoa1hHza7Bjov2QZUVCETOgAjzMODqVAJI,14003
+pyqode/core/api/utils.py,sha256=8uln522VVyhwAihG-TO8LqWuuiytZU_VGo9sNtiTnlI,41668
+pyqode/core/backend/__init__.py,sha256=HHY4cDsBLCvdDI1PnplI4lsXmcmBTRyFv3h3TSt8lHQ,3868
+pyqode/core/backend/server.py,sha256=W-6_Ta6qvO02rVJ6KkCy_e8z2YVp6I2nke7ypGvysNs,7535
+pyqode/core/backend/workers.py,sha256=OC0kuouVb81KbHH0BmQx-CG-jcIdKMGGoNHMaFHFV2s,9895
+pyqode/core/dialogs/__init__.py,sha256=RWt3kUp6e2QMSCSmZtTtKeIkQ_N1pZcyGIahGpaAfus,347
+pyqode/core/dialogs/encodings.py,sha256=f959uAyWEnMG4_RjfdBq408frUGK3I9JVy0yIUXEiMk,7396
+pyqode/core/dialogs/goto.py,sha256=zav6T1SS-u546VVq0IbF2dT8WYho2GZqSti0jJGvz8E,1493
+pyqode/core/dialogs/unsaved_files.py,sha256=QASXkirSNRO47xMUvD3QRaxkha2cnZB_gDSDJ-LwexY,2032
+pyqode/core/managers/__init__.py,sha256=kgdGYY5RYio1QyG5t17SLfClCtOgjUetT0MbW2xrK3I,827
+pyqode/core/managers/backend.py,sha256=jAjYFt3jr9TJMxg-1ETVAqOagAAyqS8fNeaOv1U1MfE,12934
+pyqode/core/managers/decorations.py,sha256=KkchlypD_FiCHOeuGJxYB-lNPiDoeDxe4obZN_JvczY,2651
+pyqode/core/managers/file.py,sha256=lYMV1_A_xkUkO6aWd7zZ1__DZS6dcIMTdP98zMuJll8,15486
+pyqode/core/managers/modes.py,sha256=fbeSnGiNEwOZcfur_kUr91Ce4KZk7ZrbFpvcqjUlKHc,2249
+pyqode/core/managers/panels.py,sha256=Tfk4ONXO2Eq5PyuWWc0ThC_ihKy9bCrpdyu_gcouoTk,10670
+pyqode/core/modes/__init__.py,sha256=uuS5htfVQW1NMDJHKwCYm0W3zbMQEjHRwunVXD1opKE,2033
+pyqode/core/modes/autocomplete.py,sha256=tVB7N6znsnNrVz5YO-nXRZfuLyRQDXC5TMfATbZVaCQ,4924
+pyqode/core/modes/autoindent.py,sha256=gjPxB__LdDVGIskHYksNidzS-wDhPBPA-Rbd4MubpZM,2240
+pyqode/core/modes/backspace.py,sha256=KJ2iFlZSDIyGQPXi6Du7kguRq-MyzaCpTf44nsVROv8,9277
+pyqode/core/modes/breakpoint.py,sha256=4odv4EGIYuaZJRQblgjYm78ZgOOzD-Yms8piA9kIYtI,3062
+pyqode/core/modes/calltips.py,sha256=70O9tum-bKmWL-MdA8ymT_7jWaEWLzExmzWxYL45AJg,5690
+pyqode/core/modes/caret_line_highlight.py,sha256=Fy-oQ8ypbITp9M3xdQ70Pz1KJ0QvRnfLAYVll_XKbXk,2723
+pyqode/core/modes/case_converter.py,sha256=23b8MGx7O_I842kNuiCh3sq25Wsmxw7Z_WXuNVuK-AI,1996
+pyqode/core/modes/checker.py,sha256=KEFzwMV1TZ30y98LkxdFWZBjsWSZUZFuMwbN0pJi9WE,14809
+pyqode/core/modes/code_completion.py,sha256=mRfFc7n6bLZNy352VObRe410tg3dOXyhBkPCrRNS1Ps,27374
+pyqode/core/modes/comments.py,sha256=WeSmknKy4gx8saaLdvv00zVSbHH2ggSzMUnJQtkEcdE,6068
+pyqode/core/modes/cursor_history.py,sha256=-KotEg8IGiTl5d9gmauvqP7vHHHPgPGmcxvwOyUWabE,2976
+pyqode/core/modes/extended_selection.py,sha256=AAh5b9uLclZj4TUZbvrfYf8abJAYlxlXlvlugYP9i0I,7594
+pyqode/core/modes/filewatcher.py,sha256=eYNLSDVvwQdaQHFX8m55wnyr-zuW0TQKZlVoSbYtyNA,7520
+pyqode/core/modes/image_annotations.py,sha256=sUkpzBSZBdrtadpgUMl2Y_ah44dLlQeGCX-2m1zQeFk,1709
+pyqode/core/modes/indenter.py,sha256=N1JqqYFUXNyaCCPDrnA93CXBgkaFhrFyAchG9QnDHcc,7151
+pyqode/core/modes/line_highlighter.py,sha256=PyEP-vmILquAQvI4LTgfjFzGBnkyjEdX1WJIM8TRB3o,2620
+pyqode/core/modes/line_sorter.py,sha256=a8bf7EHQ_fcYo_K0g25hNklI7a0baUh1fvc0JVQkhgw,1927
+pyqode/core/modes/matcher.py,sha256=a1IyPJOoTawjuFXJLzS0-_X0eDf5R5TdxicmKYlyJbY,10408
+pyqode/core/modes/occurences.py,sha256=Fp-SHC7fXlPTR3OBK0JW4TB6nZg87yrVhajJ6e-oW74,6447
+pyqode/core/modes/outline.py,sha256=H0N_g5RJ2klJxg0TdDeNXeGBS_tUYzSsa2KqLNTrbCk,2850
+pyqode/core/modes/pygments_sh.py,sha256=gVzK701MwHQGUEIsr6yCH_fWrauYz8e6fN10MZOFIu8,14766
+pyqode/core/modes/right_margin.py,sha256=U0EM7XUiMu9BIMB4lF_Tg0PSFCHOT26SnDJpZMooIO8,2712
+pyqode/core/modes/spellchecker_mode.py,sha256=jMRrxjacWEj3Gm3mhwEyEuHe7hTcSn1rs-yzmHWUnQo,1832
+pyqode/core/modes/wordclick.py,sha256=6C8J1XASrvTLCnTrE_Xp5rXn_n5hdhyUCYV5BJMZOLg,4840
+pyqode/core/modes/zoom.py,sha256=3fslt3og6Y_eNC5-hW8OOcr1rnd1Mih7qZy14bi1tP4,3039
+pyqode/core/panels/__init__.py,sha256=4MbdKuKhMCFOBtuBH2EyywB6yzx0QY22NomevSfCOcQ,833
+pyqode/core/panels/change_extension.py,sha256=S2txz2yuTvRQwWON6ySVha5XE0AeeeimrlNCdYDvrUk,3566
+pyqode/core/panels/checker.py,sha256=xG_qQ1_sPEHn66iiL2Mqy_DHfpuRNIQ3Fdk-Y2K1SQc,5771
+pyqode/core/panels/encodings.py,sha256=ErZU_MSgc4eN1e-UcXJpdOqqPJThbuZxUax1rxcoL2g,7939
+pyqode/core/panels/folding.py,sha256=A4bqoROtITLEkTqwQ7-Ve--CjqbMnDbK2JhWL6lCOlY,30707
+pyqode/core/panels/global_checker.py,sha256=6IVeM_H4ve7nD6gO9yr1J3pjvzEW2g33OwAntjGNATA,3361
+pyqode/core/panels/image_annotations.py,sha256=oMjKw-Wc-m80FJLdpis7_TThguUpo-jrtD3GTrJ4-lA,1756
+pyqode/core/panels/line_number.py,sha256=obuCyt0Vi9tCjdqr4XQMb0WW3iSTSvGQ6KfhvMqRNlI,4233
+pyqode/core/panels/margin.py,sha256=dlnJV5kWnOomt0bhiWuut4C6zpRQPNlupYnOUzejEXk,1782
+pyqode/core/panels/marker.py,sha256=VqH7ud6kqALbn2g9TuVRNV-1IxEW7Vcx3nsz49YPgPE,8015
+pyqode/core/panels/read_only.py,sha256=2w6gbCfpEbx8wCQSH8fH6MRreap04xddefjp8HExbLY,2299
+pyqode/core/panels/search_and_replace.py,sha256=hvdOtPjT-laDjSjtsGDLcgG8DQATjuzNv7Vs3BzPNI8,25998
+pyqode/core/styles/__init__.py,sha256=OpvhlYW5PYrNf1pULFLvj_fy2Vl3jTkLd_iYuJQuCXo,290
+pyqode/core/styles/darcula.py,sha256=xyodd_fRupwqSAygJd3Px-p6KFYPIN2OUFENbBgnOrc,2109
+pyqode/core/styles/qt.py,sha256=kAROh4Z2_Nq3hRoUQUioHWB3aBrlVEqcCrYPVJ0fb1g,2067
+pyqode/core/tools/__init__.py,sha256=7fQi1Q-dVqieAtPHNUOcvttAz6iAC-EjX3MsiXG9C5c,254
+pyqode/core/tools/console.py,sha256=_4W9EgDZalGanL92pKqXtO4K_c-sqwUKS8LEItagCMM,1134
+pyqode/core/widgets/__init__.py,sha256=3mMASOCgoCRjPzUbTEgUxAXph3wGlGyb8P-RK8mOFeQ,2515
+pyqode/core/widgets/_pty.py,sha256=KmO4MH1_xfuA6S4hjQbNKUrOz6OYPrXJA-Y7SCn3RnU,5160
+pyqode/core/widgets/code_edits.py,sha256=Uh9A7qi6V34mI2qP_pMlglNGqjrrL_s0gODinVHSB0Q,6785
+pyqode/core/widgets/encodings.py,sha256=nVK_YS1lPIMfH_sICbmk7GWRcqvuhg3O__e7O8qGs5o,7301
+pyqode/core/widgets/errors_table.py,sha256=lhIG2d4tySgiiLGROXmJgZ0LcRz6KYKu2inTsEZnXT0,5816
+pyqode/core/widgets/file_icons_provider.py,sha256=do71d5ynQ5c3t389xl-oNdGzCSkpLMXpXzOJFTpFq2o,2005
+pyqode/core/widgets/filesystem_treeview.py,sha256=gKVLKr5Cofpsd3Q1XsvPcT5NfdydvNMzDUoC6jguWok,30870
+pyqode/core/widgets/interactive.py,sha256=jFF78nfGIsV6ilw4n2jjD8X5EK0d5MpxmVKIGbrmxx8,15526
+pyqode/core/widgets/menu_recents.py,sha256=fEMcIkj02-6bLG2j2OY4MU-ybt3XXlVu1YEXEH8oo4s,6954
+pyqode/core/widgets/outline.py,sha256=Auek3CXSlGkzytU75HQu-J1XH1WYyMqpjB4pzufjAxE,9670
+pyqode/core/widgets/output_window.py,sha256=Dec3etBuE2s4OVsbbiM2lmn4zFCkjZy2ndivBvAPWtg,56914
+pyqode/core/widgets/preview.py,sha256=2at91-GHRTQPG23KlKnrX23ZAfB2rr_kYHkXPtiXZgw,1928
+pyqode/core/widgets/prompt_line_edit.py,sha256=AfrqLnZLBiO7_9YVLjUVynsx3JuVd3LiQNphMJAxz6g,3432
+pyqode/core/widgets/pty_wrapper.py,sha256=MUijj_6nzcVE_FA8DDT4e2FELaTmxnoe1EiIUe9SrH8,476
+pyqode/core/widgets/splittable_tab_widget.py,sha256=eU8v24X-CELxgmD2hUWC96pIb--2sv7q7VZgcJmbUpg,73573
+pyqode/core/widgets/tab_bar.py,sha256=jVsERP7q-RSV6EB7FGAe-GAqqKJtwF2g53noZzcPHEM,955
+pyqode/core/widgets/tabs.py,sha256=FnSA5wERHwOnpy4VkEkw0CE_QeuSCHUIDZwnSh5Q5gU,16197
+pyqode/core/widgets/terminal.py,sha256=wKgqaHvNo2qR7_G3intjQMc6cJABDQD9qUmMGn5dr9A,2329
+pyqode_core-4.0.5.dist-info/LICENSE,sha256=j_FIVglqwnvuyOHy6sV5JtzqKqnbo70dOE22iYCSDKM,1119
+pyqode_core-4.0.5.dist-info/WHEEL,sha256=rSgq_JpHF9fHR1lx53qwg_1-2LypZE_qmcuXbVUq948,81
+pyqode_core-4.0.5.dist-info/METADATA,sha256=w1YsC6-_lKQVgCd_0fajnsq2F1BGnrPvqOH59Z3YTRA,1476
+pyqode_core-4.0.5.dist-info/RECORD,,
```

