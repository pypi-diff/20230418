# Comparing `tmp/iprPy-0.11.4.tar.gz` & `tmp/iprPy-0.11.5.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "C:\Users\lmh1\Documents\Python-packages\iprPy\dist\tmp1yuptpff\iprPy-0.11.4.tar", last modified: Mon Oct  3 18:13:21 2022, max compression
+gzip compressed data, was "C:\Users\lmh1\Documents\Python-packages\iprPy\dist\.tmp-qrolqopu\iprPy-0.11.5.tar", last modified: Tue Apr 18 20:31:01 2023, max compression
```

## Comparing `iprPy-0.11.4.tar` & `iprPy-0.11.5.tar`

### file list

```diff
@@ -1,390 +1,417 @@
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/
--rw-rw-rw-   0        0        0     2776 2019-07-10 17:30:09.000000 iprPy-0.11.4/LICENSE.TXT
--rw-rw-rw-   0        0        0      181 2021-09-14 19:12:36.000000 iprPy-0.11.4/MANIFEST.in
--rw-rw-rw-   0        0        0     2480 2022-10-03 18:13:21.000000 iprPy-0.11.4/PKG-INFO
--rw-rw-rw-   0        0        0     1779 2022-07-22 14:05:14.000000 iprPy-0.11.4/README.rst
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:18.000000 iprPy-0.11.4/bin/
--rw-rw-rw-   0        0        0     3216 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/README.rst
--rw-rw-rw-   0        0        0     7371 2022-05-23 16:10:36.000000 iprPy-0.11.4/bin/check_runners.py
--rw-rw-rw-   0        0        0      148 2020-07-31 19:29:10.000000 iprPy-0.11.4/bin/iprPy
--rw-rw-rw-   0        0        0      341 2022-04-07 17:25:44.000000 iprPy-0.11.4/bin/iprPy_prepare
--rw-rw-rw-   0        0        0      348 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/iprPy_prepare_pool_1
--rw-rw-rw-   0        0        0      348 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/iprPy_prepare_pool_2
--rw-rw-rw-   0        0        0      348 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/iprPy_prepare_pool_3
--rw-rw-rw-   0        0        0      348 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/iprPy_prepare_pool_4
--rw-rw-rw-   0        0        0      348 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/iprPy_prepare_pool_5
--rw-rw-rw-   0        0        0      289 2021-01-07 21:36:18.000000 iprPy-0.11.4/bin/iprPy_slurm
--rw-rw-rw-   0        0        0      291 2021-01-07 21:36:18.000000 iprPy-0.11.4/bin/iprPy_slurm_16
--rw-rw-rw-   0        0        0      289 2021-01-07 21:36:18.000000 iprPy-0.11.4/bin/iprPy_slurm_4
--rw-rw-rw-   0        0        0      289 2021-01-07 21:36:18.000000 iprPy-0.11.4/bin/iprPy_slurm_8
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:18.000000 iprPy-0.11.4/bin/prepare/
--rw-rw-rw-   0        0        0     3423 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/prepare/master_prepare_ctcms.in
--rw-rw-rw-   0        0        0     1974 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_1.in
--rw-rw-rw-   0        0        0     1960 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_2.in
--rw-rw-rw-   0        0        0     1949 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_3.in
--rw-rw-rw-   0        0        0     2053 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_4.in
--rw-rw-rw-   0        0        0     1997 2022-06-01 13:45:46.000000 iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_5.in
--rw-rw-rw-   0        0        0     3041 2022-05-23 16:10:36.000000 iprPy-0.11.4/bin/prepare/master_prepare_desktop.in
--rw-rw-rw-   0        0        0     2996 2022-04-26 15:37:32.000000 iprPy-0.11.4/bin/prepare/master_prepare_desktop_wsl.in
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy/
--rw-rw-rw-   0        0        0     6336 2022-03-03 21:50:38.000000 iprPy-0.11.4/iprPy/Settings.py
--rw-rw-rw-   0        0        0        6 2022-10-03 15:49:49.000000 iprPy-0.11.4/iprPy/VERSION
--rw-rw-rw-   0        0        0     1168 2022-05-23 16:10:36.000000 iprPy-0.11.4/iprPy/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/analysis/
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/
--rw-rw-rw-   0        0        0    10392 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/__init__.py
--rw-rw-rw-   0        0        0     4276 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_crystal.py
--rw-rw-rw-   0        0        0    12591 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_diatom.py
--rw-rw-rw-   0        0        0     7155 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_elastic.py
--rw-rw-rw-   0        0        0     2155 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_empty.py
--rw-rw-rw-   0        0        0    12580 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_evsr.py
--rw-rw-rw-   0        0        0     8958 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_point.py
--rw-rw-rw-   0        0        0    11840 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_stacking.py
--rw-rw-rw-   0        0        0     5958 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_surface.py
--rw-rw-rw-   0        0        0      261 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/__init__.py
--rw-rw-rw-   0        0        0     4931 2022-05-23 16:10:36.000000 iprPy-0.11.4/iprPy/analysis/get_isolated_atom_energies.py
--rw-rw-rw-   0        0        0     3054 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/analysis/match_reference_prototype.py
--rw-rw-rw-   0        0        0    48139 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/analysis/process_relaxations.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/
--rw-rw-rw-   0        0        0    27898 2022-04-04 16:51:14.000000 iprPy-0.11.4/iprPy/calculation/Calculation.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/
--rw-rw-rw-   0        0        0    23436 2022-07-28 17:51:02.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/EvsRScan.py
--rw-rw-rw-   0        0        0     1725 2022-03-10 16:52:33.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/README.md
--rw-rw-rw-   0        0        0       92 2020-07-31 15:20:45.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/__init__.py
--rw-rw-rw-   0        0        0      275 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsd
--rw-rw-rw-   0        0        0     4925 2022-07-27 14:05:09.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsl
--rw-rw-rw-   0        0        0     3160 2022-07-27 14:04:58.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan_short.xsl
--rw-rw-rw-   0        0        0     5982 2022-03-04 18:07:19.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/e_vs_r_scan.py
--rw-rw-rw-   0        0        0      269 2019-11-25 20:53:45.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/run0.template
--rw-rw-rw-   0        0        0      570 2020-09-22 22:04:08.000000 iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/theory.md
--rw-rw-rw-   0        0        0     2920 2022-03-08 18:33:42.000000 iprPy-0.11.4/iprPy/calculation/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/
--rw-rw-rw-   0        0        0    94770 2020-07-29 18:48:37.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/Bain.ipynb
--rw-rw-rw-   0        0        0     7362 2020-08-19 22:39:20.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/Bain.py
--rw-rw-rw-   0        0        0     3352 2020-09-25 16:28:16.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/BainTransformationMap.py
--rw-rw-rw-   0        0        0      131 2020-07-31 15:18:16.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/__init__.py
--rw-rw-rw-   0        0        0    10690 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calc_bain_transformation_map.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/
--rw-rw-rw-   0        0        0     5486 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/CalculationBainTransformationMap.py
--rw-rw-rw-   0        0        0      980 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/README.md
--rw-rw-rw-   0        0        0      160 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/__init__.py
--rw-rw-rw-   0        0        0      287 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/record-calculation-bain-transformation-map.xsd
--rw-rw-rw-   0        0        0     2908 2016-09-16 16:31:10.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/data_model.py
--rw-rw-rw-   0        0        0      409 2020-07-29 18:48:37.000000 iprPy-0.11.4/iprPy/calculation/bain_transformation_map/min.template
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/
--rw-rw-rw-   0        0        0    29330 2022-06-01 17:14:12.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/BondAngleScan.py
--rw-rw-rw-   0        0        0      735 2021-04-02 19:28:45.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/README.md
--rw-rw-rw-   0        0        0      107 2021-04-02 19:34:59.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/__init__.py
--rw-rw-rw-   0        0        0     5097 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/bond_angle_scan.py
--rw-rw-rw-   0        0        0     2355 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/bond_scan.template
--rw-rw-rw-   0        0        0      279 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/calculation_bond_angle_scan.xsd
--rw-rw-rw-   0        0        0     3255 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/prepare_bond_angle_scan.py
--rw-rw-rw-   0        0        0      902 2021-04-02 19:56:56.000000 iprPy-0.11.4/iprPy/calculation/bond_angle_scan/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/
--rw-rw-rw-   0        0        0    26512 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/CrystalSpaceGroup.py
--rw-rw-rw-   0        0        0     1453 2022-03-10 16:52:45.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/README.md
--rw-rw-rw-   0        0        0      119 2020-07-31 15:20:32.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/__init__.py
--rw-rw-rw-   0        0        0      283 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/calculation_crystal_space_group.xsd
--rw-rw-rw-   0        0        0     5703 2022-03-10 18:43:15.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/crystal_space_group.py
--rw-rw-rw-   0        0        0      463 2020-09-22 21:59:57.000000 iprPy-0.11.4/iprPy/calculation/crystal_space_group/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/
--rw-rw-rw-   0        0        0    22181 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/DiatomScan.py
--rw-rw-rw-   0        0        0     1077 2022-02-16 18:54:28.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/README.md
--rw-rw-rw-   0        0        0       98 2020-07-31 15:18:45.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/__init__.py
--rw-rw-rw-   0        0        0      275 2021-09-14 18:07:38.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/calculation_diatom_scan.xsd
--rw-rw-rw-   0        0        0     4566 2022-07-27 13:47:53.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/calculation_diatom_scan.xsl
--rw-rw-rw-   0        0        0     2817 2022-07-27 13:49:28.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/calculation_diatom_scan_short.xsl
--rw-rw-rw-   0        0        0     4392 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/diatom_scan.py
--rw-rw-rw-   0        0        0      174 2019-11-25 20:53:45.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/run0.template
--rw-rw-rw-   0        0        0     1377 2020-09-22 22:00:40.000000 iprPy-0.11.4/iprPy/calculation/diatom_scan/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/
--rw-rw-rw-   0        0        0    41883 2022-04-04 16:41:45.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/DislocationSDVPN.py
--rw-rw-rw-   0        0        0     1828 2022-03-10 16:53:15.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/README.md
--rw-rw-rw-   0        0        0      116 2020-07-31 15:20:42.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/__init__.py
--rw-rw-rw-   0        0        0      281 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/calculation_dislocation_SDVPN.xsd
--rw-rw-rw-   0        0        0     8557 2022-03-11 20:18:23.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/dislocation_SDVPN.py
--rw-rw-rw-   0        0        0      324 2020-09-22 22:03:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/
--rw-rw-rw-   0        0        0      673 2017-12-15 01:46:29.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/README.md
--rw-rw-rw-   0        0        0     1725 2018-06-27 13:54:23.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/__init__.py
--rw-rw-rw-   0        0        0     7475 2018-04-09 16:15:16.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.py
--rw-rw-rw-   0        0        0     1066 2017-12-15 01:43:48.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.template
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/
--rw-rw-rw-   0        0        0     1060 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/README.md
--rw-rw-rw-   0        0        0      401 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/__init__.py
--rw-rw-rw-   0        0        0     4832 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/buildmodel.py
--rw-rw-rw-   0        0        0     1141 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/compare_terms.py
--rw-rw-rw-   0        0        0      298 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/record-calculation-dislocation-Peierls-Nabarro-stress.xsd
--rw-rw-rw-   0        0        0      515 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/schema.py
--rw-rw-rw-   0        0        0     3664 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/todict.py
--rw-rw-rw-   0        0        0    26459 2017-07-24 22:29:09.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/dislocation_Peierls_Nabarro_stress_template.ipynb
--rw-rw-rw-   0        0        0     9722 2018-04-11 20:14:48.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/prepare_dislocation_Peierls_Nabarro_stress.py
--rw-rw-rw-   0        0        0       24 2017-12-14 22:04:14.000000 iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/
--rw-rw-rw-   0        0        0    27771 2022-04-04 16:41:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/DislocationMonopole.py
--rw-rw-rw-   0        0        0     2534 2022-03-10 16:52:53.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/README.md
--rw-rw-rw-   0        0        0      125 2020-07-31 15:19:29.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/__init__.py
--rw-rw-rw-   0        0        0      284 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/calculation_dislocation_monopole.xsd
--rw-rw-rw-   0        0        0      439 2020-08-27 19:35:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/disl_relax.template
--rw-rw-rw-   0        0        0    18549 2022-03-08 15:33:29.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/dislocation_monopole.py
--rw-rw-rw-   0        0        0     3519 2020-09-22 22:01:26.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/
--rw-rw-rw-   0        0        0      161 2018-06-27 14:18:08.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/__init__.py
--rw-rw-rw-   0        0        0     1062 2021-02-26 18:52:18.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/calc_crss.template
--rw-rw-rw-   0        0        0    18416 2021-03-03 17:27:38.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/calc_dislocation_monopole_crss.py
--rw-rw-rw-   0        0        0     4133 2016-10-25 14:41:24.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/data_model.py
--rw-rw-rw-   0        0        0    15473 2016-10-25 14:41:24.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/prepare.py
--rw-rw-rw-   0        0        0     4089 2016-10-25 14:41:24.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/read_input.py
--rw-rw-rw-   0        0        0     3199 2021-02-26 18:52:21.000000 iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/strain_system.template
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/
--rw-rw-rw-   0        0        0    28959 2022-04-04 16:41:20.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/DislocationPeriodicArray.py
--rw-rw-rw-   0        0        0     1284 2022-03-10 16:55:13.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/README.md
--rw-rw-rw-   0        0        0      140 2020-07-31 15:19:40.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/__init__.py
--rw-rw-rw-   0        0        0      290 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/calculation_dislocation_periodic_array.xsd
--rw-rw-rw-   0        0        0      439 2020-08-27 19:35:33.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/disl_relax.template
--rw-rw-rw-   0        0        0    18993 2022-03-08 15:37:40.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/dislocation_periodic_array.py
--rw-rw-rw-   0        0        0     3573 2020-09-22 22:02:12.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/
--rw-rw-rw-   0        0        0     2548 2019-07-10 17:30:46.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/DislocationPeriodicArrayStress.py
--rw-rw-rw-   0        0        0     1603 2019-07-10 17:30:46.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/README.md
--rw-rw-rw-   0        0        0      279 2019-07-22 15:37:51.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/__init__.py
--rw-rw-rw-   0        0        0    12411 2019-07-29 16:01:17.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.py
--rw-rw-rw-   0        0        0     1337 2019-07-10 17:30:46.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.template
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/
--rw-rw-rw-   0        0        0     6824 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/CalculationDislocationPeriodicArrayStress.py
--rw-rw-rw-   0        0        0      818 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/README.md
--rw-rw-rw-   0        0        0      215 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/__init__.py
--rw-rw-rw-   0        0        0      297 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/record-calculation-dislocation-periodic-array-stress.xsd
--rw-rw-rw-   0        0        0     1944 2019-07-10 17:30:46.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/dislarray_free_stress.template
--rw-rw-rw-   0        0        0     2158 2019-07-10 17:30:46.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/dislarray_rigid_stress.template
--rw-rw-rw-   0        0        0     3573 2019-07-10 17:30:46.000000 iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:19.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/
--rw-rw-rw-   0        0        0      161 2019-07-22 15:38:08.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/
--rw-rw-rw-   0        0        0     3101 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/522c8437-eceb-480d-8f0c-77f83cdb3125.json
--rw-rw-rw-   0        0        0   795421 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/base.dat
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/
--rw-rw-rw-   0        0        0      765 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/110-edge.json
--rw-rw-rw-   0        0        0      768 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/111-screw.json
--rw-rw-rw-   0        0        0      765 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/112-edge.json
--rw-rw-rw-   0        0        0     4399 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc.json
--rw-rw-rw-   0        0        0      963 2016-09-16 16:31:10.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.in
--rw-rw-rw-   0        0        0     1211 2016-09-16 16:31:10.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.py
--rw-rw-rw-   0        0        0     1355 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.template
--rw-rw-rw-   0        0        0      822 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/create_sys.in
--rw-rw-rw-   0        0        0   795381 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl.dat
--rw-rw-rw-   0        0        0  1095015 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl.dump
--rw-rw-rw-   0        0        0      948 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.in
--rw-rw-rw-   0        0        0      733 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.template
--rw-rw-rw-   0        0        0      477 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax_notemp.template
--rw-rw-rw-   0        0        0     1913 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax_script.py
--rw-rw-rw-   0        0        0     4177 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/fcc.json
--rw-rw-rw-   0        0        0     4725 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/log.lammps
--rw-rw-rw-   0        0        0     4273 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/results.json
--rw-rw-rw-   0        0        0     3773 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/data_model.py
--rw-rw-rw-   0        0        0    11136 2016-06-21 13:43:04.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/prepare.py
--rw-rw-rw-   0        0        0     3762 2016-09-16 16:31:10.000000 iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/read_input.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/
--rw-rw-rw-   0        0        0      629 2018-06-27 14:18:20.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/__init__.py
--rw-rw-rw-   0        0        0     1365 2017-03-16 13:24:41.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.in
--rw-rw-rw-   0        0        0    29430 2017-03-29 13:15:42.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.py
--rw-rw-rw-   0        0        0     1416 2017-02-17 17:13:16.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.template
--rw-rw-rw-   0        0        0      591 2017-02-13 20:46:19.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/full_relax.template
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/
--rw-rw-rw-   0        0        0    18016 2022-05-23 16:10:36.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/ElasticConstantsStatic.py
--rw-rw-rw-   0        0        0     1884 2022-03-10 16:52:22.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/README.md
--rw-rw-rw-   0        0        0      134 2020-07-31 15:20:28.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/__init__.py
--rw-rw-rw-   0        0        0      288 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/calculation_elastic_constants_static.xsd
--rw-rw-rw-   0        0        0     3343 2021-01-29 17:33:30.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/cij.template
--rw-rw-rw-   0        0        0     8251 2022-03-07 20:09:20.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/elastic_constants_static.py
--rw-rw-rw-   0        0        0     1363 2020-09-22 22:04:58.000000 iprPy-0.11.4/iprPy/calculation/elastic_constants_static/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/energy_check/
--rw-rw-rw-   0        0        0     7517 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/EnergyCheck.py
--rw-rw-rw-   0        0        0      636 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/README.md
--rw-rw-rw-   0        0        0       99 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/__init__.py
--rw-rw-rw-   0        0        0      276 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/calculation_energy_check.xsd
--rw-rw-rw-   0        0        0     2160 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/energy_check.py
--rw-rw-rw-   0        0        0      269 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/run0.template
--rw-rw-rw-   0        0        0      230 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/calculation/energy_check/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/free_energy/
--rw-rw-rw-   0        0        0    27988 2022-09-20 21:29:45.000000 iprPy-0.11.4/iprPy/calculation/free_energy/FreeEnergy.py
--rw-rw-rw-   0        0        0      804 2022-09-20 17:22:25.000000 iprPy-0.11.4/iprPy/calculation/free_energy/README.md
--rw-rw-rw-   0        0        0       77 2022-09-20 17:05:23.000000 iprPy-0.11.4/iprPy/calculation/free_energy/__init__.py
--rw-rw-rw-   0        0        0      275 2022-09-20 17:22:26.000000 iprPy-0.11.4/iprPy/calculation/free_energy/calculation_free_energy.xsd
--rw-rw-rw-   0        0        0    16471 2022-09-20 17:22:39.000000 iprPy-0.11.4/iprPy/calculation/free_energy/free_energy.py
--rw-rw-rw-   0        0        0     1053 2022-09-20 15:32:26.000000 iprPy-0.11.4/iprPy/calculation/free_energy/free_energy.template
--rw-rw-rw-   0        0        0      609 2022-09-19 15:15:23.000000 iprPy-0.11.4/iprPy/calculation/free_energy/msd.template
--rw-rw-rw-   0        0        0      766 2022-09-20 17:22:13.000000 iprPy-0.11.4/iprPy/calculation/free_energy/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/
--rw-rw-rw-   0        0        0      638 2018-06-27 14:18:00.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/__init__.py
--rw-rw-rw-   0        0        0    11732 2017-03-13 18:10:32.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.py
--rw-rw-rw-   0        0        0     1252 2016-12-30 23:01:13.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.template
--rw-rw-rw-   0        0        0     2059 2016-12-30 22:37:08.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/grain_boundary.template
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/
--rw-rw-rw-   0        0        0     1020 2017-05-01 19:00:38.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/README.md
--rw-rw-rw-   0        0        0       97 2018-06-27 14:18:33.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/__init__.py
--rw-rw-rw-   0        0        0      525 2017-07-06 18:31:53.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/compare_terms.py
--rw-rw-rw-   0        0        0      285 2016-12-31 00:03:23.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/record-calculation-grain-boundary-search.xsd
--rw-rw-rw-   0        0        0      158 2017-05-03 19:21:57.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/schema.py
--rw-rw-rw-   0        0        0     1469 2017-05-03 19:22:32.000000 iprPy-0.11.4/iprPy/calculation/grain_boundary_search/todict.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/
--rw-rw-rw-   0        0        0    12404 2022-04-04 16:42:26.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/IsolatedAtom.py
--rw-rw-rw-   0        0        0     1059 2022-03-10 16:52:15.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/README.md
--rw-rw-rw-   0        0        0      127 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/__init__.py
--rw-rw-rw-   0        0        0      277 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/calculation_isolated_atom.xsd
--rw-rw-rw-   0        0        0     2405 2022-07-26 20:19:39.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/calculation_isolated_atom.xsl
--rw-rw-rw-   0        0        0      469 2022-07-19 16:35:37.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/calculation_isolated_atom_short.xsl
--rw-rw-rw-   0        0        0     2725 2022-03-07 20:08:50.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/isolated_atom.py
--rw-rw-rw-   0        0        0      174 2020-07-29 18:48:37.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/run0.template
--rw-rw-rw-   0        0        0      955 2020-09-22 22:05:46.000000 iprPy-0.11.4/iprPy/calculation/isolated_atom/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/phonon/
--rw-rw-rw-   0        0        0    32261 2022-07-14 14:36:41.000000 iprPy-0.11.4/iprPy/calculation/phonon/Phonon.py
--rw-rw-rw-   0        0        0      794 2022-03-10 16:52:05.000000 iprPy-0.11.4/iprPy/calculation/phonon/README.md
--rw-rw-rw-   0        0        0       86 2020-07-31 15:21:30.000000 iprPy-0.11.4/iprPy/calculation/phonon/__init__.py
--rw-rw-rw-   0        0        0    16689 2022-07-13 14:34:30.000000 iprPy-0.11.4/iprPy/calculation/phonon/calc_phonon.py
--rw-rw-rw-   0        0        0      270 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/phonon/calculation_phonon.xsd
--rw-rw-rw-   0        0        0      298 2020-12-21 15:35:11.000000 iprPy-0.11.4/iprPy/calculation/phonon/phonon.template
--rw-rw-rw-   0        0        0      780 2019-07-26 17:47:07.000000 iprPy-0.11.4/iprPy/calculation/phonon/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/
--rw-rw-rw-   0        0        0    31162 2022-04-04 16:43:33.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/PointDefectDiffusion.py
--rw-rw-rw-   0        0        0     1213 2022-03-10 16:53:46.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/README.md
--rw-rw-rw-   0        0        0      128 2020-07-31 15:21:39.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/__init__.py
--rw-rw-rw-   0        0        0      286 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/calculation_point_defect_diffusion.xsd
--rw-rw-rw-   0        0        0     1144 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/diffusion.template
--rw-rw-rw-   0        0        0     9991 2022-03-07 20:41:33.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/point_defect_diffusion.py
--rw-rw-rw-   0        0        0     1462 2019-07-26 17:49:39.000000 iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/
--rw-rw-rw-   0        0        0    25442 2022-07-13 10:35:52.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/PointDefectStatic.py
--rw-rw-rw-   0        0        0     2080 2022-03-10 16:51:46.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/README.md
--rw-rw-rw-   0        0        0      119 2020-07-31 15:22:45.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/__init__.py
--rw-rw-rw-   0        0        0      283 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/calculation_point_defect_static.xsd
--rw-rw-rw-   0        0        0      427 2021-01-07 21:36:18.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/min.template
--rw-rw-rw-   0        0        0    18254 2022-03-10 20:44:04.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/point_defect_static.py
--rw-rw-rw-   0        0        0     3954 2019-07-26 19:10:33.000000 iprPy-0.11.4/iprPy/calculation/point_defect_static/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/relax_box/
--rw-rw-rw-   0        0        0     1485 2022-03-10 16:51:20.000000 iprPy-0.11.4/iprPy/calculation/relax_box/README.md
--rw-rw-rw-   0        0        0    31685 2022-05-23 16:10:36.000000 iprPy-0.11.4/iprPy/calculation/relax_box/RelaxBox.py
--rw-rw-rw-   0        0        0       92 2020-07-31 15:22:51.000000 iprPy-0.11.4/iprPy/calculation/relax_box/__init__.py
--rw-rw-rw-   0        0        0      273 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/relax_box/calculation_relax_box.xsd
--rw-rw-rw-   0        0        0     4352 2021-10-20 21:24:11.000000 iprPy-0.11.4/iprPy/calculation/relax_box/cij_run0.template
--rw-rw-rw-   0        0        0    17154 2022-03-07 17:38:17.000000 iprPy-0.11.4/iprPy/calculation/relax_box/relax_box.py
--rw-rw-rw-   0        0        0     1570 2020-09-22 22:06:42.000000 iprPy-0.11.4/iprPy/calculation/relax_box/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/
--rw-rw-rw-   0        0        0     2295 2022-03-10 16:50:31.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/README.md
--rw-rw-rw-   0        0        0    52872 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/RelaxDynamic.py
--rw-rw-rw-   0        0        0      104 2020-07-31 15:22:56.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/__init__.py
--rw-rw-rw-   0        0        0      277 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/calculation_relax_dynamic.xsd
--rw-rw-rw-   0        0        0      577 2022-03-08 18:15:11.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/full_relax.template
--rw-rw-rw-   0        0        0      570 2022-03-08 18:32:01.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/full_relax_restart.template
--rw-rw-rw-   0        0        0    20476 2022-05-23 16:10:36.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/relax_dynamic.py
--rw-rw-rw-   0        0        0     2051 2020-09-22 22:07:08.000000 iprPy-0.11.4/iprPy/calculation/relax_dynamic/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/relax_static/
--rw-rw-rw-   0        0        0     1137 2022-03-10 16:50:26.000000 iprPy-0.11.4/iprPy/calculation/relax_static/README.md
--rw-rw-rw-   0        0        0    35692 2022-05-23 16:10:36.000000 iprPy-0.11.4/iprPy/calculation/relax_static/RelaxStatic.py
--rw-rw-rw-   0        0        0      101 2020-07-31 15:23:02.000000 iprPy-0.11.4/iprPy/calculation/relax_static/__init__.py
--rw-rw-rw-   0        0        0      276 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/relax_static/calculation_relax_static.xsd
--rw-rw-rw-   0        0        0      552 2020-07-29 18:48:37.000000 iprPy-0.11.4/iprPy/calculation/relax_static/minbox.template
--rw-rw-rw-   0        0        0    11585 2022-03-07 17:03:22.000000 iprPy-0.11.4/iprPy/calculation/relax_static/relax_static.py
--rw-rw-rw-   0        0        0      555 2020-09-22 22:07:34.000000 iprPy-0.11.4/iprPy/calculation/relax_static/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/
--rw-rw-rw-   0        0        0     1128 2022-03-10 16:54:23.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/README.md
--rw-rw-rw-   0        0        0    21113 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/StackingFaultMap2D.py
--rw-rw-rw-   0        0        0      122 2020-07-31 15:23:08.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/__init__.py
--rw-rw-rw-   0        0        0      285 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/calculation_stacking_fault_map_2D.xsd
--rw-rw-rw-   0        0        0      482 2020-08-18 13:49:57.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/sfmin.template
--rw-rw-rw-   0        0        0    15829 2022-03-07 20:57:51.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/stacking_fault_map_2D.py
--rw-rw-rw-   0        0        0     3050 2020-09-22 22:08:55.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/
--rw-rw-rw-   0        0        0     1013 2022-03-10 16:54:46.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/README.md
--rw-rw-rw-   0        0        0    19457 2022-04-04 16:45:36.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/StackingFaultStatic.py
--rw-rw-rw-   0        0        0      125 2020-07-31 15:23:15.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/__init__.py
--rw-rw-rw-   0        0        0      285 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/calculation_stacking_fault_static.xsd
--rw-rw-rw-   0        0        0      482 2020-08-18 13:49:56.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/sfmin.template
--rw-rw-rw-   0        0        0    17048 2022-03-07 20:57:52.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/stacking_fault_static.py
--rw-rw-rw-   0        0        0     2829 2020-09-22 22:09:25.000000 iprPy-0.11.4/iprPy/calculation/stacking_fault_static/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/
--rw-rw-rw-   0        0        0     1159 2022-03-10 16:54:57.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/README.md
--rw-rw-rw-   0        0        0    18174 2022-07-18 15:00:20.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/SurfaceEnergyStatic.py
--rw-rw-rw-   0        0        0      125 2020-07-31 15:23:22.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/__init__.py
--rw-rw-rw-   0        0        0      285 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/calculation_surface_energy_static.xsd
--rw-rw-rw-   0        0        0      408 2020-08-18 13:49:53.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/min.template
--rw-rw-rw-   0        0        0    12968 2022-03-10 20:44:03.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/surface_energy_static.py
--rw-rw-rw-   0        0        0     1844 2020-09-22 22:10:07.000000 iprPy-0.11.4/iprPy/calculation/surface_energy_static/theory.md
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:20.000000 iprPy-0.11.4/iprPy/calculation_subset/
--rw-rw-rw-   0        0        0    13949 2022-02-15 16:29:14.000000 iprPy-0.11.4/iprPy/calculation_subset/AtommanElasticConstants.py
--rw-rw-rw-   0        0        0     8181 2022-02-15 16:31:50.000000 iprPy-0.11.4/iprPy/calculation_subset/AtommanGammaSurface.py
--rw-rw-rw-   0        0        0    28547 2022-02-17 15:01:23.000000 iprPy-0.11.4/iprPy/calculation_subset/AtommanSystemLoad.py
--rw-rw-rw-   0        0        0    26262 2022-02-15 16:32:00.000000 iprPy-0.11.4/iprPy/calculation_subset/AtommanSystemManipulate.py
--rw-rw-rw-   0        0        0     8663 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation_subset/CalculationSubset.py
--rw-rw-rw-   0        0        0    39500 2022-02-15 16:31:55.000000 iprPy-0.11.4/iprPy/calculation_subset/Dislocation.py
--rw-rw-rw-   0        0        0    27866 2022-02-15 16:32:19.000000 iprPy-0.11.4/iprPy/calculation_subset/FreeSurface.py
--rw-rw-rw-   0        0        0    11093 2022-02-15 16:32:15.000000 iprPy-0.11.4/iprPy/calculation_subset/LammpsCommands.py
--rw-rw-rw-   0        0        0    13355 2022-02-15 16:32:10.000000 iprPy-0.11.4/iprPy/calculation_subset/LammpsMinimize.py
--rw-rw-rw-   0        0        0    17710 2022-02-15 16:32:05.000000 iprPy-0.11.4/iprPy/calculation_subset/LammpsPotential.py
--rw-rw-rw-   0        0        0    21897 2022-02-15 16:32:36.000000 iprPy-0.11.4/iprPy/calculation_subset/PointDefect.py
--rw-rw-rw-   0        0        0    32907 2022-02-15 16:32:24.000000 iprPy-0.11.4/iprPy/calculation_subset/StackingFault.py
--rw-rw-rw-   0        0        0     6004 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation_subset/Units.py
--rw-rw-rw-   0        0        0      600 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/calculation_subset/__init__.py
--rw-rw-rw-   0        0        0      468 2022-03-03 21:58:36.000000 iprPy-0.11.4/iprPy/check_modules.py
--rw-rw-rw-   0        0        0    21032 2022-03-29 19:24:37.000000 iprPy-0.11.4/iprPy/command_line.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/database/
--rw-rw-rw-   0        0        0      235 2022-05-23 16:10:37.000000 iprPy-0.11.4/iprPy/database/CDCSDatabase.py
--rw-rw-rw-   0        0        0    26668 2022-05-23 16:10:37.000000 iprPy-0.11.4/iprPy/database/IprPyDatabase.py
--rw-rw-rw-   0        0        0      238 2022-05-23 16:10:37.000000 iprPy-0.11.4/iprPy/database/LocalDatabase.py
--rw-rw-rw-   0        0        0     1642 2022-05-23 16:10:37.000000 iprPy-0.11.4/iprPy/database/MongoDatabase.py
--rw-rw-rw-   0        0        0     1892 2022-05-23 16:10:37.000000 iprPy-0.11.4/iprPy/database/__init__.py
--rw-rw-rw-   0        0        0     1061 2022-02-15 16:32:45.000000 iprPy-0.11.4/iprPy/database/load_database.py
--rw-rw-rw-   0        0        0     5800 2022-04-07 17:25:44.000000 iprPy-0.11.4/iprPy/database/master_prepare.py
--rw-rw-rw-   0        0        0    16390 2022-05-23 16:10:37.000000 iprPy-0.11.4/iprPy/database/prepare.py
--rw-rw-rw-   0        0        0     1817 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/database/reset_orphans.py
--rw-rw-rw-   0        0        0    24405 2022-02-15 16:01:52.000000 iprPy-0.11.4/iprPy/database/runner.py
--rw-rw-rw-   0        0        0     3819 2022-04-26 15:37:32.000000 iprPy-0.11.4/iprPy/fix_lammps_versions.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/input/
--rw-rw-rw-   0        0        0      391 2022-03-03 22:02:42.000000 iprPy-0.11.4/iprPy/input/__init__.py
--rw-rw-rw-   0        0        0      980 2022-03-03 22:15:35.000000 iprPy-0.11.4/iprPy/input/boolean.py
--rw-rw-rw-   0        0        0     1220 2022-03-03 22:05:53.000000 iprPy-0.11.4/iprPy/input/buildcombos.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/
--rw-rw-rw-   0        0        0     5918 2019-07-24 15:27:46.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/README.rst
--rw-rw-rw-   0        0        0      471 2022-03-03 22:19:43.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/__init__.py
--rw-rw-rw-   0        0        0     6741 2022-03-03 22:42:59.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/atomicarchive.py
--rw-rw-rw-   0        0        0     7120 2022-03-03 22:40:49.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/atomicparent.py
--rw-rw-rw-   0        0        0     7354 2022-03-03 22:42:55.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/atomicreference.py
--rw-rw-rw-   0        0        0     6477 2022-03-03 22:41:53.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/crystalprototype.py
--rw-rw-rw-   0        0        0     3097 2022-03-03 22:38:23.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/defect.py
--rw-rw-rw-   0        0        0     3450 2022-03-03 22:38:35.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/diatom.py
--rw-rw-rw-   0        0        0     3057 2022-03-03 22:38:30.000000 iprPy-0.11.4/iprPy/input/buildcombos_functions/lammpspotential.py
--rw-rw-rw-   0        0        0     4050 2022-03-03 22:15:33.000000 iprPy-0.11.4/iprPy/input/parse.py
--rw-rw-rw-   0        0        0     2015 2022-03-03 22:18:09.000000 iprPy-0.11.4/iprPy/input/termtodict.py
--rw-rw-rw-   0        0        0     1698 2022-03-03 22:19:18.000000 iprPy-0.11.4/iprPy/input/value.py
--rw-rw-rw-   0        0        0     1283 2022-03-03 21:53:28.000000 iprPy-0.11.4/iprPy/load_run_directory.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/record/
--rw-rw-rw-   0        0        0    11167 2022-07-11 18:42:03.000000 iprPy-0.11.4/iprPy/record/PotentialProperties.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/
--rw-rw-rw-   0        0        0     5535 2022-06-01 13:45:46.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/CrystalStructure.py
--rw-rw-rw-   0        0        0     1305 2022-02-15 16:01:52.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/DiatomScan.py
--rw-rw-rw-   0        0        0     5317 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/ElasticConstants.py
--rw-rw-rw-   0        0        0     1805 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/EvsRScan.py
--rw-rw-rw-   0        0        0     3847 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/FreeSurface.py
--rw-rw-rw-   0        0        0     4598 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/PointDefect.py
--rw-rw-rw-   0        0        0      888 2022-02-15 16:01:52.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/PotentialsPropertiesSubset.py
--rw-rw-rw-   0        0        0     6241 2022-07-11 18:42:14.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/StackingFault.py
--rw-rw-rw-   0        0        0      280 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/__init__.py
--rw-rw-rw-   0        0        0      320 2022-07-11 18:42:03.000000 iprPy-0.11.4/iprPy/record/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/record/xsd/
--rw-rw-rw-   0        0        0        0 2021-09-14 18:07:39.000000 iprPy-0.11.4/iprPy/record/xsd/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:21.000000 iprPy-0.11.4/iprPy/tools/
--rw-rw-rw-   0        0        0      491 2022-03-03 22:08:21.000000 iprPy-0.11.4/iprPy/tools/__init__.py
--rw-rw-rw-   0        0        0     1905 2022-03-03 21:43:00.000000 iprPy-0.11.4/iprPy/tools/dict_insert.py
--rw-rw-rw-   0        0        0     1934 2022-03-03 21:50:13.000000 iprPy-0.11.4/iprPy/tools/dynamic_import.py
--rw-rw-rw-   0        0        0      726 2022-03-03 21:50:16.000000 iprPy-0.11.4/iprPy/tools/read_calc_file.py
-drwxrwxrwx   0        0        0        0 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/
--rw-rw-rw-   0        0        0     2480 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    17618 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       58 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/entry_points.txt
--rw-rw-rw-   0        0        0        2 2019-07-10 18:55:45.000000 iprPy-0.11.4/iprPy.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0       68 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2022-10-03 18:13:18.000000 iprPy-0.11.4/iprPy.egg-info/top_level.txt
--rw-rw-rw-   0        0        0      108 2022-02-03 20:26:52.000000 iprPy-0.11.4/pyproject.toml
--rw-rw-rw-   0        0        0       42 2022-10-03 18:13:21.000000 iprPy-0.11.4/setup.cfg
--rw-rw-rw-   0        0        0     1655 2022-06-01 17:14:13.000000 iprPy-0.11.4/setup.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/
+-rw-rw-rw-   0        0        0     2776 2019-07-10 17:30:09.000000 iprPy-0.11.5/LICENSE.TXT
+-rw-rw-rw-   0        0        0      181 2021-09-14 19:12:36.000000 iprPy-0.11.5/MANIFEST.in
+-rw-rw-rw-   0        0        0     2584 2023-04-18 20:31:01.000000 iprPy-0.11.5/PKG-INFO
+-rw-rw-rw-   0        0        0     1779 2022-07-22 14:05:14.000000 iprPy-0.11.5/README.rst
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/bin/
+-rw-rw-rw-   0        0        0     3216 2022-06-01 13:45:46.000000 iprPy-0.11.5/bin/README.rst
+-rw-rw-rw-   0        0        0     7371 2022-05-23 16:10:36.000000 iprPy-0.11.5/bin/check_runners.py
+-rw-rw-rw-   0        0        0      148 2020-07-31 19:29:10.000000 iprPy-0.11.5/bin/iprPy
+-rw-rw-rw-   0        0        0      341 2022-04-07 17:25:44.000000 iprPy-0.11.5/bin/iprPy_prepare
+-rw-rw-rw-   0        0        0      289 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/iprPy_prepare_pool_1
+-rw-rw-rw-   0        0        0      289 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/iprPy_prepare_pool_2
+-rw-rw-rw-   0        0        0      289 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/iprPy_prepare_pool_3
+-rw-rw-rw-   0        0        0      289 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/iprPy_prepare_pool_4
+-rw-rw-rw-   0        0        0      289 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/iprPy_prepare_pool_5
+-rw-rw-rw-   0        0        0      289 2021-01-07 21:36:18.000000 iprPy-0.11.5/bin/iprPy_slurm
+-rw-rw-rw-   0        0        0      291 2021-01-07 21:36:18.000000 iprPy-0.11.5/bin/iprPy_slurm_16
+-rw-rw-rw-   0        0        0      289 2021-01-07 21:36:18.000000 iprPy-0.11.5/bin/iprPy_slurm_4
+-rw-rw-rw-   0        0        0      289 2021-01-07 21:36:18.000000 iprPy-0.11.5/bin/iprPy_slurm_8
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/bin/prepare/
+-rw-rw-rw-   0        0        0     3155 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/prepare/master_prepare_ctcms.in
+-rw-rw-rw-   0        0        0     1965 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_1.in
+-rw-rw-rw-   0        0        0     1950 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_2.in
+-rw-rw-rw-   0        0        0     1939 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_3.in
+-rw-rw-rw-   0        0        0     2044 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_4.in
+-rw-rw-rw-   0        0        0     1988 2022-10-04 13:35:04.000000 iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_5.in
+-rw-rw-rw-   0        0        0     3041 2022-05-23 16:10:36.000000 iprPy-0.11.5/bin/prepare/master_prepare_desktop.in
+-rw-rw-rw-   0        0        0     2996 2022-04-26 15:37:32.000000 iprPy-0.11.5/bin/prepare/master_prepare_desktop_wsl.in
+-rw-rw-rw-   0        0        0     7160 2022-10-17 16:30:15.000000 iprPy-0.11.5/bin/prepare_relax_dynamic_at_temp.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/
+-rw-rw-rw-   0        0        0     6271 2023-04-07 15:29:07.000000 iprPy-0.11.5/iprPy/Settings.py
+-rw-rw-rw-   0        0        0        6 2023-04-18 20:29:48.000000 iprPy-0.11.5/iprPy/VERSION
+-rw-rw-rw-   0        0        0     1169 2023-04-07 15:19:20.000000 iprPy-0.11.5/iprPy/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/analysis/
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/
+-rw-rw-rw-   0        0        0    10425 2022-11-18 21:22:35.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/__init__.py
+-rw-rw-rw-   0        0        0     4276 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_crystal.py
+-rw-rw-rw-   0        0        0    12591 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_diatom.py
+-rw-rw-rw-   0        0        0     7155 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_elastic.py
+-rw-rw-rw-   0        0        0     2155 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_empty.py
+-rw-rw-rw-   0        0        0    12580 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_evsr.py
+-rw-rw-rw-   0        0        0    26217 2023-04-11 18:57:57.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_phonon.py
+-rw-rw-rw-   0        0        0     8958 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_point.py
+-rw-rw-rw-   0        0        0    11840 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_stacking.py
+-rw-rw-rw-   0        0        0     5958 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_surface.py
+-rw-rw-rw-   0        0        0      283 2022-11-18 20:44:32.000000 iprPy-0.11.5/iprPy/analysis/__init__.py
+-rw-rw-rw-   0        0        0     4931 2022-05-23 16:10:36.000000 iprPy-0.11.5/iprPy/analysis/get_isolated_atom_energies.py
+-rw-rw-rw-   0        0        0     3054 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/analysis/match_reference_prototype.py
+-rw-rw-rw-   0        0        0    48139 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/analysis/process_relaxations.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/analysis/thermo/
+-rw-rw-rw-   0        0        0     5112 2022-11-18 20:42:40.000000 iprPy-0.11.5/iprPy/analysis/thermo/AnalyzeFE.py
+-rw-rw-rw-   0        0        0     4590 2023-04-07 14:34:12.000000 iprPy-0.11.5/iprPy/analysis/thermo/AnalyzeMD.py
+-rw-rw-rw-   0        0        0     3912 2022-11-18 20:43:35.000000 iprPy-0.11.5/iprPy/analysis/thermo/AnalyzeQHA.py
+-rw-rw-rw-   0        0        0      102 2022-11-18 20:44:06.000000 iprPy-0.11.5/iprPy/analysis/thermo/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/
+-rw-rw-rw-   0        0        0    29258 2023-04-11 18:36:26.000000 iprPy-0.11.5/iprPy/calculation/Calculation.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/
+-rw-rw-rw-   0        0        0    21892 2023-04-11 18:48:44.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/EvsRScan.py
+-rw-rw-rw-   0        0        0     1725 2022-03-10 16:52:33.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/README.md
+-rw-rw-rw-   0        0        0       92 2020-07-31 15:20:45.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/__init__.py
+-rw-rw-rw-   0        0        0      275 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsd
+-rw-rw-rw-   0        0        0     4925 2022-07-27 14:05:09.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsl
+-rw-rw-rw-   0        0        0     3160 2022-07-27 14:04:58.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan_short.xsl
+-rw-rw-rw-   0        0        0     5982 2022-03-04 18:07:19.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/e_vs_r_scan.py
+-rw-rw-rw-   0        0        0      269 2019-11-25 20:53:45.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/run0.template
+-rw-rw-rw-   0        0        0      570 2020-09-22 22:04:08.000000 iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/theory.md
+-rw-rw-rw-   0        0        0     3524 2022-10-04 19:31:01.000000 iprPy-0.11.5/iprPy/calculation/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/
+-rw-rw-rw-   0        0        0    94770 2020-07-29 18:48:37.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/Bain.ipynb
+-rw-rw-rw-   0        0        0     7362 2020-08-19 22:39:20.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/Bain.py
+-rw-rw-rw-   0        0        0     3352 2020-09-25 16:28:16.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/BainTransformationMap.py
+-rw-rw-rw-   0        0        0      131 2020-07-31 15:18:16.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/__init__.py
+-rw-rw-rw-   0        0        0    10690 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calc_bain_transformation_map.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/
+-rw-rw-rw-   0        0        0     5486 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/CalculationBainTransformationMap.py
+-rw-rw-rw-   0        0        0      980 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/README.md
+-rw-rw-rw-   0        0        0      160 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/__init__.py
+-rw-rw-rw-   0        0        0      287 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/record-calculation-bain-transformation-map.xsd
+-rw-rw-rw-   0        0        0     2908 2016-09-16 16:31:10.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/data_model.py
+-rw-rw-rw-   0        0        0      409 2020-07-29 18:48:37.000000 iprPy-0.11.5/iprPy/calculation/bain_transformation_map/min.template
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/
+-rw-rw-rw-   0        0        0    26044 2023-04-11 18:41:38.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/BondAngleScan.py
+-rw-rw-rw-   0        0        0      735 2021-04-02 19:28:45.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/README.md
+-rw-rw-rw-   0        0        0      107 2021-04-02 19:34:59.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/__init__.py
+-rw-rw-rw-   0        0        0     5097 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/bond_angle_scan.py
+-rw-rw-rw-   0        0        0     2355 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/bond_scan.template
+-rw-rw-rw-   0        0        0      279 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/calculation_bond_angle_scan.xsd
+-rw-rw-rw-   0        0        0     3255 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/prepare_bond_angle_scan.py
+-rw-rw-rw-   0        0        0      902 2021-04-02 19:56:56.000000 iprPy-0.11.5/iprPy/calculation/bond_angle_scan/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/
+-rw-rw-rw-   0        0        0    23286 2023-04-11 18:41:45.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/CrystalSpaceGroup.py
+-rw-rw-rw-   0        0        0     1453 2022-03-10 16:52:45.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/README.md
+-rw-rw-rw-   0        0        0      119 2020-07-31 15:20:32.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/__init__.py
+-rw-rw-rw-   0        0        0      283 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/calculation_crystal_space_group.xsd
+-rw-rw-rw-   0        0        0     5703 2022-03-10 18:43:15.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/crystal_space_group.py
+-rw-rw-rw-   0        0        0      463 2020-09-22 21:59:57.000000 iprPy-0.11.5/iprPy/calculation/crystal_space_group/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/
+-rw-rw-rw-   0        0        0    19871 2023-04-11 18:41:49.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/DiatomScan.py
+-rw-rw-rw-   0        0        0     1077 2022-02-16 18:54:28.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/README.md
+-rw-rw-rw-   0        0        0       98 2020-07-31 15:18:45.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/__init__.py
+-rw-rw-rw-   0        0        0      275 2021-09-14 18:07:38.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/calculation_diatom_scan.xsd
+-rw-rw-rw-   0        0        0     4566 2022-07-27 13:47:53.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/calculation_diatom_scan.xsl
+-rw-rw-rw-   0        0        0     2817 2022-07-27 13:49:28.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/calculation_diatom_scan_short.xsl
+-rw-rw-rw-   0        0        0     4392 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/diatom_scan.py
+-rw-rw-rw-   0        0        0      174 2019-11-25 20:53:45.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/run0.template
+-rw-rw-rw-   0        0        0     1377 2020-09-22 22:00:40.000000 iprPy-0.11.5/iprPy/calculation/diatom_scan/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/
+-rw-rw-rw-   0        0        0    41247 2023-04-11 18:48:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/DislocationSDVPN.py
+-rw-rw-rw-   0        0        0     1828 2022-03-10 16:53:15.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/README.md
+-rw-rw-rw-   0        0        0      116 2020-07-31 15:20:42.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/__init__.py
+-rw-rw-rw-   0        0        0      281 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/calculation_dislocation_SDVPN.xsd
+-rw-rw-rw-   0        0        0     8557 2022-03-11 20:18:23.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/dislocation_SDVPN.py
+-rw-rw-rw-   0        0        0      324 2020-09-22 22:03:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/
+-rw-rw-rw-   0        0        0      673 2017-12-15 01:46:29.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/README.md
+-rw-rw-rw-   0        0        0     1725 2018-06-27 13:54:23.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/__init__.py
+-rw-rw-rw-   0        0        0     7475 2018-04-09 16:15:16.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.py
+-rw-rw-rw-   0        0        0     1066 2017-12-15 01:43:48.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.template
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/
+-rw-rw-rw-   0        0        0     1060 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/README.md
+-rw-rw-rw-   0        0        0      401 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/__init__.py
+-rw-rw-rw-   0        0        0     4832 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/buildmodel.py
+-rw-rw-rw-   0        0        0     1141 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/compare_terms.py
+-rw-rw-rw-   0        0        0      298 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/record-calculation-dislocation-Peierls-Nabarro-stress.xsd
+-rw-rw-rw-   0        0        0      515 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/schema.py
+-rw-rw-rw-   0        0        0     3664 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/todict.py
+-rw-rw-rw-   0        0        0    26459 2017-07-24 22:29:09.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/dislocation_Peierls_Nabarro_stress_template.ipynb
+-rw-rw-rw-   0        0        0     9722 2018-04-11 20:14:48.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/prepare_dislocation_Peierls_Nabarro_stress.py
+-rw-rw-rw-   0        0        0       24 2017-12-14 22:04:14.000000 iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/
+-rw-rw-rw-   0        0        0    27276 2023-04-11 18:41:52.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/DislocationMonopole.py
+-rw-rw-rw-   0        0        0     2534 2022-03-10 16:52:53.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/README.md
+-rw-rw-rw-   0        0        0      125 2020-07-31 15:19:29.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/__init__.py
+-rw-rw-rw-   0        0        0      284 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/calculation_dislocation_monopole.xsd
+-rw-rw-rw-   0        0        0      439 2020-08-27 19:35:19.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/disl_relax.template
+-rw-rw-rw-   0        0        0    18549 2022-03-08 15:33:29.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/dislocation_monopole.py
+-rw-rw-rw-   0        0        0     3519 2020-09-22 22:01:26.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/
+-rw-rw-rw-   0        0        0      161 2018-06-27 14:18:08.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/__init__.py
+-rw-rw-rw-   0        0        0     1062 2021-02-26 18:52:18.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/calc_crss.template
+-rw-rw-rw-   0        0        0    18416 2021-03-03 17:27:38.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/calc_dislocation_monopole_crss.py
+-rw-rw-rw-   0        0        0     4133 2016-10-25 14:41:24.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/data_model.py
+-rw-rw-rw-   0        0        0    15473 2016-10-25 14:41:24.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/prepare.py
+-rw-rw-rw-   0        0        0     4089 2016-10-25 14:41:24.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/read_input.py
+-rw-rw-rw-   0        0        0     3199 2021-02-26 18:52:21.000000 iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/strain_system.template
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/
+-rw-rw-rw-   0        0        0    28345 2023-04-11 18:41:59.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/DislocationPeriodicArray.py
+-rw-rw-rw-   0        0        0     1284 2022-03-10 16:55:13.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/README.md
+-rw-rw-rw-   0        0        0      140 2020-07-31 15:19:40.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/__init__.py
+-rw-rw-rw-   0        0        0      290 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/calculation_dislocation_periodic_array.xsd
+-rw-rw-rw-   0        0        0      439 2020-08-27 19:35:33.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/disl_relax.template
+-rw-rw-rw-   0        0        0    18993 2022-03-08 15:37:40.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/dislocation_periodic_array.py
+-rw-rw-rw-   0        0        0     3573 2020-09-22 22:02:12.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/
+-rw-rw-rw-   0        0        0     2548 2019-07-10 17:30:46.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/DislocationPeriodicArrayStress.py
+-rw-rw-rw-   0        0        0     1603 2019-07-10 17:30:46.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/README.md
+-rw-rw-rw-   0        0        0      279 2019-07-22 15:37:51.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/__init__.py
+-rw-rw-rw-   0        0        0    12411 2019-07-29 16:01:17.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.py
+-rw-rw-rw-   0        0        0     1337 2019-07-10 17:30:46.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.template
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/
+-rw-rw-rw-   0        0        0     6824 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/CalculationDislocationPeriodicArrayStress.py
+-rw-rw-rw-   0        0        0      818 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/README.md
+-rw-rw-rw-   0        0        0      215 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/__init__.py
+-rw-rw-rw-   0        0        0      297 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/record-calculation-dislocation-periodic-array-stress.xsd
+-rw-rw-rw-   0        0        0     1944 2019-07-10 17:30:46.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/dislarray_free_stress.template
+-rw-rw-rw-   0        0        0     2158 2019-07-10 17:30:46.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/dislarray_rigid_stress.template
+-rw-rw-rw-   0        0        0     3573 2019-07-10 17:30:46.000000 iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/
+-rw-rw-rw-   0        0        0      161 2019-07-22 15:38:08.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/
+-rw-rw-rw-   0        0        0     3101 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/522c8437-eceb-480d-8f0c-77f83cdb3125.json
+-rw-rw-rw-   0        0        0   795421 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/base.dat
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/
+-rw-rw-rw-   0        0        0      765 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/110-edge.json
+-rw-rw-rw-   0        0        0      768 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/111-screw.json
+-rw-rw-rw-   0        0        0      765 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/112-edge.json
+-rw-rw-rw-   0        0        0     4399 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc.json
+-rw-rw-rw-   0        0        0      963 2016-09-16 16:31:10.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.in
+-rw-rw-rw-   0        0        0     1211 2016-09-16 16:31:10.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.py
+-rw-rw-rw-   0        0        0     1355 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.template
+-rw-rw-rw-   0        0        0      822 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/create_sys.in
+-rw-rw-rw-   0        0        0   795381 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl.dat
+-rw-rw-rw-   0        0        0  1095015 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl.dump
+-rw-rw-rw-   0        0        0      948 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.in
+-rw-rw-rw-   0        0        0      733 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.template
+-rw-rw-rw-   0        0        0      477 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax_notemp.template
+-rw-rw-rw-   0        0        0     1913 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax_script.py
+-rw-rw-rw-   0        0        0     4177 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/fcc.json
+-rw-rw-rw-   0        0        0     4725 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/log.lammps
+-rw-rw-rw-   0        0        0     4273 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/results.json
+-rw-rw-rw-   0        0        0     3773 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/data_model.py
+-rw-rw-rw-   0        0        0    11136 2016-06-21 13:43:04.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/prepare.py
+-rw-rw-rw-   0        0        0     3762 2016-09-16 16:31:10.000000 iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/read_input.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/
+-rw-rw-rw-   0        0        0      629 2018-06-27 14:18:20.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/__init__.py
+-rw-rw-rw-   0        0        0     1365 2017-03-16 13:24:41.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.in
+-rw-rw-rw-   0        0        0    29440 2022-10-04 13:35:04.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.py
+-rw-rw-rw-   0        0        0     1416 2017-02-17 17:13:16.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.template
+-rw-rw-rw-   0        0        0      591 2017-02-13 20:46:19.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/full_relax.template
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/
+-rw-rw-rw-   0        0        0    17145 2023-04-11 18:48:47.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/ElasticConstantsStatic.py
+-rw-rw-rw-   0        0        0     1884 2022-03-10 16:52:22.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/README.md
+-rw-rw-rw-   0        0        0      134 2020-07-31 15:20:28.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/__init__.py
+-rw-rw-rw-   0        0        0      288 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/calculation_elastic_constants_static.xsd
+-rw-rw-rw-   0        0        0     3343 2021-01-29 17:33:30.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/cij.template
+-rw-rw-rw-   0        0        0     8251 2022-03-07 20:09:20.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/elastic_constants_static.py
+-rw-rw-rw-   0        0        0     1363 2020-09-22 22:04:58.000000 iprPy-0.11.5/iprPy/calculation/elastic_constants_static/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/energy_check/
+-rw-rw-rw-   0        0        0     9182 2023-04-11 18:49:09.000000 iprPy-0.11.5/iprPy/calculation/energy_check/EnergyCheck.py
+-rw-rw-rw-   0        0        0      636 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/energy_check/README.md
+-rw-rw-rw-   0        0        0       99 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/energy_check/__init__.py
+-rw-rw-rw-   0        0        0      276 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/energy_check/calculation_energy_check.xsd
+-rw-rw-rw-   0        0        0     2160 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/energy_check/energy_check.py
+-rw-rw-rw-   0        0        0      269 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/energy_check/run0.template
+-rw-rw-rw-   0        0        0      230 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/calculation/energy_check/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/free_energy/
+-rw-rw-rw-   0        0        0    27755 2023-04-11 18:49:23.000000 iprPy-0.11.5/iprPy/calculation/free_energy/FreeEnergy.py
+-rw-rw-rw-   0        0        0      804 2022-09-20 17:22:25.000000 iprPy-0.11.5/iprPy/calculation/free_energy/README.md
+-rw-rw-rw-   0        0        0       77 2022-09-20 17:05:23.000000 iprPy-0.11.5/iprPy/calculation/free_energy/__init__.py
+-rw-rw-rw-   0        0        0      275 2022-09-20 17:22:26.000000 iprPy-0.11.5/iprPy/calculation/free_energy/calculation_free_energy.xsd
+-rw-rw-rw-   0        0        0    16471 2022-09-20 17:22:39.000000 iprPy-0.11.5/iprPy/calculation/free_energy/free_energy.py
+-rw-rw-rw-   0        0        0     1053 2022-09-20 15:32:26.000000 iprPy-0.11.5/iprPy/calculation/free_energy/free_energy.template
+-rw-rw-rw-   0        0        0      609 2022-09-19 15:15:23.000000 iprPy-0.11.5/iprPy/calculation/free_energy/msd.template
+-rw-rw-rw-   0        0        0      766 2022-09-20 17:22:13.000000 iprPy-0.11.5/iprPy/calculation/free_energy/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/
+-rw-rw-rw-   0        0        0    25588 2023-04-11 18:49:32.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/FreeEnergyLiquid.py
+-rw-rw-rw-   0        0        0      962 2022-10-18 17:47:07.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/README.md
+-rw-rw-rw-   0        0        0    76625 2022-10-26 16:32:59.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/UhlenbeckFordModel.py
+-rw-rw-rw-   0        0        0       95 2022-10-18 17:43:55.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/__init__.py
+-rw-rw-rw-   0        0        0      282 2022-10-18 17:42:30.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/calculation_free_energy_liquid.xsd
+-rw-rw-rw-   0        0        0    11975 2022-10-19 18:31:36.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/free_energy_liquid.py
+-rw-rw-rw-   0        0        0     1186 2022-10-19 16:40:06.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/free_energy_liquid.template
+-rw-rw-rw-   0        0        0      766 2022-09-20 17:22:13.000000 iprPy-0.11.5/iprPy/calculation/free_energy_liquid/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/
+-rw-rw-rw-   0        0        0      638 2018-06-27 14:18:00.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/__init__.py
+-rw-rw-rw-   0        0        0    11732 2017-03-13 18:10:32.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.py
+-rw-rw-rw-   0        0        0     1252 2016-12-30 23:01:13.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.template
+-rw-rw-rw-   0        0        0     2059 2016-12-30 22:37:08.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/grain_boundary.template
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/
+-rw-rw-rw-   0        0        0     1020 2017-05-01 19:00:38.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/README.md
+-rw-rw-rw-   0        0        0       97 2018-06-27 14:18:33.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/__init__.py
+-rw-rw-rw-   0        0        0      525 2017-07-06 18:31:53.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/compare_terms.py
+-rw-rw-rw-   0        0        0      285 2016-12-31 00:03:23.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/record-calculation-grain-boundary-search.xsd
+-rw-rw-rw-   0        0        0      158 2017-05-03 19:21:57.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/schema.py
+-rw-rw-rw-   0        0        0     1469 2017-05-03 19:22:32.000000 iprPy-0.11.5/iprPy/calculation/grain_boundary_search/todict.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/
+-rw-rw-rw-   0        0        0    11570 2023-04-11 18:49:40.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/IsolatedAtom.py
+-rw-rw-rw-   0        0        0     1059 2022-03-10 16:52:15.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/README.md
+-rw-rw-rw-   0        0        0      127 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/__init__.py
+-rw-rw-rw-   0        0        0      277 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/calculation_isolated_atom.xsd
+-rw-rw-rw-   0        0        0     2405 2022-07-26 20:19:39.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/calculation_isolated_atom.xsl
+-rw-rw-rw-   0        0        0      469 2022-07-19 16:35:37.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/calculation_isolated_atom_short.xsl
+-rw-rw-rw-   0        0        0     2725 2022-03-07 20:08:50.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/isolated_atom.py
+-rw-rw-rw-   0        0        0      174 2020-07-29 18:48:37.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/run0.template
+-rw-rw-rw-   0        0        0      955 2020-09-22 22:05:46.000000 iprPy-0.11.5/iprPy/calculation/isolated_atom/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/phonon/
+-rw-rw-rw-   0        0        0    30125 2023-04-11 18:57:57.000000 iprPy-0.11.5/iprPy/calculation/phonon/Phonon.py
+-rw-rw-rw-   0        0        0      794 2022-03-10 16:52:05.000000 iprPy-0.11.5/iprPy/calculation/phonon/README.md
+-rw-rw-rw-   0        0        0       86 2020-07-31 15:21:30.000000 iprPy-0.11.5/iprPy/calculation/phonon/__init__.py
+-rw-rw-rw-   0        0        0    16969 2023-04-18 20:04:30.000000 iprPy-0.11.5/iprPy/calculation/phonon/calc_phonon.py
+-rw-rw-rw-   0        0        0      270 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/phonon/calculation_phonon.xsd
+-rw-rw-rw-   0        0        0      298 2020-12-21 15:35:11.000000 iprPy-0.11.5/iprPy/calculation/phonon/phonon.template
+-rw-rw-rw-   0        0        0      780 2019-07-26 17:47:07.000000 iprPy-0.11.5/iprPy/calculation/phonon/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/
+-rw-rw-rw-   0        0        0    30411 2023-04-11 18:50:11.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/PointDefectDiffusion.py
+-rw-rw-rw-   0        0        0     1213 2022-03-10 16:53:46.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/README.md
+-rw-rw-rw-   0        0        0      128 2020-07-31 15:21:39.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/__init__.py
+-rw-rw-rw-   0        0        0      286 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/calculation_point_defect_diffusion.xsd
+-rw-rw-rw-   0        0        0     1144 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/diffusion.template
+-rw-rw-rw-   0        0        0     9991 2022-03-07 20:41:33.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/point_defect_diffusion.py
+-rw-rw-rw-   0        0        0     1462 2019-07-26 17:49:39.000000 iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/
+-rw-rw-rw-   0        0        0    24890 2023-04-11 18:50:23.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/PointDefectStatic.py
+-rw-rw-rw-   0        0        0     2080 2022-03-10 16:51:46.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/README.md
+-rw-rw-rw-   0        0        0      119 2020-07-31 15:22:45.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/__init__.py
+-rw-rw-rw-   0        0        0      283 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/calculation_point_defect_static.xsd
+-rw-rw-rw-   0        0        0      427 2021-01-07 21:36:18.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/min.template
+-rw-rw-rw-   0        0        0    18254 2022-03-10 20:44:04.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/point_defect_static.py
+-rw-rw-rw-   0        0        0     3954 2019-07-26 19:10:33.000000 iprPy-0.11.5/iprPy/calculation/point_defect_static/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/relax_box/
+-rw-rw-rw-   0        0        0     1485 2022-03-10 16:51:20.000000 iprPy-0.11.5/iprPy/calculation/relax_box/README.md
+-rw-rw-rw-   0        0        0    30864 2023-04-11 18:50:36.000000 iprPy-0.11.5/iprPy/calculation/relax_box/RelaxBox.py
+-rw-rw-rw-   0        0        0       92 2020-07-31 15:22:51.000000 iprPy-0.11.5/iprPy/calculation/relax_box/__init__.py
+-rw-rw-rw-   0        0        0      273 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/relax_box/calculation_relax_box.xsd
+-rw-rw-rw-   0        0        0     4352 2021-10-20 21:24:11.000000 iprPy-0.11.5/iprPy/calculation/relax_box/cij_run0.template
+-rw-rw-rw-   0        0        0    17154 2022-03-07 17:38:17.000000 iprPy-0.11.5/iprPy/calculation/relax_box/relax_box.py
+-rw-rw-rw-   0        0        0     1570 2020-09-22 22:06:42.000000 iprPy-0.11.5/iprPy/calculation/relax_box/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/
+-rw-rw-rw-   0        0        0     2295 2022-03-10 16:50:31.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/README.md
+-rw-rw-rw-   0        0        0    53007 2023-04-11 18:50:53.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/RelaxDynamic.py
+-rw-rw-rw-   0        0        0      104 2020-07-31 15:22:56.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/__init__.py
+-rw-rw-rw-   0        0        0      277 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/calculation_relax_dynamic.xsd
+-rw-rw-rw-   0        0        0      577 2022-03-08 18:15:11.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/full_relax.template
+-rw-rw-rw-   0        0        0      570 2022-03-08 18:32:01.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/full_relax_restart.template
+-rw-rw-rw-   0        0        0    20476 2022-05-23 16:10:36.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/relax_dynamic.py
+-rw-rw-rw-   0        0        0     2051 2020-09-22 22:07:08.000000 iprPy-0.11.5/iprPy/calculation/relax_dynamic/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/
+-rw-rw-rw-   0        0        0     1423 2022-10-14 17:45:58.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/README.md
+-rw-rw-rw-   0        0        0    45155 2023-04-18 20:04:30.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/RelaxLiquid.py
+-rw-rw-rw-   0        0        0      101 2022-10-11 12:17:29.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/__init__.py
+-rw-rw-rw-   0        0        0      276 2022-10-11 19:15:07.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/calculation_relax_liquid.xsd
+-rw-rw-rw-   0        0        0     3099 2022-11-02 19:22:40.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/liquid_ave_pe.template
+-rw-rw-rw-   0        0        0     3044 2022-11-02 19:22:47.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/liquid_ave_te.template
+-rw-rw-rw-   0        0        0    14797 2022-11-02 17:44:12.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/relax_liquid.py
+-rw-rw-rw-   0        0        0     5838 2022-10-15 13:24:08.000000 iprPy-0.11.5/iprPy/calculation/relax_liquid/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/relax_static/
+-rw-rw-rw-   0        0        0     1137 2022-03-10 16:50:26.000000 iprPy-0.11.5/iprPy/calculation/relax_static/README.md
+-rw-rw-rw-   0        0        0    34926 2023-04-11 18:51:08.000000 iprPy-0.11.5/iprPy/calculation/relax_static/RelaxStatic.py
+-rw-rw-rw-   0        0        0      101 2020-07-31 15:23:02.000000 iprPy-0.11.5/iprPy/calculation/relax_static/__init__.py
+-rw-rw-rw-   0        0        0      276 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/relax_static/calculation_relax_static.xsd
+-rw-rw-rw-   0        0        0      552 2020-07-29 18:48:37.000000 iprPy-0.11.5/iprPy/calculation/relax_static/minbox.template
+-rw-rw-rw-   0        0        0    11585 2022-03-07 17:03:22.000000 iprPy-0.11.5/iprPy/calculation/relax_static/relax_static.py
+-rw-rw-rw-   0        0        0      555 2020-09-22 22:07:34.000000 iprPy-0.11.5/iprPy/calculation/relax_static/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/
+-rw-rw-rw-   0        0        0     1128 2022-03-10 16:54:23.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/README.md
+-rw-rw-rw-   0        0        0    21441 2023-04-11 18:51:20.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/StackingFaultMap2D.py
+-rw-rw-rw-   0        0        0      122 2020-07-31 15:23:08.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/__init__.py
+-rw-rw-rw-   0        0        0      285 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/calculation_stacking_fault_map_2D.xsd
+-rw-rw-rw-   0        0        0      482 2020-08-18 13:49:57.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/sfmin.template
+-rw-rw-rw-   0        0        0    15829 2022-03-07 20:57:51.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/stacking_fault_map_2D.py
+-rw-rw-rw-   0        0        0     3050 2020-09-22 22:08:55.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/
+-rw-rw-rw-   0        0        0     1013 2022-03-10 16:54:46.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/README.md
+-rw-rw-rw-   0        0        0    18699 2023-04-11 18:51:33.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/StackingFaultStatic.py
+-rw-rw-rw-   0        0        0      125 2020-07-31 15:23:15.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/__init__.py
+-rw-rw-rw-   0        0        0      285 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/calculation_stacking_fault_static.xsd
+-rw-rw-rw-   0        0        0      482 2020-08-18 13:49:56.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/sfmin.template
+-rw-rw-rw-   0        0        0    17048 2022-03-07 20:57:52.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/stacking_fault_static.py
+-rw-rw-rw-   0        0        0     2829 2020-09-22 22:09:25.000000 iprPy-0.11.5/iprPy/calculation/stacking_fault_static/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/
+-rw-rw-rw-   0        0        0     1159 2022-03-10 16:54:57.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/README.md
+-rw-rw-rw-   0        0        0    17361 2023-04-11 18:51:51.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/SurfaceEnergyStatic.py
+-rw-rw-rw-   0        0        0      125 2020-07-31 15:23:22.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/__init__.py
+-rw-rw-rw-   0        0        0      285 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/calculation_surface_energy_static.xsd
+-rw-rw-rw-   0        0        0      408 2020-08-18 13:49:53.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/min.template
+-rw-rw-rw-   0        0        0    12968 2022-03-10 20:44:03.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/surface_energy_static.py
+-rw-rw-rw-   0        0        0     1844 2020-09-22 22:10:07.000000 iprPy-0.11.5/iprPy/calculation/surface_energy_static/theory.md
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/calculation_subset/
+-rw-rw-rw-   0        0        0    14400 2023-04-10 17:16:00.000000 iprPy-0.11.5/iprPy/calculation_subset/AtommanElasticConstants.py
+-rw-rw-rw-   0        0        0     8647 2023-04-10 17:16:10.000000 iprPy-0.11.5/iprPy/calculation_subset/AtommanGammaSurface.py
+-rw-rw-rw-   0        0        0    26242 2023-04-10 17:16:23.000000 iprPy-0.11.5/iprPy/calculation_subset/AtommanSystemLoad.py
+-rw-rw-rw-   0        0        0    21641 2023-04-10 17:16:40.000000 iprPy-0.11.5/iprPy/calculation_subset/AtommanSystemManipulate.py
+-rw-rw-rw-   0        0        0     8322 2023-04-08 17:04:04.000000 iprPy-0.11.5/iprPy/calculation_subset/CalculationSubset.py
+-rw-rw-rw-   0        0        0    35750 2023-04-10 17:17:51.000000 iprPy-0.11.5/iprPy/calculation_subset/Dislocation.py
+-rw-rw-rw-   0        0        0    23748 2023-04-10 17:17:32.000000 iprPy-0.11.5/iprPy/calculation_subset/FreeSurface.py
+-rw-rw-rw-   0        0        0     9644 2023-04-10 17:16:46.000000 iprPy-0.11.5/iprPy/calculation_subset/LammpsCommands.py
+-rw-rw-rw-   0        0        0    14048 2023-04-10 17:16:53.000000 iprPy-0.11.5/iprPy/calculation_subset/LammpsMinimize.py
+-rw-rw-rw-   0        0        0    15229 2023-04-10 17:17:13.000000 iprPy-0.11.5/iprPy/calculation_subset/LammpsPotential.py
+-rw-rw-rw-   0        0        0    21964 2023-04-10 17:19:16.000000 iprPy-0.11.5/iprPy/calculation_subset/PointDefect.py
+-rw-rw-rw-   0        0        0    28989 2023-04-10 17:18:02.000000 iprPy-0.11.5/iprPy/calculation_subset/StackingFault.py
+-rw-rw-rw-   0        0        0     7119 2023-04-10 17:02:30.000000 iprPy-0.11.5/iprPy/calculation_subset/Units.py
+-rw-rw-rw-   0        0        0      617 2023-04-07 16:02:15.000000 iprPy-0.11.5/iprPy/calculation_subset/__init__.py
+-rw-rw-rw-   0        0        0      458 2023-04-07 15:12:34.000000 iprPy-0.11.5/iprPy/check_modules.py
+-rw-rw-rw-   0        0        0    21218 2023-04-07 15:17:36.000000 iprPy-0.11.5/iprPy/command_line.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/database/
+-rw-rw-rw-   0        0        0      235 2022-05-23 16:10:37.000000 iprPy-0.11.5/iprPy/database/CDCSDatabase.py
+-rw-rw-rw-   0        0        0    26668 2022-05-23 16:10:37.000000 iprPy-0.11.5/iprPy/database/IprPyDatabase.py
+-rw-rw-rw-   0        0        0      238 2022-05-23 16:10:37.000000 iprPy-0.11.5/iprPy/database/LocalDatabase.py
+-rw-rw-rw-   0        0        0     1642 2022-05-23 16:10:37.000000 iprPy-0.11.5/iprPy/database/MongoDatabase.py
+-rw-rw-rw-   0        0        0     1892 2022-05-23 16:10:37.000000 iprPy-0.11.5/iprPy/database/__init__.py
+-rw-rw-rw-   0        0        0     1061 2022-02-15 16:32:45.000000 iprPy-0.11.5/iprPy/database/load_database.py
+-rw-rw-rw-   0        0        0     5800 2022-04-07 17:25:44.000000 iprPy-0.11.5/iprPy/database/master_prepare.py
+-rw-rw-rw-   0        0        0    16414 2022-10-20 11:33:59.000000 iprPy-0.11.5/iprPy/database/prepare.py
+-rw-rw-rw-   0        0        0     1817 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/database/reset_orphans.py
+-rw-rw-rw-   0        0        0    24405 2022-02-15 16:01:52.000000 iprPy-0.11.5/iprPy/database/runner.py
+-rw-rw-rw-   0        0        0     3812 2023-04-07 15:08:49.000000 iprPy-0.11.5/iprPy/fix_lammps_versions.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/input/
+-rw-rw-rw-   0        0        0      391 2022-03-03 22:02:42.000000 iprPy-0.11.5/iprPy/input/__init__.py
+-rw-rw-rw-   0        0        0      980 2022-03-03 22:15:35.000000 iprPy-0.11.5/iprPy/input/boolean.py
+-rw-rw-rw-   0        0        0     1220 2022-03-03 22:05:53.000000 iprPy-0.11.5/iprPy/input/buildcombos.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/
+-rw-rw-rw-   0        0        0     5918 2019-07-24 15:27:46.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/README.rst
+-rw-rw-rw-   0        0        0      471 2022-03-03 22:19:43.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/__init__.py
+-rw-rw-rw-   0        0        0     6741 2022-03-03 22:42:59.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/atomicarchive.py
+-rw-rw-rw-   0        0        0     7120 2022-03-03 22:40:49.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/atomicparent.py
+-rw-rw-rw-   0        0        0     7354 2022-03-03 22:42:55.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/atomicreference.py
+-rw-rw-rw-   0        0        0     6477 2022-03-03 22:41:53.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/crystalprototype.py
+-rw-rw-rw-   0        0        0     3097 2022-03-03 22:38:23.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/defect.py
+-rw-rw-rw-   0        0        0     3450 2022-03-03 22:38:35.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/diatom.py
+-rw-rw-rw-   0        0        0     3057 2022-03-03 22:38:30.000000 iprPy-0.11.5/iprPy/input/buildcombos_functions/lammpspotential.py
+-rw-rw-rw-   0        0        0     4050 2022-03-03 22:15:33.000000 iprPy-0.11.5/iprPy/input/parse.py
+-rw-rw-rw-   0        0        0     2015 2022-03-03 22:18:09.000000 iprPy-0.11.5/iprPy/input/termtodict.py
+-rw-rw-rw-   0        0        0     1698 2022-03-03 22:19:18.000000 iprPy-0.11.5/iprPy/input/value.py
+-rw-rw-rw-   0        0        0     1335 2023-04-07 15:07:09.000000 iprPy-0.11.5/iprPy/load_run_directory.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/record/
+-rw-rw-rw-   0        0        0    12587 2023-04-07 15:33:56.000000 iprPy-0.11.5/iprPy/record/PotentialProperties.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/
+-rw-rw-rw-   0        0        0     5535 2022-06-01 13:45:46.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/CrystalStructure.py
+-rw-rw-rw-   0        0        0     1305 2022-02-15 16:01:52.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/DiatomScan.py
+-rw-rw-rw-   0        0        0     5317 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/ElasticConstants.py
+-rw-rw-rw-   0        0        0     1805 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/EvsRScan.py
+-rw-rw-rw-   0        0        0     3847 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/FreeSurface.py
+-rw-rw-rw-   0        0        0     6255 2023-04-11 18:57:57.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/Phonon.py
+-rw-rw-rw-   0        0        0     4598 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/PointDefect.py
+-rw-rw-rw-   0        0        0     1025 2023-03-07 17:45:11.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/PotentialsPropertiesSubset.py
+-rw-rw-rw-   0        0        0     6241 2022-07-11 18:42:14.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/StackingFault.py
+-rw-rw-rw-   0        0        0      308 2022-11-18 21:23:15.000000 iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/__init__.py
+-rw-rw-rw-   0        0        0      322 2023-04-07 15:52:13.000000 iprPy-0.11.5/iprPy/record/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/record/xsd/
+-rw-rw-rw-   0        0        0        0 2021-09-14 18:07:39.000000 iprPy-0.11.5/iprPy/record/xsd/__init__.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:01.000000 iprPy-0.11.5/iprPy/tools/
+-rw-rw-rw-   0        0        0      574 2022-11-18 20:44:52.000000 iprPy-0.11.5/iprPy/tools/__init__.py
+-rw-rw-rw-   0        0        0     1910 2023-04-07 15:21:37.000000 iprPy-0.11.5/iprPy/tools/dict_insert.py
+-rw-rw-rw-   0        0        0     1934 2022-03-03 21:50:13.000000 iprPy-0.11.5/iprPy/tools/dynamic_import.py
+-rw-rw-rw-   0        0        0     1679 2023-04-07 15:22:17.000000 iprPy-0.11.5/iprPy/tools/num_deriv_3_point.py
+-rw-rw-rw-   0        0        0      746 2023-04-07 15:23:02.000000 iprPy-0.11.5/iprPy/tools/read_calc_file.py
+drwxrwxrwx   0        0        0        0 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/
+-rw-rw-rw-   0        0        0     2584 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    18763 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       58 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/entry_points.txt
+-rw-rw-rw-   0        0        0        2 2019-07-10 18:55:45.000000 iprPy-0.11.5/iprPy.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0       89 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2023-04-18 20:31:00.000000 iprPy-0.11.5/iprPy.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0      108 2022-02-03 20:26:52.000000 iprPy-0.11.5/pyproject.toml
+-rw-rw-rw-   0        0        0       42 2023-04-18 20:31:01.000000 iprPy-0.11.5/setup.cfg
+-rw-rw-rw-   0        0        0     1846 2023-04-18 20:01:28.000000 iprPy-0.11.5/setup.py
```

### Comparing `iprPy-0.11.4/LICENSE.TXT` & `iprPy-0.11.5/LICENSE.TXT`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/PKG-INFO` & `iprPy-0.11.5/PKG-INFO`

 * *Files 13% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 Metadata-Version: 2.1
 Name: iprPy
-Version: 0.11.4
+Version: 0.11.5
 Summary: Interatomic Potential Repository Python Property Calculations and Tools
 Home-page: https://github.com/usnistgov/iprPy
 Author: Lucas Hale
 Author-email: lucas.hale@nist.gov
 Keywords: atom,atomic,atomistic,molecular dynamics,high-throughput,interatomic potential
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: Natural Language :: English
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Scientific/Engineering :: Physics
 License-File: LICENSE.TXT
 
 =====
 iprPy
 =====
```

### Comparing `iprPy-0.11.4/README.rst` & `iprPy-0.11.5/README.rst`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/bin/README.rst` & `iprPy-0.11.5/bin/README.rst`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/bin/check_runners.py` & `iprPy-0.11.5/bin/check_runners.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_ctcms.in` & `iprPy-0.11.5/bin/prepare/master_prepare_ctcms.in`

 * *Files 14% similar despite different names*

```diff
@@ -1,49 +1,45 @@
 ######################## Master prepare input script ##########################
 
 # Settings here are for the CTCMS cluster
 
 ################## Primary LAMMPS executable and MPI command ##################
 
 # Primary LAMMPS executable (machine-specific location)
-lammps_command              /users/lmh1/LAMMPS/2020_03_03/src/lmp_mpi
+lammps_command              /toolbox/lmh1/LAMMPS/2022_06_23/build/lmp
 
 # MPI command to use with the LAMMPS executable(s)
-mpi_command                 /cluster/deb9/bin/mpirun -n {np_per_runner}
+mpi_command                 mpirun -n {np_per_runner}
 
 ####################### Alternate LAMMPS executables ##########################
 
 # Optional and only needed if you wish to run old versions of some potentials.
 
 # SNAP version 1 needs LAMMPS between 8 Oct 2014 and 30 May 2017.
-lammps_command_snap_1       /users/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
+lammps_command_snap_1       /toolbox/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
 
 # SNAP version 2 needs LAMMPS between 3 Dec 2018 and 12 June 2019.
-lammps_command_snap_2       /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_snap_2       /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # Some older implementations of potentials need LAMMPS before 30 Oct 2019.
-lammps_command_old          /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_old          /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # LAMMPS built with an external module to run aenet potentials
-lammps_command_aenet        /users/lmh1/LAMMPS/bin/lmp_mpi_2020_03_03_aenet
+lammps_command_aenet        /toolbox/lmh1/LAMMPS/2022_06_23_aenet/src/lmp_mpi
 
 # LAMMPS built with an external module to run pinn potentials
-lammps_command_pinn         /users/lmh1/LAMMPS/LAMMPS-USER-PINN/src/lmp_mpi
+lammps_command_pinn         /toolbox/lmh1/LAMMPS/2020_10_29_pinn/src/lmp_mpi
 
 ############################ Potential limiters ###############################
 
 # Set status to active to only use current versions of potentials
 #potential_status            active
 
 # Directly specify LAMMPS potentials by id
-#potential_id                2022--Xu-Y--Ni-Rh--LAMMPS--ipr1
-#potential_id                2022--Xu-Y--Ni-Pd--LAMMPS--ipr1
-#potential_id                2019--Plummer-G--Ti-Al-C--LAMMPS--ipr1
-#potential_id                2019--Plummer-G--Ti-Si-C--LAMMPS--ipr1
-#potential_id                2021--Plummer-G--Ti-Al-C--LAMMPS--ipr1
+potential_id                2022--Zhou-M--Zr--LAMMPS--ipr1
 
 # Limit by database parsing terms
 #potential_potid
 #potential_pair_style
 #potential_symbols
 #potential_elements
 
@@ -52,30 +48,30 @@
 # Each pool requires a value for:
 # - styles : Space-delimited calculation styles (and branches)
 # - run_directory : Run directory where the calculations will be prepared to
 # - np_per_runner : Number of processors the prepared calculations expect
 # - num_pots : The max number of potentials to prepare at a time
 
 # Pool #1: Basic potential evaluations and scans
-styles                      isolated_atom diatom_scan E_vs_r_scan:bop E_vs_r_scan
-run_directory               iprhub_1
-np_per_runner               1
-num_pots                    100
+#styles                      isolated_atom diatom_scan E_vs_r_scan:bop E_vs_r_scan
+#run_directory               iprhub_1
+#np_per_runner               1
+#num_pots                    100
 
 # Pool #2: Round 1 of crystal structure relaxations
-styles                      relax_box relax_static relax_dynamic
-run_directory               iprhub_2
-np_per_runner               1
-num_pots                    100
+#styles                      relax_box relax_static relax_dynamic
+#run_directory               iprhub_2
+#np_per_runner               1
+#num_pots                    100
 
 # Pool #3: Round 2 of crystal structure relaxations
-styles                      relax_static:from_dynamic
-run_directory               iprhub_3
-np_per_runner               1
-num_pots                    100
+#styles                      relax_static:from_dynamic
+#run_directory               iprhub_3
+#np_per_runner               1
+#num_pots                    100
 
 # Pool #4: Crystal space group analysis
 styles                      crystal_space_group:relax 
 #styles                      crystal_space_group:relax crystal_space_group:prototype crystal_space_group:reference
 run_directory               iprhub_4
 np_per_runner               1
 num_pots                    50
```

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_1.in` & `iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_3.in`

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 ######################## Master prepare input script ##########################
 
-# This script is designed specifically to prepare all missing Pool #1
+# This script is designed specifically to prepare all missing Pool #3
 # calculations on the "CTCMS" cluster.  See the non-pool master_prepare scripts
 # for more details and options.
 
 ################## Primary LAMMPS executable and MPI command ##################
 
 # Primary LAMMPS executable (machine-specific location)
-lammps_command              /users/lmh1/LAMMPS/2020_03_03/src/lmp_mpi
+lammps_command              /toolbox/lmh1/LAMMPS/2022_06_23/build/lmp
 
 # MPI command to use with the LAMMPS executable(s)
-mpi_command                 /cluster/deb9/bin/mpirun -n {np_per_runner}
+mpi_command                 mpirun -n {np_per_runner}
 
 ####################### Alternate LAMMPS executables ##########################
 
 # Optional and only needed if you wish to run old versions of some potentials.
 
 # SNAP version 1 needs LAMMPS between 8 Oct 2014 and 30 May 2017.
-lammps_command_snap_1       /users/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
+lammps_command_snap_1       /toolbox/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
 
 # SNAP version 2 needs LAMMPS between 3 Dec 2018 and 12 June 2019.
-lammps_command_snap_2       /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_snap_2       /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # Some older implementations of potentials need LAMMPS before 30 Oct 2019.
-lammps_command_old          /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_old          /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # LAMMPS built with an external module to run aenet potentials
-lammps_command_aenet        /users/lmh1/LAMMPS/bin/lmp_mpi_2020_03_03_aenet
+lammps_command_aenet        /toolbox/lmh1/LAMMPS/2022_06_23_aenet/src/lmp_mpi
 
 # LAMMPS built with an external module to run pinn potentials
-lammps_command_pinn         /users/lmh1/LAMMPS/LAMMPS-USER-PINN/src/lmp_mpi
+lammps_command_pinn         /toolbox/lmh1/LAMMPS/2020_10_29_pinn/src/lmp_mpi
 
 ############################ Potential limiters ###############################
 
 # None used here: this prepare is meant to check for any missing calculations.
 
 ################################ Pool Settings #################################
 
-# Pool #1: Basic potential evaluations and scans
-styles                      isolated_atom diatom_scan E_vs_r_scan:bop E_vs_r_scan
-run_directory               iprhub_1
+# Pool #3: Round 2 of crystal structure relaxations
+styles                      relax_static:from_dynamic
+run_directory               iprhub_5
 np_per_runner               1
-num_pots                    100
+num_pots                    50
```

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_2.in` & `iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_2.in`

 * *Files 13% similar despite different names*

```diff
@@ -3,42 +3,42 @@
 # This script is designed specifically to prepare all missing Pool #2
 # calculations on the "CTCMS" cluster.  See the non-pool master_prepare scripts
 # for more details and options.
 
 ################## Primary LAMMPS executable and MPI command ##################
 
 # Primary LAMMPS executable (machine-specific location)
-lammps_command              /users/lmh1/LAMMPS/2020_03_03/src/lmp_mpi
+lammps_command              /toolbox/lmh1/LAMMPS/2022_06_23/build/lmp
 
 # MPI command to use with the LAMMPS executable(s)
-mpi_command                 /cluster/deb9/bin/mpirun -n {np_per_runner}
+mpi_command                 mpirun -n {np_per_runner}
 
 ####################### Alternate LAMMPS executables ##########################
 
 # Optional and only needed if you wish to run old versions of some potentials.
 
 # SNAP version 1 needs LAMMPS between 8 Oct 2014 and 30 May 2017.
-lammps_command_snap_1       /users/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
+lammps_command_snap_1       /toolbox/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
 
 # SNAP version 2 needs LAMMPS between 3 Dec 2018 and 12 June 2019.
-lammps_command_snap_2       /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_snap_2       /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # Some older implementations of potentials need LAMMPS before 30 Oct 2019.
-lammps_command_old          /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_old          /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # LAMMPS built with an external module to run aenet potentials
-lammps_command_aenet        /users/lmh1/LAMMPS/bin/lmp_mpi_2020_03_03_aenet
+lammps_command_aenet        /toolbox/lmh1/LAMMPS/2022_06_23_aenet/src/lmp_mpi
 
 # LAMMPS built with an external module to run pinn potentials
-lammps_command_pinn         /users/lmh1/LAMMPS/LAMMPS-USER-PINN/src/lmp_mpi
+lammps_command_pinn         /toolbox/lmh1/LAMMPS/2020_10_29_pinn/src/lmp_mpi
 
 ############################ Potential limiters ###############################
 
 # None used here: this prepare is meant to check for any missing calculations.
 
 ################################ Pool Settings #################################
 
 # Pool #2: Round 1 of crystal structure relaxations
 styles                      relax_box relax_static relax_dynamic
 run_directory               iprhub_2
 np_per_runner               1
-num_pots                    100
+num_pots                    50
```

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_3.in` & `iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_5.in`

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,45 @@
 ######################## Master prepare input script ##########################
 
-# This script is designed specifically to prepare all missing Pool #3
+# This script is designed specifically to prepare all missing Pool #4
 # calculations on the "CTCMS" cluster.  See the non-pool master_prepare scripts
 # for more details and options.
 
 ################## Primary LAMMPS executable and MPI command ##################
 
 # Primary LAMMPS executable (machine-specific location)
-lammps_command              /users/lmh1/LAMMPS/2020_03_03/src/lmp_mpi
+lammps_command              /toolbox/lmh1/LAMMPS/2022_06_23/build/lmp
 
 # MPI command to use with the LAMMPS executable(s)
-mpi_command                 /cluster/deb9/bin/mpirun -n {np_per_runner}
+mpi_command                 mpirun -n {np_per_runner}
 
 ####################### Alternate LAMMPS executables ##########################
 
 # Optional and only needed if you wish to run old versions of some potentials.
 
 # SNAP version 1 needs LAMMPS between 8 Oct 2014 and 30 May 2017.
-lammps_command_snap_1       /users/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
+lammps_command_snap_1       /toolbox/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
 
 # SNAP version 2 needs LAMMPS between 3 Dec 2018 and 12 June 2019.
-lammps_command_snap_2       /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_snap_2       /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # Some older implementations of potentials need LAMMPS before 30 Oct 2019.
-lammps_command_old          /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_old          /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # LAMMPS built with an external module to run aenet potentials
-lammps_command_aenet        /users/lmh1/LAMMPS/bin/lmp_mpi_2020_03_03_aenet
+lammps_command_aenet        /toolbox/lmh1/LAMMPS/2022_06_23_aenet/src/lmp_mpi
 
 # LAMMPS built with an external module to run pinn potentials
-lammps_command_pinn         /users/lmh1/LAMMPS/LAMMPS-USER-PINN/src/lmp_mpi
+lammps_command_pinn         /toolbox/lmh1/LAMMPS/2020_10_29_pinn/src/lmp_mpi
 
 ############################ Potential limiters ###############################
 
 # None used here: this prepare is meant to check for any missing calculations.
 
 ################################ Pool Settings #################################
 
-# Pool #3: Round 2 of crystal structure relaxations
-styles                      relax_static:from_dynamic
-run_directory               iprhub_3
+# Pool #4: Crystal space group analysis
+styles                      elastic_constants_static
+#styles                      elastic_constants_static phonon
+run_directory               iprhub_5
 np_per_runner               1
-num_pots                    100
+num_pots                    50
```

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_4.in` & `iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_4.in`

 * *Files 12% similar despite different names*

```diff
@@ -3,37 +3,37 @@
 # This script is designed specifically to prepare all missing Pool #4
 # calculations on the "CTCMS" cluster.  See the non-pool master_prepare scripts
 # for more details and options.
 
 ################## Primary LAMMPS executable and MPI command ##################
 
 # Primary LAMMPS executable (machine-specific location)
-lammps_command              /users/lmh1/LAMMPS/2020_03_03/src/lmp_mpi
+lammps_command              /toolbox/lmh1/LAMMPS/2022_06_23/build/lmp
 
 # MPI command to use with the LAMMPS executable(s)
-mpi_command                 /cluster/deb9/bin/mpirun -n {np_per_runner}
+mpi_command                 mpirun -n {np_per_runner}
 
 ####################### Alternate LAMMPS executables ##########################
 
 # Optional and only needed if you wish to run old versions of some potentials.
 
 # SNAP version 1 needs LAMMPS between 8 Oct 2014 and 30 May 2017.
-lammps_command_snap_1       /users/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
+lammps_command_snap_1       /toolbox/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
 
 # SNAP version 2 needs LAMMPS between 3 Dec 2018 and 12 June 2019.
-lammps_command_snap_2       /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_snap_2       /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # Some older implementations of potentials need LAMMPS before 30 Oct 2019.
-lammps_command_old          /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_old          /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # LAMMPS built with an external module to run aenet potentials
-lammps_command_aenet        /users/lmh1/LAMMPS/bin/lmp_mpi_2020_03_03_aenet
+lammps_command_aenet        /toolbox/lmh1/LAMMPS/2022_06_23_aenet/src/lmp_mpi
 
 # LAMMPS built with an external module to run pinn potentials
-lammps_command_pinn         /users/lmh1/LAMMPS/LAMMPS-USER-PINN/src/lmp_mpi
+lammps_command_pinn         /toolbox/lmh1/LAMMPS/2020_10_29_pinn/src/lmp_mpi
 
 ############################ Potential limiters ###############################
 
 # None used here: this prepare is meant to check for any missing calculations.
 
 ################################ Pool Settings #################################
```

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_ctcms_pool_5.in` & `iprPy-0.11.5/bin/prepare/master_prepare_ctcms_pool_1.in`

 * *Files 12% similar despite different names*

```diff
@@ -1,45 +1,44 @@
 ######################## Master prepare input script ##########################
 
-# This script is designed specifically to prepare all missing Pool #4
+# This script is designed specifically to prepare all missing Pool #1
 # calculations on the "CTCMS" cluster.  See the non-pool master_prepare scripts
 # for more details and options.
 
 ################## Primary LAMMPS executable and MPI command ##################
 
 # Primary LAMMPS executable (machine-specific location)
-lammps_command              /users/lmh1/LAMMPS/2020_03_03/src/lmp_mpi
+lammps_command              /toolbox/lmh1/LAMMPS/2022_06_23/build/lmp
 
 # MPI command to use with the LAMMPS executable(s)
-mpi_command                 /cluster/deb9/bin/mpirun -n {np_per_runner}
+mpi_command                 mpirun -n {np_per_runner}
 
 ####################### Alternate LAMMPS executables ##########################
 
 # Optional and only needed if you wish to run old versions of some potentials.
 
 # SNAP version 1 needs LAMMPS between 8 Oct 2014 and 30 May 2017.
-lammps_command_snap_1       /users/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
+lammps_command_snap_1       /toolbox/lmh1/LAMMPS/2017_03_31/src/lmp_mpi
 
 # SNAP version 2 needs LAMMPS between 3 Dec 2018 and 12 June 2019.
-lammps_command_snap_2       /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_snap_2       /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # Some older implementations of potentials need LAMMPS before 30 Oct 2019.
-lammps_command_old          /users/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
+lammps_command_old          /toolbox/lmh1/LAMMPS/2019_06_05/src/lmp_mpi
 
 # LAMMPS built with an external module to run aenet potentials
-lammps_command_aenet        /users/lmh1/LAMMPS/bin/lmp_mpi_2020_03_03_aenet
+lammps_command_aenet        /toolbox/lmh1/LAMMPS/2022_06_23_aenet/src/lmp_mpi
 
 # LAMMPS built with an external module to run pinn potentials
-lammps_command_pinn         /users/lmh1/LAMMPS/LAMMPS-USER-PINN/src/lmp_mpi
+lammps_command_pinn         /toolbox/lmh1/LAMMPS/2020_10_29_pinn/src/lmp_mpi
 
 ############################ Potential limiters ###############################
 
 # None used here: this prepare is meant to check for any missing calculations.
 
 ################################ Pool Settings #################################
 
-# Pool #4: Crystal space group analysis
-styles                      elastic_constants_static
-#styles                      elastic_constants_static phonon
-run_directory               iprhub_5
+# Pool #1: Basic potential evaluations and scans
+styles                      isolated_atom diatom_scan E_vs_r_scan:bop E_vs_r_scan
+run_directory               iprhub_1
 np_per_runner               1
-num_pots                    50
+num_pots                    100
```

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_desktop.in` & `iprPy-0.11.5/bin/prepare/master_prepare_desktop.in`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/bin/prepare/master_prepare_desktop_wsl.in` & `iprPy-0.11.5/bin/prepare/master_prepare_desktop_wsl.in`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/Settings.py` & `iprPy-0.11.5/iprPy/Settings.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 # iprPy imports
 from .tools import screen_input
 
 class Settings(potentials.Settings.Settings):
     """
     Class for handling saved settings.
     """
-    
+
     @property
     def runner_log_directory(self) -> Path:
         """pathlib.Path : Path to the directory where runner logs are saved to."""
 
         # Check runner_log_directory value
         if 'iprPy_runner_log_directory' in self.__content:
             return Path(self.__content['iprPy_runner_log_directory'])
@@ -33,15 +33,15 @@
             self.__content['iprPy_run_directory'] = {}
         return deepcopy(self.__content['iprPy_run_directory'])
 
     @property
     def list_run_directories(self) -> list:
         """list: The names of the pre-defined database names"""
         return list(self.run_directories.keys())
-    
+
     def set_runner_log_directory(self,
                                  path: Union[str, Path, None] = None):
         """
         Sets the runner log directory to a different location.
 
         Parameters
         ----------
@@ -52,46 +52,46 @@
         """
         # Check if a different directory has already been set
         if 'iprPy_runner_log_directory' in self.__content:
             print(f'Runner log directory already set to {self.runner_log_directory}')
             option = screen_input('Overwrite? (yes or no):')
             if option.lower() in ['yes', 'y']:
                 pass
-            elif option.lower() in ['no', 'n']: 
-                return None
-            else: 
+            elif option.lower() in ['no', 'n']:
+                return
+            else:
                 raise ValueError('Invalid choice')
-        
+
         # Ask for path if not given
         if path is None:
             path = screen_input("Enter the path for the new runner log directory:")
         self.__content['iprPy_runner_log_directory'] = Path(path).resolve().as_posix()
 
         # Save changes
         self.save()
-        
+
     def unset_runner_log_directory(self):
         """
         Resets the saved runner log directory information back to the default
         <Settings.directory>/runner-logs/ location.
         """
-        
+
         # Check if library_directory has been set
         if 'iprPy_runner_log_directory' not in self.__content:
             print(f'Runner log directory not set: still using {self.runner_log_directory}')
-        
+
         else:
             print(f'Remove runner log directory {self.runner_log_directory} and reset to {Path(self.directory, "runner-logs")}?')
             test = screen_input('Delete settings? (must type yes):').lower()
             if test == 'yes':
                 del self.__content['iprPy_runner_log_directory']
 
             # Save changes
             self.save()
-                  
+
     def set_run_directory(self,
                           name: Optional[str] = None,
                           path: Optional[str] = None):
         """
         Allows for run_directory information to be defined in the settings file.
 
         Parameters
@@ -99,32 +99,32 @@
         name : str, optional
             The name to assign to the run_directory.  If not given, the user will
             be prompted to enter one.
         path : str, optional
             The directory path for the run_directory.  If not given, the user will
             be prompted to enter one.
         """
-                  
+
         # Ask for name if not given
         if name is None:
             name = screen_input('Enter a name for the run_directory:')
 
         # Load run_directory if it exists
         if name in self.list_run_directories:
-            
-            # Ask if existing run_directory should be overwritten     
+
+            # Ask if existing run_directory should be overwritten
             print(f'run_directory {name} already defined.')
             option = screen_input('Overwrite? (yes or no):')
             if option.lower() in ['yes', 'y']:
                 pass
-            elif option.lower() in ['no', 'n']: 
-                return None
-            else: 
+            elif option.lower() in ['no', 'n']:
+                return
+            else:
                 raise ValueError('Invalid choice')
-        
+
         # Ask for path if not given
         if path is None:
             path = screen_input("Enter the run_directory's path:")
         self.__content['iprPy_run_directory'][name] = Path(path).resolve().as_posix()
 
         self.save()
 
@@ -146,28 +146,28 @@
             if len(run_directory_names) > 0:
                 print('Select a run_directory:')
                 for i, run_directory in enumerate(run_directory_names):
                     print(i+1, run_directory)
                 choice = screen_input(':')
                 try:
                     choice = int(choice)
-                except:
+                except (ValueError, TypeError):
                     name = choice
                 else:
                     name = run_directory_names[choice-1]
             else:
                 print('No run_directories currently set')
                 return None
 
-        # Verify listed name exists 
+        # Verify listed name exists
         try:
             i = run_directory_names.index(name)
-        except:
-            raise ValueError(f'Run directory {name} not found')
+        except Exception as err:
+            raise ValueError(f'Run directory {name} not found') from err
 
         print(f'Run directory {name} found')
         test = screen_input('Delete settings? (must type yes):').lower()
         if test == 'yes':
-            del(self.__content['iprPy_run_directory'][name])
+            del self.__content['iprPy_run_directory'][name]
             self.save()
 
-settings = Settings()
+settings = Settings()
```

### Comparing `iprPy-0.11.4/iprPy/__init__.py` & `iprPy-0.11.5/iprPy/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,23 +2,14 @@
 
 # Standard Python libraries
 from importlib import resources
 
 # Read version from VERSION file
 __version__ = resources.read_text('iprPy', 'VERSION').strip()
 
-__all__ = ['__version__', 'tools', 'settings', 'input', 
-           'load_run_directory', 'fix_lammps_versions',
-           'record', 'load_record', 'recordmanager',
-           'calculation_subset',
-           'calculation', 'load_calculation', 'calculationmanager',
-           'database', 'load_database', 'databasemanager',
-           'check_modules', 'command_line', 'reset_orphans']
-__all__.sort()
-
 # iprPy imports
 from . import tools
 from .Settings import settings
 from .load_run_directory import load_run_directory
 from .fix_lammps_versions import fix_lammps_versions
 from . import input
 
@@ -30,8 +21,17 @@
 from .calculation import load_calculation, calculationmanager
 
 from .database import load_database, databasemanager, reset_orphans
 
 from .check_modules import check_modules
 from .command_line import command_line
 
-from . import analysis
+from . import analysis
+
+__all__ = ['__version__', 'tools', 'settings', 'input',
+           'load_run_directory', 'fix_lammps_versions',
+           'record', 'load_record', 'recordmanager',
+           'calculation_subset',
+           'calculation', 'load_calculation', 'calculationmanager',
+           'database', 'load_database', 'databasemanager',
+           'check_modules', 'command_line', 'reset_orphans']
+__all__.sort()
```

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/__init__.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -22,14 +22,15 @@
     from ._diatom import diatom
     from ._evsr import evsr
     from ._crystal import crystal
     from ._elastic import elastic
     from ._surface import surface
     from ._stacking import stacking
     from ._point import point
+    from ._phonon import phonon
 
     def __init__(self,
                  database: Union[IprPyDatabase, str],
                  outputpath: Union[Path, str]):
         """
         Initializes a PropertyProcessor object to manage creating and updating
         property results content for the website based on finished calculation
```

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_crystal.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_crystal.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_diatom.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_diatom.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_elastic.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_elastic.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_empty.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_empty.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_evsr.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_evsr.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_point.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_point.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_stacking.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_stacking.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/PropertyProcessor/_surface.py` & `iprPy-0.11.5/iprPy/analysis/PropertyProcessor/_surface.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/get_isolated_atom_energies.py` & `iprPy-0.11.5/iprPy/analysis/get_isolated_atom_energies.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/match_reference_prototype.py` & `iprPy-0.11.5/iprPy/analysis/match_reference_prototype.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/analysis/process_relaxations.py` & `iprPy-0.11.5/iprPy/analysis/process_relaxations.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/Calculation.py` & `iprPy-0.11.5/iprPy/calculation/Calculation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,33 +1,40 @@
 # coding: utf-8
 # Standard Python libraries
+from io import IOBase
 from pathlib import Path
 from copy import deepcopy
 from importlib import resources
+from typing import Optional, Union
 
-from yabadaba import query
+from yabadaba import load_query
 
 from DataModelDict import DataModelDict as DM
 
 import atomman as am
-from atomman import __version__ as atomman_version
+from atomman import __version__ as current_atomman_version
 
-from .. import __version__ as iprPy_version
+from .. import __version__ as current_iprPy_version
 from ..input import parse
 import uuid
 
 from ..record import Record
 
 class Calculation(Record):
     """Base class for managing calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, database=None,
-                 subsets=None, **kwargs):
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 database = None,
+                 subsets: Optional[tuple] = None,
+                 **kwargs: any):
         """
         Initializes a Calculation object for a given style.
 
         Parameters
         ----------
         model : str, file-like object or DataModelDict, optional
             Record content in data model format to read in.  Cannot be given
@@ -51,145 +58,155 @@
         **kwargs : any
             Any other core Calculation record attributes to set.  Cannot be
             given with model.
         """
         # Throw error for default class
         if self.__module__ == __name__:
             raise TypeError("Don't use Calculation itself, only use derived classes")
-        
+
         # Check for params
         if params is not None and model is not None:
-                raise ValueError('model and params cannot both be given')
+            raise ValueError('model and params cannot both be given')
 
         # Set style and parent_module
         module_terms = self.__module__.split('.')
         self.__parent_module = '.'.join(module_terms[:-1])
         self.__calc_style = module_terms[-2]
 
+        # Set default values (just in case)
+        self.__iprPy_version = current_iprPy_version
+        self.__atomman_version = current_atomman_version
+        self.__key = str(uuid.uuid4())
+        self.__branch = 'main'
+        self.__status = 'not calculated'
+        self.__error = None
+
         # Link to database
         self.database = database
 
         # Initialize subsets list
         if subsets is not None:
             self.__subsets = tuple(subsets)
         else:
-            self.__subsets = () 
+            self.__subsets = ()
 
         # Call Record's init
         super().__init__(model=model, name=name, **kwargs)
 
         # Load parameters if given
         if params is not None:
             self.load_parameters(params, key=kwargs.get('key', None))
 
     @property
-    def maindoc(self):
+    def maindoc(self) -> str:
         """str: the overview documentation for the calculation"""
         try:
             return resources.read_text(self.parent_module, 'README.md')
         except:
             return ""
 
     @property
-    def theorydoc(self):
+    def theorydoc(self) -> str:
         """str: the methods and theory documentation for the calculation"""
         try:
             return resources.read_text(self.parent_module, 'theory.md')
         except:
             return ""
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""        
         return []
-    
+
     @property
-    def files(self):
+    def files(self) -> dict:
         """dict: the names and contents of all required files."""
         files = {}
         for filename in self.filenames:
             files[filename] = resources.read_text(self.parent_module, filename)
         
         return files
 
 ############################### Class attributes ##############################
 
     @property
-    def subsets(self):
+    def subsets(self) -> tuple:
         """tuple: The calculation's subsets"""
         return self.__subsets
 
     @property
-    def style(self):
+    def style(self) -> str:
         """str: The record style"""
         return f'calculation_{self.calc_style}'
 
     @property
-    def calc_style(self):
+    def calc_style(self) -> str:
         """str : The calculation style"""
         return self.__calc_style
 
     @property
-    def key(self):
+    def key(self) -> str:
         """str : The UUID4 key used to identify the calculation run"""
         return self.__key
-    
+
     @property
-    def iprPy_version(self):
+    def iprPy_version(self) -> str:
         """str : The version of iprPy used"""
         return self.__iprPy_version
 
     @property
-    def atomman_version(self):
+    def atomman_version(self) -> str:
         """str : The version of atomman used"""
         return self.__atomman_version
 
     @property
-    def script(self):
+    def script(self) -> str:
         """str : The name of the calculation script used"""
         return self.__script
 
     @property
-    def branch(self):
+    def branch(self) -> str:
         """str : The calculation branch name"""
         return self.__branch
-    
+
     @property
-    def status(self):
+    def status(self) -> str:
         """str : The current status of the calculation"""
         return self.__status
 
     @property
-    def error(self):
+    def error(self) -> Optional[str]:
         """str or None : Any error message generated by the calculation"""
         return self.__error
 
     @property
-    def parent_module(self):
+    def parent_module(self) -> str:
         """str : Name of the module where the calculation's code is located"""
         return self.__parent_module
 
     @property
     def database(self):
         """iprPy.Database : The Database associated with the calculation record"""
         return self.__database
 
     @database.setter
     def database(self, value):
 
         # Set None or atomman.library.Database values
         if value is None or isinstance(value, am.library.Database):
             self.__database = value
-        
+
         # Otherwise assume that it is a yabadaba/iprPy database
         else:
             self.__database = am.library.Database(local_database=value,
                                                   remote=False)
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -212,16 +229,16 @@
         error : str or None, optional
             An error message for the calculation, if one was raised.
         **kwargs : any, optional
             All extra keywords are passed on to the set_values() methods of
             the calculation's subsets.
         """
         # Set universal content
-        self.__iprPy_version = kwargs.get('iprPy_version', iprPy_version)
-        self.__atomman_version = kwargs.get('atomman_version', atomman_version)
+        self.__iprPy_version = kwargs.get('iprPy_version', current_iprPy_version)
+        self.__atomman_version = kwargs.get('atomman_version', current_atomman_version)
         self.__key = kwargs.get('key', str(uuid.uuid4()))
         self.__script = f'calc_{self.calc_style}' # Obsolete....
         self.__branch = kwargs.get('branch', 'main')
         self.__status = kwargs.get('status', 'not calculated')
         self.__error = kwargs.get('error', None)
 
         # Set name
@@ -230,30 +247,19 @@
         else:
             self.name = name
 
         # Set subset content
         for subset in self.subsets:
             subset.set_values(**kwargs)
 
-    def isvalid(self):
-        """
-        Looks at the set atttributes to determine if the associated calculation
-        would be a valid one to run.
-        
-        Returns
-        -------
-        bool
-            True if element combinations are valid, False if not.
-        """
-        # Default Record.isvalid() returns True
-        return True
-
 ##################### Parameter file interactions ########################### 
 
-    def load_parameters(self, params, key=None):
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
         """
         Reads in and sets calculation parameters.
 
         Parameters
         ----------
         params : dict, str or file-like object
             The parameters or parameter file to read in.
@@ -263,34 +269,28 @@
             unchanged.
         """
         # Parse params to input_dict if needed
         if isinstance(params, dict):
             input_dict = params
         else:
             input_dict = parse(params, allsingular=True)
-        
-        #    try:
-        #        assert Path(params).is_file()
-        #    except:
-        #        input_dict = parse(params, allsingular=True)
-        #    else:
-        #        with open(params) as f:
-        #            input_dict = parse(f, allsingular=True)
-        
+
         self.__branch = input_dict.get('branch', 'main')
-        
+
         # Set calculation UUID
         if key is not None:
             self.__key = self.name = key
         else:
             self.__key = self.name = input_dict.get('calc_key', self.key)
 
         return input_dict
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -305,58 +305,35 @@
         -------
         params : dict
             The full set of prepare parameters based on the workflow branch
         """
         raise NotImplementedError('Not implemented for the calculation style')
 
     @property
-    def singularkeys(self):
-        """list: Calculation keys that can have single values during prepare."""
-        return  ['branch']
-    
-    @property
-    def multikeys(self):
-        """list: Calculation key sets that can have multiple values during prepare."""
-        return []
-    
-    @property
-    def allkeys(self):
-        """
-        list: All keys used by the calculation.
-        """
-        # Build list of all keys
-        allkeys = deepcopy(self.singularkeys)
-        for keyset in self.multikeys:
-            allkeys.extend(keyset)
-        
-        return allkeys
-
-    @property
-    def commontemplatekeys(self):
+    def commontemplatekeys(self) -> dict:
         """dict : The input keys and their descriptions shared by all calculations."""
-        
         return {
             'branch': ' '.join([
                 "A metadata group name that the calculation can be parsed by.",
                 "Primarily meant for differentiating runs with different",
                 "settings parameters."
             ])
         }
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
         return {}
 
     @property
-    def template(self):
+    def template(self) -> str:
         """str: The template to use for generating calc.in files."""
         # Start template
         lines = [f'# Input script for iprPy calculation {self.calc_style}', '']
-        
+
         # Build common content
         lines += ['# Calculation Metadata']
         for key in self.commontemplatekeys.keys():
             spacelen = 32 - len(key)
             if spacelen < 1:
                 spacelen = 1
             space = ' ' * spacelen
@@ -371,25 +348,25 @@
         if len(self.templatekeys) > 0:
             lines += ['# Run Parameters']
             for key in self.templatekeys.keys():
                 spacelen = 32 - len(key)
                 if spacelen < 1:
                     spacelen = 1
                 space = ' ' * spacelen
-                lines.append(f'{key}{space}<{key}>')    
-        
+                lines.append(f'{key}{space}<{key}>')
+
         # Join and return lines
         return '\n'.join(lines)
 
     @property
-    def templatedoc(self):
+    def templatedoc(self) -> str:
         """str: The documentation for the template lines for this calculation."""
-        
+
         lines = [f'# {self.calc_style} Input Terms', '']
-        
+
         # Specify common content
         lines += ['## Calculation Metadata',
                   '',
                   "Specifies metadata descriptors common to all calculation styles.",
                   '']
 
         # Build lines for each common template key
@@ -406,48 +383,105 @@
             lines.append('## Run Parameters\n')
             for key, doc in self.templatekeys.items():
                 lines.append(f'- __{key}__: {doc}')
 
         # Join and return lines
         return '\n'.join(lines)
 
-    def _template_builder(self, header, keys):
+    def _template_builder(self,
+                          header: str,
+                          keys: list) -> str:
         """Builds a section of the template for a set of parameter keys"""
         if len(keys) > 0:
             template = f'# {header}\n'
             for key in keys:
                 spacelen = 32 - len(key)
                 if spacelen < 1:
                     spacelen = 1
                 space = ' ' * spacelen
                 template += f'{key}{space}<{key}>\n'
         return template
 
+    @property
+    def singularkeys(self) -> list:
+        """list: Calculation keys that can have single values during prepare."""
+        return  ['branch']
+
+    @property
+    def multikeys(self) -> list:
+        """list: Calculation key sets that can have multiple values during prepare."""
+        return []
+
+    @property
+    def allkeys(self) -> list:
+        """
+        list: All keys used by the calculation.
+        """
+        # Build list of all keys
+        allkeys = deepcopy(self.singularkeys)
+        for keyset in self.multikeys:
+            allkeys.extend(keyset)
+
+        return allkeys
+
 ########################### Data model interactions ###########################
 
     @property
     def xsd_filename(self):
         """tuple: The module path and file name of the record's xsd schema"""
         return (self.parent_module, f'{self.style}.xsd')
 
-    def load_model(self, model, name=None):
+    @property
+    def xsl_filename(self):
+        """tuple: The module path and file name of the record's xsl transform"""
+        return (self.parent_module, f'{self.style}.xsl')
+
+    def build_model(self) -> DM:
+        """
+        Generates and returns model content based on the values set to object.
+        """
+        # Create the root of the DataModelDict
+        model = DM()
+        model[self.modelroot] = calc = DM()
+
+        # Assign uuid
+        calc['key'] = self.key
+
+        # Save calculation parameters
+        calc['calculation'] = DM()
+        calc['calculation']['iprPy-version'] = self.iprPy_version
+        calc['calculation']['atomman-version'] = self.atomman_version        
+        calc['calculation']['script'] = self.script
+        calc['calculation']['branch'] = self.branch
+
+        if self.status != 'finished':
+            calc['status'] = self.status
+
+            if self.status == 'error':
+                calc['error'] = self.error
+
+        return model
+
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
         name : str, optional
             The name to assign to the record.  Often inferred from other
             attributes if not given.
         """
         super().load_model(model, name=name)
         calc = self.model[self.modelroot]
-        
+
         # Load universal content
         self.__key = calc['key']
         self.__iprPy_version = calc['calculation']['iprPy-version']
         self.__atomman_version = calc['calculation']['atomman-version']
         self.__script = calc['calculation']['script']
         self.__branch = calc['calculation'].get('branch', 'main')
         self.__status = calc.get('status', 'finished')
@@ -459,261 +493,251 @@
         except:
             self.name = self.key
 
         # Load subset content
         for subset in self.subsets:
             subset.load_model(calc)
 
-    def build_model(self):
-        """
-        Generates and returns model content based on the values set to object.
-        """
-        # Create the root of the DataModelDict
-        model = DM()
-        model[self.modelroot] = calc = DM()
-        
-        # Assign uuid
-        calc['key'] = self.key
-        
-        # Save calculation parameters
-        calc['calculation'] = DM()
-        calc['calculation']['iprPy-version'] = self.iprPy_version
-        calc['calculation']['atomman-version'] = self.atomman_version        
-        calc['calculation']['script'] = self.script
-        calc['calculation']['branch'] = self.branch
-
-        if self.status != 'finished':
-            calc['status'] = self.status
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
+        queries = {
+            'key': load_query(
+                style='str_match',
+                name='key',
+                path=f'{self.modelroot}.key',
+                description="search by calculation's UUID key"),
+            'iprPy_version': load_query(
+                style='str_match',
+                name='iprPy_version',
+                path=f'{self.modelroot}.calculation.iprPy-version',
+                description="search by iprPy version used"),
+            'atomman_version': load_query(
+                style='str_match',
+                name='atomman_version',
+                path=f'{self.modelroot}.calculation.atomman-version',
+                description="search by atomman version used"),
+            'script': load_query(
+                style='str_match',
+                name='script',
+                path=f'{self.modelroot}.calculation.script',
+                description="search by script name used"),
+            'branch': load_query(
+                style='str_match',
+                name='branch',
+                path=f'{self.modelroot}.calculation.branch',
+                description="search by calculation branch name"),
+            'status': load_query(
+                style='str_match',
+                name='status',
+                path=None,
+                description="search by calculation status"),
+        }
 
-            if self.status == 'error':
-                calc['error'] = self.error
+        # Add subset queries
+        for subset in self.subsets:
+            queries.update(subset.queries)
 
-        return model
+        return queries
 
-    def mongoquery(self, name=None, key=None, iprPy_version=None,
-                   atomman_version=None, script=None, branch=None,
-                   status=None, **kwargs):
+    def mongoquery(self,
+                   name: Union[str, list, None] = None,
+                   key: Union[str, list, None] = None,
+                   iprPy_version: Union[str, list, None] = None,
+                   atomman_version: Union[str, list, None] = None,
+                   script: Union[str, list, None] = None,
+                   branch: Union[str, list, None] = None,
+                   status: Union[str, list, None] = None,
+                   **kwargs: any) -> dict:
         """
         Builds a Mongo-style query based on kwargs values for the record style.
 
         Parameters
         ----------
-        name : str or list
+        name : str or list, optional
             The record name(s) to parse by.
-        key : str or list
+        key : str or list, optional
             The unique record UUID4 keys to parse by.
-        iprPy_version : str or list
+        iprPy_version : str or list, optional
             The version(s) of iprPy to parse by.
-        atomman_version : str or list
+        atomman_version : str or list, optional
             The version(s) of atomman to parse by.
-        script : str or list
+        script : str or list, optional
             The name(s) of the calculation script to parse by.
-        branch : str or list
+        branch : str or list, optional
             The calculation branch name(s) to parse by.
-        status : str or list
+        status : str or list, optional
             The status(es) of the calculations to parse by.
         **kwargs : any
             Any extra query terms associated with one of the calculation's
-            subsets.        
+            subsets.
         
         Returns
         -------
         dict
             The Mongo-style query.
         """
-        
-        mquery = {}
-        query.str_match.mongo(mquery, f'name', name)
-        
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.key', key)
-        query.str_match.mongo(mquery, f'{root}.calculation.iprPy-version', iprPy_version)
-        query.str_match.mongo(mquery, f'{root}.calculation.atomman-version', atomman_version)
-        query.str_match.mongo(mquery, f'{root}.calculation.script', script)
-        query.str_match.mongo(mquery, f'{root}.calculation.branch', branch)
-        if status is not None:            
+
+        # Pass all known and unknown kwargs except status
+        mquery = super().mongoquery(name=name, key=key, iprPy_version=iprPy_version,
+                                    atomman_version=atomman_version, script=script,
+                                    branch=branch, **kwargs)
+
+        # Add status
+        if status is not None:
             assert isinstance(status, str), 'lists of status not yet supported'
+
+            root = f'content.{self.modelroot}'
+            querylist = mquery['$and']
+
             if status == 'finished':
-                mquery[f'{root}.status'] = {'$exists': False}
+                querylist.append( {f'{root}.status': {'$exists': False} } )
             else:
-                mquery[f'{root}.status'] = status
-        
-        # Build subset terms
-        for subset in self.subsets:
-            mquery.update(subset.mongoquery(**kwargs))
+                querylist.append( {f'{root}.status': status} )
 
         return mquery
 
-    def cdcsquery(self, key=None, iprPy_version=None,
-                  atomman_version=None, script=None, branch=None,
-                  status=None, **kwargs):
+    def cdcsquery(self,
+                  key: Union[str, list, None] = None,
+                  iprPy_version: Union[str, list, None] = None,
+                  atomman_version: Union[str, list, None] = None,
+                  script: Union[str, list, None] = None,
+                  branch: Union[str, list, None] = None,
+                  status: Union[str, list, None] = None,
+                  **kwargs: any) -> dict:
         """
         Builds a CDCS-style query based on kwargs values for the record style.
 
         Parameters
         ----------
-        key : str or list
+        key : str or list, optional
             The unique record UUID4 keys to parse by.
         iprPy_version : str or list
             The version(s) of iprPy to parse by.
-        atomman_version : str or list
+        atomman_version : str or list, optional
             The version(s) of atomman to parse by.
-        script : str or list
+        script : str or list, optional
             The name(s) of the calculation script to parse by.
-        branch : str or list
+        branch : str or list, optional
             The calculation branch name(s) to parse by.
-        status : str or list
+        status : str or list, optional
             The status(es) of the calculations to parse by.
         **kwargs : any
             Any extra query terms associated with one of the calculation's
-            subsets.        
+            subsets.
         
         Returns
         -------
         dict
             The CDCS-style query.
         """
-        mquery = {}
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.key', key)
-        query.str_match.mongo(mquery, f'{root}.calculation.iprPy-version', iprPy_version)
-        query.str_match.mongo(mquery, f'{root}.calculation.atomman-version', atomman_version)
-        query.str_match.mongo(mquery, f'{root}.calculation.script', script)
-        query.str_match.mongo(mquery, f'{root}.calculation.branch', branch)
-        if status is not None:            
+        # Pass all known and unknown kwargs except status
+        mquery = super().cdcsquery(key=key, iprPy_version=iprPy_version,
+                                   atomman_version=atomman_version, script=script,
+                                   branch=branch, **kwargs)
+
+        # Add status
+        if status is not None:
             assert isinstance(status, str), 'lists of status not yet supported'
+
+            root = self.modelroot
+            querylist = mquery['$and']
+
             if status == 'finished':
-                mquery[f'{root}.status'] = {'$exists': False}
+                querylist.append( {f'{root}.status': {'$exists': False} } )
             else:
-                mquery[f'{root}.status'] = status
-
-        # Build subset terms
-        for subset in self.subsets:
-            mquery.update(subset.cdcsquery(**kwargs))
+                querylist.append( {f'{root}.status': status} )
 
         return mquery
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         meta = {}
         meta['name'] = self.name
-        
+
         # Set universal calculation record params
         meta['key'] = self.key
         meta['iprPy_version'] = self.iprPy_version
         meta['atomman_version'] = self.atomman_version
         meta['script'] = self.script
         meta['branch'] = self.branch
 
         # Fetch calculation status
         meta['status'] = self.status
         if self.status == 'error':
             meta['error'] = self.error
-        
+
         # Extract subset content
         for subset in self.subsets:
             subset.metadata(meta)
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return []
-    
+
     @property
     def compare_fterms(self):
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def pandasfilter(self, dataframe, name=None, key=None, iprPy_version=None,
-                     atomman_version=None, script=None, branch=None,
-                     status=None, **kwargs):
+    def isvalid(self) -> bool:
         """
-        Filters a pandas.DataFrame based on kwargs values for the record style.
-        
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            A table of metadata for multiple records of the record style.
-        name : str or list
-            The record name(s) to parse by.
-        key : str or list
-            The unique record UUID4 keys to parse by.
-        iprPy_version : str or list
-            The version(s) of iprPy to parse by.
-        atomman_version : str or list
-            The version(s) of atomman to parse by.
-        script : str or list
-            The name(s) of the calculation script to parse by.
-        branch : str or list
-            The calculation branch name(s) to parse by.
-        status : str or list
-            The status(es) of the calculations to parse by.
-        **kwargs : any
-            Any extra query terms associated with one of the calculation's
-            subsets.
+        Looks at the set attributes to determine if the associated calculation
+        would be a valid one to run.
         
         Returns
         -------
-        pandas.Series, numpy.NDArray
-            Boolean map of matching values
+        bool
+            True if element combinations are valid, False if not.
         """
-        # Filter by universal terms
-        matches = (
-            query.str_match.pandas(dataframe, 'name', name)
-            &query.str_match.pandas(dataframe, 'key', key)
-            &query.str_match.pandas(dataframe, 'iprPy_version', iprPy_version)
-            &query.str_match.pandas(dataframe, 'atomman_version', atomman_version)
-            &query.str_match.pandas(dataframe, 'script', script)
-            &query.str_match.pandas(dataframe, 'branch', branch)
-            &query.str_match.pandas(dataframe, 'status', status)
-        )
-
-        # Filter by subset terms
-        for subset in self.subsets:
-            matches = (matches & subset.pandasfilter(dataframe, **kwargs))
-
-        return matches
+        # Default Record.isvalid() returns True
+        return True
 
 ########################### Calculation interactions ##########################
 
     def clean(self):
         """Resets the calculation state for running again."""
         self.__status = 'not calculated'
         self.__error = None
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
         raise AttributeError('calc_inputs not defined for Calculation style')
 
-    def calc(self, *args, **kwargs):
+    def calc(self, *args, **kwargs) -> dict:
         """Calls the calculation's primary function(s)"""
         raise AttributeError('calc not defined for Calculation style')
 
-    def process_results(self, results_dict):
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         raise AttributeError('process_results not defined for Calculation style')
 
-    def run(self, params=None, newkey=False, results_json=False,
-            verbose=False):
+    def run(self,
+            params: Union[str, dict, IOBase, None] = None,
+            newkey: bool = False,
+            results_json: bool = False,
+            raise_error: bool = False,
+            verbose: bool = False):
         """
         Runs the calculation using the current object attribute values or
         supplied parameters. Status after running will be either "finished"
         or "error".
 
         Parameters
         ----------
@@ -723,55 +747,61 @@
         newkey : bool, optional
             If True, then the calculation's key and name will be replaced with
             a new UUID4.  This allows for iterations on previous runs to be
             uniquely labeled.  Default value is False.
         results_json : bool, optional
             If True, then a "results.json" file will be generated following
             the run.
+        raise_error : bool, optional
+            The default behavior of run is to take any error messages from the
+            calculation and set them to class attributes and save to
+            results.json. This allows for calculations to successfully fail.
+            Setting this to True will instead raise the errors, which can
+            provide more details for debugging.
         verbose : bool, optional
             If True, a message relating to the calculation's status will be
             printed upon completion.  Default value is False.
         """
         # Clean record back to not calculated state
-        self.clean()        
-        
+        self.clean()
+
         # Update iprPy and atomman version info
-        self.__iprPy_version = iprPy_version
-        self.__atomman_version = atomman_version
+        self.__iprPy_version = current_iprPy_version
+        self.__atomman_version = current_atomman_version
 
         # Change the calculation's key if requested
         if newkey:
             self.__key = self.name = str(uuid.uuid4())
 
         # Load params if given
         if params is not None:
             self.load_parameters(params)
 
         # Build calculation inputs
         input_dict = self.calc_inputs()
-        
+
         try:
             # Pass inputs to calc function
             results_dict = self.calc(**input_dict)
-        
+
         except Exception as e:
+            if raise_error:
+                raise e
             # Catch any error messages
             self.__status = 'error'
             self.__error = str(e)
             results_dict = None
-        
+
         else:
             self.__status = 'finished'
             self.process_results(results_dict)
-        
+
         if verbose:
             if self.status == 'finished':
                 print('Calculation finished successfully')
             else:
                 print('Error:', self.error)
 
         # Save results to json
         if results_json is True:
             with open('results.json', 'w', encoding='UTF-8') as f:
                 self.build_model().json(fp=f, indent=4, ensure_ascii=False)
-
-
```

### Comparing `iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/EvsRScan.py` & `iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/EvsRScan.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,38 +1,62 @@
 # coding: utf-8
 # Standard Python libraries
-import uuid
+from io import IOBase
+from pathlib import Path
 from copy import deepcopy
+from typing import Optional, Union
 
 import numpy as np
+import numpy.typing as npt
 
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .e_vs_r_scan import e_vs_r_scan
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate)
+from ...input import value
+from ...tools import aslist
 
 class EvsRScan(Calculation):
     """Class for managing energy versus r volumetric scans for crystals"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
 
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
@@ -52,144 +76,149 @@
         self.calc = e_vs_r_scan
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'e_vs_r_scan.py',
             'run0.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
 
     @property
-    def number_of_steps_r(self):
+    def number_of_steps_r(self) -> int:
+        """int: The number of r values where the energy is evaluated"""
         return self.__number_of_steps_r
 
     @number_of_steps_r.setter
-    def number_of_steps_r(self, value):
-        value = int(value)
-        assert value > 0
-        self.__number_of_steps_r = value
+    def number_of_steps_r(self, val: int):
+        val = int(val)
+        assert val > 0
+        self.__number_of_steps_r = val
 
     @property
-    def minimum_r(self):
+    def minimum_r(self) -> float:
+        """float: The minimum r value to evaluate"""
         return self.__minimum_r
 
     @minimum_r.setter
-    def minimum_r(self, value):
-        value = float(value)
-        assert value > 0
-        self.__minimum_r = value
+    def minimum_r(self, val: float):
+        val = float(val)
+        assert val > 0
+        self.__minimum_r = val
 
     @property
-    def maximum_r(self):
+    def maximum_r(self) -> float:
+        """float: The maximum r value to evaluate"""
         return self.__maximum_r
 
     @maximum_r.setter
-    def maximum_r(self, value):
-        value = float(value)
-        assert value > 0
-        self.__maximum_r = value
+    def maximum_r(self, val: float):
+        val = float(val)
+        assert val > 0
+        self.__maximum_r = val
 
     @property
-    def r_values(self):
+    def r_values(self) -> np.ndarray:
         """numpy.NDArray : Interatomic distances used for the scan."""
         if self.__r_values is None:
             raise ValueError('No results yet!')
         return self.__r_values
 
     @r_values.setter
-    def r_values(self, value):
-        if value is None:
-            self.__r_values = value
+    def r_values(self, val: npt.ArrayLike):
+        if val is None:
+            self.__r_values = val
         else:
-            value = np.asarray(value, dtype=float)
-            self.__r_values = value
-            self.number_of_steps_r = len(value)
-            self.minimum_r = value[0]
-            self.maximum_r = value[-1]
+            val = np.asarray(val, dtype=float)
+            self.__r_values = val
+            self.number_of_steps_r = len(val)
+            self.minimum_r = val[0]
+            self.maximum_r = val[-1]
 
     @property
-    def a_values(self):
+    def a_values(self) -> np.ndarray:
         """numpy.NDArray : Unit cell a lattice parameters associated with the scan."""
         if self.__a_values is None:
             raise ValueError('No results yet!')
         return self.__a_values
 
     @a_values.setter
-    def a_values(self, value):
-        if value is None:
-            self.__a_values = value
+    def a_values(self, val: npt.ArrayLike):
+        if val is None:
+            self.__a_values = val
         else:
-            value = np.asarray(value, dtype=float)
-            self.__a_values = value
+            val = np.asarray(val, dtype=float)
+            self.__a_values = val
 
     @property
-    def energy_values(self):
+    def energy_values(self) -> np.ndarray:
         """numpy.NDArray : Measured potential energy for each r value."""
         if self.__energy_values is None:
             raise ValueError('No results yet!')
         return self.__energy_values
 
     @energy_values.setter
-    def energy_values(self, value):
-        if value is None:
-            self.__energy_values = value
+    def energy_values(self, val: npt.ArrayLike):
+        if val is None:
+            self.__energy_values = val
         else:
-            value = np.asarray(value, dtype=float)
-            self.__energy_values = value
+            val = np.asarray(val, dtype=float)
+            self.__energy_values = val
 
     @property
-    def min_cells(self):
+    def min_cells(self) -> list:
         """list : atomman.Systems for the dimensions scanned with local energy minima."""
         if self.__min_cells is None:
             raise ValueError('No results yet!')
         for i in range(len(self.__min_cells)):
             if not isinstance(self.__min_cells[i], am.System):
                 self.__min_cells[i] = am.load('system_model', self.__min_cells[i])
         return self.__min_cells
 
     @min_cells.setter
-    def min_cells(self, value):
-        if value is None:
-            self.__min_cells = value
+    def min_cells(self, val: Union[am.System, list, None]):
+        if val is None:
+            self.__min_cells = val
         else:
-            self.__min_cells = aslist(value)
+            self.__min_cells = aslist(val)
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -212,52 +241,67 @@
         if 'number_of_steps_r' in kwargs:
             self.number_of_steps_r = kwargs['number_of_steps_r']
         if 'minimum_r' in kwargs:
             self.minimum_r = kwargs['minimum_r']
         if 'maximum_r' in kwargs:
             self.maximum_r = kwargs['maximum_r']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
 
         # Load input/output units
         self.units.load_parameters(input_dict)
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.number_of_steps_r = int(input_dict.get('number_of_steps_r', 201))
 
         # Load calculation-specific unitless floats
-        
+
         # Load calculation-specific floats with units
         self.minimum_r = value(input_dict, 'minimum_r',
                                default_unit=self.units.length_unit,
                                default_term='2.0 angstrom')
         self.maximum_r = value(input_dict, 'maximum_r',
                                default_unit=self.units.length_unit,
                                default_term='6.0 angstrom')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -275,136 +319,136 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'crystalprototype load_file prototype'
             params['sizemults'] = '10 10 10'
             params['minimum_r'] = '0.5 angstrom'
             params['maximum_r'] = '6.0 angstrom'
             params['number_of_steps_r'] = '276'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'prototype_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
-        
+
         elif branch == 'bop':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'crystalprototype load_file prototype'
             params['prototype_potential_pair_style'] = 'bop'
             params['sizemults'] = '10 10 10'
             params['minimum_r'] = '2.0 angstrom'
             params['maximum_r'] = '6.0 angstrom'
             params['number_of_steps_r'] = '201'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     if key != 'potential_pair_style':
                         params[f'prototype_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'minimum_r': ' '.join([
                 "The minimum interatomic spacing, r, for the scan.  Default",
                 "value is '2.0 angstrom'."]),
             'maximum_r': ' '.join([
                 "The maximum interatomic spacing, r, for the scan.  Default"
                 "value is '6.0 angstrom'."]),
             'number_of_steps_r': ' '.join([
                 "The number of interatomic spacing values, r, to use.  Default"
                 "value is 201."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
                 self.potential.keyset + 
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
-            
+
             # Run parameters
             [
                 [
                     'minimum_r',
                     'maximum_r',
                     'number_of_steps_r',
                 ]
             ]
-        )   
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-E-vs-r-scan'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -431,21 +475,23 @@
             calc['cohesive-energy-relation'] = scan = DM()
             scan['r'] = uc.model(self.r_values, self.units.length_unit)
             scan['a'] = uc.model(self.a_values, self.units.length_unit)
             scan['cohesive-energy'] = uc.model(self.energy_values,
                                                 self.units.energy_unit)
 
             for cell in self.min_cells:
-               system_model = cell.dump('system_model', box_unit=self.units.length_unit)
-               calc.append('minimum-atomic-system', system_model['atomic-system'])
+                system_model = cell.dump('system_model', box_unit=self.units.length_unit)
+                calc.append('minimum-atomic-system', system_model['atomic-system'])
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -468,200 +514,113 @@
             scan = calc['cohesive-energy-relation']
             self.r_values = uc.value_unit(scan['r'])
             self.a_values = uc.value_unit(scan['a'])
             self.energy_values = uc.value_unit(scan['cohesive-energy'])
 
             self.min_cells = []
             for cell in calc.aslist('minimum-atomic-system'):
-               self.min_cells.append(DM([('atomic-system', cell)]))
-
-    def mongoquery(self, minimum_r=None, maximum_r=None,
-                   number_of_steps_r=None, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
+                self.min_cells.append(DM([('atomic-system', cell)]))
 
-        Parameters
-        ----------
-        minimum_r : float or list, optional
-            The minimum_r run parameter value(s) to parse by.
-        maximum_r : float or list, optional
-            The maximum_r run parameter value(s) to parse by.
-        number_of_steps_r : int or list, optional
-            The number_of_steps_r run parameter value(s) to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_r', minimum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_r', maximum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_r', number_of_steps_r)
-
-        return mquery
-
-    def cdcsquery(self, minimum_r=None, maximum_r=None,
-                  number_of_steps_r=None, **kwargs):
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        minimum_r : float or list, optional
-            The minimum_r run parameter value(s) to parse by.
-        maximum_r : float or list, optional
-            The maximum_r run parameter value(s) to parse by.
-        number_of_steps_r : int or list, optional
-            The number_of_steps_r run parameter value(s) to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_r', minimum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_r', maximum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_r', number_of_steps_r)
-
-        return mquery
+    @property
+    def queries(self) -> dict:
+        queries = deepcopy(super().queries)
+        queries.update({
+            'minimum_r': load_query(
+                style='float_match',
+                name='minimum_r',
+                path=f'{self.modelroot}.calculation.run-parameter.minimum_r.value',
+                description='search by the minimum r value used in angstroms',
+                unit='angstrom'),
+            'maximum_r': load_query(
+                style='float_match',
+                name='maximum_r',
+                path=f'{self.modelroot}.calculation.run-parameter.maximum_r.value',
+                description='search by the maximum r value used in Angstroms',
+                unit='angstrom'),
+            'number_of_steps_r': load_query(
+                style='int_match',
+                name='number_of_steps_r',
+                path=f'{self.modelroot}.calculation.run-parameter.number_of_steps_r',
+                description='search by number of r steps used'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
         meta['minimum_r'] = self.minimum_r
         meta['maximum_r'] = self.maximum_r
         meta['number_of_steps_r'] = self.number_of_steps_r
-        
+
         # Extract results
         if self.status == 'finished':
             meta['r_values'] = self.r_values.tolist()
             meta['a_values'] = self.a_values.tolist()
             meta['energy_values'] = self.energy_values.tolist()
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
-        #    'a_mult',
-        #    'b_mult',
-        #    'c_mult',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def pandasfilter(self, dataframe, minimum_r=None, maximum_r=None,
-                     number_of_steps_r=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        minimum_r : float or list, optional
-            The minimum_r run parameter value(s) to parse by.
-        maximum_r : float or list, optional
-            The maximum_r run parameter value(s) to parse by.
-        number_of_steps_r : int or list, optional
-            The number_of_steps_r run parameter value(s) to parse by.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        matches = (matches
-            &query.str_match.pandas(dataframe, 'minimum_r', minimum_r)
-            &query.str_match.pandas(dataframe, 'maximum_r', maximum_r)
-            &query.str_match.pandas(dataframe, 'number_of_steps_r', number_of_steps_r)
-        )
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
-        
+
         # Remove unused subset inputs
         del input_dict['transform']
 
         # Add calculation-specific inputs
         input_dict['rmin'] = self.minimum_r
         input_dict['rmax'] = self.maximum_r
         input_dict['rsteps'] = self.number_of_steps_r
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         self.r_values = results_dict['r_values']
         self.a_values = results_dict['a_values']
         self.energy_values = results_dict['Ecoh_values']
         self.min_cells = results_dict['min_cell']
-
```

### Comparing `iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/README.md` & `iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsl` & `iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsl`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan_short.xsl` & `iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan_short.xsl`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/e_vs_r_scan.py` & `iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/e_vs_r_scan.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/E_vs_r_scan/theory.md` & `iprPy-0.11.5/iprPy/calculation/E_vs_r_scan/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/Bain.ipynb` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/Bain.ipynb`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/Bain.py` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/Bain.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/BainTransformationMap.py` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/BainTransformationMap.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calc_bain_transformation_map.py` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calc_bain_transformation_map.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/CalculationBainTransformationMap.py` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/CalculationBainTransformationMap.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/README.md` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/calculation_bain_transformation_map/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bain_transformation_map/data_model.py` & `iprPy-0.11.5/iprPy/calculation/bain_transformation_map/data_model.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bond_angle_scan/BondAngleScan.py` & `iprPy-0.11.5/iprPy/calculation/bond_angle_scan/BondAngleScan.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,236 +1,261 @@
 # coding: utf-8
 # Standard Python libraries
+from io import IOBase
+from pathlib import Path
+from copy import deepcopy
+from typing import Optional, Union
 
-
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
 import atomman as am
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .bond_angle_scan import bond_angle_scan
-from ...calculation_subset import *
+from ...calculation_subset import LammpsPotential, LammpsCommands, Units
 from ...input import value
 from ...tools import aslist, dict_insert
 
 class BondAngleScan(Calculation):
     """Class for managing 3-body (bond angle) energy scan calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         subsets = (self.commands, self.potential, self.units)
 
         # Initialize unique calculation attributes
         self.symbols = None
         self.number_of_steps_r = 100
         self.minimum_r = uc.set_in_units(0.5, 'angstrom')
         self.maximum_r = uc.set_in_units(6.0, 'angstrom')
         self.number_of_steps_theta = 100
         self.minimum_theta = 1.0
         self.maximum_theta = 180.0
-        
+
         self.cluster = None
         self.results_file = None
         self.results_length_unit = None
         self.results_energy_unit = None
 
         # Define calc shortcut
         self.calc = bond_angle_scan
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'bond_angle_scan.py',
             'bond_scan.template'
         ]
 
-############################## Class attributes ###############################                
+############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def symbols(self):
-        """The potential symbols to use"""
+    def symbols(self) -> list:
+        """list: The potential symbols to use"""
         return self.__symbols
 
     @symbols.setter
-    def symbols(self, value):
-        if value is None:
+    def symbols(self, val: Union[str, list, None]):
+        if val is None:
             self.__symbols = []
         else:
-            value = aslist(value)
+            val = aslist(val)
 
             # Replicate single symbol
-            if len(value) == 1:
-                value = [value, value, value]
-            
+            if len(val) == 1:
+                val = [val, val, val]
+
             # Check that 3 symbols are given for calc
-            elif len(value) != 3:
+            elif len(val) != 3:
                 raise ValueError('Invalid number of symbols')
-            
-            self.__symbols = value
+
+            self.__symbols = val
 
     @property
-    def number_of_steps_r(self):
+    def number_of_steps_r(self) -> int:
         """int : The number of r evaluation steps"""
         return self.__number_of_steps_r
 
     @number_of_steps_r.setter
-    def number_of_steps_r(self, value):
-        value = int(value)
-        assert value > 0
-        self.__number_of_steps_r = value
+    def number_of_steps_r(self, val: int):
+        val = int(val)
+        assert val > 0
+        self.__number_of_steps_r = val
 
     @property
-    def minimum_r(self):
+    def minimum_r(self) -> float:
         """float : The minimum value of r"""
         return self.__minimum_r
 
     @minimum_r.setter
-    def minimum_r(self, value):
-        value = float(value)
-        assert value > 0
-        self.__minimum_r = value
+    def minimum_r(self, val: float):
+        val = float(val)
+        assert val > 0
+        self.__minimum_r = val
 
     @property
-    def maximum_r(self):
+    def maximum_r(self) -> float:
         """float : The maximum value of r"""
         return self.__maximum_r
 
     @maximum_r.setter
-    def maximum_r(self, value):
-        value = float(value)
-        assert value > 0
-        self.__maximum_r = value
+    def maximum_r(self, val: float):
+        val = float(val)
+        assert val > 0
+        self.__maximum_r = val
 
     @property
-    def number_of_steps_theta(self):
+    def number_of_steps_theta(self) -> int:
         """int : The number of theta evaluation steps"""
         return self.__number_of_steps_theta
 
     @number_of_steps_theta.setter
-    def number_of_steps_theta(self, value):
-        value = int(value)
-        assert value > 0
-        self.__number_of_steps_theta = value
+    def number_of_steps_theta(self, val: int):
+        val = int(val)
+        assert val > 0
+        self.__number_of_steps_theta = val
 
     @property
-    def minimum_theta(self):
+    def minimum_theta(self) -> float:
         """float : The minimum value of theta"""
         return self.__minimum_theta
 
     @minimum_theta.setter
-    def minimum_theta(self, value):
-        value = float(value)
-        assert value > 0
-        assert value <= 180.0
-        self.__minimum_theta = value
+    def minimum_theta(self, val: float):
+        val = float(val)
+        assert val > 0
+        assert val <= 180.0
+        self.__minimum_theta = val
 
     @property
-    def maximum_theta(self):
+    def maximum_theta(self) -> float:
         """float : The maximum value of theta"""
         return self.__maximum_theta
 
     @maximum_theta.setter
-    def maximum_theta(self, value):
-        value = float(value)
-        assert value > 0
-        assert value <= 180.0
-        self.__maximum_theta = value
+    def maximum_theta(self, val: float):
+        val = float(val)
+        assert val > 0
+        assert val <= 180.0
+        self.__maximum_theta = val
 
     @property
-    def cluster(self):
+    def cluster(self) -> am.cluster.BondAngleMap:
         """atomman.cluster.BondAngleMap : Measured energies and coordinates"""
         if self.__cluster is None:
             raise ValueError('No results yet!')
         return self.__cluster
 
     @cluster.setter
-    def cluster(self, value):
-        if value is None:
-            self.__cluster = value
-        elif isinstance(value, am.cluster.BondAngleMap):
-            self.__cluster = value
+    def cluster(self, val: Optional[am.cluster.BondAngleMap]):
+        if val is None:
+            self.__cluster = val
+        elif isinstance(val, am.cluster.BondAngleMap):
+            self.__cluster = val
         else:
             raise TypeError('Must be a cluster object')
-        
+
     @property
-    def results_file(self):
+    def results_file(self) -> str:
         """str : File name where the raw results are saved."""
         if self.__results_file is None:
             raise ValueError('No results yet!')
         return self.__results_file
 
     @results_file.setter
-    def results_file(self, value):
-        if value is None:
-            self.__results_file = value
+    def results_file(self, val: Optional[str]):
+        if val is None:
+            self.__results_file = val
         else:
-            self.__results_file = str(value)
+            self.__results_file = str(val)
 
     @property
-    def results_length_unit(self):
+    def results_length_unit(self) -> str:
         """str : Unit of length for the results_file."""
         if self.__results_length_unit is None:
             raise ValueError('No results yet!')
         return self.__results_length_unit
 
     @results_length_unit.setter
-    def results_length_unit(self, value):
-        if value is None:
-            self.__results_length_unit = value
+    def results_length_unit(self, val: Optional[str]):
+        if val is None:
+            self.__results_length_unit = val
         else:
-            self.__results_length_unit = str(value)
+            self.__results_length_unit = str(val)
 
     @property
-    def results_energy_unit(self):
+    def results_energy_unit(self) -> str:
         """str : Unit of energy for the results_file."""
         if self.__results_energy_unit is None:
             raise ValueError('No results yet!')
         return self.__results_energy_unit
 
     @results_energy_unit.setter
-    def results_energy_unit(self, value):
-        if value is None:
-            self.__results_energy_unit = value
+    def results_energy_unit(self, val: Optional[str]):
+        if val is None:
+            self.__results_energy_unit = val
         else:
-            self.__results_energy_unit = str(value)
+            self.__results_energy_unit = str(val)
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -251,15 +276,15 @@
         maximum_theta : float, optional
             The maximum theta angle value to evaluate.
         **kwargs : any, optional
             Any keyword parameters supported by the set_values() methods of
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
-        super().set_values(name=None, **kwargs)
+        super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
         if 'symbols' in kwargs:
             self.symbols = kwargs['symbols']
         if 'number_of_steps_r' in kwargs:
             self.number_of_steps_r = kwargs['number_of_steps_r']
         if 'minimum_r' in kwargs:
@@ -269,40 +294,42 @@
         if 'number_of_steps_theta' in kwargs:
             self.number_of_steps_theta = kwargs['number_of_steps_theta']
         if 'minimum_theta' in kwargs:
             self.minimum_theta = kwargs['minimum_theta']
         if 'maximum_theta' in kwargs:
             self.maximum_theta = kwargs['maximum_theta']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
         """
         Reads in and sets calculation parameters.
 
         Parameters
         ----------
         params : dict, str or file-like object
             The parameters or parameter file to read in.
         key : str, optional
             A new key value to assign to the object.  If not given, will use
             calc_key field in params if it exists, or leave the key value
             unchanged.
         """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Load calculation-specific strings
         self.symbols = input_dict['symbols'].split()
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.number_of_steps_r = int(input_dict.get('number_of_steps_r', 100))
         self.number_of_steps_theta = int(input_dict.get('number_of_steps_theta', 100))
 
         # Load calculation-specific unitless floats
         self.minimum_theta = float(input_dict.get('minimum_theta', 1.0))
         self.maximum_theta = float(input_dict.get('maximum_theta', 180.0))
@@ -310,22 +337,24 @@
         # Load calculation-specific floats with units
         self.minimum_r = value(input_dict, 'minimum_r',
                                default_unit=self.units.length_unit,
                                default_term='0.5 angstrom')
         self.maximum_r = value(input_dict, 'maximum_r',
                                default_unit=self.units.length_unit,
                                default_term='6.0 angstrom')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -343,45 +372,45 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'bondangle potential_file intpot'
             params['minimum_r'] = '0.5 angstrom'
             params['maximum_r'] = '6.0 angstrom'
             params['number_of_steps_r'] = '100'
             params['minimum_theta'] = '1.0'
             params['maximum_theta'] = '180.0'
             params['number_of_steps_theta'] = '100'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'intpot_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
-        
+
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'symbols': ' '.join([
                 "The one or three model symbols to perform the scan for."]),
             'minimum_r': ' '.join([
                 "The minimum interatomic spacing, r, for the scan.  Default",
@@ -397,43 +426,43 @@
                 "value is 1.0."]),
             'maximum_theta': ' '.join([
                 "The maximum bond angle, theta, for the scan in degrees.  Default"
                 "value is 180.0."]),
             'number_of_steps_theta': ' '.join([
                 "The number of bond angle, theta, to use.  Default"
                 "value is 100."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""        
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
         return keys
-    
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
-            super().multikeys + 
+            super().multikeys +
 
             # Potential keys plus symbols
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 [
                     'symbols'
                 ]
             ] +
 
             # Run parameter keys
             [
@@ -443,26 +472,26 @@
                     'number_of_steps_r',
                 ],
                 [
                     'minimum_theta', 
                     'maximum_theta', 
                     'number_of_steps_theta',
                 ]
-            ]  
+            ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-bond-angle-scan'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         if len(self.symbols) is None:
             raise ValueError('symbols not set')
 
         # Build universal content
@@ -486,27 +515,28 @@
         run_params['number_of_steps_r'] = self.number_of_steps_r
         run_params['minimum_theta'] = self.minimum_theta
         run_params['maximum_theta'] = self.maximum_theta
         run_params['number_of_steps_theta'] = self.number_of_steps_theta
 
         dict_insert(calc, 'system-info', DM(), after='potential-LAMMPS')
         calc['system-info']['symbol'] = self.symbols
-        
 
         # Build results
         if self.status == 'finished':
             calc['results'] = results = DM()
             results['file'] = self.results_file
             results['length_unit'] = self.results_length_unit
             results['energy_unit'] = self.results_energy_unit
-        
+
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -527,223 +557,121 @@
         self.maximum_theta = run_params['maximum_theta']
         self.number_of_steps_theta = run_params['number_of_steps_theta']
 
         self.symbols = calc['system-info']['symbol']
 
         # Load results
         if self.status == 'finished':
-           self.cluster = am.cluster.BondAngleMap(rmin=self.minimum_r,
-                                                  rmax=self.maximum_r,
-                                                  rnum=self.number_of_steps_r,
-                                                  thetamin=self.minimum_theta,
-                                                  thetamax=self.maximum_theta,
-                                                  thetanum=self.number_of_steps_theta,
-                                                  symbols=self.symbols)
-           self.results_file = calc['calculation']['results']['file']
-           self.results_length_unit = calc['calculation']['results']['length_unit']
-           self.results_energy_unit = calc['calculation']['results']['energy_unit']
-
-    def mongoquery(self, minimum_r=None, maximum_r=None,
-                   number_of_steps_r=None, minimum_theta=None,
-                   maximum_theta=None, number_of_steps_theta=None, symbol=None,
-                   **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        minimum_r : float
-            The minimum interatomic spacing to use for the scan.
-        maximum_r : float
-            The maximum interatomic spacing to use for the scan.
-        number_of_steps_r : int
-            The number of interatomic spacings to use for the scan.
-        minimum_theta : float
-            The minimum bond angle to use for the scan.
-        maximum_theta : float
-            The maximum bond angle to use for the scan.
-        number_of_steps_theta : int
-            The number of bond angles to use for the scan.
-        symbol : str
-            Element model symbol(s) assigned to the two atoms.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_r', minimum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_r', maximum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_r', number_of_steps_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_theta', minimum_theta)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_theta', maximum_theta)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_theta', number_of_steps_theta)
-        query.in_list.mongo(mquery, f'{root}.system-info.symbols', symbol)
-
-        return mquery
-
-    def cdcsquery(self, minimum_r=None, maximum_r=None, number_of_steps_r=None,
-                  minimum_theta=None, maximum_theta=None,
-                  number_of_steps_theta=None, symbol=None, **kwargs):
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        minimum_r : float
-            The minimum interatomic spacing to use for the scan.
-        maximum_r : float
-            The maximum interatomic spacing to use for the scan.
-        number_of_steps_r : int
-            The number of evaluation points to use for the scan.
-        minimum_theta : float
-            The minimum bond angle to use for the scan.
-        maximum_theta : float
-            The maximum bond angle to use for the scan.
-        number_of_steps_theta : int
-            The number of bond angles to use for the scan.
-        symbol : str
-            Element model symbol(s) assigned to the two atoms.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_r', minimum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_r', maximum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_r', number_of_steps_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_theta', minimum_theta)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_theta', maximum_theta)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_theta', number_of_steps_theta)
-        query.in_list.mongo(mquery, f'{root}.system-info.symbols', symbol)
-
-        return mquery
+            self.cluster = am.cluster.BondAngleMap(rmin=self.minimum_r,
+                                                    rmax=self.maximum_r,
+                                                    rnum=self.number_of_steps_r,
+                                                    thetamin=self.minimum_theta,
+                                                    thetamax=self.maximum_theta,
+                                                    thetanum=self.number_of_steps_theta,
+                                                    symbols=self.symbols)
+            self.results_file = calc['calculation']['results']['file']
+            self.results_length_unit = calc['calculation']['results']['length_unit']
+            self.results_energy_unit = calc['calculation']['results']['energy_unit']
+
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
+        queries = deepcopy(super().queries)
+        queries.update({
+            'minimum_r': load_query(
+                style='float_match',
+                name='minimum_r',
+                path=f'{self.modelroot}.calculation.run-parameter.minimum_r.value',
+                description='search by the minimum r value used in angstroms',
+                unit='angstrom'),
+            'maximum_r': load_query(
+                style='float_match',
+                name='maximum_r',
+                path=f'{self.modelroot}.calculation.run-parameter.maximum_r.value',
+                description='search by the maximum r value used in Angstroms',
+                unit='angstrom'),
+            'number_of_steps_r': load_query(
+                style='int_match',
+                name='number_of_steps_r',
+                path=f'{self.modelroot}.calculation.run-parameter.number_of_steps_r',
+                description='search by the number of r steps used'),
+            'minimum_theta': load_query(
+                style='float_match',
+                name='minimum_theta',
+                path=f'{self.modelroot}.calculation.run-parameter.minimum_theta.value',
+                description='search by the minimum theta value used in degrees'),
+            'maximum_theta': load_query(
+                style='float_match',
+                name='maximum_theta',
+                path=f'{self.modelroot}.calculation.run-parameter.maximum_theta.value',
+                description='search by the maximum theta value used in degrees'),
+            'number_of_steps_theta': load_query(
+                style='int_match',
+                name='number_of_steps_theta',
+                path=f'{self.modelroot}.calculation.run-parameter.number_of_steps_theta',
+                description='search by the number of theta steps used'),
+            'symbol': load_query(
+                style='list_contains',
+                name='symbols',
+                path=f'{self.modelroot}.system-info.symbols',
+                description='search by element symbols used'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Check required parameters
         if len(self.symbols) is None:
             raise ValueError('symbols not set')
 
         # Call super to extract universal and subset content
         meta = super().metadata()
-        
+
         # Extract calculation-specific content
         meta['minimum_r'] = self.minimum_r
         meta['maximum_r'] = self.maximum_r
         meta['number_of_steps_r'] = self.number_of_steps_r
         meta['minimum_theta'] = self.minimum_theta
         meta['maximum_theta'] = self.maximum_theta
         meta['number_of_steps_theta'] = self.number_of_steps_theta
         meta['symbols'] = ' '.join(sorted(self.symbols))
-        
+
         # Extract results
         if self.status == 'finished':
             meta['results_file'] = self.results_file
             meta['results_length_unit'] = self.results_length_unit
             meta['results_energy_unit'] = self.results_energy_unit
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
             'symbols',
             'potential_LAMMPS_key',
             'potential_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def pandasfilter(self, dataframe, minimum_r=None, maximum_r=None,
-                     number_of_steps_r=None, minimum_theta=None,
-                     maximum_theta=None, number_of_steps_theta=None,
-                     symbol=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        minimum_r : float
-            The minimum interatomic spacing to use for the scan.
-        maximum_r : float
-            The maximum interatomic spacing to use for the scan.
-        number_of_steps_r : int
-            The number of evaluation points to use for the scan.
-        minimum_theta : float
-            The minimum bond angle to use for the scan.
-        maximum_theta : float
-            The maximum bond angle to use for the scan.
-        number_of_steps_theta : int
-            The number of bond angles to use for the scan.
-        symbol : str
-            Element model symbol(s) assigned to the two atoms.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        matches = (matches
-            &query.str_match.pandas(dataframe, 'minimum_r', minimum_r)
-            &query.str_match.pandas(dataframe, 'maximum_r', maximum_r)
-            &query.str_match.pandas(dataframe, 'number_of_steps_r', number_of_steps_r)
-            &query.str_match.pandas(dataframe, 'minimum_theta', minimum_theta)
-            &query.str_match.pandas(dataframe, 'maximum_theta', maximum_theta)
-            &query.str_match.pandas(dataframe, 'number_of_steps_theta', number_of_steps_theta)
-            &query.in_list.pandas(dataframe, 'symbols', symbol)
-        )
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Check required parameters
         if len(self.symbols) is None:
             raise ValueError('symbols not set')
 
         # Initialize input_dict
         input_dict = {}
 
@@ -758,22 +686,22 @@
         input_dict['rnum'] = self.number_of_steps_r
         input_dict['thetamin'] = self.minimum_theta
         input_dict['thetamax'] = self.maximum_theta
         input_dict['thetanum'] = self.number_of_steps_theta
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         self.cluster = results_dict['cluster']
         self.results_file = results_dict['results_file']
         self.results_length_unit = results_dict['length_unit']
-        self.results_energy_unit = results_dict['energy_unit']
+        self.results_energy_unit = results_dict['energy_unit']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/bond_angle_scan/README.md` & `iprPy-0.11.5/iprPy/calculation/bond_angle_scan/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bond_angle_scan/bond_angle_scan.py` & `iprPy-0.11.5/iprPy/calculation/bond_angle_scan/bond_angle_scan.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bond_angle_scan/bond_scan.template` & `iprPy-0.11.5/iprPy/calculation/bond_angle_scan/bond_scan.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bond_angle_scan/prepare_bond_angle_scan.py` & `iprPy-0.11.5/iprPy/calculation/bond_angle_scan/prepare_bond_angle_scan.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/bond_angle_scan/theory.md` & `iprPy-0.11.5/iprPy/calculation/bond_angle_scan/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/crystal_space_group/CrystalSpaceGroup.py` & `iprPy-0.11.5/iprPy/calculation/crystal_space_group/CrystalSpaceGroup.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,38 +1,59 @@
 # coding: utf-8
 # Standard Python libraries
+from io import IOBase
+from pathlib import Path
 from copy import deepcopy
+from typing import Optional, Union
 
 import numpy as np
 
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .crystal_space_group import crystal_space_group
-from ...calculation_subset import *
+from ...calculation_subset import Units, AtommanSystemLoad
 from ...input import value, boolean
-from ...tools import aslist, dict_insert
 
 class CrystalSpaceGroup(Calculation):
     """Class for managing space group analysis of crystals"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         subsets = (self.system, self.units)
 
         # Initialize unique calculation attributes
         self.primitivecell = False
@@ -50,111 +71,116 @@
         self.calc = crystal_space_group
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'crystal_space_group.py'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def primitivecell(self):
+    def primitivecell(self) -> bool:
         """bool : Indicates if spg_ucell is conventional (False) or primitive (True)."""
         return self.__primitivecell
 
     @primitivecell.setter
-    def primitivecell(self, value):
-        self.__primitivecell = boolean(value)
+    def primitivecell(self, val: bool):
+        self.__primitivecell = boolean(val)
 
     @property
-    def idealcell(self):
+    def idealcell(self) -> bool:
         """bool : Indicates if spg_ucell atoms are averaged (False) or idealized (True)."""
         return self.__idealcell
 
     @idealcell.setter
-    def idealcell(self, value):
-        self.__idealcell = boolean(value)
+    def idealcell(self, val: bool):
+        self.__idealcell = boolean(val)
 
     @property
-    def symmetryprecision(self):
-        """float : Length tolerance used in identifying symmetry of atomic sites and system dimensions"""
+    def symmetryprecision(self) -> float:
+        """
+        float : Length tolerance used in identifying symmetry of atomic sites
+        and system dimensions
+        """
         return self.__symmetryprecision
 
     @symmetryprecision.setter
-    def symmetryprecision(self, value):
-        self.__symmetryprecision = float(value)
+    def symmetryprecision(self, val: float):
+        self.__symmetryprecision = float(val)
 
     @property
-    def pearson(self):
+    def pearson(self) -> str:
         """str: Pearson symbol."""
         if self.__pearson is None:
             raise ValueError('No results yet!')
         return self.__pearson
 
     @property
-    def number(self):
+    def number(self) -> int:
         """int: Space group number."""
         if self.__number is None:
             raise ValueError('No results yet!')
         return self.__number
-    
+
     @property
-    def international(self):
+    def international(self) -> str:
         """str: Space group International symbol."""
         if self.__international is None:
             raise ValueError('No results yet!')
         return self.__international
 
     @property
-    def schoenflies(self):
+    def schoenflies(self) -> str:
         """str: Space group Schoenflies symbol."""
         if self.__schoenflies is None:
             raise ValueError('No results yet!')
         return self.__schoenflies
 
     @property
-    def wyckoffs(self):
+    def wyckoffs(self) -> list:
         """list: Wykoff site letter for each atom."""
         if self.__wyckoffs is None:
             raise ValueError('No results yet!')
         return self.__wyckoffs
 
     @property
-    def wyckoff_fingerprint(self):
+    def wyckoff_fingerprint(self) -> str:
         """str: Combines all Wyckoff letters."""
         if self.__wyckoff_fingerprint is None:
             raise ValueError('No results yet!')
         return self.__wyckoff_fingerprint
 
     @property
-    def spg_ucell(self):
+    def spg_ucell(self) -> am.System:
         """atomman.System: The unit cell identified following the space-group analysis"""
         if self.__spg_ucell is None:
             raise ValueError('No results yet!')
         if not isinstance(self.__spg_ucell, am.System):
             self.__spg_ucell = am.load('system_model', self.__spg_ucell)
         return self.__spg_ucell
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -179,45 +205,60 @@
         if 'primitivecell' in kwargs:
             self.primitivecell = kwargs['primitivecell']
         if 'idealcell' in kwargs:
             self.idealcell = kwargs['idealcell']
         if 'symmetryprecision' in kwargs:
             self.symmetryprecision = kwargs['symmetryprecision']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
 
-        # Load calculation-specific strings       
+        # Load calculation-specific strings
 
         # Load calculation-specific booleans
         self.primitivecell = boolean(input_dict.get('primitivecell', False))
         self.idealcell = boolean(input_dict.get('idealcell', True))
 
         # Load calculation-specific integers
 
         # Load calculation-specific unitless floats
-        
+
         # Load calculation-specific floats with units
         self.symmetryprecision = value(input_dict, 'symmetryprecision',
                                        default_unit=self.units.length_unit,
                                        default_term='0.01 angstrom')
-        
+
         # Load initial system
         self.system.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -235,146 +276,146 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            raise ValueError(f'No main branch: use relax, prototype or reference')
+            raise ValueError('No main branch: use relax, prototype or reference')
 
         elif branch == 'relax':
-            
+
             # Check for required kwargs
-            
+
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicarchive load_file archive1',
                 'atomicarchive load_file archive2'
             ]
             params['archive1_record'] = 'calculation_relax_static'
             params['archive1_load_key'] = 'final-system'
             params['archive1_status'] = 'finished'
             params['archive2_record'] = 'calculation_relax_box'
             params['archive2_load_key'] = 'final-system'
             params['archive2_status'] = 'finished'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key == 'potential_id':
                     params['archive1_potential_LAMMPS_id'] = kwargs[key]
                     params['archive2_potential_LAMMPS_id'] = kwargs[key]
                 elif key == 'potential_key':
                     params['archive1_potential_LAMMPS_key'] = kwargs[key]
                     params['archive2_potential_LAMMPS_key'] = kwargs[key]
                 elif key == 'potential_pot_id':
                     params['archive1_potential_id'] = kwargs[key]
                     params['archive2_potential_id'] = kwargs[key]
                 elif key == 'potential_pot_key':
                     params['archive1_potential_key'] = kwargs[key]
                     params['archive2_potential_key'] = kwargs[key]
 
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         elif branch == 'prototype':
-            
+
             # Check for required kwargs
-            
+
             # Set default workflow settings
             params['buildcombos'] = 'crystalprototype load_file proto'
 
             # Copy kwargs to params
             for key in kwargs:
                 params[key] = kwargs[key]
 
         elif branch == 'reference':
-            
+
             # Check for required kwargs
-            
+
             # Set default workflow settings
             params['buildcombos'] = 'atomicreference load_file ref'
 
             # Copy kwargs to params
             for key in kwargs:
                 params[key] = kwargs[key]
-        
+
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'symmetryprecision': ' '.join([
                 "The precision tolerance used for the atomic positions and box",
                 "dimensions for determining symmetry elements.  Default value is",
                 "'0.01 angstrom'."]),
             'primitivecell': ' '.join([
                 "A boolean flag indicating if the returned unit cell is to be",
                 "primitive (True) or conventional (False).  Default value is False."]),
             'idealcell': ' '.join([
                 "A boolean flag indicating if the box dimensions and atomic positions",
                 "are to be idealized based on the space group (True) or averaged based",
                 "on their actual values (False).  Default value is True."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
-    
+        return keys
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # System keys
             [
                 self.system.keyset
             ] +
-            
+
             # Run parameter keys
             [
                 [
                     'symmetryprecision',
                     'primitivecell',
                     'idealcell',
                 ]
             ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-crystal-space-group'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -394,30 +435,32 @@
         # Build results
         if self.status == 'finished':
             calc['Pearson-symbol'] = self.pearson
             calc['space-group'] = DM()
             calc['space-group']['number'] = self.number
             calc['space-group']['Hermann-Maguin'] = self.international
             calc['space-group']['Schoenflies'] = self.schoenflies
-            
+
             wykoffletters, wykoffmults = np.unique(self.wyckoffs, return_counts=True)
             for letter, mult in zip(wykoffletters, wykoffmults):
                 wykoff = DM()
                 wykoff['letter'] = letter
                 wykoff['multiplicity'] = int(mult)
                 calc['space-group'].append('Wykoff', wykoff)
             calc['space-group']['Wyckoff-fingerprint'] = self.wyckoff_fingerprint
 
             system_model = self.spg_ucell.dump('system_model', box_unit=self.units.length_unit)
             calc['unit-cell-atomic-system'] = system_model['atomic-system']
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -444,122 +487,73 @@
             self.__wyckoffs = []
             for wyckoff in calc['space-group'].aslist('Wykoff'):
                 self.__wyckoffs.extend([wyckoff['letter']] * wyckoff['multiplicity'])
             self.__wyckoff_fingerprint = calc['space-group']['Wyckoff-fingerprint']
 
             self.__spg_ucell = DM([('atomic-system', calc['unit-cell-atomic-system'])])
 
-    def mongoquery(self, symmetryprecision=None, idealcell=None,
-                   primitivecell=None, pearson=None, number=None,
-                   international=None, schoenflies=None, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        symmetryprecision : float or list, optional
-            symmetryprecision parameter value(s) to parse by.
-        idealcell : bool or list, optional
-            idealcell parameter value(s) to parse by.
-        primitivecell : bool or list, optional
-            primitivecell parameter value(s) to parse by.
-        pearson : str or list, optional
-            Pearson symbol(s) to parse by.
-        number : int or list, optional
-            Space group numbers to parse by.
-        international : str or list, optional
-            International space group symbols to parse by.
-        schoenflies : str or list, optional
-            Schoenflies space group symbol(s) to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.symmetryprecision', symmetryprecision)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.idealcell', idealcell)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.primitivecell', primitivecell)
-        query.str_match.mongo(mquery, f'{root}.Pearson-symbol', pearson)
-        query.str_match.mongo(mquery, f'{root}.space-group.number', number)
-        query.str_match.mongo(mquery, f'{root}.space-group.Hermann-Maguin', international)
-        query.str_match.mongo(mquery, f'{root}.space-group.Schoenflies', schoenflies)
-
-        return mquery
-
-    def cdcsquery(self, symmetryprecision=None, idealcell=None,
-                  primitivecell=None, pearson=None, number=None,
-                  international=None, schoenflies=None, **kwargs):
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        symmetryprecision : float or list, optional
-            symmetryprecision parameter value(s) to parse by.
-        idealcell : bool or list, optional
-            idealcell parameter value(s) to parse by.
-        primitivecell : bool or list, optional
-            primitivecell parameter value(s) to parse by.
-        pearson : str or list, optional
-            Pearson symbol(s) to parse by.
-        number : int or list, optional
-            Space group numbers to parse by.
-        international : str or list, optional
-            International space group symbols to parse by.
-        schoenflies : str or list, optional
-            Schoenflies space group symbol(s) to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.symmetryprecision', symmetryprecision)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.idealcell', idealcell)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.primitivecell', primitivecell)
-        query.str_match.mongo(mquery, f'{root}.Pearson-symbol', pearson)
-        query.str_match.mongo(mquery, f'{root}.space-group.number', pearson)
-        query.str_match.mongo(mquery, f'{root}.space-group.Hermann-Maguin', international)
-        query.str_match.mongo(mquery, f'{root}.space-group.Schoenflies', schoenflies)
-
-        return mquery
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
+        queries = deepcopy(super().queries)
+        queries.update({
+            'symmetryprecision': load_query(
+                style='float_match',
+                name='symmetryprecision',
+                path=f'{self.modelroot}.calculation.run-parameter.symmetryprecision',
+                description='search by the symmetry precision tolerance used'),
+            'idealcell': load_query(
+                style='str_match',
+                name='idealcell',
+                path=f'{self.modelroot}.calculation.run-parameter.idealcell',
+                description='search by the ideal cell setting'),
+            'primitivecell': load_query(
+                style='str_match',
+                name='primitivecell',
+                path=f'{self.modelroot}.calculation.run-parameter.primitivecell',
+                description='search by the primitive cell setting'),
+            'pearson': load_query(
+                style='str_match',
+                name='pearson',
+                path=f'{self.modelroot}.Pearson-symbol',
+                description='search by the Pearson symbol'),
+            'number': load_query(
+                style='int_match',
+                name='number',
+                path=f'{self.modelroot}.space-group.number',
+                description='search by the space group number'),
+            'international': load_query(
+                style='str_match',
+                name='international',
+                path=f'{self.modelroot}.space-group.Hermann-Maguin',
+                description='search by the space group international Hermann-Maguin symbol'),
+            'schoenflies': load_query(
+                style='str_contains',
+                name='schoenflies',
+                path=f'{self.modelroot}.space-group.Schoenflies',
+                description='search by the space group Schoenflies symbol'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
         meta['symmetryprecision'] = self.symmetryprecision
         meta['idealcell'] = self.idealcell
         meta['primitivecell'] = self.primitivecell
-        
+
         # Extract results
         if self.status == 'finished':
             meta['pearson_symbol'] = self.pearson
             meta['spacegroup_number'] = self.number
             meta['spacegroup_international'] = self.international
             meta['spacegroup_Schoenflies'] = self.schoenflies
             meta['wykoff_fingerprint'] = self.wyckoff_fingerprint
@@ -571,111 +565,57 @@
             meta['beta'] = self.spg_ucell.box.beta
             meta['gamma'] = self.spg_ucell.box.gamma
             meta['natoms'] = self.spg_ucell.natoms
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'parent_key',
             'load_options',
-            
+
             'primitivecell',
             'idealcell',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'symmetryprecision':1e-5,
         }
 
-    def pandasfilter(self, dataframe, symmetryprecision=None, idealcell=None,
-                     primitivecell=None,
-                     pearson=None, number=None, international=None, schoenflies=None,
-                     **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        symmetryprecision : float or list, optional
-            symmetryprecision parameter value(s) to parse by.
-        idealcell : bool or list, optional
-            idealcell parameter value(s) to parse by.
-        primitivecell : bool or list, optional
-            primitivecell parameter value(s) to parse by.
-        pearson : str or list, optional
-            Pearson symbol(s) to parse by.
-        number : int or list, optional
-            Space group numbers to parse by.
-        international : str or list, optional
-            International space group symbols to parse by.
-        schoenflies : str or list, optional
-            Schoenflies space group symbol(s) to parse by.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        matches = (matches
-            &query.str_match.pandas(dataframe, 'symmetryprecision', symmetryprecision)
-            &query.str_match.pandas(dataframe, 'idealcell', idealcell)
-            &query.str_match.pandas(dataframe, 'primitivecell', primitivecell)
-            &query.str_match.pandas(dataframe, 'pearson', pearson)
-            &query.str_match.pandas(dataframe, 'number', number)
-            &query.str_match.pandas(dataframe, 'international', international)
-            &query.str_match.pandas(dataframe, 'schoenflies', schoenflies) 
-        )
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
-        
+
         # Modify subset inputs
         input_dict['system'] = input_dict.pop('ucell')
 
         # Add calculation-specific inputs
         input_dict['symprec'] = self.symmetryprecision
         input_dict['to_primitive'] = self.primitivecell
         input_dict['no_idealize'] = not self.idealcell
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
@@ -683,8 +623,8 @@
         """
         self.__pearson = results_dict['pearson']
         self.__number = results_dict['number']
         self.__international = results_dict['international']
         self.__schoenflies = results_dict['schoenflies']
         self.__wyckoffs = results_dict['wyckoffs']
         self.__wyckoff_fingerprint = results_dict['wyckoff_fingerprint']
-        self.__spg_ucell = results_dict['ucell']
+        self.__spg_ucell = results_dict['ucell']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/crystal_space_group/README.md` & `iprPy-0.11.5/iprPy/calculation/crystal_space_group/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/crystal_space_group/crystal_space_group.py` & `iprPy-0.11.5/iprPy/calculation/crystal_space_group/crystal_space_group.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/diatom_scan/DiatomScan.py` & `iprPy-0.11.5/iprPy/calculation/diatom_scan/DiatomScan.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,39 +1,60 @@
 # coding: utf-8
 # Standard Python libraries
-import uuid
+from io import IOBase
+from pathlib import Path
 from copy import deepcopy
+from typing import Optional, Union
 
 import numpy as np
+import numpy.typing as npt
 
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .diatom_scan import diatom_scan
-from ...calculation_subset import *
-from ...input import value, boolean
+from ...calculation_subset import LammpsCommands, LammpsPotential, Units
+from ...input import value
 from ...tools import aslist, dict_insert
 
 class DiatomScan(Calculation):
     """Class for managing diatom energy scan calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
 
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         subsets = (self.commands, self.potential, self.units)
 
         # Initialize unique calculation attributes
@@ -48,126 +69,128 @@
         self.calc = diatom_scan
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'diatom_scan.py',
             'run0.template'
         ]
 
-############################## Class attributes ###############################                
+############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def symbols(self):
-        """The potential symbols to use"""
+    def symbols(self) -> list:
+        """list : The potential symbols to use"""
         return self.__symbols
 
     @symbols.setter
-    def symbols(self, value):
-        if value is None:
+    def symbols(self, val: Union[str, list, None]):
+        if val is None:
             self.__symbols = []
         else:
-            value = aslist(value)
+            val = aslist(val)
             # Replicate single symbol
-            if len(value) == 1:
-                value += value
-            
+            if len(val) == 1:
+                val += val
+
             # Check that at most 2 symbols given for calc
-            elif len(value) > 2:
+            elif len(val) > 2:
                 raise ValueError('Invalid number of symbols')
-            
-            self.__symbols = value
+
+            self.__symbols = val
 
     @property
-    def number_of_steps_r(self):
+    def number_of_steps_r(self) -> int:
         """int : The number of r evaluation steps"""
         return self.__number_of_steps_r
 
     @number_of_steps_r.setter
-    def number_of_steps_r(self, value):
-        value = int(value)
-        assert value > 0
-        self.__number_of_steps_r = value
+    def number_of_steps_r(self, val: int):
+        val = int(val)
+        assert val > 0
+        self.__number_of_steps_r = val
 
     @property
-    def minimum_r(self):
+    def minimum_r(self) -> float:
         """float : The minimum value of r"""
         return self.__minimum_r
 
     @minimum_r.setter
-    def minimum_r(self, value):
-        value = float(value)
-        assert value > 0
-        self.__minimum_r = value
+    def minimum_r(self, val: float):
+        val = float(val)
+        assert val > 0
+        self.__minimum_r = val
 
     @property
-    def maximum_r(self):
+    def maximum_r(self) -> float:
         """float : The maximum value of r"""
         return self.__maximum_r
 
     @maximum_r.setter
-    def maximum_r(self, value):
-        value = float(value)
-        assert value > 0
-        self.__maximum_r = value
+    def maximum_r(self, val: float):
+        val = float(val)
+        assert val > 0
+        self.__maximum_r = val
 
     @property
-    def r_values(self):
+    def r_values(self) -> np.ndarray:
         """numpy.NDArray : Interatomic distances used for the scan."""
         if self.__r_values is None:
             raise ValueError('No results yet!')
         return self.__r_values
 
     @r_values.setter
-    def r_values(self, value):
-        if value is None:
-            self.__r_values = value
+    def r_values(self, val: Optional[npt.ArrayLike]):
+        if val is None:
+            self.__r_values = val
         else:
-            value = np.asarray(value, dtype=float)
-            self.__r_values = value
-            self.number_of_steps_r = len(value)
-            self.minimum_r = value[0]
-            self.maximum_r = value[-1]
+            val = np.asarray(val, dtype=float)
+            self.__r_values = val
+            self.number_of_steps_r = len(val)
+            self.minimum_r = val[0]
+            self.maximum_r = val[-1]
 
     @property
-    def energy_values(self):
+    def energy_values(self) -> np.ndarray:
         """numpy.NDArray : Measured potential energy for each r value."""
         if self.__energy_values is None:
             raise ValueError('No results yet!')
         return self.__energy_values
 
     @energy_values.setter
-    def energy_values(self, value):
-        if value is None:
-            self.__energy_values = value
+    def energy_values(self, val: Optional[npt.ArrayLike]):
+        if val is None:
+            self.__energy_values = val
         else:
-            value = np.asarray(value, dtype=float)
-            self.__energy_values = value
+            val = np.asarray(val, dtype=float)
+            self.__energy_values = val
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -182,72 +205,76 @@
         maximum_r : float, optional
             The maximum r spacing value to evaluate.
         **kwargs : any, optional
             Any keyword parameters supported by the set_values() methods of
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
-        super().set_values(name=None, **kwargs)
+        super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
         if 'symbols' in kwargs:
             self.symbols = kwargs['symbols']
         if 'number_of_steps_r' in kwargs:
             self.number_of_steps_r = kwargs['number_of_steps_r']
         if 'minimum_r' in kwargs:
             self.minimum_r = kwargs['minimum_r']
         if 'maximum_r' in kwargs:
             self.maximum_r = kwargs['maximum_r']
-    
-####################### Parameter file interactions ########################### 
 
-    def load_parameters(self, params, key=None):
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
         """
         Reads in and sets calculation parameters.
 
         Parameters
         ----------
         params : dict, str or file-like object
             The parameters or parameter file to read in.
         key : str, optional
             A new key value to assign to the object.  If not given, will use
             calc_key field in params if it exists, or leave the key value
             unchanged.
         """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Load calculation-specific strings
         self.symbols = input_dict['symbols'].split()
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.number_of_steps_r = int(input_dict.get('number_of_steps_r', 300))
 
         # Load calculation-specific unitless floats
-        
+
         # Load calculation-specific floats with units
         self.minimum_r = value(input_dict, 'minimum_r',
                                default_unit=self.units.length_unit,
                                default_term='0.02 angstrom')
         self.maximum_r = value(input_dict, 'maximum_r',
                                default_unit=self.units.length_unit,
                                default_term='6.0 angstrom')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -265,78 +292,78 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'diatom potential_file intpot'
             params['minimum_r'] = '0.02 angstrom'
             params['maximum_r'] = '10.0 angstrom'
             params['number_of_steps_r'] = '500'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'intpot_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
-        
+
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'symbols': ' '.join([
                 "The one or two model symbols to perform the scan for."]),
             'minimum_r': ' '.join([
                 "The minimum interatomic spacing, r, for the scan.  Default",
                 "value is '0.02 angstrom'."]),
             'maximum_r': ' '.join([
                 "The maximum interatomic spacing, r, for the scan.  Default"
                 "value is '6.0 angstrom'."]),
             'number_of_steps_r': ' '.join([
                 "The number of interatomic spacing values, r, to use.  Default"
                 "value is 300."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
-    
+        return keys
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Potential keys plus symbols
             [
                 self.potential.keyset + 
@@ -355,19 +382,19 @@
             ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-diatom-scan'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         if len(self.symbols) is None:
             raise ValueError('symbols not set')
 
         # Build universal content
@@ -388,26 +415,28 @@
                                            self.units.length_unit)
         run_params['maximum_r'] = uc.model(self.maximum_r,
                                            self.units.length_unit)
         run_params['number_of_steps_r'] = self.number_of_steps_r
 
         dict_insert(calc, 'system-info', DM(), after='potential-LAMMPS')
         calc['system-info']['symbol'] = self.symbols
-        
+
         # Build results
         if self.status == 'finished':
             calc['diatom-energy-relation'] = scan = DM()
             scan['r'] = uc.model(self.r_values, self.units.length_unit)
             scan['potential-energy'] = uc.model(self.energy_values,
                                                 self.units.energy_unit)
-        
+
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -425,181 +454,95 @@
         self.maximum_r = uc.value_unit(run_params['maximum_r'])
         self.number_of_steps_r = run_params['number_of_steps_r']
 
         self.symbols = calc['system-info']['symbol']
 
         # Load results
         if self.status == 'finished':
-           scan = calc['diatom-energy-relation']
-           self.r_values = uc.value_unit(scan['r'])
-           self.energy_values = uc.value_unit(scan['potential-energy'])
-
-    def mongoquery(self, minimum_r=None, maximum_r=None,
-                   number_of_steps_r=None, symbol=None, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        minimum_r : float
-            The minimum interatomic spacing to use for the scan.
-        maximum_r : float
-            The maximum interatomic spacing to use for the scan.
-        number_of_steps_r : int
-            The number of evaluation points to use for the scan.
-        symbol : str
-            Element model symbol(s) assigned to the two atoms.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_r', minimum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_r', maximum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_r', number_of_steps_r)
-        query.in_list.mongo(mquery, f'{root}.system-info.symbols', symbol)
-
-        return mquery
-
-    def cdcsquery(self, minimum_r=None, maximum_r=None, number_of_steps_r=None,
-                  symbol=None, **kwargs):
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        minimum_r : float
-            The minimum interatomic spacing to use for the scan.
-        maximum_r : float
-            The maximum interatomic spacing to use for the scan.
-        number_of_steps_r : int
-            The number of evaluation points to use for the scan.
-        symbol : str
-            Element model symbol(s) assigned to the two atoms.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.minimum_r', minimum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.maximum_r', maximum_r)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.number_of_steps_r', number_of_steps_r)
-        query.in_list.mongo(mquery, f'{root}.system-info.symbols', symbol)
-
-        return mquery
+            scan = calc['diatom-energy-relation']
+            self.r_values = uc.value_unit(scan['r'])
+            self.energy_values = uc.value_unit(scan['potential-energy'])
+
+    @property
+    def queries(self) -> dict:
+        queries = deepcopy(super().queries)
+        queries.update({
+            'minimum_r': load_query(
+                style='float_match',
+                name='minimum_r',
+                path=f'{self.modelroot}.calculation.run-parameter.minimum_r.value',
+                description='search by the minimum r value used in angstroms',
+                unit='angstrom'),
+            'maximum_r': load_query(
+                style='float_match',
+                name='maximum_r',
+                path=f'{self.modelroot}.calculation.run-parameter.maximum_r.value',
+                description='search by the maximum r value used in Angstroms',
+                unit='angstrom'),
+            'number_of_steps_r': load_query(
+                style='int_match',
+                name='number_of_steps_r',
+                path=f'{self.modelroot}.calculation.run-parameter.number_of_steps_r',
+                description='search by the number of r steps used'),
+            'symbol': load_query(
+                style='list_contains',
+                name='symbols',
+                path=f'{self.modelroot}.system-info.symbols',
+                description='search by element symbols used'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Check required parameters
         if len(self.symbols) is None:
             raise ValueError('symbols not set')
 
         # Call super to extract universal and subset content
         meta = super().metadata()
-        
+
         # Extract calculation-specific content
         meta['minimum_r'] = self.minimum_r
         meta['maximum_r'] = self.maximum_r
         meta['number_of_steps_r'] = self.number_of_steps_r
         meta['symbols'] = ' '.join(sorted(self.symbols))
-        
+
         # Extract results
         if self.status == 'finished':
             meta['r_values'] = self.r_values.tolist()
             meta['energy_values'] = self.energy_values.tolist()
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
             'symbols',
             'potential_LAMMPS_key',
             'potential_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def pandasfilter(self, dataframe, minimum_r=None, maximum_r=None,
-                     number_of_steps_r=None, symbol=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        minimum_r : float
-            The minimum interatomic spacing to use for the scan.
-        maximum_r : float
-            The maximum interatomic spacing to use for the scan.
-        number_of_steps_r : int
-            The number of evaluation points to use for the scan.
-        symbol : str
-            Element model symbol(s) assigned to the two atoms.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        matches = (matches
-            &query.str_match.pandas(dataframe, 'minimum_r', minimum_r)
-            &query.str_match.pandas(dataframe, 'maximum_r', maximum_r)
-            &query.str_match.pandas(dataframe, 'number_of_steps_r', number_of_steps_r)
-            &query.in_list.pandas(dataframe, 'symbols', symbol)
-        )
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Check required parameters
         if len(self.symbols) is None:
             raise ValueError('symbols not set')
 
         # Initialize input_dict
         input_dict = {}
 
@@ -611,20 +554,20 @@
         input_dict['symbols'] = self.symbols
         input_dict['rmin'] = self.minimum_r
         input_dict['rmax'] = self.maximum_r
         input_dict['rsteps'] = self.number_of_steps_r
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         self.r_values = results_dict['r_values']
-        self.energy_values = results_dict['energy_values']
+        self.energy_values = results_dict['energy_values']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/diatom_scan/README.md` & `iprPy-0.11.5/iprPy/calculation/diatom_scan/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/diatom_scan/calculation_diatom_scan.xsl` & `iprPy-0.11.5/iprPy/calculation/diatom_scan/calculation_diatom_scan.xsl`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/diatom_scan/calculation_diatom_scan_short.xsl` & `iprPy-0.11.5/iprPy/calculation/diatom_scan/calculation_diatom_scan_short.xsl`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/diatom_scan/diatom_scan.py` & `iprPy-0.11.5/iprPy/calculation/diatom_scan/diatom_scan.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/diatom_scan/theory.md` & `iprPy-0.11.5/iprPy/calculation/diatom_scan/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/DislocationSDVPN.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/DislocationSDVPN.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,41 +1,60 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
-import random
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 import numpy as np
-
-from yabadaba import query
+import numpy.typing as npt
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .dislocation_SDVPN import sdvpn
-from ...calculation_subset import *
+from ...calculation_subset import (Units, AtommanSystemLoad, Dislocation,
+                                   AtommanElasticConstants, AtommanGammaSurface)
 from ...input import termtodict, value, boolean
-from ...tools import aslist, dict_insert
+from ...tools import aslist
 
 class DislocationSDVPN(Calculation):
     """Class for managing semi-discrete variational Peierls-Nabarro calcuations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__defect = Dislocation(self)
         self.__elastic = AtommanElasticConstants(self)
         self.__gamma = AtommanGammaSurface(self)
         subsets = (self.system, self.elastic, self.gamma,
@@ -55,268 +74,273 @@
         self.beta = np.zeros((3,3))
         self.cdiffelastic = False
         self.cdiffsurface = True
         self.cdiffstress = False
         self.halfwidth = uc.set_in_units(1, 'angstrom')
         self.normalizedisreg = True
         self.fullstress = True
-        
+
         self.__sdvpn_solution = None
         self.__energies = None
         self.__disregistries = None
 
         # Define calc shortcut
         self.calc = sdvpn
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'dislocation_SDVPN.py'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def defect(self):
+    def defect(self) -> Dislocation:
         """Dislocation subset"""
         return self.__defect
 
     @property
-    def elastic(self):
+    def elastic(self) -> AtommanElasticConstants:
         """AtommanElasticConstants subset"""
         return self.__elastic
 
     @property
-    def gamma(self):
+    def gamma(self) -> AtommanGammaSurface:
         """AtommanGammaSurface subset"""
         return self.__gamma
 
     @property
-    def xnum(self):
+    def xnum(self) -> int:
         """int: The number of x coordinate values"""
         return self.__xnum
 
     @xnum.setter
-    def xnum(self, value):
-        if value is None:
-            self.__xnum = value
+    def xnum(self, val: int):
+        if val is None:
+            self.__xnum = val
         else:
-            self.__xnum = int(value)
+            self.__xnum = int(val)
 
     @property
-    def xmax(self):
+    def xmax(self) -> float:
         """float: The maximum x coordinate value"""
         return self.__xmax
 
     @xmax.setter
-    def xmax(self, value):
-        if value is None:
-            self.__xmax = value
+    def xmax(self, val: float):
+        if val is None:
+            self.__xmax = val
         else:
-            self.__xmax = float(value)
+            self.__xmax = float(val)
 
     @property
-    def xstep(self):
+    def xstep(self) -> float:
         """float: The step size between the x coordinate values"""
         return self.__xstep
 
     @xstep.setter
-    def xstep(self, value):
-        if value is None:
-            self.__xstep = value
+    def xstep(self, val: float):
+        if val is None:
+            self.__xstep = val
         else:
-            self.__xstep = float(value)
+            self.__xstep = float(val)
 
     @property
-    def xscale(self):
+    def xscale(self) -> Optional[bool]:
         """bool: Flag if xstep/xmax values are absolute or scaled"""
         return self.__xscale
 
     @xscale.setter
-    def xscale(self, value):
-        if value is None:
-            self.__xscale = value
+    def xscale(self, val: Optional[bool]):
+        if val is None:
+            self.__xscale = val
         else:
-            self.__xscale = boolean(value)
+            self.__xscale = boolean(val)
 
     @property
-    def minimize_style(self):
+    def minimize_style(self) -> str:
         """str: The scipy.minimize style to use"""
         return self.__minimize_style
 
     @minimize_style.setter
-    def minimize_style(self, value):
-        self.__minimize_style = str(value)
+    def minimize_style(self, val: str):
+        self.__minimize_style = str(val)
 
     @property
-    def minimize_options(self):
+    def minimize_options(self) -> dict:
         """dict: kwarg options to pass to scipy.minimize"""
         return self.__minimize_options
 
     @minimize_options.setter
-    def minimize_options(self, value):
-        assert isinstance(value, dict)
-        self.__minimize_options = value
+    def minimize_options(self, val: dict):
+        assert isinstance(val, dict)
+        self.__minimize_options = val
 
     @property
-    def minimize_cycles(self):
+    def minimize_cycles(self) -> int:
         """int: The number of minimization cycles to run"""
         return self.__minimize_cycles
 
     @minimize_cycles.setter
-    def minimize_cycles(self, value):
-        self.__minimize_cycles = int(value)
+    def minimize_cycles(self, val: int):
+        self.__minimize_cycles = int(val)
 
     @property
-    def cutofflongrange(self):
+    def cutofflongrange(self) -> float:
         """float: The cutoff to use for the long-range elastic energy term"""
         return self.__cutofflongrange
 
     @cutofflongrange.setter
-    def cutofflongrange(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__cutofflongrange = float(value)
+    def cutofflongrange(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__cutofflongrange = float(val)
 
     @property
-    def tau(self):
+    def tau(self) -> np.ndarray:
         """numpy.NDArray: External stress tensor to apply to the system"""
         return self.__tau
 
     @tau.setter
-    def tau(self, value):
-        value = np.asarray(value)
-        assert value.shape == (3,3)
-        self.__tau = value
+    def tau(self, val: npt.ArrayLike):
+        val = np.asarray(val)
+        assert val.shape == (3,3)
+        self.__tau = val
 
     @property
-    def alpha(self):
+    def alpha(self) -> list:
         """list: Non-local correction term parameters"""
         return self.__alpha
-    
+
     @alpha.setter
-    def alpha(self, value):
+    def alpha(self, val: Union[str, list]):
         if isinstance(value, str):
-            self.__alpha = [float(v) for v in value.split()]
+            self.__alpha = [float(v) for v in val.split()]
         else:
-            self.__alpha = [float(v) for v in aslist(value)]
+            self.__alpha = [float(v) for v in aslist(val)]
 
     @property
-    def beta(self):
+    def beta(self) -> np.ndarray:
         """numpy.NDArray: Surface correction term parameter tensor"""
         return self.__beta
 
     @beta.setter
-    def beta(self, value):
-        value = np.asarray(value)
-        assert value.shape == (3,3)
-        self.__beta = value
+    def beta(self, val: npt.ArrayLike):
+        val = np.asarray(val)
+        assert val.shape == (3,3)
+        self.__beta = val
 
     @property
-    def cdiffelastic(self):
+    def cdiffelastic(self) -> Optional[bool]:
         """bool: Flag if central difference is used for the elastic term"""
         return self.__cdiffelastic
 
     @cdiffelastic.setter
-    def cdiffelastic(self, value):
-        if value is None:
-            self.__cdiffelastic = value
+    def cdiffelastic(self, val: Optional[bool]):
+        if val is None:
+            self.__cdiffelastic = val
         else:
-            self.__cdiffelastic = boolean(value)
+            self.__cdiffelastic = boolean(val)
 
     @property
-    def cdiffsurface(self):
+    def cdiffsurface(self) -> Optional[bool]:
         """bool: Flag if central difference is used for the surface term"""
         return self.__cdiffsurface
 
     @cdiffsurface.setter
-    def cdiffsurface(self, value):
-        if value is None:
-            self.__cdiffsurface = value
+    def cdiffsurface(self, val: Optional[bool]):
+        if val is None:
+            self.__cdiffsurface = val
         else:
-            self.__cdiffsurface = boolean(value)
+            self.__cdiffsurface = boolean(val)
 
     @property
-    def cdiffstress(self):
+    def cdiffstress(self) -> Optional[bool]:
         """bool: Flag if central difference is used for the stress term"""
         return self.__cdiffstress
 
     @cdiffstress.setter
-    def cdiffstress(self, value):
-        if value is None:
-            self.__cdiffstress = value
+    def cdiffstress(self, val: Optional[bool]):
+        if val is None:
+            self.__cdiffstress = val
         else:
-            self.__cdiffstress = boolean(value)
-    
+            self.__cdiffstress = boolean(val)
+
     @property
-    def normalizedisreg(self):
-        """bool: Flag indicating if the total cumulative disregistry is normalized to the Burgers vector"""
+    def normalizedisreg(self) -> Optional[bool]:
+        """
+        bool: Flag indicating if the total cumulative disregistry is normalized
+        to the Burgers vector
+        """
         return self.__normalizedisreg
 
     @normalizedisreg.setter
-    def normalizedisreg(self, value):
-        if value is None:
-            self.__normalizedisreg = value
+    def normalizedisreg(self, val: Optional[bool]):
+        if val is None:
+            self.__normalizedisreg = val
         else:
-            self.__normalizedisreg = boolean(value)
+            self.__normalizedisreg = boolean(val)
 
     @property
-    def fullstress(self):
+    def fullstress(self) -> Optional[bool]:
         """bool: Flag for switching which stress term equation is used"""
         return self.__fullstress
 
     @fullstress.setter
-    def fullstress(self, value):
-        if value is None:
-            self.__fullstress = value
+    def fullstress(self, val: Optional[bool]):
+        if val is None:
+            self.__fullstress = val
         else:
-            self.__fullstress = boolean(value)
+            self.__fullstress = boolean(val)
 
     @property
-    def sdvpn_solution(self):
+    def sdvpn_solution(self) -> am.defect.SDVPN:
         """atomman.defect.SDVPN: The dislocation solution object"""
         if self.__sdvpn_solution is None:
             raise ValueError('No results yet!')
         elif not isinstance(self.__sdvpn_solution, am.defect.SDVPN):
             self.__sdvpn_solution = am.defect.SDVPN(model=self.__sdvpn_solution)
-        
+
         return self.__sdvpn_solution
 
     @property
-    def energies(self):
+    def energies(self) -> list:
         """list: The total energies for the solution after each minimization cycle"""
         if self.__energies is None:
             raise ValueError('No results yet!')
         else:
             return self.__energies
 
     @property
-    def disregistries(self):
+    def disregistries(self) -> list:
         """list: The disregistry profiles for the solution after each minimization cycle"""
         if self.__disregistries is None:
             raise ValueError('No results yet!')
         else:
             return self.__disregistries
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -397,26 +421,39 @@
         if 'halfwidth' in kwargs:
             self.halfwidth = kwargs['halfwidth']
         if 'normalizedisreg' in kwargs:
             self.normalizedisreg = kwargs['normalizedisreg']
         if 'fullstress' in kwargs:
             self.fullstress = kwargs['fullstress']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
         pl_unit = f'{self.units.pressure_unit}*{self.units.length_unit}'
         p_per_l_unit = f'{self.units.pressure_unit}/{self.units.length_unit}'
-        
+
         # Change default values for subset terms
 
         # Load calculation-specific strings
         alpha = input_dict.get('alpha', '0.0')
         self.minimize_style = input_dict.get('minimize_style', 'Powell')
         minimize_options = input_dict.get('minimize_options', '')
 
@@ -431,15 +468,15 @@
         # Load calculation-specific integers
         self.xnum = input_dict.get('xnum', None)
         self.minimize_cycles = int(input_dict.get('minimize_cycles', 10))
 
         # Load calculation-specific unitless floats
         self.xstep = input_dict.get('xstep', None)
         self.xmax = input_dict.get('xmax', None)
-        
+
         # Load calculation-specific floats with units
         bxx = value(input_dict, 'beta_xx', default_unit=pl_unit,
                     default_term='0.0 GPa*angstrom')
         bxy = value(input_dict, 'beta_xy', default_unit=pl_unit,
                     default_term='0.0 GPa*angstrom')
         bxz = value(input_dict, 'beta_xz', default_unit=pl_unit,
                     default_term='0.0 GPa*angstrom')
@@ -457,15 +494,15 @@
                     default_term='0.0 GPa')
         self.halfwidth = value(input_dict, 'halfwidth',
                                default_unit=self.units.length_unit,
                                default_term='1.0 angstrom')
         self.cutofflongrange = value(input_dict, 'cutofflongrange',
                                      default_unit=self.units.length_unit,
                                      default_term='1000 angstrom')
-        
+
         # Process calculation-specific terms
         alpha = alpha.split()
         if len(alpha) > 1:
             try:
                 float(alpha[-1])
             except:
                 unit = alpha.pop()
@@ -511,15 +548,17 @@
         # Scale xmax and xstep if needed
         if xscale is True:
             if self.xmax is not None:
                 self.xmax *= self.system.ucell.box.a
             if self.xstep is not None:
                 self.xstep *= self.system.ucell.box.a
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -557,15 +596,15 @@
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'xmax': ' '.join([
                 "The maximum value of the x-coordinates to use for the points",
                 "where the disregistry is evaluated.  The solution is centered",
                 "around x=0, therefore this also corresponds to the minimum value",
@@ -613,18 +652,14 @@
                 "Coefficient(s) (in pressure/length units) of the non-local",
                 "energy correction term to use.  Default value is 0.0, meaning",
                 "this correction is not applied."]),
             'beta_xx': ' '.join([
                 "The xx component of the surface energy coefficient tensor",
                 "(in units pressure-length) to use. Default value is 0.0",
                 "GPa-Angstrom."]),
-            'beta_xx': ' '.join([
-                "The xx component of the surface energy coefficient tensor",
-                "(in units pressure-length) to use. Default value is 0.0",
-                "GPa-Angstrom."]),
             'beta_yy': ' '.join([
                 "The yy component of the surface energy coefficient tensor",
                 "(in units pressure-length) to use. Default value is 0.0",
                 "GPa-Angstrom."]),
             'beta_zz': ' '.join([
                 "The zz component of the surface energy coefficient tensor",
                 "(in units pressure-length) to use. Default value is 0.0",
@@ -664,46 +699,46 @@
                 "vector.  Note that the disregistry for these endpoints is",
                 "fixed, so if you use False the initial disregistry should be",
                 "close to the final solution."]),
             'fullstress': ' '.join([
                 "Boolean indicating which of two stress formulas to use.",
                 "True uses the original full formulation, while False uses a",
                 "newer, simpler representation.  Default value is True."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
 
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.units.keyset
 
             # Calculation-specific keys
         )
         return keys
-    
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of system, elastic and gamma keys
             [
                 self.system.keyset + 
                 self.elastic.keyset + 
                 self.gamma.keyset
             ] +
-        
+
             # Defect multikeys
             self.defect.multikeys +
 
             # Run parameters
             [
                 [
                     'xmax',
@@ -728,25 +763,25 @@
                     'cdiffsurface',
                     'cdiffstress',
                     'halfwidth',
                     'normalizedisreg',
                     'fullstress',
                 ]
             ]
-        )    
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-dislocation-SDVPN'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -761,15 +796,15 @@
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
 
         run_params['halfwidth'] = uc.model(self.halfwidth,
                                            self.units.length_unit)
-        
+
         # Scale xmax and xstep by alat
         if self.xscale is True:
             if self.system.box_parameters is not None:
                 alat = float(self.system.box_parameters[0])
             else:
                 try:
                     alat = self.system.ucell.box.a
@@ -781,27 +816,27 @@
                     if self.xstep is not None:
                         self.xstep *= alat
                     self.xscale = False
 
         x = am.defect.pn_arctan_disregistry(xmax=self.xmax,
                                             xnum=self.xnum,
                                             xstep=self.xstep)[0]
-        
+
         run_params['xmax'] = x.max()
         run_params['xnum'] = len(x)
         run_params['xstep'] = x[1]-x[0]
         run_params['xscale'] = self.xscale
         run_params['min_cycles'] = self.minimize_cycles
 
         # Build results
         if self.status != 'finished':
             p_per_l_unit = f'{self.units.pressure_unit}/{self.units.length_unit}'
             p_l_unit = f'{self.units.pressure_unit}*{self.units.length_unit}'
-            calc['semidiscrete-variational-Peierls-Nabarro'] = sdvpn = DM()
-            sdvpn['parameter'] = params = DM()
+            calc['semidiscrete-variational-Peierls-Nabarro'] = svpn = DM()
+            svpn['parameter'] = params = DM()
             params['tau'] = uc.model(self.tau, self.units.pressure_unit)
             params['alpha'] = uc.model(self.alpha, p_per_l_unit)
             params['beta'] = uc.model(self.beta, p_l_unit)
             params['cdiffelastic'] = self.cdiffelastic
             params['cdiffsurface'] = self.cdiffsurface
             params['cdiffstress'] = self.cdiffstress
             params['cutofflongrange'] = uc.model(self.cutofflongrange,
@@ -815,29 +850,31 @@
             pnsolution = self.sdvpn_solution
             pnmodel = pnsolution.model(length_unit=self.units.length_unit,
                                        #energyperarea_unit=self.units.energy_unit,
                                        pressure_unit=self.units.pressure_unit,
                                        include_gamma=False)
             key = 'semidiscrete-variational-Peierls-Nabarro'
             calc[key] = pnmodel[key]
-            
+
             e_per_l_unit = f'{self.units.energy_unit}/{self.units.length_unit}'
             calc['misfit-energy'] = uc.model(pnsolution.misfit_energy(), e_per_l_unit)
             calc['elastic-energy'] = uc.model(pnsolution.elastic_energy(), e_per_l_unit)
             calc['long-range-energy'] = uc.model(pnsolution.longrange_energy(), e_per_l_unit)
             calc['stress-energy'] = uc.model(pnsolution.stress_energy(), e_per_l_unit)
             calc['surface-energy'] = uc.model(pnsolution.surface_energy(), e_per_l_unit)
             calc['nonlocal-energy'] = uc.model(pnsolution.nonlocal_energy(), e_per_l_unit)
             calc['total-energy'] = uc.model(pnsolution.total_energy(), e_per_l_unit)
             calc['total-energy-per-cycle'] = uc.model(self.energies, e_per_l_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -856,18 +893,18 @@
         self.xnum = run_params['xnum']
         self.xstep = run_params['xstep']
         self.xscale = run_params.get('xscale', False)
         self.minimize_cycles = run_params['min_cycles']
 
         # Build results
         if self.status != 'finished':
-            p_per_l_unit = f'{self.units.pressure_unit}/{self.units.length_unit}'
-            p_l_unit = f'{self.units.pressure_unit}*{self.units.length_unit}'
+            #p_per_l_unit = f'{self.units.pressure_unit}/{self.units.length_unit}'
+            #p_l_unit = f'{self.units.pressure_unit}*{self.units.length_unit}'
             params = calc['semidiscrete-variational-Peierls-Nabarro']['parameter']
-            
+
             self.tau = uc.value_unit(params['tau'])
             self.alpha = uc.value_unit(params['alpha'])
             self.beta = uc.value_unit(params['beta'])
             self.cdiffelastic = params['cdiffelastic']
             self.cdiffsurface = params['cdiffsurface']
             self.cdiffstress = params['cdiffstress']
             self.cutofflongrange = uc.value_unit(params['cutofflongrange'])
@@ -875,65 +912,18 @@
             self.minimize_style = params['min_method']
             self.minimize_options = params['min_options']
 
         # Load results
         if self.status == 'finished':
             self.__sdvpn_solution = calc
             self.__energies = uc.value_unit(calc['total-energy-per-cycle'])
-         
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
@@ -954,39 +944,39 @@
         meta['fullstress'] = self.fullstress
         meta['min_method'] = self.minimize_style
         meta['min_options'] = self.minimize_options
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'xnum',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'dislocation_key',
             'gammasurface_calc_key',
-            
+
             'cdiffelastic',
             'cdiffsurface',
             'cdiffstress',
-            
+
             'fullstress',
             'min_method',
             'min_options',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'xmax':1e-2,
             'xstep':1e-2,
             'cutofflongrange':1e-2,
             'K11':1e-2, 
             'K12':1e-2, 
@@ -1005,50 +995,22 @@
             'beta13':1e-2, 
             'beta22':1e-2, 
             'beta23':1e-2, 
             'beta33':1e-2,
             'alpha1':1e-2,
         }
 
-    def isvalid(self):
+    def isvalid(self) -> bool:
         return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
@@ -1077,21 +1039,21 @@
         input_dict['xmax'] = self.xmax
         input_dict['xscale'] = self.xscale
         input_dict['min_method'] = self.minimize_style
         input_dict['min_options'] = self.minimize_options
         input_dict['min_cycles'] = self.minimize_cycles
 
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         self.__sdvpn_solution = results_dict['SDVPN_solution']
         self.__energies = results_dict['minimization_energies']
-        self.__disregistries = results_dict['disregistry_profiles']
+        self.__disregistries = results_dict['disregistry_profiles']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN/dislocation_SDVPN.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN/dislocation_SDVPN.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/__init__.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/__init__.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calc_dislocation_Peierls_Nabarro_stress.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/buildmodel.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/buildmodel.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/compare_terms.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/compare_terms.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/schema.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/schema.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/todict.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/calculation_dislocation_SDVPN_stress/todict.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/dislocation_Peierls_Nabarro_stress_template.ipynb` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/dislocation_Peierls_Nabarro_stress_template.ipynb`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_SDVPN_stress/prepare_dislocation_Peierls_Nabarro_stress.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_SDVPN_stress/prepare_dislocation_Peierls_Nabarro_stress.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole/DislocationMonopole.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole/DislocationMonopole.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,41 +1,60 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 import random
 
 import numpy as np
 
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .dislocation_monopole import dislocation_monopole
-from ...calculation_subset import *
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, LammpsMinimize, Dislocation,
+                                   AtommanElasticConstants)
 from ...input import value, boolean
-from ...tools import aslist, dict_insert
 
 class DislocationMonopole(Calculation):
     """Class for managing dislocation monopole constructions and relaxation"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__minimize = LammpsMinimize(self)
         self.__defect = Dislocation(self)
@@ -54,197 +73,201 @@
         self.__dumpfile_defect = None
         self.__symbols_base = None
         self.__symbols_defect = None
         self.__potential_energy_defect = None
         self.__dislocation = None
         self.__preln = None
         self.__K_tensor = None
-        
+
         # Define calc shortcut
         self.calc = dislocation_monopole
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'dislocation_monopole.py',
             'disl_relax.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def defect(self):
+    def defect(self) -> Dislocation:
         """Dislocation subset"""
         return self.__defect
 
     @property
-    def elastic(self):
+    def elastic(self) -> AtommanElasticConstants:
         """AtommanElasticConstants subset"""
         return self.__elastic
 
     @property
-    def annealtemperature(self):
+    def annealtemperature(self) -> float:
         """float: Temperature to use for annealing the system"""
         return self.__annealtemperature
 
     @annealtemperature.setter
-    def annealtemperature(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__annealtemperature = float(value)
+    def annealtemperature(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__annealtemperature = float(val)
 
     @property
-    def annealsteps(self):
+    def annealsteps(self) -> int:
         """int: Number of time steps to use for annealing the system"""
         if self.__annealsteps is None:
             if self.annealtemperature == 0.0:
                 return 0
             else:
                 return 10000
         else:
             return self.__annealsteps
 
     @annealsteps.setter
-    def annealsteps(self, value):
-        if value is None:
+    def annealsteps(self, val: int):
+        if val is None:
             self.__annealsteps = None
         else:
-            self.__annealsteps = int(value)
+            self.__annealsteps = int(val)
 
     @property
-    def randomseed(self):
-        """str: MD integration scheme"""
+    def randomseed(self) -> int:
+        """int: random number generator seed to use"""
         return self.__randomseed
 
     @randomseed.setter
-    def randomseed(self, value):
-        if value is None:
-            value = random.randint(1, 900000000)
+    def randomseed(self, val: int):
+        if val is None:
+            val = random.randint(1, 900000000)
         else:
-            value = int(value)
-            assert value > 0 and value <= 900000000
-        self.__randomseed = value
+            val = int(val)
+            assert val > 0 and val <= 900000000
+        self.__randomseed = val
 
     @property
-    def boundaryshape(self):
+    def boundaryshape(self) -> str:
         """str: The shape of the boundary region"""
         return self.__boundaryshape
 
     @boundaryshape.setter
-    def boundaryshape(self, value):
-        assert value in ['cylinder', 'box']
-        self.__boundaryshape = value
+    def boundaryshape(self, val: str):
+        assert val in ['cylinder', 'box']
+        self.__boundaryshape = val
 
     @property
-    def boundarywidth(self):
+    def boundarywidth(self) -> float:
         """float: The minimum width of the boundary region"""
         return self.__boundarywidth
 
     @boundarywidth.setter
-    def boundarywidth(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__boundarywidth = float(value)
+    def boundarywidth(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__boundarywidth = float(val)
 
     @property
-    def boundaryscale(self):
+    def boundaryscale(self) -> bool:
         """bool: Flag indicating if boundarywidth is scaled versus the system or absolute"""
         return self.__boundaryscale
 
     @boundaryscale.setter
-    def boundaryscale(self, value):
-        self.__boundaryscale = boolean(value)
+    def boundaryscale(self, val: bool):
+        self.__boundaryscale = boolean(val)
 
     @property
-    def dumpfile_base(self):
+    def dumpfile_base(self) -> str:
         """str: Name of the LAMMPS dump file of the 0 shift reference system"""
         if self.__dumpfile_base is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_base
-    
+
     @property
-    def dumpfile_defect(self):
+    def dumpfile_defect(self) -> str:
         """str: Name of the LAMMPS dump file of the defect system"""
         if self.__dumpfile_defect is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_defect
 
     @property
-    def symbols_base(self):
+    def symbols_base(self) -> list:
         """list: Model symbols for the base system"""
         if self.__symbols_base is None:
             raise ValueError('No results yet!')
         return self.__symbols_base
-    
+
     @property
-    def symbols_defect(self):
+    def symbols_defect(self) -> list:
         """list: Model symbols for the defect system"""
         if self.__symbols_defect is None:
             raise ValueError('No results yet!')
         return self.__symbols_defect
 
     @property
-    def potential_energy_defect(self):
+    def potential_energy_defect(self) -> float:
         """float: Potential energy of the defect system"""
         if self.__potential_energy_defect is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_defect
 
     @property
-    def dislocation(self):
+    def dislocation(self) -> am.defect.Dislocation:
         """atomman.defect.Dislocation: Volterra dislocation solution"""
         if self.__dislocation is None:
             raise ValueError('No results yet!')
         return self.__dislocation
 
     @property
-    def preln(self):
+    def preln(self) -> float:
+        """float: The dislocation's elastic pre-ln energy factor"""
         if self.__preln is None:
             return self.dislocation.dislsol.preln
         else:
             return self.__preln
 
     @property
-    def K_tensor(self):
+    def K_tensor(self) -> np.ndarray:
+        """numpy.ndarray: The dislocation's elastic K tensor"""
         if self.__K_tensor is None:
             return self.dislocation.dislsol.K_tensor
         else:
             return self.__K_tensor
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -281,24 +304,37 @@
         if 'boundaryshape' in kwargs:
             self.boundaryshape = kwargs['boundaryshape']
         if 'boundarywidth' in kwargs:
             self.boundarywidth = kwargs['boundarywidth']
         if 'boundaryscale' in kwargs:
             self.boundaryscale = kwargs['boundaryscale']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['forcetolerance'] = input_dict.get('forcetolerance',
                                                   '1.0e-6 eV/angstrom')
 
         # Load calculation-specific strings
         self.boundaryshape = input_dict.get('dislocation_boundaryshape',
                                             'cylinder')
@@ -309,23 +345,23 @@
 
         # Load calculation-specific integers
         self.randomseed = input_dict.get('randomseed', None)
         self.annealsteps = input_dict.get('annealsteps', None)
 
         # Load calculation-specific unitless floats
         self.annealtemperature = float(input_dict.get('annealtemperature', 0.0))
-        
+
         # Load calculation-specific floats with units
         self.boundarywidth = value(input_dict, 'dislocation_boundarywidth',
                                    default_unit=self.units.length_unit,
                                    default_term='0 angstrom')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load minimization parameters
         self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
@@ -333,15 +369,17 @@
 
         # Load defect parameters
         self.defect.load_parameters(input_dict)
 
         # Load elastic constants
         self.elastic.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -404,27 +442,27 @@
             params['sizemults'] = '1 68 48'
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         # Copy kwargs to params
         for key in kwargs:
-            
+
             # Rename potential-related terms for buildcombos
             if key[:10] == 'potential_':
                 params[f'parent_{key}'] = kwargs[key]
-            
+
             # Copy/overwrite other terms
             else:
                 params[key] = kwargs[key]
 
         return params
-    
+
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'annealtemperature': ' '.join([
                 "The temperature at which to anneal the dislocation system",
                 "If 0, then no MD anneal will be performed."]),
             'annealsteps': ' '.join([
@@ -441,18 +479,18 @@
                 "the active region is a cylinder centered around the dislocation line.",
                 "Default value is 'cylinder'."]),
             'dislocation_boundarywidth': ' '.join([
                 "The minimum thickness of the boundary region."]),
             'dislocation_boundaryscale': ' '.join([
                 "Boolean indicating if boundarywidth is taken as Cartesian (False)",
                 "or scaled by the loaded unit cell's a lattice parameter."]),
-        } 
-    
+        }
+
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
 
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
@@ -463,51 +501,51 @@
             + [
                 'dislocation_boundaryshape',
                 'dislocation_boundarywidth',
                 'dislocation_boundaryscale',
             ]
         )
         return keys
-    
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
         keys = (
             # Universal multikeys
             super().multikeys +
-            
+
             # Combination of potential, system and elastic keys
             [
                 self.potential.keyset +
                 self.system.keyset +
                 self.elastic.keyset
             ] +
-            
+
             # Defect multikeys
             self.defect.multikeys + 
-            
+
             # Combination of minimize and run parameter keys
             [
                 self.minimize.keyset + [
                     'randomseed',
                     'annealtemperature',
                     'annealsteps',
                 ]
             ]
-        )       
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-dislocation-monopole'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -521,48 +559,50 @@
 
         # Build calculation-specific content
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
-        
+
         run_params['dislocation_boundaryshape'] = self.boundaryshape
         run_params['dislocation_boundarywidth'] = self.boundarywidth
         run_params['dislocation_boundaryscale'] = self.boundaryscale
         run_params['annealtemperature'] = self.annealtemperature
         run_params['annealsteps'] = self.annealsteps
 
         # Build results
         if self.status == 'finished':
             calc['base-system'] = DM()
             calc['base-system']['artifact'] = DM()
             calc['base-system']['artifact']['file'] = self.dumpfile_base
             calc['base-system']['artifact']['format'] = 'atom_dump'
             calc['base-system']['symbols'] = self.symbols_base
-            
+
             calc['defect-system'] = DM()
             calc['defect-system']['artifact'] = DM()
             calc['defect-system']['artifact']['file'] = self.dumpfile_defect
             calc['defect-system']['artifact']['format'] = 'atom_dump'
             calc['defect-system']['symbols'] = self.symbols_defect
             calc['defect-system']['potential-energy'] = uc.model(self.potential_energy_defect,
                                                                  self.units.energy_unit)
-            
+
             calc['elastic-solution'] = elsol = DM()
             elsol['pre-ln-factor'] = uc.model(self.preln,
                                              f"{self.units.energy_unit}/{self.units.length_unit}")
-            
+
             elsol['K-tensor'] = uc.model(self.K_tensor,
                                          self.units.pressure_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -582,73 +622,26 @@
         self.annealtemperature = run_params['annealtemperature']
         self.annealsteps = run_params['annealsteps']
 
         # Load results
         if self.status == 'finished':
             self.__dumpfile_base = calc['base-system']['artifact']['file']
             self.__symbols_base = calc['base-system']['symbols']
-                        
+
             self.__dumpfile_defect = calc['defect-system']['artifact']['file']
             self.__symbols_defect = calc['defect-system']['symbols']
             self.__potential_energy_defect = uc.value_unit(calc['defect-system']['potential-energy'])
-            
-            elsol = calc['elastic-solution'] 
+
+            elsol = calc['elastic-solution']
             self.__preln = uc.value_unit(elsol['pre-ln-factor'])
             self.__K_tensor = uc.value_unit(elsol['K-tensor'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
-
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
@@ -669,78 +662,50 @@
             meta['potential_energy_defect'] = self.potential_energy_defect
             meta['preln'] = self.preln
             meta['K_tensor'] = self.K_tensor
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
+
             'a_mult',
             'b_mult',
             'c_mult',
-            
+
             'dislocation_key',
 
             'annealsteps',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'annealtemperature':1,
         }
 
-    def isvalid(self):
+    def isvalid(self) -> bool:
         return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
@@ -750,24 +715,24 @@
         input_dict['randomseed'] = self.randomseed
         input_dict['boundaryshape'] = self.boundaryshape
         input_dict['boundarywidth'] = self.boundarywidth
         input_dict['boundaryscale'] = self.boundaryscale
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         self.__dumpfile_base = results_dict['dumpfile_base']
         self.__dumpfile_defect = results_dict['dumpfile_disl']
         self.__symbols_base = results_dict['symbols_base']
         self.__symbols_defect = results_dict['symbols_disl']
         self.__potential_energy_defect = results_dict['E_total_disl']
-        self.__dislocation = results_dict['dislocation']
+        self.__dislocation = results_dict['dislocation']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole/dislocation_monopole.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole/dislocation_monopole.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole/theory.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/calc_crss.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/calc_crss.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/calc_dislocation_monopole_crss.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/calc_dislocation_monopole_crss.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/data_model.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/data_model.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/prepare.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/prepare.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/read_input.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/read_input.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_monopole_crss/strain_system.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_monopole_crss/strain_system.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/DislocationPeriodicArray.py` & `iprPy-0.11.5/iprPy/calculation/free_energy/FreeEnergy.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,369 +1,389 @@
 # coding: utf-8
-
 # Standard Python libraries
-import uuid
+from io import IOBase
+from pathlib import Path
 from copy import deepcopy
+from typing import Optional, Union
 import random
 
 import numpy as np
+import numpy.typing as npt
 
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
-from .dislocation_periodic_array import dislocation_array
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from .free_energy import free_energy
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate)
+from ...input import value
+from ...tools import aslist
 
-class DislocationPeriodicArray(Calculation):
-    """Class for managing periodic array of dislocations constructions and relaxations"""
+class FreeEnergy(Calculation):
+    """Class for managing dynamic relaxations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
-        self.__minimize = LammpsMinimize(self)
-        self.__defect = Dislocation(self)
-        self.__elastic = AtommanElasticConstants(self)
+        self.__system_mods = AtommanSystemManipulate(self)
         subsets = (self.commands, self.potential, self.system,
-                   self.elastic, self.minimize, self.defect, self.units)
+                   self.system_mods, self.units)
 
         # Initialize unique calculation attributes
-        self.annealtemperature = 0.0
-        self.annealsteps = None
+        self.temperature = None
+        self.spring_constants = None
+        self.equilsteps = 25000
+        self.switchsteps = 50000
+        self.springsteps = 50000
+        self.pressure = 0.0
         self.randomseed = None
-        self.duplicatecutoff = uc.set_in_units(0.5, 'angstrom')
-        self.boundarywidth = 0.0
-        self.boundaryscale = False
-        self.onlylinear = False
-        self.__dumpfile_base = None
-        self.__dumpfile_defect = None
-        self.__symbols_base = None
-        self.__symbols_defect = None
-        self.__potential_energy_defect = None
-        self.__dislocation = None
-        self.__preln = None
-        self.__K_tensor = None
-        
+
+        self.__volume = None
+        self.__natoms = None
+        self.__work_forward = None
+        self.__work_reverse = None
+        self.__work = None
+        self.__helmholtz_reference = None
+        self.__helmholtz = None
+        self.__gibbs = None
+
         # Define calc shortcut
-        self.calc = dislocation_array
+        self.calc = free_energy
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
-            'dislocation_periodic_array.py',
-            'disl_relax.template'
+            'free_energy.py',
+            'msd.template',
+            'free_energy.template'
         ]
 
-############################## Class attributes ###############################
+############################## Class attributes ################################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
-    @property
-    def minimize(self):
-        """LammpsMinimize subset"""
-        return self.__minimize
 
     @property
-    def defect(self):
-        """Dislocation subset"""
-        return self.__defect
+    def system_mods(self) -> AtommanSystemManipulate:
+        """AtommanSystemManipulate subset"""
+        return self.__system_mods
 
     @property
-    def elastic(self):
-        """AtommanElasticConstants subset"""
-        return self.__elastic
+    def temperature(self) -> float:
+        """float: Target temperature"""
+        return self.__temperature
 
-    @property
-    def annealtemperature(self):
-        """float: Temperature to use for annealing the system"""
-        return self.__annealtemperature
-
-    @annealtemperature.setter
-    def annealtemperature(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__annealtemperature = float(value)
+    @temperature.setter
+    def temperature(self, val: float):
+        if val is not None:
+            val = float(val)
+            assert val >= 0.0
+        self.__temperature = val
 
     @property
-    def annealsteps(self):
-        """int: Number of time steps to use for annealing the system"""
-        if self.__annealsteps is None:
-            if self.annealtemperature == 0.0:
-                return 0
-            else:
-                return 10000
-        else:
-            return self.__annealsteps
+    def spring_constants(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The Einstein spring constants for each temperature"""
+        return self.__spring_constants
 
-    @annealsteps.setter
-    def annealsteps(self, value):
-        if value is None:
-            self.__annealsteps = None
-        else:
-            self.__annealsteps = int(value)
+    @spring_constants.setter
+    def spring_constants(self, val: Optional[npt.ArrayLike]):
+        if val is not None:
+            val = np.asarray(aslist(val))
+        self.__spring_constants = val
 
     @property
-    def randomseed(self):
-        """str: MD integration scheme"""
-        return self.__randomseed
+    def equilsteps(self) -> int:
+        """int: The number of ignored equilibration steps at the beginning of simulations"""
+        return self.__equilsteps
 
-    @randomseed.setter
-    def randomseed(self, value):
-        if value is None:
-            value = random.randint(1, 900000000)
-        else:
-            value = int(value)
-            assert value > 0 and value <= 900000000
-        self.__randomseed = value
+    @equilsteps.setter
+    def equilsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__equilsteps = val
 
     @property
-    def duplicatecutoff(self):
-        """float: The cutoff used to identify duplicate atoms"""
-        return self.__duplicatecutoff
+    def switchsteps(self) -> int:
+        """int: The number of steps to perform during the two switch runs."""
+        return self.__switchsteps
 
-    @duplicatecutoff.setter
-    def duplicatecutoff(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__duplicatecutoff = value
+    @switchsteps.setter
+    def switchsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__switchsteps = val
 
     @property
-    def boundarywidth(self):
-        """float: The minimum width of the boundary region"""
-        return self.__boundarywidth
+    def springsteps(self) -> int:
+        """int: The number of steps to perform to evaluate the spring constants."""
+        return self.__springsteps
 
-    @boundarywidth.setter
-    def boundarywidth(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__boundarywidth = float(value)
+    @springsteps.setter
+    def springsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__springsteps = val
 
     @property
-    def boundaryscale(self):
-        """bool: Flag indicating if boundarywidth is scaled versus the system or absolute"""
-        return self.__boundaryscale
+    def randomseed(self) -> int:
+        """int: Random number seed used by LAMMPS."""
+        return self.__randomseed
 
-    @boundaryscale.setter
-    def boundaryscale(self, value):
-        self.__boundaryscale = boolean(value)
+    @randomseed.setter
+    def randomseed(self, val: Optional[int]):
+        if val is None:
+            val = random.randint(1, 900000000)
+        else:
+            val = int(val)
+            assert val > 0 and val <= 900000000
+        self.__randomseed = val
 
     @property
-    def onlylinear(self):
-        """bool: Flag indicating if only linear gradient displacements are used"""
-        return self.__onlylinear
-
-    @onlylinear.setter
-    def onlylinear(self, value):
-        self.__onlylinear = boolean(value)
+    def volume(self) -> float:
+        """float: The total volume of the system."""
+        if self.__volume is None:
+            return self.system_mods.system.box.volume
+        else:
+            return self.__volume
 
     @property
-    def dumpfile_base(self):
-        """str: Name of the LAMMPS dump file of the 0 shift reference system"""
-        if self.__dumpfile_base is None:
-            raise ValueError('No results yet!')
-        return self.__dumpfile_base
-    
-    @property
-    def dumpfile_defect(self):
-        """str: Name of the LAMMPS dump file of the defect system"""
-        if self.__dumpfile_defect is None:
-            raise ValueError('No results yet!')
-        return self.__dumpfile_defect
+    def natoms(self) -> float:
+        """int: The total number of atoms in the system."""
+        if self.__natoms is None:
+            return self.system_mods.system.natoms
+        else:
+            return self.__natoms
 
     @property
-    def symbols_base(self):
-        """list: Model symbols for the base system"""
-        if self.__symbols_base is None:
+    def work_forward(self) -> float:
+        """float: The work/atom during the forward switching step."""
+        if self.__work_forward is None:
             raise ValueError('No results yet!')
-        return self.__symbols_base
-    
+        return self.__work_forward
+
     @property
-    def symbols_defect(self):
-        """list: Model symbols for the defect system"""
-        if self.__symbols_defect is None:
+    def work_reverse(self) -> float:
+        """float: The work/atom during the reverse switching step."""
+        if self.__work_reverse is None:
             raise ValueError('No results yet!')
-        return self.__symbols_defect
+        return self.__work_reverse
 
     @property
-    def potential_energy_defect(self):
-        """float: Potential energy of the defect system"""
-        if self.__potential_energy_defect is None:
+    def work(self) -> float:
+        """float: The reversible work/atom."""
+        if self.__work is None:
             raise ValueError('No results yet!')
-        return self.__potential_energy_defect
+        return self.__work
 
     @property
-    def dislocation(self):
-        """atomman.defect.Dislocation: Volterra dislocation solution"""
-        if self.__dislocation is None:
+    def helmholtz_reference(self) -> float:
+        """float: The Helmholtz free energy/atom for the reference Einstein solid."""
+        if self.__helmholtz_reference is None:
             raise ValueError('No results yet!')
-        return self.__dislocation
+        return self.__helmholtz_reference
 
     @property
-    def preln(self):
-        if self.__preln is None:
-            return self.dislocation.dislsol.preln
-        else:
-            return self.__preln
+    def helmholtz(self) -> float:
+        """float: The Helmholtz free energy/atom."""
+        if self.__helmholtz is None:
+            raise ValueError('No results yet!')
+        return self.__helmholtz
 
     @property
-    def K_tensor(self):
-        if self.__K_tensor is None:
-            return self.dislocation.dislsol.K_tensor
-        else:
-            return self.__K_tensor
+    def gibbs(self) -> float:
+        """float: The Gibbs free energy/atom."""
+        if self.__gibbs is None:
+            raise ValueError('No results yet!')
+        return self.__gibbs
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
             The name to assign to the calculation.  By default, this is set as
             the calculation's key.
-        annealtemperature : float, optional
-            The temperature to use for MD annealing steps.
-        annealsteps : int, optional
-            The number of MD annealing steps to perform.
+        temperature : float, optional
+            The temperature to run at.
+        spring_constants : float, array-like object or None, optional
+            The Einstein solid spring constants to assign to each atom type.  If
+            None (default), then a separate simulation will estimate them using
+            mean squared displacements.
+        equilsteps : int, optional
+            The number of equilibration timesteps at the beginning of simulations
+            to ignore before evaluations.  This is used at the beginning of both
+            the spring constant estimate and before each thermo switch run.
+        switchsteps : int, optional
+            The number of integration steps to perform during the two switch runs.
+        springsteps : int, optional
+            The number of integration steps to perform for the spring constants
+            estimation, which is only done if spring_constants is None.
+        pressure : float, optional
+            A value of pressure to use for computing the Gibbs free energy from
+            the Helmholtz free energy.  NOTE: this is not used to equilibrate the
+            system during this calculation!
         randomseed : int, optional
-            A random number seed to use for generating the initial velocities
-            for the MD anneal.
-        duplicatecutoff : float, optional
-            Distance tolerance to use for identifying duplicate atoms when the
-            dislocation has an edge component.
-        boundarywidth : float, optional
-            The minimum width of the boundary region.
-        boundaryscale : bool, optional
-            Indicates if boundarywidth is absolute (False) or relative to the
-            unit cell's a lattice parameter (True).
-        onlylinear : bool, optional
-            If True, the dislocation solution used will only be based on a
-            linear gradient of displacements rather than the Volterra
-            dislocation solution.
+            Random number seed used by LAMMPS.
         **kwargs : any, optional
             Any keyword parameters supported by the set_values() methods of
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
         super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
-        if 'annealtemperature' in kwargs:
-            self.annealtemperature = kwargs['annealtemperature']
-        if 'annealsteps' in kwargs:
-            self.annealsteps = kwargs['annealsteps']
+        if 'temperature' in kwargs:
+            self.temperature = kwargs['temperature']
+        if 'spring_constants' in kwargs:
+            self.spring_constants = kwargs['spring_constants']
+        if 'equilsteps' in kwargs:
+            self.equilsteps = kwargs['equilsteps']
+        if 'switchsteps' in kwargs:
+            self.switchsteps = kwargs['switchsteps']
+        if 'springsteps' in kwargs:
+            self.springsteps = kwargs['springsteps']
+        if 'pressure' in kwargs:
+            self.pressure = kwargs['pressure']
         if 'randomseed' in kwargs:
             self.randomseed = kwargs['randomseed']
-        if 'duplicatecutoff' in kwargs:
-            self.duplicatecutoff = kwargs['duplicatecutoff']
-        if 'boundarywidth' in kwargs:
-            self.boundarywidth = kwargs['boundarywidth']
-        if 'boundaryscale' in kwargs:
-            self.boundaryscale = kwargs['boundaryscale']
-        if 'onlylinear' in kwargs:
-            self.onlylinear = kwargs['onlylinear']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
-        input_dict['forcetolerance'] = input_dict.get('forcetolerance',
-                                                  '1.0e-6 eV/angstrom')
+        input_dict['sizemults'] = input_dict.get('sizemults', '10 10 10')
 
         # Load calculation-specific strings
-        self.boundaryshape = input_dict.get('dislocation_boundaryshape',
-                                            'cylinder')
 
         # Load calculation-specific booleans
-        self.onlylinear = boolean(input_dict.get('dislocation_onlylinear', False))
-        self.boundaryscale = boolean(input_dict.get('dislocation_boundaryscale',
-                                                    False))
 
         # Load calculation-specific integers
+        self.equilsteps = int(input_dict.get('equilsteps', 25000))
+        self.switchsteps = int(input_dict.get('switchsteps', 50000))
+        self.springsteps = int(input_dict.get('springsteps', 50000))
         self.randomseed = input_dict.get('randomseed', None)
-        self.annealsteps = input_dict.get('annealsteps', None)
 
         # Load calculation-specific unitless floats
-        self.annealtemperature = float(input_dict.get('annealtemperature', 0.0))
-        
+        self.temperature = float(input_dict['temperature'])
+
         # Load calculation-specific floats with units
-        self.boundarywidth = value(input_dict, 'dislocation_boundarywidth',
-                                   default_unit=self.units.length_unit,
-                                   default_term='0 angstrom')
-        self.duplicatecutoff = value(input_dict, 'dislocation_duplicatecutoff',
-                                     default_unit=self.units.length_unit,
-                                     default_term='0.5 angstrom')
-        
+        self.pressure = value(input_dict, 'pressure',
+                              default_unit=self.units.pressure_unit,
+                              default_term='0.0 GPa')
+
+        # Load and split spring constants - None, or float(s) with units energy/area
+        spring_constants = input_dict.get('spring_constants', None)
+        if spring_constants is not None:
+            spring_constants = spring_constants.split()
+            for i in range(len(spring_constants)-1):
+                spring_constants[i] = float(spring_constants[i])
+            try:
+                spring_constants[-1] = float(spring_constants[-1])
+                unit = f'{self.units.energy_unit}/{self.units.length_unit}^2'
+            except:
+                unit = spring_constants.pop(-1)
+            spring_constants = uc.set_in_units(spring_constants, unit)
+        self.spring_constants = spring_constants
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
-        # Load minimization parameters
-        self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
-        # Load defect parameters
-        self.defect.load_parameters(input_dict)
+        # Manipulate system
+        self.system_mods.load_parameters(input_dict)
 
-        # Load elastic constants
-        self.elastic.load_parameters(input_dict)
-
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -375,214 +395,216 @@
             prepare scripts.
 
         Returns
         -------
         params : dict
             The full set of prepare parameters based on the workflow branch
         """
+        raise NotImplementedError('TBD')
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
-        # Check for required kwargs
-        assert 'lammps_command' in kwargs
+        # main branch
+        if branch == 'main':
 
-        # Set common workflow settings
-        params['buildcombos'] = [
-            'atomicarchive load_file parent',
-            'defect dislocation_file'
-        ]
-        params['parent_record'] = 'calculation_elastic_constants_static'
-        params['parent_load_key'] = 'system-info'
-        params['parent_strainrange'] = 1e-7
-        params['defect_record'] = 'dislocation'
-
-        params['dislocation_boundarywidth'] = '3'
-        params['dislocation_boundaryscale'] = 'True'
-        params['dislocation_duplicatecutoff'] = '1 angstrom'
-        params['annealtemperature'] = '10'
-        params['annealsteps'] = '10000000'
-        params['maxiterations'] = '10000'
-        params['maxevaluations'] = '100000'
-
-        # Set branch-specific parameters
-        if branch == 'fcc_edge_mix':
-            params['parent_family'] = 'A1--Cu--fcc'
-            params['defect_id'] = 'A1--Cu--fcc--a-2-110--90-edge--{111}'
-            params['sizemults'] = '1 200 50'
-            params['dislocation_onlylinear'] = 'False'
-
-        elif branch == 'fcc_screw':
-            params['parent_family'] = 'A1--Cu--fcc'
-            params['defect_id'] = 'A1--Cu--fcc--a-2-110--0-screw--{111}'
-            params['sizemults'] = '1 200 50'
-            params['dislocation_onlylinear'] = 'True'
+            # Check for required kwargs
+            assert 'lammps_command' in kwargs
+
+            # Set default workflow settings
+            params['buildcombos'] = [
+                'atomicreference load_file reference',
+                'atomicparent load_file parent'
+            ]
+            params['parent_record'] = 'calculation_E_vs_r_scan'
+            params['parent_load_key'] = 'minimum-atomic-system'
+            params['parent_status'] = 'finished'
+            params['sizemults'] = '10 10 10'
+            params['atomshift'] = '0.05 0.05 0.05'
+            params['temperature'] = '0.0'
+            params['integrator'] = 'nph+l'
+            params['thermosteps'] = '1000'
+            params['runsteps'] = '10000'
+            params['equilsteps'] = '0'
+
+
+            # Copy kwargs to params
+            for key in kwargs:
+
+                # Rename potential-related terms for buildcombos
+                if key[:10] == 'potential_':
+                    params[f'reference_{key}'] = kwargs[key]
+                    params[f'parent_{key}'] = kwargs[key]
+
+                # Copy/overwrite other terms
+                else:
+                    params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
-        # Copy kwargs to params
-        for key in kwargs:
-            
-            # Rename potential-related terms for buildcombos
-            if key[:10] == 'potential_':
-                params[f'parent_{key}'] = kwargs[key]
-            
-            # Copy/overwrite other terms
-            else:
-                params[key] = kwargs[key]
-
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
-            'annealtemperature': ' '.join([
-                "The temperature at which to anneal the dislocation system",
-                "If 0, then no MD anneal will be performed."]),
-            'annealsteps': ' '.join([
-                "The number of MD steps to perform at  the anneal temperature",
-                "before running the energy/force minimization.  Default value",
-                "is 0 if annealtemperature=0, and 10,000 if annealtemperature > 0."]),
+            'temperature': ' '.join([
+                "Target temperature for the simulations.  Required."]),
+            'spring_constants': ' '.join([
+                "The Einstein solid spring constants (in energy/area) to assign",
+                "to each atom type, given as space-delimited floats with optional",
+                "units.  If not given, then a separate simulation will be",
+                "performed to estimate the constants from mean squared displacements"]),
+            'equilsteps': ' '.join([
+                "The number of equilibration timesteps at the beginning of",
+                "simulations to ignore before evaluations.  This is used at",
+                "the beginning of both the spring constant estimate and before",
+                "each thermo switch run.  Default value is 25000."]),
+            'switchsteps': ' '.join([
+                "The number of integration steps to perform during each of the two",
+                "switch runs.  Default value is 50000."]),
+            'springsteps': ' '.join([
+                "The number of integration steps to perform for the spring",
+                "constants estimation, which is only done if spring_constants are",
+                "not given.  Default value is 50000."]),
+            'pressure': ' '.join([
+                "A value of pressure to use for computing the Gibbs free energy",
+                "from the Helmholtz free energy.  NOTE: this is not used to",
+                "equilibrate the system during this calculation!  Default value",
+                "is 0.0."]),
             'randomseed': ' '.join([
                 "An int random number seed to use for generating initial velocities.",
                 "A random int will be selected if not given."]),
-            'dislocation_duplicatecutoff': ' '.join([
-                "The cutoff distance to use for determining duplicate atoms to delete",
-                "associated with the extra half-plane formed by a dislocation's edge",
-                "component.  Default value is 0.5 Angstroms."]),
-            'dislocation_boundarywidth': ' '.join([
-                "The minimum thickness of the boundary region."]),
-            'dislocation_boundaryscale': ' '.join([
-                "Boolean indicating if boundarywidth is taken as Cartesian (False)",
-                "or scaled by the loaded unit cell's a lattice parameter."]),
-            'dislocation_onlylinear': ' '.join([
-                "Boolean, which if True will only use linear gradient displacements",
-                "to form the dislocation and not the Volterra solution displacements.",
-                "Setting this to be True is useful for screw dislocations that",
-                "dissociate as it ensures that the resulting structure will dissociate",
-                "along the correct slip plane."]),
-        } 
-    
+        }
+
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
-            + [
-                'dislocation_duplicatecutoff',
-                'dislocation_boundarywidth',
-                'dislocation_boundaryscale',
-                'dislocation_onlylinear',
-            ]
         )
         return keys
-    
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
+
         keys = (
             # Universal multikeys
             super().multikeys +
-            
-            # Combination of potential, system and elastic keys
+
+            # Combination of potential and system keys
             [
                 self.potential.keyset +
                 self.system.keyset +
-                self.elastic.keyset
+                # Phase parameters
+                [
+                    'temperature',
+                    'pressure',
+                    'spring_constants',
+                ]
+            ] +
+
+            # System mods keys
+            [
+                self.system_mods.keyset
             ] +
-            
-            # Defect multikeys
-            self.defect.multikeys + 
-            
-            # Combination of minimize and run parameter keys
+
+            # Run parameters
             [
-                self.minimize.keyset + [
+                [
+                    'equilsteps',
+                    'switchsteps',
+                    'springsteps',
                     'randomseed',
-                    'annealtemperature',
-                    'annealsteps',
                 ]
             ]
         )
-                    
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
-        return 'calculation-dislocation-periodic-array'
+        return 'calculation-free-energy'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
         # Build subset content
         self.commands.build_model(calc, after='atomman-version')
         self.potential.build_model(calc, after='calculation')
         self.system.build_model(calc, after='potential-LAMMPS')
-        self.defect.build_model(calc, after='system-info')
-        self.minimize.build_model(calc)
-        self.elastic.build_model(calc)
+        self.system_mods.build_model(calc)
 
         # Build calculation-specific content
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
 
-        run_params['dislocation_boundarywidth'] = self.boundarywidth
-        run_params['dislocation_boundaryscale'] = self.boundaryscale
-        run_params['dislocation_onlylinear'] = self.onlylinear
-        run_params['annealtemperature'] = self.annealtemperature
-        run_params['annealsteps'] = self.annealsteps
+        run_params['equilsteps'] = self.equilsteps
+        run_params['switchsteps'] = self.switchsteps
+        run_params['springsteps'] = self.springsteps
+        run_params['randomseed'] = self.randomseed
+
+        # Save phase-state info
+        calc['phase-state'] = DM()
+        calc['phase-state']['temperature'] = uc.model(self.temperature, 'K')
+        calc['phase-state']['pressure'] = uc.model(self.pressure,
+                                                   self.units.pressure_unit)
 
         # Build results
         if self.status == 'finished':
-            calc['base-system'] = DM()
-            calc['base-system']['artifact'] = DM()
-            calc['base-system']['artifact']['file'] = self.dumpfile_base
-            calc['base-system']['artifact']['format'] = 'atom_dump'
-            calc['base-system']['symbols'] = self.symbols_base
-            
-            calc['defect-system'] = DM()
-            calc['defect-system']['artifact'] = DM()
-            calc['defect-system']['artifact']['file'] = self.dumpfile_defect
-            calc['defect-system']['artifact']['format'] = 'atom_dump'
-            calc['defect-system']['symbols'] = self.symbols_defect
-            calc['defect-system']['potential-energy'] = uc.model(self.potential_energy_defect,
-                                                                 self.units.energy_unit)
-            
-            calc['elastic-solution'] = elsol = DM()
-            elsol['pre-ln-factor'] = uc.model(self.preln,
-                                             f"{self.units.energy_unit}/{self.units.length_unit}")
-            
-            elsol['K-tensor'] = uc.model(self.K_tensor,
-                                         self.units.pressure_unit)
+
+            # Save the total system volume and number of atoms
+            calc['volume'] = uc.model(self.volume,
+                                      f'{self.units.length_unit}^3')
+            calc['natoms'] = self.natoms
+
+            # Save the spring constants used
+            calc['spring-constants'] = uc.model(self.spring_constants,
+                                                f'{self.units.energy_unit}/{self.units.length_unit}^2')
+
+            # Save the computed energy terms
+            calc['work-forward'] = uc.model(self.work_forward,
+                                            self.units.energy_unit)
+            calc['work-reverse'] = uc.model(self.work_reverse,
+                                            self.units.energy_unit)
+            calc['work'] = uc.model(self.work, self.units.energy_unit)
+            calc['Helmholtz-energy-reference'] = uc.model(self.helmholtz_reference,
+                                                          self.units.energy_unit)
+            calc['Helmholtz-energy'] = uc.model(self.helmholtz,
+                                                self.units.energy_unit)
+            calc['Gibbs-energy'] = uc.model(self.gibbs,
+                                            self.units.energy_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -592,203 +614,137 @@
         """
         # Load universal and subset content
         super().load_model(model, name=name)
         calc = self.model[self.modelroot]
 
         # Load calculation-specific content
         run_params = calc['calculation']['run-parameter']
-        self.boundarywidth = run_params['dislocation_boundarywidth']
-        self.boundaryscale = run_params['dislocation_boundaryscale']
-        self.onlylinear = run_params['dislocation_onlylinear']
-        self.annealtemperature = run_params['annealtemperature']
-        self.annealsteps = run_params['annealsteps']
+        self.equilsteps = run_params['equilsteps']
+        self.switchsteps = run_params['switchsteps']
+        self.springsteps = run_params['springsteps']
+        self.randomseed = run_params['randomseed']
+
+        # Load phase-state info
+        self.temperature = uc.value_unit(calc['phase-state']['temperature'])
+        self.pressure = uc.value_unit(calc['phase-state']['pressure'])
 
         # Load results
         if self.status == 'finished':
-            self.__dumpfile_base = calc['base-system']['artifact']['file']
-            self.__symbols_base = calc['base-system']['symbols']
-                        
-            self.__dumpfile_defect = calc['defect-system']['artifact']['file']
-            self.__symbols_defect = calc['defect-system']['symbols']
-            #self.__potential_energy_defect = uc.value_unit(calc['defect-system']['potential-energy'])
-            
-            elsol = calc['elastic-solution'] 
-            self.__preln = uc.value_unit(elsol['pre-ln-factor'])
-            self.__K_tensor = uc.value_unit(elsol['K-tensor'])
-
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
+            self.__volume = uc.value_unit(calc['volume'])
+            self.__natoms = calc['natoms']
+            self.__spring_constants = uc.value_unit(calc['spring-constants'])
+            self.__work_forward = uc.value_unit(calc['work-forward'])
+            self.__work_reverse = uc.value_unit(calc['work-reverse'])
+            self.__work = uc.value_unit(calc['work'])
+            self.__helmholtz_reference = uc.value_unit(calc['Helmholtz-energy-reference'])
+            self.__helmholtz = uc.value_unit(calc['Helmholtz-energy'])
+            self.__gibbs = uc.value_unit(calc['Gibbs-energy'])
+
+    @property
+    def queries(self) -> dict:
+        queries = deepcopy(super().queries)
+        queries.update({
+            'temperature': load_query(
+                style='float_match',
+                name='temperature',
+                path=f'{self.modelroot}.phase-state.temperature.value',
+                description='search by temperature in Kelvin'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        meta['boundarywidth'] = self.boundarywidth
-        meta['boundaryscale'] = self.boundaryscale
-        meta['onlylinear'] = self.onlylinear
-        meta['annealtemperature'] = self.annealtemperature
-        meta['annealsteps'] = self.annealsteps
-        
+        meta['temperature'] = self.temperature
+        meta['pressure'] = self.pressure
+
         # Extract results
-        if self.status == 'finished':            
-            meta['dumpfile_base'] = self.dumpfile_base
-            meta['dumpfile_defect'] = self.dumpfile_defect
-            meta['symbols_base'] = self.symbols_base
-            meta['symbols_defect'] = self.symbols_defect
-            #meta['potential_energy_defect'] = self.potential_energy_defect
-            meta['preln'] = self.preln
-            meta['K_tensor'] = self.K_tensor
+        if self.status == 'finished':
+            meta['spring_constants'] = self.spring_constants.tolist()
+            meta['volume'] = self.volume
+            meta['natoms'] = self.natoms
+            meta['work_forward'] = self.work_forward
+            meta['work_reverse'] = self.work_reverse
+            meta['work'] = self.work
+            meta['Helmholtz_reference'] = self.helmholtz_reference
+            meta['Helmholtz'] = self.helmholtz
+            meta['Gibbs'] = self.gibbs
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
-            'load_file',
+
+            'parent_key',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
-            'a_mult',
-            'b_mult',
-            'c_mult',
-            
-            'dislocation_key',
-
-            'annealsteps',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
-            'annealtemperature':1,
+            'temperature':1e-2,
+            'pressure':1e-2,
         }
 
-    def isvalid(self):
-        return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
-            
-        # Modify inputs for calculation
-        input_dict['annealtemp'] = self.annealtemperature
-        input_dict['annealsteps'] = self.annealsteps
+
+        # Remove unused subset inputs
+        del input_dict['transform']
+        del input_dict['ucell']
+
+        # Add calculation-specific inputs
+        input_dict['temperature'] = self.temperature
+        input_dict['spring_constants'] = self.spring_constants
+        input_dict['pressure'] = self.pressure
+
+        input_dict['equilsteps'] = self.equilsteps
+        input_dict['switchsteps'] = self.switchsteps
+        input_dict['springsteps'] = self.springsteps
         input_dict['randomseed'] = self.randomseed
-        input_dict['linear'] = self.onlylinear
-        input_dict['cutoff'] = self.duplicatecutoff
-        input_dict['boundarywidth'] = self.boundarywidth
-        input_dict['boundaryscale'] = self.boundaryscale
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
-        self.__dumpfile_base = results_dict['dumpfile_base']
-        self.__dumpfile_defect = results_dict['dumpfile_disl']
-        self.__symbols_base = results_dict['symbols_base']
-        self.__symbols_defect = results_dict['symbols_disl']
-        self.__potential_energy_defect = results_dict['E_total_disl']
-        self.__dislocation = results_dict['dislocation']
+        self.spring_constants = results_dict['spring_constants']
+        self.__work_forward = results_dict['work_forward']
+        self.__work_reverse = results_dict['work_reverse']
+        self.__work = results_dict['work']
+        self.__helmholtz_reference = results_dict['Helmholtz_reference']
+        self.__helmholtz = results_dict['Helmholtz']
+        self.__gibbs = results_dict['Gibbs']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/dislocation_periodic_array.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/dislocation_periodic_array.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array/theory.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/DislocationPeriodicArrayStress.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/DislocationPeriodicArrayStress.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calc_dislocation_periodic_array_stress.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/CalculationDislocationPeriodicArrayStress.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/CalculationDislocationPeriodicArrayStress.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/README.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/calculation_dislocation_periodic_array_stress/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/dislarray_free_stress.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/dislarray_free_stress.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/dislarray_rigid_stress.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/dislarray_rigid_stress.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_periodic_array_stress/theory.md` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array_stress/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/522c8437-eceb-480d-8f0c-77f83cdb3125.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/522c8437-eceb-480d-8f0c-77f83cdb3125.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/base.dat` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/base.dat`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/110-edge.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/110-edge.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/111-screw.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/111-screw.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc/112-edge.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc/112-edge.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/bcc.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/bcc.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.in` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.in`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/calc_dislocation_vacancy.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/create_sys.in` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/create_sys.in`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl.dat` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl.dat`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl.dump` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl.dump`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.in` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.in`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.template` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax_script.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/disl_relax_script.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/fcc.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/fcc.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/log.lammps` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/log.lammps`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/calc_files/results.json` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/calc_files/results.json`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/data_model.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/data_model.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/prepare.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/prepare.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/dislocation_vacancy/read_input.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_vacancy/read_input.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/__init__.py` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/__init__.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.in` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.in`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.py` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.py`

 * *Files 1% similar despite different names*

```diff
@@ -398,44 +398,44 @@
     all_eps = [['xx+', 'xx-'], ['yy+', 'yy-'], ['zz+', 'zz-'], ['yz+', 'yz-'], ['xz+', 'xz-'], ['xy+', 'xy-']]
     
     # Iterate over strain components
     for i, eps in enumerate(all_eps):
         
         # Calculate elastic constants
         delta_strain = raw_dict[eps[0]]['strain'][i] - raw_dict[eps[1]]['strain'][i]
-        print delta_strain
+        print(delta_strain)
         delta_stress = - np.array([ raw_dict[eps[0]]['pxx'][0] - raw_dict[eps[1]]['pxx'][0], 
                                     raw_dict[eps[0]]['pyy'][0] - raw_dict[eps[1]]['pyy'][0], 
                                     raw_dict[eps[0]]['pzz'][0] - raw_dict[eps[1]]['pzz'][0], 
                                     raw_dict[eps[0]]['pyz'][0] - raw_dict[eps[1]]['pyz'][0], 
                                     raw_dict[eps[0]]['pxz'][0] - raw_dict[eps[1]]['pxz'][0], 
                                     raw_dict[eps[0]]['pxy'][0] - raw_dict[eps[1]]['pxy'][0] ])
-        print np.array_str(delta_stress, precision=4, supress_small=True)
+        print(np.array_str(delta_stress, precision=4, supress_small=True))
         cij[i] = delta_stress / delta_strain
         
         # Calculate error
         cij_std[i] = np.array([ raw_dict[eps[0]]['pxx'][1]**2 + raw_dict[eps[1]]['pxx'][1]**2,
                                 raw_dict[eps[0]]['pyy'][1]**2 + raw_dict[eps[1]]['pyy'][1]**2,
                                 raw_dict[eps[0]]['pzz'][1]**2 + raw_dict[eps[1]]['pzz'][1]**2,
                                 raw_dict[eps[0]]['pyz'][1]**2 + raw_dict[eps[1]]['pyz'][1]**2,
                                 raw_dict[eps[0]]['pxz'][1]**2 + raw_dict[eps[1]]['pxz'][1]**2,
                                 raw_dict[eps[0]]['pxy'][1]**2 + raw_dict[eps[1]]['pxy'][1]**2 ])**0.5 / delta_strain
 
-    print
-    print np.array_str(cij, precision=4, suppress_small=True)
-    print np.array_str(cij_std, precision=4, suppress_small=True)
+    print()
+    print(np.array_str(cij, precision=4, suppress_small=True))
+    print(np.array_str(cij_std, precision=4, suppress_small=True))
     
     # Average symmetric terms
     for i in xrange(6):
         for j in xrange(i):
             cij[i,j] = cij[j,i] = (cij[i,j] + cij[j,i]) / 2
             cij_std[i,j] = cij_std[j,i] = (cij_std[i,j] + cij_std[j,i]) / 2
-    print
-    print np.array_str(cij, precision=4, suppress_small=True)
-    print np.array_str(cij_std, precision=4, suppress_small=True)
+    print()
+    print(np.array_str(cij, precision=4, suppress_small=True))
+    print(np.array_str(cij_std, precision=4, suppress_small=True))
             
     results_dict['C'] = am.ElasticConstants(Cij=cij)
     results_dict['cij_std'] = cij_std
     
     return results_dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.template` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/calc_dynamic_elastic.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_dynamic/full_relax.template` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_dynamic/full_relax.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_static/ElasticConstantsStatic.py` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_static/ElasticConstantsStatic.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,35 +1,61 @@
 # coding: utf-8
 # Standard Python libraries
+from io import IOBase
+from pathlib import Path
+from copy import deepcopy
+from typing import Optional, Union
 
-from yabadaba import query
+from yabadaba import load_query
+
+import numpy as np
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .elastic_constants_static import elastic_constants_static
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate,
+                                   LammpsMinimize)
 
 class ElasticConstantsStatic(Calculation):
     """Class for managing static elastic constants calculations from small strains"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
+
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
         self.__minimize = LammpsMinimize(self)
@@ -37,93 +63,95 @@
                    self.system_mods, self.minimize, self.units)
 
         # Initialize unique calculation attributes
         self.strainrange = 1e-6
         self.__C = None
         self.__raw_Cij_positive = None
         self.__raw_Cij_negative = None
-        
+
         # Define calc shortcut
         self.calc = elastic_constants_static
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'elastic_constants_static.py',
             'cij.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
-    
+
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def strainrange(self):
+    def strainrange(self) -> float:
         """float: Strain step size used in estimating elastic constants"""
         return self.__strainrange
 
     @strainrange.setter
-    def strainrange(self, value):
-        self.__strainrange = float(value)
-        
+    def strainrange(self, val: float):
+        self.__strainrange = float(val)
+
     @property
-    def C(self):
+    def C(self) -> am.ElasticConstants:
         """atomman.ElasticConstants: Averaged elastic constants"""
         if self.__C is None:
             raise ValueError('No results yet!')
         return self.__C
 
     @property
-    def raw_Cij_positive(self):
+    def raw_Cij_positive(self) -> np.ndarray:
         """numpy.NDArray: Cij 6x6 array measured using positive strain steps"""
         if self.__raw_Cij_positive is None:
             raise ValueError('No results yet!')
         return self.__raw_Cij_positive
 
     @property
-    def raw_Cij_negative(self):
+    def raw_Cij_negative(self) -> np.ndarray:
         """numpy.NDArray: Cij 6x6 array measured using negative strain steps"""
         if self.__raw_Cij_negative is None:
             raise ValueError('No results yet!')
         return self.__raw_Cij_negative
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -138,56 +166,71 @@
         # Call super to set universal and subset content
         super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
         if 'strainrange' in kwargs:
             self.strainrange = kwargs['strainrange']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '3 3 3')
         input_dict['forcetolerance'] = input_dict.get('forcetolerance',
                                                   '1.0e-6 eV/angstrom')
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
 
         # Load calculation-specific unitless floats
         self.strainrange = float(input_dict.get('strainrange', 1e-6))
 
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load minimization parameters
         self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -205,15 +248,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'atomicparent load_file parent'
             params['parent_record'] = 'relaxed_crystal'
             params['parent_standing'] = 'good'
@@ -221,94 +264,94 @@
             params['maxiterations'] = '5000'
             params['maxevaluations'] = '10000'
             params['strainrange'] = ['1e-6', '1e-7', '1e-8']
 
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'strainrange': ' '.join([
                 "The strain range to apply to the system to evaluate the",
                 "elastic constants.  Default value is '1e-6'"]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
         return keys
-    
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
-            
+
             # Strainrange
             [
                 [
                     'strainrange',
                 ]
             ] +
-            
+
             [
                 self.minimize.keyset
             ]
-        )    
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-elastic-constants-static'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -333,23 +376,25 @@
             cij['Cij'] = uc.model(self.raw_Cij_negative,
                                   self.units.pressure_unit)
             calc.append('raw-elastic-constants', cij)
             cij = DM()
             cij['Cij'] = uc.model(self.raw_Cij_positive,
                                   self.units.pressure_unit)
             calc.append('raw-elastic-constants', cij)
-            
+
             calc['elastic-constants'] = DM()
             calc['elastic-constants']['Cij'] = uc.model(self.C.Cij,
                                                         self.units.pressure_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -368,151 +413,74 @@
         # Load results
         if self.status == 'finished':
             self.__raw_Cij_negative = uc.value_unit(calc['raw-elastic-constants'][0]['Cij'])
             self.__raw_Cij_positive = uc.value_unit(calc['raw-elastic-constants'][1]['Cij'])
             Cij = uc.value_unit(calc['elastic-constants']['Cij'])
             self.__C = am.ElasticConstants(Cij=Cij)
 
-    def mongoquery(self, strainrange=None, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        strainrange : float or list, optional
-            strainrange values to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.strain-range', strainrange)
-
-        return mquery
-
-    def cdcsquery(self, strainrange=None, **kwargs):
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        strainrange : float or list, optional
-            strainrange values to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.strain-range', strainrange)
-        
-        return mquery
+    @property
+    def queries(self) -> dict:
+        queries = deepcopy(super().queries)
+        queries.update({
+            'strainrange': load_query(
+                style='float_match',
+                name='strainrange',
+                path=f'{self.modelroot}.calculation.run-parameter.strain-range',
+                description='search by strain range used'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
         meta['strainrange'] = self.strainrange
-        
+
         # Extract results
         if self.status == 'finished':
             meta['C'] = self.C
             meta['raw_Cij_negative'] = self.raw_Cij_negative
             meta['raw_Cij_positive'] = self.raw_Cij_positive
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
-        #    'a_mult',
-        #    'b_mult',
-        #    'c_mult',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'strainrange':1e-10,
         }
 
-    def pandasfilter(self, dataframe, strainrange=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        strainrange : float or list, optional
-            strainrange values to parse by.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        matches = (matches
-            &query.str_match.pandas(dataframe, 'strainrange', strainrange)
-        )
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
@@ -521,16 +489,16 @@
         del input_dict['ucell']
 
         # Add calculation-specific inputs
         input_dict['strainrange'] = self.strainrange
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_static/README.md` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_static/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_static/cij.template` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_static/cij.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_static/elastic_constants_static.py` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_static/elastic_constants_static.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/elastic_constants_static/theory.md` & `iprPy-0.11.5/iprPy/calculation/elastic_constants_static/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/energy_check/EnergyCheck.py` & `iprPy-0.11.5/iprPy/calculation/energy_check/EnergyCheck.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,54 @@
 # coding: utf-8
+# Standard Python libraries
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
+
+
+from DataModelDict import DataModelDict as DM
 
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # iprPy imports
 from .. import Calculation
 from .energy_check import energy_check
-from ...calculation_subset import *
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad)
 
 class EnergyCheck(Calculation):
     """Class for managing potential energy checks of structures"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
+
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         subsets = (self.commands, self.potential, self.system, self.units)
 
@@ -32,145 +59,160 @@
         self.calc = energy_check
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'energy_check.py',
             'run0.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: The measured potential energy per atom for the system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
 
         # Load calculation-specific unitless floats
 
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
-            ] 
-        )       
+            ]
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-energy-check'
-    
-    def build_model(self):
+
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
         # Build subset content
         self.commands.build_model(calc, after='atomman-version')
         self.potential.build_model(calc, after='calculation')
         self.system.build_model(calc, after='potential-LAMMPS')
 
         # Build results
         if self.status == 'finished':
-          
+
             # Save the final cohesive energy
             calc['potential-energy'] = uc.model(self.potential_energy,
                                                 self.units.energy_unit,
                                                 None)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -184,65 +226,65 @@
 
         # Load results
         if self.status == 'finished':
             self.__potential_energy = uc.value_unit(calc['potential-energy'])
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
-        
+
         # Extract results
         if self.status == 'finished':
             meta['E_pot'] = self.potential_energy
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
+
             'parent_key',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
         ]
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
         # Rename ucell to system
         input_dict['system'] = input_dict.pop('ucell')
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
-        self.__potential_energy = results_dict['E_pot']
+        self.__potential_energy = results_dict['E_pot']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/energy_check/README.md` & `iprPy-0.11.5/iprPy/calculation/energy_check/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/energy_check/energy_check.py` & `iprPy-0.11.5/iprPy/calculation/energy_check/energy_check.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/free_energy/FreeEnergy.py` & `iprPy-0.11.5/iprPy/calculation/phonon/Phonon.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,347 +1,378 @@
 # coding: utf-8
 # Standard Python libraries
-from typing import Optional
-import random
+from io import IOBase
+from pathlib import Path
+from copy import deepcopy
+from typing import Optional, Union
 
-import numpy as np
+from yabadaba import load_query
 
-from yabadaba import query
+# http://www.numpy.org/
+import numpy as np
 
 # https://github.com/usnistgov/atomman
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
-from .free_energy import free_energy
-from ...calculation_subset import *
+from .calc_phonon import phonon_quasiharmonic
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad)
 from ...input import value
-from ...tools import aslist
 
-class FreeEnergy(Calculation):
-    """Class for managing dynamic relaxations"""
+class Phonon(Calculation):
+    """Class for managing phonon and quasiharmonic calculations using phonopy"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
-        self.__system_mods = AtommanSystemManipulate(self)
         subsets = (self.commands, self.potential, self.system,
-                   self.system_mods, self.units)
+                   self.units)
 
         # Initialize unique calculation attributes
-        self.temperature = None
-        self.spring_constants = None
-        self.equilsteps = 25000
-        self.switchsteps = 50000
-        self.springsteps = 50000
-        self.pressure = 0.0
-        self.randomseed = None
-        
-        self.__volume = None
-        self.__natoms = None
-        self.__work_forward = None
-        self.__work_reverse = None
-        self.__work = None
-        self.__helmholtz_reference = None
-        self.__helmholtz = None
-        self.__gibbs = None
+        self.strainrange = 0.01
+        self.displacementdistance = uc.set_in_units(0.01, 'angstrom')
+        self.symmetryprecision = 1e-5
+        self.numstrains = 5
+        self.a_mult = 2
+        self.b_mult = 2
+        self.c_mult = 2
+        self.__bandstructure = None
+        self.__dos = None
+        self.__thermal = None
+        self.__volumescan = None
+        self.__E0 = None
+        self.__B0 = None
+        self.__B0prime = None
+        self.__V0 = None
+        self.__phonons = None
+        self.__qha = None
 
         # Define calc shortcut
-        self.calc = free_energy
+        self.calc = phonon_quasiharmonic
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
-            'free_energy.py',
-            'msd.template',
-            'free_energy.template'
+            'calc_phonon.py',
+            'phonon.template'
         ]
 
-############################## Class attributes ################################
+############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def system_mods(self):
-        """AtommanSystemManipulate subset"""
-        return self.__system_mods
-
-    @property
-    def temperature(self) -> float:
-        """float: Target temperature"""
-        return self.__temperature
+    def strainrange(self) -> float:
+        """float: Strain step size to use for quasiharmonic method"""
+        return self.__strainrange
 
-    @temperature.setter
-    def temperature(self, value):
-        if value is not None:
-            value = float(value)
-            assert value >= 0.0
-        self.__temperature = value
+    @strainrange.setter
+    def strainrange(self, val: float):
+        self.__strainrange = float(val)
 
     @property
-    def spring_constants(self) -> Optional[np.ndarray]:
-        """numpy.ndarray or None: The Einstein spring constants for each temperature"""
-        return self.__spring_constants
+    def numstrains(self) -> int:
+        """int: Number of strain states to use for quasiharmonic method"""
+        return self.__numstrains
 
-    @spring_constants.setter
-    def spring_constants(self, value):
-        if value is not None:
-            value = np.asarray(aslist(value))
-        self.__spring_constants = value
+    @numstrains.setter
+    def numstrains(self, val: int):
+        self.__numstrains = int(val)
 
     @property
-    def equilsteps(self) -> int:
-        """int: The number of ignored equilibration steps at the beginning of simulations"""
-        return self.__equilsteps
+    def a_mult(self) -> int:
+        """int: Number of replicas along the a box vect to use"""
+        return self.__a_mult
 
-    @equilsteps.setter
-    def equilsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__equilsteps = value
+    @a_mult.setter
+    def a_mult(self, val: int):
+        self.__a_mult = int(val)
 
     @property
-    def switchsteps(self) -> int:
-        """int: The number of steps to perform during the two switch runs."""
-        return self.__switchsteps
+    def b_mult(self) -> int:
+        """int: Number of replicas along the b box vect to use"""
+        return self.__b_mult
 
-    @switchsteps.setter
-    def switchsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__switchsteps = value
+    @b_mult.setter
+    def b_mult(self, val: int):
+        self.__b_mult = int(val)
 
     @property
-    def springsteps(self) -> int:
-        """int: The number of steps to perform to evaluate the spring constants."""
-        return self.__springsteps
+    def c_mult(self) -> int:
+        """int: Number of replicas along the c box vect to use"""
+        return self.__c_mult
 
-    @springsteps.setter
-    def springsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__springsteps = value
+    @c_mult.setter
+    def c_mult(self, val: int):
+        self.__c_mult = int(val)
 
     @property
-    def randomseed(self) -> Optional[int]:
-        """int or None: Random number seed used by LAMMPS."""
-        return self.__randomseed
+    def sizemults(self) -> tuple:
+        """tuple: All three sets of size multipliers"""
+        return (self.a_mult, self.b_mult, self.c_mult)
 
-    @randomseed.setter
-    def randomseed(self, value):
-        if value is None:
-            value = random.randint(1, 900000000)
+    @sizemults.setter
+    def sizemults(self, val: Union[list, tuple]):
+        if len(value) == 3:
+            self.a_mult = val[0]
+            self.b_mult = val[1]
+            self.c_mult = val[2]
         else:
-            value = int(value)
-            assert value > 0 and value <= 900000000
-        self.__randomseed = value
+            raise ValueError('len of sizemults must be 3')
 
     @property
-    def volume(self) -> float:
-        """float: The total volume of the system."""
-        if self.__volume is None:
-            return self.system_mods.system.box.volume
-        else:
-            return self.__volume
+    def symmetryprecision(self) -> float:
+        """float: Precision tolerance to use to identify symmetry elements"""
+        return self.__symmetryprecision
+
+    @symmetryprecision.setter
+    def symmetryprecision(self, val: float):
+        self.__symmetryprecision = float(val)
 
     @property
-    def natoms(self) -> float:
-        """int: The total number of atoms in the system."""
-        if self.__natoms is None:
-            return self.system_mods.system.natoms
-        else:
-            return self.__natoms
-        
+    def displacementdistance(self) -> float:
+        """float: Random max atomic displacement to use for phonon calculations"""
+        return self.__displacementdistance
+
+    @displacementdistance.setter
+    def displacementdistance(self, val: float):
+        self.__displacementdistance = float(val)
+
     @property
-    def work_forward(self) -> float:
-        """float: The work/atom during the forward switching step."""
-        if self.__work_forward is None:
+    def bandstructure(self) -> dict:
+        """dict: band structure information"""
+        if self.__bandstructure is None:
             raise ValueError('No results yet!')
-        return self.__work_forward
+        return self.__bandstructure
 
     @property
-    def work_reverse(self) -> float:
-        """float: The work/atom during the reverse switching step."""
-        if self.__work_reverse is None:
+    def dos(self) -> dict:
+        """dict: density of states information"""
+        if self.__dos is None:
             raise ValueError('No results yet!')
-        return self.__work_reverse
+        return self.__dos
 
     @property
-    def work(self) -> float:
-        """float: The reversible work/atom."""
-        if self.__work is None:
+    def thermal(self) -> dict:
+        """dict: estimated properties vs temperature"""
+        if self.__thermal is None:
             raise ValueError('No results yet!')
-        return self.__work
+        return self.__thermal
 
     @property
-    def helmholtz_reference(self) -> float:
-        """float: The Helmholtz free energy/atom for the reference Einstein solid."""
-        if self.__helmholtz_reference is None:
-            raise ValueError('No results yet!')
-        return self.__helmholtz_reference
+    def phonons(self) -> list:
+        """list: phonopy.Phonopy objects for each strain"""
+        if self.__phonons is None:
+            raise ValueError('phonon objects not set...')
+        return self.__phonons
 
     @property
-    def helmholtz(self) -> float:
-        """float: The Helmholtz free energy/atom."""
-        if self.__helmholtz is None:
-            raise ValueError('No results yet!')
-        return self.__helmholtz
+    def qha(self):
+        """phonopy.PhonopyQHA: quasiharmonic approximation object"""
+        if self.__qha is None:
+            raise ValueError('phonon qha object not set...')
+        return self.__qha
 
     @property
-    def gibbs(self) -> float:
-        """float: The Gibbs free energy/atom."""
-        if self.__gibbs is None:
-            raise ValueError('No results yet!')
-        return self.__gibbs
+    def volumescan(self) -> dict:
+        """dict: volume-energy scan used for quasiharmonic"""
+        if self.__volumescan is None:
+            raise ValueError('No quasiharmonic results!')
+        return self.__volumescan
 
-    def set_values(self, name=None, **kwargs):
+    @property
+    def E0(self) -> float:
+        """float: energy estimated for the equilibrium structure from the volume scan"""
+        if self.__E0 is None:
+            raise ValueError('No quasiharmonic results!')
+        return self.__E0
+
+    @property
+    def B0(self) -> float:
+        """float: bulk modulus estimated at the equilibrium structure from the volume scan"""
+        if self.__B0 is None:
+            raise ValueError('No quasiharmonic results!')
+        return self.__B0
+
+    @property
+    def B0prime(self) -> float:
+        """float: bulk prime modulus estimated at the equilibrium structure from the volume scan"""
+        if self.__B0prime is None:
+            raise ValueError('No quasiharmonic results!')
+        return self.__B0prime
+
+    @property
+    def V0(self) -> float:
+        """float: volume estimated for the equilibrium structure from the volume scan"""
+        if self.__V0 is None:
+            raise ValueError('No quasiharmonic results!')
+        return self.__V0
+
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
             The name to assign to the calculation.  By default, this is set as
             the calculation's key.
-        temperature : float, optional
-            The temperature to run at.
-        spring_constants : float, array-like object or None, optional
-            The Einstein solid spring constants to assign to each atom type.  If
-            None (default), then a separate simulation will estimate them using
-            mean squared displacements.
-        equilsteps : int, optional
-            The number of equilibration timesteps at the beginning of simulations
-            to ignore before evaluations.  This is used at the beginning of both
-            the spring constant estimate and before each thermo switch run.
-        switchsteps : int, optional
-            The number of integration steps to perform during the two switch runs.
-        springsteps : int, optional
-            The number of integration steps to perform for the spring constants
-            estimation, which is only done if spring_constants is None.
-        pressure : float, optional
-            A value of pressure to use for computing the Gibbs free energy from
-            the Helmholtz free energy.  NOTE: this is not used to equilibrate the
-            system during this calculation!
-        randomseed : int, optional
-            Random number seed used by LAMMPS.
+        strainrange : float, optional
+            Strain step size to use for quasiharmonic method.
+        numstrains : int, optional
+            The number of strain states to evaluate for the quasiharmonic
+            method.
+        symmetryprecision : float, optional
+            Tolerance used for identifying crystal symmetry elements
+        displacementdistance : float, optional
+            Random max atomic displacement to use for phonon calculations
         **kwargs : any, optional
             Any keyword parameters supported by the set_values() methods of
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
         super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
-        if 'temperature' in kwargs:
-            self.temperature = kwargs['temperature']
-        if 'spring_constants' in kwargs:
-            self.spring_constants = kwargs['spring_constants']
-        if 'equilsteps' in kwargs:
-            self.equilsteps = kwargs['equilsteps']
-        if 'switchsteps' in kwargs:
-            self.switchsteps = kwargs['switchsteps']
-        if 'springsteps' in kwargs:
-            self.springsteps = kwargs['springsteps']
-        if 'pressure' in kwargs:
-            self.pressure = kwargs['pressure']
-        if 'randomseed' in kwargs:
-            self.randomseed = kwargs['randomseed']
-
-####################### Parameter file interactions ########################### 
+        if 'strainrange' in kwargs:
+            self.strainrange = kwargs['strainrange']
+        if 'numstrains' in kwargs:
+            self.numstrains = kwargs['numstrains']
+        if 'symmetryprecision' in kwargs:
+            self.symmetryprecision = kwargs['symmetryprecision']
+        if 'displacementdistance' in kwargs:
+            self.displacementdistance = kwargs['displacementdistance']
+        if 'sizemults' in kwargs:
+            if 'a_mult' in kwargs or 'b_mult' in kwargs or 'c_mult' in kwargs:
+                raise ValueError('Cannot set sizemults and individual mults at the same time')
+            self.sizemults = kwargs['sizemults']
+        if 'a_mult' in kwargs:
+            self.a_mult = kwargs['a_mult']
+        if 'b_mult' in kwargs:
+            self.a_mult = kwargs['b_mult']
+        if 'c_mult' in kwargs:
+            self.a_mult = kwargs['c_mult']
+
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
-        input_dict['sizemults'] = input_dict.get('sizemults', '10 10 10')
-        
+        input_dict['sizemults'] = input_dict.get('sizemults', '3 3 3')
+        input_dict['forcetolerance'] = input_dict.get('forcetolerance',
+                                                  '1.0e-6 eV/angstrom')
+
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
-        self.equilsteps = int(input_dict.get('equilsteps', 25000))
-        self.switchsteps = int(input_dict.get('switchsteps', 50000))
-        self.springsteps = int(input_dict.get('springsteps', 50000))
-        self.randomseed = input_dict.get('randomseed', None)
+        self.numstrains = int(input_dict.get('numstrains', 11))
 
         # Load calculation-specific unitless floats
-        self.temperature = float(input_dict['temperature'])
+        self.symmetryprecision = float(input_dict.get('symmetryprecision', 1e-5))
+        self.strainrange = float(input_dict.get('strainrange', 0.05))
 
         # Load calculation-specific floats with units
-        self.pressure = value(input_dict, 'pressure',
-                              default_unit=self.units.pressure_unit,
-                              default_term='0.0 GPa')
-
-        # Load and split spring constants - None, or float(s) with units energy/area
-        spring_constants = input_dict.get('spring_constants', None)
-        if spring_constants is not None:
-            spring_constants = spring_constants.split()
-            for i in range(len(spring_constants)-1):
-                spring_constants[i] = float(spring_constants[i])
-            try:
-                spring_constants[-1] = float(spring_constants[-1])
-                unit = f'{self.units.energy_unit}/{self.units.length_unit}^2'
-            except:
-                unit = spring_constants.pop(-1)
-            spring_constants = uc.set_in_units(spring_constants, unit)
-        self.spring_constants = spring_constants
+        self.displacementdistance = value(input_dict, 'displacementdistance',
+                                          default_unit=self.units.length_unit,
+                                          default_term='0.01 angstrom')
 
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
-        # Manipulate system
-        self.system_mods.load_parameters(input_dict)
+        # Handle sizemults
+        self.sizemults = np.array(input_dict['sizemults'].strip().split(), dtype=int)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -353,214 +384,200 @@
             prepare scripts.
 
         Returns
         -------
         params : dict
             The full set of prepare parameters based on the workflow branch
         """
-        raise NotImplementedError('TBD')
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
-            params['buildcombos'] = [
-                'atomicreference load_file reference',
-                'atomicparent load_file parent'
-            ]
-            params['parent_record'] = 'calculation_E_vs_r_scan'
-            params['parent_load_key'] = 'minimum-atomic-system'
-            params['parent_status'] = 'finished'
-            params['sizemults'] = '10 10 10'
-            params['atomshift'] = '0.05 0.05 0.05'
-            params['temperature'] = '0.0'
-            params['integrator'] = 'nph+l'
-            params['thermosteps'] = '1000'
-            params['runsteps'] = '10000'
-            params['equilsteps'] = '0'
-
+            params['buildcombos'] = 'atomicparent load_file parent'
+            params['parent_record'] = 'relaxed_crystal'
+            params['parent_method'] = 'dynamic'
+            params['parent_standing'] = 'good'
+            params['sizemults'] = '3 3 3'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
-                    params[f'reference_{key}'] = kwargs[key]
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
-            'temperature': ' '.join([
-                "Target temperature for the simulations.  Required."]),
-            'spring_constants': ' '.join([
-                "The Einstein solid spring constants (in energy/area) to assign",
-                "to each atom type, given as space-delimited floats with optional",
-                "units.  If not given, then a separate simulation will be",
-                "performed to estimate the constants from mean squared displacements"]),
-            'equilsteps': ' '.join([
-                "The number of equilibration timesteps at the beginning of",
-                "simulations to ignore before evaluations.  This is used at",
-                "the beginning of both the spring constant estimate and before",
-                "each thermo switch run.  Default value is 25000."]),
-            'switchsteps': ' '.join([
-                "The number of integration steps to perform during each of the two",
-                "switch runs.  Default value is 50000."]),
-            'springsteps': ' '.join([
-                "The number of integration steps to perform for the spring",
-                "constants estimation, which is only done if spring_constants are",
-                "not given.  Default value is 50000."]),
-            'pressure': ' '.join([
-                "A value of pressure to use for computing the Gibbs free energy",
-                "from the Helmholtz free energy.  NOTE: this is not used to",
-                "equilibrate the system during this calculation!  Default value",
-                "is 0.0."]),
-            'randomseed': ' '.join([
-                "An int random number seed to use for generating initial velocities.",
-                "A random int will be selected if not given."]),
-        }  
+            'displacementdistance': ' '.join([
+                "Max distance atoms are displaced for the phonon evaluations.",
+                "Default  value is 0.01 angstrom"]),
+            'symmetryprecision': ' '.join([
+                "Precision tolerance to use for identifying symmetry elements.",
+                "Default value is 1e-5."]),
+            'numstrains': ' '.join([
+                "The number of strain states to evaluate for performing the",
+                "quasiharmonic approximation.  If set to 1, then the quasiharmonic",
+                "calculations will be skipped.  Default value is 11."]),
+            'strainrange': ' '.join([
+                "The range of strains to apply for performing the",
+                "quasiharmonic approximation.  Default value is 0.05."]),
+            'sizemults': ' '.join([
+                "Multiplication parameters to construct a supercell system.",
+                "Limited to three values for this calculation.  Default value"
+                "is 3 3 3."]),
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
-                self.system.keyset +
-                # Phase parameters
-                [
-                    'temperature',
-                    'pressure',
-                    'spring_constants',
-                ]
-            ] +
-
-            # System mods keys
-            [
-                self.system_mods.keyset
+                self.potential.keyset +
+                self.system.keyset
             ] +
 
             # Run parameters
             [
                 [
-                    'equilsteps',
-                    'switchsteps',
-                    'springsteps',
-                    'randomseed',
+                    'displacementdistance',
+                    'symmetryprecision',
+                    'numstrains',
+                    'strainrange',
+                    'sizemults'
                 ]
             ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
-        return 'calculation-free-energy'
+        return 'calculation-phonon'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
         # Build subset content
         self.commands.build_model(calc, after='atomman-version')
         self.potential.build_model(calc, after='calculation')
         self.system.build_model(calc, after='potential-LAMMPS')
-        self.system_mods.build_model(calc)
 
         # Build calculation-specific content
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
-        
-        run_params['equilsteps'] = self.equilsteps
-        run_params['switchsteps'] = self.switchsteps
-        run_params['springsteps'] = self.springsteps
-        run_params['randomseed'] = self.randomseed
-
-        # Save phase-state info
-        calc['phase-state'] = DM()
-        calc['phase-state']['temperature'] = uc.model(self.temperature, 'K')
-        calc['phase-state']['pressure'] = uc.model(self.pressure,
-                                                   self.units.pressure_unit)
+        run_params['size-multipliers'] = DM()
+        run_params['size-multipliers']['a'] = [0, self.a_mult]
+        run_params['size-multipliers']['b'] = [0, self.b_mult]
+        run_params['size-multipliers']['c'] = [0, self.c_mult]
+        run_params['displacementdistance'] = uc.model(self.displacementdistance,
+                                                      self.units.length_unit)
+        run_params['symmetryprecision'] = self.symmetryprecision
+        run_params['strainrange'] = self.strainrange
+        run_params['numstrains'] = self.numstrains
 
         # Build results
         if self.status == 'finished':
-            
-            # Save the total system volume and number of atoms
-            calc['volume'] = uc.model(self.volume,
-                                      f'{self.units.length_unit}^3')
-            calc['natoms'] = self.natoms
-
-            # Save the spring constants used
-            calc['spring-constants'] = uc.model(self.spring_constants,
-                                                f'{self.units.energy_unit}/{self.units.length_unit}^2')
-
-            # Save the computed energy terms
-            calc['work-forward'] = uc.model(self.work_forward,
-                                            self.units.energy_unit)
-            calc['work-reverse'] = uc.model(self.work_reverse,
-                                            self.units.energy_unit)
-            calc['work'] = uc.model(self.work, self.units.energy_unit)
-            calc['Helmholtz-energy-reference'] = uc.model(self.helmholtz_reference,
-                                                          self.units.energy_unit)
-            calc['Helmholtz-energy'] = uc.model(self.helmholtz,
-                                                self.units.energy_unit)
-            calc['Gibbs-energy'] = uc.model(self.gibbs,
-                                            self.units.energy_unit)
+            calc['band-structure'] = DM()
+
+            for qpoints in self.bandstructure['qpoints']:
+                calc['band-structure'].append('qpoints', uc.model(qpoints))
+
+            for distances in self.bandstructure['distances']:
+                calc['band-structure'].append('distances', uc.model(distances))
+
+            for frequencies in self.bandstructure['frequencies']:
+                calc['band-structure'].append('frequencies', uc.model(frequencies))
+
+            calc['density-of-states'] = DM()
+            calc['density-of-states']['frequency'] = uc.model(self.dos['frequency'], 'THz')
+            calc['density-of-states']['total_dos'] = uc.model(self.dos['total_dos'])
+            calc['density-of-states']['projected_dos'] = uc.model(self.dos['projected_dos'])
+
+            calc['thermal-properties'] = DM()
+            calc['thermal-properties']['temperature'] = uc.model(self.thermal['temperature'], 'K')
+            calc['thermal-properties']['Helmholtz'] = uc.model(self.thermal['Helmholtz'], 'eV')
+            calc['thermal-properties']['entropy'] = uc.model(self.thermal['entropy'], 'J/K/mol')
+            calc['thermal-properties']['heat_capacity_v'] = uc.model(self.thermal['heat_capacity_v'], 'J/K/mol')
+
+            # Add qha results
+            if self.__volumescan is not None:
+                calc['thermal-properties']['volume'] = uc.model(self.thermal['volume'], 'angstrom^3')
+                calc['thermal-properties']['thermal_expansion'] = uc.model(self.thermal['thermal_expansion'])
+                calc['thermal-properties']['Gibbs'] = uc.model(self.thermal['Gibbs'], 'eV')
+                calc['thermal-properties']['bulk_modulus'] = uc.model(self.thermal['bulk_modulus'], 'GPa')
+                calc['thermal-properties']['heat_capacity_p_numerical'] = uc.model(self.thermal['heat_capacity_p_numerical'], 'J/K/mol')
+                calc['thermal-properties']['heat_capacity_p_polyfit'] = uc.model(self.thermal['heat_capacity_p_polyfit'], 'J/K/mol')
+                calc['thermal-properties']['gruneisen'] = uc.model(self.thermal['gruneisen'])
+
+                calc['volume-scan'] = DM()
+                calc['volume-scan']['volume'] = uc.model(self.volumescan['volume'], 'angstrom^3')
+                calc['volume-scan']['strain'] = uc.model(self.volumescan['strain'])
+                calc['volume-scan']['energy'] = uc.model(self.volumescan['energy'], 'eV')
+
+                calc['E0'] = uc.model(self.E0, 'eV')
+                calc['B0'] = uc.model(self.B0, 'GPa')
+                calc['B0prime'] = uc.model(self.B0prime, 'GPa')
+                calc['V0'] = uc.model(self.V0, 'angstrom^3')
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -570,201 +587,186 @@
         """
         # Load universal and subset content
         super().load_model(model, name=name)
         calc = self.model[self.modelroot]
 
         # Load calculation-specific content
         run_params = calc['calculation']['run-parameter']
-        self.equilsteps = run_params['equilsteps']
-        self.switchsteps = run_params['switchsteps']
-        self.springsteps = run_params['springsteps']
-        self.randomseed = run_params['randomseed']
-
-        # Load phase-state info
-        self.temperature = uc.value_unit(calc['phase-state']['temperature'])
-        self.pressure = uc.value_unit(calc['phase-state']['pressure'])
-        
+        self.a_mult = run_params['size-multipliers']['a'][1]
+        self.b_mult = run_params['size-multipliers']['b'][1]
+        self.c_mult = run_params['size-multipliers']['c'][1]
+        self.displacementdistance = uc.value_unit(run_params['displacementdistance'])
+        self.symmetryprecision = run_params['symmetryprecision']
+        self.strainrange = run_params['strainrange']
+        self.numstrains = run_params['numstrains']
+
         # Load results
         if self.status == 'finished':
-            self.__volume = uc.value_unit(calc['volume'])
-            self.__natoms = calc['natoms']
-            self.__spring_constants = uc.value_unit(calc['spring-constants'])
-            self.__work_forward = uc.value_unit(calc['work-forward'])
-            self.__work_reverse = uc.value_unit(calc['work-reverse'])
-            self.__work = uc.value_unit(calc['work'])
-            self.__helmholtz_reference = uc.value_unit(calc['Helmholtz-energy-reference'])
-            self.__helmholtz = uc.value_unit(calc['Helmholtz-energy'])
-            self.__gibbs = uc.value_unit(calc['Gibbs-energy'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
+            self.__bandstructure = {}
+            self.bandstructure['qpoints'] = []
+            for qpoints in calc['band-structure']['qpoints']:
+                self.bandstructure['qpoints'].append(uc.value_unit(qpoints))
+
+            self.bandstructure['distances'] = []
+            for distances in calc['band-structure']['distances']:
+                self.bandstructure['distances'].append(uc.value_unit(distances))
+
+            self.bandstructure['frequencies'] = []
+            for frequencies in calc['band-structure']['frequencies']:
+                self.bandstructure['frequencies'].append(uc.value_unit(frequencies))
+
+            self.__dos = {}
+            self.dos['frequency'] = uc.value_unit(calc['density-of-states']['frequency'])
+            self.dos['total_dos'] = uc.value_unit(calc['density-of-states']['total_dos'])
+            self.dos['projected_dos'] = uc.value_unit(calc['density-of-states']['projected_dos'])
+
+            self.__thermal = {}
+            self.thermal['temperature'] = uc.value_unit(calc['thermal-properties']['temperature'])
+            self.thermal['Helmholtz'] = uc.value_unit(calc['thermal-properties']['Helmholtz'])
+            self.thermal['entropy'] = uc.value_unit(calc['thermal-properties']['entropy'])
+            self.thermal['heat_capacity_v'] = uc.value_unit(calc['thermal-properties']['heat_capacity_v'])
+
+            # Add qha results
+            if 'volume-scan' in calc:
+                self.thermal['volume'] = uc.value_unit(calc['thermal-properties']['volume'])
+                self.thermal['thermal_expansion'] = uc.value_unit(calc['thermal-properties']['thermal_expansion'])
+                self.thermal['Gibbs'] = uc.value_unit(calc['thermal-properties']['Gibbs'])
+                self.thermal['bulk_modulus'] = uc.value_unit(calc['thermal-properties']['bulk_modulus'])
+                self.thermal['heat_capacity_p_numerical'] = uc.value_unit(calc['thermal-properties']['heat_capacity_p_numerical'])
+                self.thermal['heat_capacity_p_polyfit'] = uc.value_unit(calc['thermal-properties']['heat_capacity_p_polyfit'])
+                self.thermal['gruneisen'] = uc.value_unit(calc['thermal-properties']['gruneisen'])
+
+                self.__volumescan = {}
+                self.volumescan['volume'] = uc.value_unit(calc['volume-scan']['volume'])
+                self.volumescan['strain'] = uc.value_unit(calc['volume-scan']['strain'])
+                self.volumescan['energy'] = uc.value_unit(calc['volume-scan']['energy'])
+
+                self.__E0 = uc.value_unit(calc['E0'])
+                self.__B0 = uc.value_unit(calc['B0'])
+                self.__B0prime = uc.value_unit(calc['B0prime'])
+                self.__V0 = uc.value_unit(calc['V0'])
+
+    @property
+    def queries(self) -> dict:
+        queries = deepcopy(super().queries)
+        queries.update({
+            'strainrange': load_query(
+                style='float_match',
+                name='strainrange',
+                path=f'{self.modelroot}.calculation.run-parameter.strainrange',
+                description='search by strain range used'),
+            'numstrains': load_query(
+                style='int_match',
+                name='numstrains',
+                path=f'{self.modelroot}.calculation.run-parameter.numstrains',
+                description='search by number of strain states used'),
+            'symmetryprecision': load_query(
+                style='float_match',
+                name='symmetryprecision',
+                path=f'{self.modelroot}.calculation.run-parameter.symmetryprecision',
+                description='search by symmetry precision tolerance used'),
+            'displacementdistance': load_query(
+                style='float_match',
+                name='displacementdistance',
+                path=f'{self.modelroot}.calculation.run-parameter.displacementdistance',
+                description='search by max displacement allowed'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        meta['temperature'] = self.temperature
-        meta['pressure'] = self.pressure
-        
+        meta['displacementdistance'] = self.displacementdistance
+        meta['symmetryprecision'] = self.symmetryprecision
+        meta['strainrange'] = self.strainrange
+        meta['numstrains'] = self.numstrains
+
         # Extract results
         if self.status == 'finished':
-            meta['spring_constants'] = self.spring_constants.tolist()
-            meta['volume'] = self.volume
-            meta['natoms'] = self.natoms
-            meta['work_forward'] = self.work_forward
-            meta['work_reverse'] = self.work_reverse
-            meta['work'] = self.work
-            meta['Helmholtz_reference'] = self.helmholtz_reference
-            meta['Helmholtz'] = self.helmholtz
-            meta['Gibbs'] = self.gibbs
+            #meta['bandstructure'] = self.bandstructure
+            #meta['thermal'] = self.thermal
+            #meta['dos'] = self.dos
+            if self.__volumescan is not None:
+                meta['volumescan'] = self.volumescan
+                meta['E0'] = self.E0
+                meta['B0'] = self.B0
+                meta['B0prime'] = self.B0prime
+                meta['V0'] = self.V0
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
-            'parent_key',
+
+            'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
-            'temperature':1e-2,
-            'pressure':1e-2,
+            'symmetryprecision':1e-7,
         }
 
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
-        # Remove unused subset inputs
-        del input_dict['transform']
-        del input_dict['ucell']
-
         # Add calculation-specific inputs
-        input_dict['temperature'] = self.temperature
-        input_dict['spring_constants'] = self.spring_constants
-        input_dict['pressure'] = self.pressure
-        
-        input_dict['equilsteps'] = self.equilsteps
-        input_dict['switchsteps'] = self.switchsteps
-        input_dict['springsteps'] = self.springsteps
-        input_dict['randomseed'] = self.randomseed
+        input_dict['distance'] = self.displacementdistance
+        input_dict['symprec'] = self.symmetryprecision
+        input_dict['strainrange'] = self.strainrange
+        input_dict['numstrains'] = self.numstrains
+        input_dict['a_mult'] = self.a_mult
+        input_dict['b_mult'] = self.b_mult
+        input_dict['c_mult'] = self.c_mult
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
-        self.spring_constants = results_dict['spring_constants']
-        self.__work_forward = results_dict['work_forward']
-        self.__work_reverse = results_dict['work_reverse']
-        self.__work = results_dict['work']
-        self.__helmholtz_reference = results_dict['Helmholtz_reference']
-        self.__helmholtz = results_dict['Helmholtz']
-        self.__gibbs = results_dict['Gibbs']
+        self.__phonons = results_dict['phonon_objects']
+        self.__qha = results_dict['qha_object']
+        self.__bandstructure = results_dict['band_structure']
+        self.__dos = results_dict['density_of_states']
+        self.__thermal = results_dict['thermal_properties']
+        if 'volume_scan' in results_dict:
+            self.__volumescan = results_dict['volume_scan']
+            self.__E0 = results_dict['E0']
+            self.__B0 = results_dict['B0']
+            self.__B0prime = results_dict['B0prime']
+            self.__V0 = results_dict['V0']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/free_energy/README.md` & `iprPy-0.11.5/iprPy/calculation/free_energy/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/free_energy/free_energy.py` & `iprPy-0.11.5/iprPy/calculation/free_energy/free_energy.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/free_energy/free_energy.template` & `iprPy-0.11.5/iprPy/calculation/free_energy/free_energy.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/free_energy/msd.template` & `iprPy-0.11.5/iprPy/calculation/free_energy/msd.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/free_energy/theory.md` & `iprPy-0.11.5/iprPy/calculation/free_energy/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/__init__.py` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/__init__.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.py` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.template` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_bcc/grain_boundary.template` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_bcc/grain_boundary.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_search/README.md` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_search/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_search/compare_terms.py` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_search/compare_terms.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/grain_boundary_search/todict.py` & `iprPy-0.11.5/iprPy/calculation/grain_boundary_search/todict.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/isolated_atom/IsolatedAtom.py` & `iprPy-0.11.5/iprPy/calculation/isolated_atom/IsolatedAtom.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,82 +1,102 @@
 # coding: utf-8
 # Standard Python libraries
-import uuid
+from io import IOBase
+from pathlib import Path
 from copy import deepcopy
-
-from yabadaba import query
+from typing import Optional, Union
 
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .isolated_atom import isolated_atom
-from ...calculation_subset import *
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units)
 
 class IsolatedAtom(Calculation):
     """Class for managing isolated atom energy calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
 
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         subsets = (self.commands, self.potential, self.units)
 
         # Initialize unique calculation attributes
         self.__isolated_atom_energy = {}
-        
+
         # Define calc shortcut
         self.calc = isolated_atom
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'isolated_atom.py',
             'run0.template'
         ]
 
-############################## Class attributes ###############################               
+############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
-    
+
     @property
-    def isolated_atom_energy(self):
+    def isolated_atom_energy(self) -> dict:
         """dict : The per-symbol isolated atom energies"""
         return self.__isolated_atom_energy
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -87,41 +107,56 @@
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
         super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Load calculation-specific strings
-        
+
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
-        
+
         # Load calculation-specific unitless floats
-        
+
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
-    
-    def master_prepare_inputs(self, branch='main', **kwargs):
+
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -139,76 +174,76 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'lammpspotential potential_file intpot'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'intpot_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
-        
+
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Potential keys
             [
                 self.potential.keyset
             ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-isolated-atom'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -225,15 +260,17 @@
                 isoatom['symbol'] = symbol
                 isoatom['energy'] = uc.model(energy, self.units.energy_unit)
                 calc.append('isolated-atom-energy', isoatom)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -245,149 +282,74 @@
         super().load_model(model, name=name)
         calc = self.model[self.modelroot]
 
         # Load calculation-specific content
 
         # Load results
         if self.status == 'finished':
-           for isoatom in calc.aslist('isolated-atom-energy'):
-               symbol = isoatom['symbol']
-               energy = uc.value_unit(isoatom['energy'])
-               self.isolated_atom_energy[symbol] = energy
-
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
+            for isoatom in calc.aslist('isolated-atom-energy'):
+                symbol = isoatom['symbol']
+                energy = uc.value_unit(isoatom['energy'])
+                self.isolated_atom_energy[symbol] = energy
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        
+
         # Extract results
         if self.status == 'finished':
             meta['isolated_atom_energy'] = deepcopy(self.isolated_atom_energy)
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
             'potential_LAMMPS_key',
             'potential_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
         # Add calculation-specific inputs
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
         for symbol, energy in results_dict['energy'].items():
-            self.isolated_atom_energy[symbol] = energy
+            self.isolated_atom_energy[symbol] = energy
```

### Comparing `iprPy-0.11.4/iprPy/calculation/isolated_atom/README.md` & `iprPy-0.11.5/iprPy/calculation/isolated_atom/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/isolated_atom/calculation_isolated_atom.xsl` & `iprPy-0.11.5/iprPy/calculation/isolated_atom/calculation_isolated_atom.xsl`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/isolated_atom/isolated_atom.py` & `iprPy-0.11.5/iprPy/calculation/isolated_atom/isolated_atom.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/isolated_atom/theory.md` & `iprPy-0.11.5/iprPy/calculation/isolated_atom/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/phonon/Phonon.py` & `iprPy-0.11.5/iprPy/calculation_subset/StackingFault.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,822 +1,701 @@
 # coding: utf-8
-# Standard Python libraries
 
-from yabadaba import query
+# Standard Python libraries
+from pathlib import Path
+from typing import Optional, Union
 
 # http://www.numpy.org/
 import numpy as np
-
-# https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
-import atomman.unitconvert as uc
+import numpy.typing as npt
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-# iprPy imports
-from .. import Calculation
-from .calc_phonon import phonon_quasiharmonic
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from yabadaba import load_query
 
-class Phonon(Calculation):
-    """Class for managing phonon and quasiharmonic calculations using phonopy"""
+# https://github.com/usnistgov/atomman
+import atomman.unitconvert as uc
+
+from . import CalculationSubset
+from ..input import boolean
+
+class StackingFault(CalculationSubset):
+    """Handles calculation terms for stacking fault parameters"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
-        # Initialize subsets used by the calculation
-        self.__potential = LammpsPotential(self)
-        self.__commands = LammpsCommands(self)
-        self.__units = Units(self)
-        self.__system = AtommanSystemLoad(self)
-        subsets = (self.commands, self.potential, self.system,
-                   self.units)
-
-        # Initialize unique calculation attributes
-        self.strainrange = 0.01
-        self.displacementdistance = uc.set_in_units(0.01, 'angstrom')
-        self.symmetryprecision = 1e-5         
-        self.numstrains = 5
-        self.a_mult = 2 
-        self.b_mult = 2
-        self.c_mult = 2
-        self.__bandstructure = None
-        self.__dos = None
-        self.__thermal = None
-        self.__volumescan = None
-        self.__E0 = None
-        self.__B0 = None
-        self.__B0prime = None
-        self.__V0 = None
-        self.__phonons = None
-        self.__qha = None
-        
-        # Define calc shortcut
-        self.calc = phonon_quasiharmonic
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
+        """
+        Initializes a calculation record subset object.
 
-        # Call parent constructor
-        super().__init__(model=model, name=name, params=params,
-                         subsets=subsets, **kwargs)
+        Parameters
+        ----------
+        parent : iprPy.calculation.Calculation
+            The parent calculation object that the subset object is part of.
+            This allows for the subset methods to access parameters set to the
+            calculation itself or other subsets.
+        prefix : str, optional
+            An optional prefix to add to metadata field names to allow for
+            differentiating between multiple subsets of the same style within
+            a single record
+        templateheader : str, optional
+            An alternate header to use in the template file for the subset.
+        templatedescription : str, optional
+            An alternate description of the subset for the templatedoc.
+        """
+        super().__init__(parent, prefix=prefix, templateheader=templateheader,
+                         templatedescription=templatedescription)
+
+        self.param_file = None
+        self.key = None
+        self.id = None
+        self.hkl = None
+        self.a1vect_uvw = None
+        self.a2vect_uvw = None
+        self.cellsetting = 'p'
+        self.cutboxvector = 'c'
+        self.shiftindex = 0
+        self.faultpos_rel = 0.5
+        self.sizemults = [1,1,1]
+        self.minwidth = 0.0
+        self.even = False
+        self.family = None
+        self.__content = None
+        self.__model = None
+
+############################## Class attributes ################################
+
+    @property
+    def param_file(self) -> Optional[Path]:
+        """Path or None: The path to the stacking fault parameter file"""
+        return self.__param_file
+
+    @param_file.setter
+    def param_file(self, val: Union[str, Path, None]):
+        if val is None:
+            self.__param_file = None
+        else:
+            self.__param_file = Path(val)
 
     @property
-    def filenames(self):
-        """list: the names of each file used by the calculation."""
-        return [
-            'calc_phonon.py',
-            'phonon.template'
-        ]
+    def key(self) -> Optional[str]:
+        """str or None: UUID key of the stacking fault parameter set"""
+        return self.__key
 
-############################## Class attributes ###############################
+    @key.setter
+    def key(self, val: Optional[str]):
+        if val is None:
+            self.__key = None
+        else:
+            self.__key = str(val)
 
     @property
-    def commands(self):
-        """LammpsCommands subset"""
-        return self.__commands
+    def id(self) -> Optional[str]:
+        """str or None: id of the stacking fault parameter set"""
+        return self.__id
 
-    @property
-    def potential(self):
-        """LammpsPotential subset"""
-        return self.__potential
+    @id.setter
+    def id(self, val: Optional[str]):
+        if val is None:
+            self.__id = None
+        else:
+            self.__id = str(val)
 
     @property
-    def units(self):
-        """Units subset"""
-        return self.__units
+    def hkl(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic (hkl) or (hkil) cut plane"""
+        return self.__hkl
 
-    @property
-    def system(self):
-        """AtommanSystemLoad subset"""
-        return self.__system
+    @hkl.setter
+    def hkl(self, val: Optional[npt.ArrayLike]):
+        if val is None:
+            self.__hkl = None
+        else:
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
+            else:
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.__hkl = val.tolist()
+
+    @property
+    def a1vect_uvw(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic [uvw] or [uvtw] a1 fault shift vector"""
+        return self.__a1vect_uvw
+
+    @a1vect_uvw.setter
+    def a1vect_uvw(self, val: Optional[npt.ArrayLike]):
+        if val is None:
+            self.__a1vect_uvw = None
+        else:
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
+            else:
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.__a1vect_uvw = val.tolist()
+
+    @property
+    def a2vect_uvw(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic [uvw] or [uvtw] a1 fault shift vector"""
+        return self.__a2vect_uvw
+
+    @a2vect_uvw.setter
+    def a2vect_uvw(self, val: Optional[npt.ArrayLike]):
+        if val is None:
+            self.__a2vect_uvw = None
+        else:
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
+            else:
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.__a2vect_uvw = val.tolist()
 
     @property
-    def strainrange(self):
-        """float: Strain step size to use for quasiharmonic method"""
-        return self.__strainrange
+    def cellsetting(self) -> str:
+        """str: The reference unit cell setting"""
+        return self.__cellsetting
 
-    @strainrange.setter
-    def strainrange(self, value):
-        self.__strainrange = float(value)
+    @cellsetting.setter
+    def cellsetting(self, val: str):
+        if val not in ['p', 'a', 'b', 'c', 'i', 'f']:
+            raise ValueError('invalid surface cellsetting')
+        self.__cellsetting = str(val)
 
     @property
-    def numstrains(self):
-        """int: Number of strain states to use for quasiharmonic method"""
-        return self.__numstrains
+    def cutboxvector(self) -> str:
+        """str: The cell box vector that the cut occurs along"""
+        return self.__cutboxvector
 
-    @numstrains.setter
-    def numstrains(self, value):
-        self.__numstrains = int(value)
+    @cutboxvector.setter
+    def cutboxvector(self, val: str):
+        if val not in ['a', 'b', 'c']:
+            raise ValueError('invalid surface cutboxvector')
+        self.__cutboxvector = str(val)
 
     @property
-    def a_mult(self):
-        """int: Number of replicas along the a box vect to use"""
-        return self.__a_mult
+    def shiftindex(self) -> int:
+        """int: The index of the pre-determined shifts values to use for shift"""
+        return self.__shiftindex
 
-    @a_mult.setter
-    def a_mult(self, value):
-        self.__a_mult = int(value)
+    @shiftindex.setter
+    def shiftindex(self, val: int):
+        self.__shiftindex = int(val)
 
     @property
-    def b_mult(self):
-        """int: Number of replicas along the b box vect to use"""
-        return self.__b_mult
+    def sizemults(self) -> list:
+        """list: The three size multipliers of rcell used"""
+        return self.__sizemults
 
-    @b_mult.setter
-    def b_mult(self, value):
-        self.__b_mult = int(value)
+    @sizemults.setter
+    def sizemults(self, val: Union[str, list, tuple]):
+        if isinstance(val, str):
+            val = np.array(val.strip().split(), dtype=int)
+        else:
+            val = np.asarray(val, dtype=int)
+        if val.shape != (3,):
+            raise ValueError('Invalid sizemults command: exactly 3 sizemults required for this calculation')
+        self.__sizemults = val.tolist()
 
     @property
-    def c_mult(self):
-        """int: Number of replicas along the c box vect to use"""
-        return self.__c_mult
+    def minwidth(self) -> float:
+        """float: The minimum width allowed perpendicular to the cut"""
+        return self.__minwidth
 
-    @c_mult.setter
-    def c_mult(self, value):
-        self.__c_mult = int(value)
+    @minwidth.setter
+    def minwidth(self, val: float):
+        self.__minwidth = float(val)
 
     @property
-    def sizemults(self):
-        """tuple: All three sets of size multipliers"""
-        return (self.a_mult, self.b_mult, self.c_mult)
+    def faultpos_rel(self) -> float:
+        """float: The relative position along the cutboxvector where the fault plane is located"""
+        return self.__faultpos_rel
 
-    @sizemults.setter
-    def sizemults(self, value):
-        if len(value) == 3:
-            self.a_mult = value[0]
-            self.b_mult = value[1]
-            self.c_mult = value[2]
-        else:
-            raise ValueError('len of sizemults must be 3')
+    @faultpos_rel.setter
+    def faultpos_rel(self, val: float):
+        self.__faultpos_rel = float(val)
 
     @property
-    def symmetryprecision(self):
-        """float: Precision tolerance to use to identify symmetry elements"""
-        return self.__symmetryprecision
+    def even(self) -> bool:
+        """bool: If True, the number of replicas along the cutboxvector will be kept even"""
+        return self.__even
 
-    @symmetryprecision.setter
-    def symmetryprecision(self, value):
-        self.__symmetryprecision = float(value)
+    @even.setter
+    def even(self, val: bool):
+        self.__even = boolean(val)
 
     @property
-    def displacementdistance(self):
-        """float: Random max atomic displacement to use for phonon calculations"""
-        return self.__displacementdistance
+    def family(self) -> Optional[str]:
+        """str or None: The prototype or reference crystal the stacking fault parameter set is for"""
+        return self.__family
 
-    @displacementdistance.setter
-    def displacementdistance(self, value):
-        self.__displacementdistance = float(value)
-        
-    @property
-    def bandstructure(self):
-        """dict: band structure information"""
-        if self.__bandstructure is None:
-            raise ValueError('No results yet!')
-        return self.__bandstructure
-
-    @property
-    def dos(self):
-        """dict: density of states information"""
-        if self.__dos is None:
-            raise ValueError('No results yet!')
-        return self.__dos
-
-    @property
-    def thermal(self):
-        """dict: estimated properties vs temperature"""
-        if self.__thermal is None:
-            raise ValueError('No results yet!')
-        return self.__thermal
-
-    @property
-    def phonons(self):
-        """list: phonopy.Phonopy objects for each strain"""
-        if self.__phonons is None:
-            raise ValueError('phonon objects not set...')
-        return self.__phonons
-
-    @property
-    def qha(self):
-        """phonopy.PhonopyQHA: quasiharmonic approximation object"""
-        if self.__qha is None:
-            raise ValueError('phonon qha object not set...')
-        return self.__qha
-
-    @property
-    def volumescan(self):
-        """dict: volume-energy scan used for quasiharmonic"""
-        if self.__volumescan is None:
-            raise ValueError('No quasiharmonic results!')
-        return self.__volumescan
-
-    @property
-    def E0(self):
-        """float: energy estimated for the equilibrium structure from the volume scan"""
-        if self.__E0 is None:
-            raise ValueError('No quasiharmonic results!')
-        return self.__E0
-    
-    @property
-    def B0(self):
-        """float: bulk modulus estimated at the equilibrium structure from the volume scan"""
-        if self.__B0 is None:
-            raise ValueError('No quasiharmonic results!')
-        return self.__B0
-    
-    @property
-    def B0prime(self):
-        """float: bulk prime modulus estimated at the equilibrium structure from the volume scan"""
-        if self.__B0prime is None:
-            raise ValueError('No quasiharmonic results!')
-        return self.__B0prime
-
-    @property
-    def V0(self):
-        """float: volume estimated for the equilibrium structure from the volume scan"""
-        if self.__V0 is None:
-            raise ValueError('No quasiharmonic results!')
-        return self.__V0
+    @family.setter
+    def family(self, val: Optional[str]):
+        if val is None:
+            self.__family = None
+        else:
+            self.__family = str(val)
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self, **kwargs: any):
         """
-        Set calculation values directly.  Any terms not given will be set
-        or reset to the calculation's default values.
+        Allows for multiple class attribute values to be updated at once.
 
         Parameters
         ----------
-        name : str, optional
-            The name to assign to the calculation.  By default, this is set as
-            the calculation's key.
-        strainrange : float, optional
-            Strain step size to use for quasiharmonic method.
-        numstrains : int, optional
-            The number of strain states to evaluate for the quasiharmonic
-            method.
-        symmetryprecision : float, optional
-            Tolerance used for identifying crystal symmetry elements
-        displacementdistance : float, optional
-            Random max atomic displacement to use for phonon calculations
-        **kwargs : any, optional
-            Any keyword parameters supported by the set_values() methods of
-            the parent Calculation class and the subset classes.
-        """
-        # Call super to set universal and subset content
-        super().set_values(name=name, **kwargs)
-
-        # Set calculation-specific values
-        if 'strainrange' in kwargs:
-            self.strainrange = kwargs['strainrange']
-        if 'numstrains' in kwargs:
-            self.numstrains = kwargs['numstrains']
-        if 'symmetryprecision' in kwargs:
-            self.symmetryprecision = kwargs['symmetryprecision']
-        if 'displacementdistance' in kwargs:
-            self.displacementdistance = kwargs['displacementdistance']
+        param_file : str, optional
+            The path to a file that fully defines the input parameters for
+            a specific defect type
+        key : str, optional
+            The UUID4 unique key associated with the defect parameter set.
+        id : str, optional
+            The unique id associated with the defect parameter set.
+        hkl : str or array-like object, optional
+            The Miller (hkl) fault plane.
+        cellsetting : str, optional
+            Indicates the setting of the unit cell, if it is not primitive.
+            This allows for the proper identification of the shortest lattice
+            vectors for applying the stacking fault shifts.
+        cutboxvector : str, optional
+            Indicates which box vector will be made non-periodic to allow for
+            the defect to be created.
+        shiftindex : int, optional
+            A rigid shift will be applied to position the cutboxvector's
+            boundary halfway between two atomic planes.  Changing this value
+            changes the termination planes.
+        sizemults : str or array-like object, optional
+            The system size multipliers.  
+        minwidth : float, optional
+            A minimum width for the box's cutboxvector direction.  The sizemults
+            will be modified to ensure this as needed.
+        even : bool, optional
+            If True, the sizemult for the cutboxvector direction will be
+            constrained to be even.  This will ensure that the free surfaces
+            and fault plane surface will have identical neighboring atomic
+            planes.
+        family : str or None, optional
+            The system's family identifier that the defect is defined for.
+        a1vect_uvw : str or array-like object, optional
+            The in-plane a1 shift vector that indicates a full shift from one
+            lattice site to another.
+        a2vect_uvw : str or array-like object, optional
+            The in-plane a2 shift vector that indicates a full shift from one
+            lattice site to another.
+        faultpos_rel : float, optional
+            The relative position along the cutboxvector where the fault plane
+            is to be located.  Default value is 0.5 (middle).
+        """
+        if 'param_file' in kwargs:
+            self.param_file = kwargs['param_file']
+        if 'key' in kwargs:
+            self.key = kwargs['key']
+        if 'id' in kwargs:
+            self.id = kwargs['id']
+        if 'hkl' in kwargs:
+            self.hkl = kwargs['hkl']
+        if 'cellsetting' in kwargs:
+            self.cellsetting = kwargs['cellsetting']
+        if 'cutboxvector' in kwargs:
+            self.cutboxvector = kwargs['cutboxvector']
+        if 'shiftindex' in kwargs:
+            self.shiftindex = kwargs['shiftindex']
         if 'sizemults' in kwargs:
-            if 'a_mult' in kwargs or 'b_mult' in kwargs or 'c_mult' in kwargs:
-                raise ValueError('Cannot set sizemults and individual mults at the same time')
             self.sizemults = kwargs['sizemults']
-        if 'a_mult' in kwargs:
-            self.a_mult = kwargs['a_mult']
-        if 'b_mult' in kwargs:
-            self.a_mult = kwargs['b_mult']
-        if 'c_mult' in kwargs:
-            self.a_mult = kwargs['c_mult']
-
-####################### Parameter file interactions ########################### 
-
-    def load_parameters(self, params, key=None):
-        
-        # Load universal content
-        input_dict = super().load_parameters(params, key=key)
-        
-        # Load input/output units
-        self.units.load_parameters(input_dict)
-        
-        # Change default values for subset terms
-        input_dict['sizemults'] = input_dict.get('sizemults', '3 3 3')
-        input_dict['forcetolerance'] = input_dict.get('forcetolerance',
-                                                  '1.0e-6 eV/angstrom')
-
-        # Load calculation-specific strings
-
-        # Load calculation-specific booleans
-        
-        # Load calculation-specific integers
-        self.numstrains = int(input_dict.get('numstrains', 11))
-
-        # Load calculation-specific unitless floats
-        self.symmetryprecision = float(input_dict.get('symmetryprecision', 1e-5))
-        self.strainrange = float(input_dict.get('strainrange', 0.05))
-
-        # Load calculation-specific floats with units
-        self.displacementdistance = value(input_dict, 'displacementdistance',
-                                          default_unit=self.units.length_unit,
-                                          default_term='0.01 angstrom')
-
-        # Load LAMMPS commands
-        self.commands.load_parameters(input_dict)
-
-        # Load LAMMPS potential
-        self.potential.load_parameters(input_dict)
-
-        # Load initial system
-        self.system.load_parameters(input_dict)
-
-        # Handle sizemults
-        self.sizemults = np.array(input_dict['sizemults'].strip().split(), dtype=int)
-
-    def master_prepare_inputs(self, branch='main', **kwargs):
+        if 'minwidth' in kwargs:
+            self.minwidth = kwargs['minwidth']
+        if 'even' in kwargs:
+            self.even = kwargs['even']
+        if 'family' in kwargs:
+            self.family = kwargs['family']
+        if 'a1vect_uvw' in kwargs:
+            self.a1vect_uvw = kwargs['a1vect_uvw']
+        if 'a2vect_uvw' in kwargs:
+            self.a2vect_uvw = kwargs['a2vect_uvw']
+        if 'faultpos_rel' in kwargs:
+            self.faultpos_rel = kwargs['faultpos_rel']
+
+####################### Parameter file interactions ###########################
+
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
-        Utility method that build input parameters for prepare according to the
-        workflows used by the NIST Interatomic Potentials Repository.  In other
-        words, transforms inputs from master_prepare into inputs for prepare.
+        Sets the template header and description values.
 
         Parameters
         ----------
-        branch : str, optional
-            Indicates the workflow branch to prepare calculations for.  Default
-            value is 'main'.
-        **kwargs : any
-            Any parameter modifications to make to the standard workflow
-            prepare scripts.
-
-        Returns
-        -------
-        params : dict
-            The full set of prepare parameters based on the workflow branch
-        """
-        # Initialize params and copy over branch
-        params = {}
-        params['branch'] = branch
-
-        # main branch
-        if branch == 'main':
-            
-            # Check for required kwargs
-            assert 'lammps_command' in kwargs
-
-            # Set default workflow settings
-            params['buildcombos'] = 'atomicparent load_file parent'
-            params['parent_record'] = 'relaxed_crystal'
-            params['parent_method'] = 'dynamic'
-            params['parent_standing'] = 'good'
-            params['sizemults'] = '3 3 3'
-
-            # Copy kwargs to params
-            for key in kwargs:
-                
-                # Rename potential-related terms for buildcombos
-                if key[:10] == 'potential_':
-                    params[f'parent_{key}'] = kwargs[key]
-                
-                # Copy/overwrite other terms
-                else:
-                    params[key] = kwargs[key]
+        templateheader : str, optional
+            An alternate header to use in the template file for the subset.
+        templatedescription : str, optional
+            An alternate description of the subset for the templatedoc.
+        """
+        # Set default template header
+        if templateheader is None:
+            templateheader = 'Stacking Fault'
 
-        else:
-            raise ValueError(f'Unknown branch {branch}')
+        # Set default template description
+        if templatedescription is None:
+            templatedescription = ' '.join([
+                "Specifies the parameter set that defines a stacking fault."])
 
-        return params
+        super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
-        """dict : The calculation-specific input keys and their descriptions."""
-
+    def templatekeys(self) -> dict:
+        """dict : The subset-specific input keys and their descriptions."""
         return {
-            'displacementdistance': ' '.join([
-                "Max distance atoms are displaced for the phonon evaluations.",
-                "Default  value is 0.01 angstrom"]),
-            'symmetryprecision': ' '.join([
-                "Precision tolerance to use for identifying symmetry elements.",
-                "Default value is 1e-5."]),
-            'numstrains': ' '.join([
-                "The number of strain states to evaluate for performing the",
-                "quasiharmonic approximation.  If set to 1, then the quasiharmonic",
-                "calculations will be skipped.  Default value is 11."]),
-            'strainrange': ' '.join([
-                "The range of strains to apply for performing the",
-                "quasiharmonic approximation.  Default value is 0.05."]),
+            'stackingfault_file': ' '.join([
+                "The path to a stacking_fault record file that collects the",
+                "parameters associated with a specific stacking fault."]),
+            'stackingfault_hkl': ' '.join([
+                "The Miller (hkl) plane for the fault plane given as three",
+                "space-delimited integers."]),
+            'stackingfault_a1vect_uvw': ' '.join([
+                "The Miller [uvw] vector to use for the a1 shift vector",
+                "given as three space-delimited floats."]),
+            'stackingfault_a2vect_uvw': ' '.join([
+                "The Miller [uvw] vector to use for the a2 shift vector",
+                "given as three space-delimited floats."]),
+            'stackingfault_cellsetting': ' '.join([
+                "The conventional cell setting to take stackingfault_hkl relative to",
+                "if the loaded unit cell is a primitive cell.  Allowed values are 'p',",
+                "'c', 'i', 'a', 'b' and 'c'."]),
+            'stackingfault_cutboxvector': ' '.join([
+                "Indicates which of the three box vectors ('a', 'b', or 'c')",
+                "that the surface and fault planes will be made along.",
+                "Default value is 'c'."]),
+            'stackingfault_shiftindex': ' '.join([
+                "A rigid body shift will be applied to the atoms such that the",
+                "created surface plane will be halfway between two atomic planes.",
+                "This is an integer value that changes which set of atomic planes",
+                "that the plane is inserted between.  Changing this effectively",
+                "changes the termination planes."]),
+            'stackingfault_faultpos_rel': ' '.join([
+                "A fractional coordinate from 0 to 1 indicating where along the",
+                "cutboxvector to position the fault plane. Default value is 0.5,",
+                "which if stackingfault_even is True will result in the same",
+                "termination planes at the free surface and the stacking fault."]),
             'sizemults': ' '.join([
-                "Multiplication parameters to construct a supercell system.",
-                "Limited to three values for this calculation.  Default value"
-                "is 3 3 3."]),
-        } 
+                "Multiplication parameters to construct a supercell from the rotated",
+                "system.  Limited to three values for stacking fault generation."]),
+            'stackingfault_minwidth': ' '.join([
+                "Specifies a mimimum width in length units that the system must be",
+                "along the cutboxvector direction. The associated sizemult value",
+                "will be increased if necessary to ensure this. Default value is 0.0."]),
+            'stackingfault_even': ' '.join([
+                "If True, the number of replicas in the cutboxvector direction will"
+                "be even. Default value is False."]),
+        }
 
     @property
-    def singularkeys(self):
-        """list: Calculation keys that can have single values during prepare."""
-        
-        keys = (
-            # Universal keys
-            super().singularkeys
-
-            # Subset keys
-            + self.commands.keyset
-            + self.units.keyset
-
-            # Calculation-specific keys
-        )
-        return keys
-
-    @property
-    def multikeys(self):
-        """list: Calculation key sets that can have multiple values during prepare."""
-
-        keys = (
-            # Universal multikeys
-            super().multikeys +
-
-            # Combination of potential and system keys
-            [
-                self.potential.keyset + 
-                self.system.keyset
-            ] +
-
-            # Run parameters
-            [
-                [
-                    'displacementdistance',
-                    'symmetryprecision',
-                    'numstrains',
-                    'strainrange',
-                    'sizemults'
-                ]
-            ]
-        )
-        return keys
-
-########################### Data model interactions ###########################
+    def preparekeys(self) -> list:
+        """
+        list : The input keys (without prefix) used when preparing a calculation.
+        Typically, this is templatekeys plus *_content keys so prepare can access
+        content before it exists in the calc folders being prepared.
+        """
+        return list(self.templatekeys.keys()) + [
+            'stackingfault_family',
+            'stackingfault_content',
+        ]
 
     @property
-    def modelroot(self):
-        """str: The root element of the content"""
-        return 'calculation-phonon'
-
-    def build_model(self):
-        """
-        Generates and returns model content based on the values set to object.
-        """
-        # Build universal content
-        model = super().build_model()
-        calc = model[self.modelroot]
-
-        # Build subset content
-        self.commands.build_model(calc, after='atomman-version')
-        self.potential.build_model(calc, after='calculation')
-        self.system.build_model(calc, after='potential-LAMMPS')
-
-        # Build calculation-specific content
-        if 'calculation' not in calc:
-            calc['calculation'] = DM()
-        if 'run-parameter' not in calc['calculation']:
-            calc['calculation']['run-parameter'] = DM()
-        run_params = calc['calculation']['run-parameter']
-        run_params['size-multipliers'] = DM()
-        run_params['size-multipliers']['a'] = [0, self.a_mult]
-        run_params['size-multipliers']['b'] = [0, self.b_mult]
-        run_params['size-multipliers']['c'] = [0, self.c_mult]
-        run_params['displacementdistance'] = uc.model(self.displacementdistance,
-                                                      self.units.length_unit)
-        run_params['symmetryprecision'] = self.symmetryprecision
-        run_params['strainrange'] = self.strainrange
-        run_params['numstrains'] = self.numstrains
-
-        # Build results
-        if self.status == 'finished':
-            calc['band-structure'] = DM()
-
-            for qpoints in self.bandstructure['qpoints']:
-                calc['band-structure'].append('qpoints', uc.model(qpoints))
-                
-            for distances in self.bandstructure['distances']:
-                calc['band-structure'].append('distances', uc.model(distances))
-                
-            for frequencies in self.bandstructure['frequencies']:
-                calc['band-structure'].append('frequencies', uc.model(frequencies))
-
-            calc['density-of-states'] = DM()
-            calc['density-of-states']['frequency'] = uc.model(self.dos['frequency'], 'THz')
-            calc['density-of-states']['total_dos'] = uc.model(self.dos['total_dos'])
-            calc['density-of-states']['projected_dos'] = uc.model(self.dos['projected_dos'])
-
-            calc['thermal-properties'] = DM()
-            calc['thermal-properties']['temperature'] = uc.model(self.thermal['temperature'], 'K')
-            calc['thermal-properties']['Helmholtz'] = uc.model(self.thermal['Helmholtz'], 'eV')
-            calc['thermal-properties']['entropy'] = uc.model(self.thermal['entropy'], 'J/K/mol')
-            calc['thermal-properties']['heat_capacity_v'] = uc.model(self.thermal['heat_capacity_v'], 'J/K/mol')
-
-            # Add qha results
-            if self.__volumescan is not None:
-                calc['thermal-properties']['volume'] = uc.model(self.thermal['volume'], 'angstrom^3')
-                calc['thermal-properties']['thermal_expansion'] = uc.model(self.thermal['thermal_expansion'])
-                calc['thermal-properties']['Gibbs'] = uc.model(self.thermal['Gibbs'], 'eV')
-                calc['thermal-properties']['bulk_modulus'] = uc.model(self.thermal['bulk_modulus'], 'GPa')
-                calc['thermal-properties']['heat_capacity_p_numerical'] = uc.model(self.thermal['heat_capacity_p_numerical'], 'J/K/mol')
-                calc['thermal-properties']['heat_capacity_p_polyfit'] = uc.model(self.thermal['heat_capacity_p_polyfit'], 'J/K/mol')
-                calc['thermal-properties']['gruneisen'] = uc.model(self.thermal['gruneisen'])
-                
-                calc['volume-scan'] = DM()
-                calc['volume-scan']['volume'] = uc.model(self.volumescan['volume'], 'angstrom^3')
-                calc['volume-scan']['strain'] = uc.model(self.volumescan['strain'])
-                calc['volume-scan']['energy'] = uc.model(self.volumescan['energy'], 'eV')
-
-                calc['E0'] = uc.model(self.E0, 'eV')
-                calc['B0'] = uc.model(self.B0, 'GPa')
-                calc['B0prime'] = uc.model(self.B0prime, 'GPa')
-                calc['V0'] = uc.model(self.V0, 'angstrom^3')
-
-        self._set_model(model)
-        return model
-
-    def load_model(self, model, name=None):
+    def interpretkeys(self) -> list:
         """
-        Loads record contents from a given model.
-
-        Parameters
-        ----------
-        model : str or DataModelDict
-            The model contents of the record to load.
-        name : str, optional
-            The name to assign to the record.  Often inferred from other
-            attributes if not given.
-        """
-        # Load universal and subset content
-        super().load_model(model, name=name)
-        calc = self.model[self.modelroot]
-
-        # Load calculation-specific content
-        run_params = calc['calculation']['run-parameter']
-        self.a_mult = run_params['size-multipliers']['a'][1]
-        self.b_mult = run_params['size-multipliers']['b'][1]
-        self.c_mult = run_params['size-multipliers']['c'][1]
-        self.displacementdistance = uc.value_unit(run_params['displacementdistance'])
-        self.symmetryprecision = run_params['symmetryprecision']
-        self.strainrange = run_params['strainrange']
-        self.numstrains = run_params['numstrains']
-
-
-        # Load results
-        if self.status == 'finished':
-            
-            self.__bandstructure = {}
-            self.bandstructure['qpoints'] = []
-            for qpoints in calc['band-structure']['qpoints']:
-                self.bandstructure['qpoints'].append(uc.value_unit(qpoints))
-            
-            self.bandstructure['distances'] = []
-            for distances in calc['band-structure']['distances']:
-                self.bandstructure['distances'].append(uc.value_unit(distances))
-            
-            self.bandstructure['frequencies'] = []
-            for frequencies in calc['band-structure']['frequencies']:
-                self.bandstructure['frequencies'].append(uc.value_unit(frequencies))
-
-            self.__dos = {}
-            self.dos['frequency'] = uc.value_unit(calc['density-of-states']['frequency'])
-            self.dos['total_dos'] = uc.value_unit(calc['density-of-states']['total_dos'])
-            self.dos['projected_dos'] = uc.value_unit(calc['density-of-states']['projected_dos'])
-
-            self.__thermal = {}
-            self.thermal['temperature'] = uc.value_unit(calc['thermal-properties']['temperature'])
-            self.thermal['Helmholtz'] = uc.value_unit(calc['thermal-properties']['Helmholtz'])
-            self.thermal['entropy'] = uc.value_unit(calc['thermal-properties']['entropy'])
-            self.thermal['heat_capacity_v'] = uc.value_unit(calc['thermal-properties']['heat_capacity_v'])
-
-            # Add qha results
-            if 'volume-scan' in calc:
-                self.thermal['volume'] = uc.value_unit(calc['thermal-properties']['volume'])
-                self.thermal['thermal_expansion'] = uc.value_unit(calc['thermal-properties']['thermal_expansion'])
-                self.thermal['Gibbs'] = uc.value_unit(calc['thermal-properties']['Gibbs'])
-                self.thermal['bulk_modulus'] = uc.value_unit(calc['thermal-properties']['bulk_modulus'])
-                self.thermal['heat_capacity_p_numerical'] = uc.value_unit(calc['thermal-properties']['heat_capacity_p_numerical'])
-                self.thermal['heat_capacity_p_polyfit'] = uc.value_unit(calc['thermal-properties']['heat_capacity_p_polyfit'])
-                self.thermal['gruneisen'] = uc.value_unit(calc['thermal-properties']['gruneisen'])
-                
-                self.__volumescan = {}
-                self.volumescan['volume'] = uc.value_unit(calc['volume-scan']['volume'])
-                self.volumescan['strain'] = uc.value_unit(calc['volume-scan']['strain'])
-                self.volumescan['energy'] = uc.value_unit(calc['volume-scan']['energy'])
-
-                self.__E0 = uc.value_unit(calc['E0'])
-                self.__B0 = uc.value_unit(calc['B0'])
-                self.__B0prime = uc.value_unit(calc['B0prime'])
-                self.__V0 = uc.value_unit(calc['V0'])
+        list : The input keys (without prefix) accessed when interpreting the 
+        calculation input file.  Typically, this is preparekeys plus any extra
+        keys used or generated when processing the inputs.
+        """
+        return self.preparekeys + [
+            'stackingfault_model',
+        ]
 
-    def mongoquery(self, strainrange=None, numstrains=None,
-                   symmetryprecision=None, displacementdistance=None, **kwargs):
+    @property
+    def multikeys(self) -> list:
+        """
+        list: Calculation subset key sets that can have multiple values during prepare.
         """
-        Builds a Mongo-style query based on kwargs values for the record style.
+        # Define key set for system size parameters
+        sizekeys = ['sizemults', 'stackingfault_minwidth', 'stackingfault_even']
 
-        Parameters
-        ----------
-        strainrange : float or list, optional
-            strainrange values to parse by.
-        numstrains : int or list, optional
-            numstrains values to parse by.
-        symmetryprecision : float or list, optional
-            symmetryprecision values to parse by.
-        displacementdistance : float or list, optional
-            displacementdistance values to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.strainrange', strainrange)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.numstrains', numstrains)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.symmetryprecision', symmetryprecision)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.displacementdistance', displacementdistance)
+        # Define key set for defect parameters as the remainder
+        defectkeys = []
+        for key in self.preparekeys:
+            if key not in sizekeys:
+                defectkeys.append(key)
 
-        return mquery
+        # Add prefixes and return
+        return [
+            self._pre(sizekeys),
+            self._pre(defectkeys)
+        ]
 
-    def cdcsquery(self, strainrange=None, numstrains=None,
-                  symmetryprecision=None, displacementdistance=None, **kwargs):
+    def load_parameters(self, input_dict: dict):
         """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
+        Interprets calculation parameters.
+        
         Parameters
         ----------
-        strainrange : float or list, optional
-            strainrange values to parse by.
-        numstrains : int or list, optional
-            numstrains values to parse by.
-        symmetryprecision : float or list, optional
-            symmetryprecision values to parse by.
-        displacementdistance : float or list, optional
-            displacementdistance values to parse by.
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.       
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.strainrange', strainrange)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.numstrains', numstrains)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.symmetryprecision', symmetryprecision)
-        query.str_match.mongo(mquery, f'{root}.calculation.run-parameter.displacementdistance', displacementdistance)
+        input_dict : dict
+            Dictionary containing input parameter key-value pairs.
+        """
 
-        return mquery
+        # Set default keynames
+        keymap = self.keymap
 
-########################## Metadata interactions ##############################
+        # Extract input values and assign default values
+        self.param_file = input_dict.get(keymap['stackingfault_file'], None)
+        self.__content = input_dict.get(keymap['stackingfault_content'], None)
+
+        # Replace defect model with defect content if given
+        param_file = self.param_file
+        if self.__content is not None:
+            param_file = self.__content
+
+        # Extract parameters from a file
+        if param_file is not None:
+
+            # Verify competing parameters are not defined
+            for key in ('stackingfault_hkl',
+                        'stackingfault_shiftindex',
+                        'stackingfault_a1vect_uvw',
+                        'stackingfault_a2vect_uvw',
+                        'stackingfault_cellsetting',
+                        'stackingfault_cutboxvector',
+                        'stackingfault_faultpos_rel'):
+                if keymap[key] in input_dict:
+                    raise ValueError(f"{keymap[key]} and {keymap['stackingfault_file']} cannot both be supplied")
+
+            # Load defect model
+            self.__model = model = DM(param_file).find('stacking-fault')
+
+            # Extract parameter values from defect model
+            self.key = model['key']
+            self.id = model['id']
+            self.family = model['system-family']
+            self.hkl = model['calculation-parameter']['hkl']
+            self.a1vect_uvw = model['calculation-parameter']['a1vect_uvw']
+            self.a2vect_uvw = model['calculation-parameter']['a2vect_uvw']
+            self.shiftindex = int(model['calculation-parameter'].get('shiftindex', 0))
+            self.cutboxvector = model['calculation-parameter']['cutboxvector']
+            self.faultpos_rel = float(model['calculation-parameter'].get('faultpos_rel', 0.5))
+            self.cellsetting = model['calculation-parameter'].get('cellsetting', 'p')
 
-    def metadata(self):
-        """
-        Generates a dict of simple metadata values associated with the record.
-        Useful for quickly comparing records and for building pandas.DataFrames
-        for multiple records of the same style.
-        """
-        # Call super to extract universal and subset content
-        meta = super().metadata()
-
-        # Extract calculation-specific content
-        meta['displacementdistance'] = self.displacementdistance
-        meta['symmetryprecision'] = self.symmetryprecision
-        meta['strainrange'] = self.strainrange
-        meta['numstrains'] = self.numstrains
-
-        # Extract results
-        if self.status == 'finished':
-            meta['bandstructure'] = self.bandstructure
-            meta['thermal'] = self.thermal
-            meta['dos'] = self.dos
-            if self.__volumescan is not None:
-                meta['volumescan'] = self.volumescan
-                meta['E0'] = self.E0
-                meta['B0'] = self.B0
-                meta['B0prime'] = self.B0prime
-                meta['V0'] = self.V0
-        
-        return meta
+        # Set parameter values directly
+        else:
+            self.__model = None
+            self.key = None
+            self.id = None
+            self.family = self.parent.system.family
+            self.hkl = input_dict[keymap['stackingfault_hkl']]
+            self.a1vect_uvw = input_dict.get(keymap['stackingfault_a1vect_uvw'], None)
+            self.a2vect_uvw = input_dict.get(keymap['stackingfault_a2vect_uvw'], None)
+            self.shiftindex = int(input_dict.get(keymap['stackingfault_shiftindex'], 0))
+            self.cutboxvector = input_dict.get(keymap['stackingfault_cutboxvector'], 'c')
+            self.faultpos_rel = float(input_dict.get(keymap['stackingfault_faultpos_rel'], 0.5))
+            self.cellsetting = input_dict.get(keymap['stackingfault_cellsetting'], 'p')
+
+        # Set default values for fault system manipulations
+        self.sizemults = input_dict.get(keymap['sizemults'], '1 1 1')
+        self.minwidth = float(input_dict.get(keymap['stackingfault_minwidth'], 0.0))
+        self.even = boolean(input_dict.get(keymap['stackingfault_even'], False))
+
+########################### Data model interactions ###########################
 
     @property
-    def compare_terms(self):
-        """list: The terms to compare metadata values absolutely."""
-        return [
-            'script',
+    def modelroot(self) -> str:
+        """str : The root element name for the subset terms."""
+        baseroot = 'stacking-fault'
+        return f'{self.modelprefix}{baseroot}'
+
+    def load_model(self, model: DM):
+        """Loads subset attributes from an existing model."""
+        sf = model[self.modelroot]
+
+        self.__model = None
+        self.__param_file = None
+        self.key = sf['key']
+        self.id = sf['id']
+        self.family = sf['system-family']
+
+        cp = sf['calculation-parameter']
+        self.hkl = cp['hkl']
+        self.a1vect_uvw = cp['a1vect_uvw']
+        self.a2vect_uvw = cp['a2vect_uvw']
+        self.shiftindex = int(cp['shiftindex'])
+        self.cutboxvector = cp['cutboxvector']
+        self.faultpos_rel = float(cp['faultpos_rel'])
+        self.cellsetting = cp['cellsetting'] 
+
+        run_params = model['calculation']['run-parameter']
+
+        a_mult = run_params[f'{self.modelprefix}size-multipliers']['a'][1]
+        b_mult = run_params[f'{self.modelprefix}size-multipliers']['b'][1]
+        c_mult = run_params[f'{self.modelprefix}size-multipliers']['c'][1]
+        self.sizemults = [a_mult, b_mult, c_mult]
+        self.minwidth = uc.value_unit(run_params[f'{self.modelprefix}minimum-width'])
+
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
+        """
+        Adds the subset model to the parent model.
         
-            'load_file',
-            'load_options',
-            'symbols',
-            
-            'potential_LAMMPS_key',
-            'potential_key',
-            
-        ]
-    
+        Parameters
+        ----------
+        model : DataModelDict.DataModelDict
+            The record content (after root element) to add content to.
+        kwargs : any
+            Any options to pass on to dict_insert that specify where the subset
+            content gets added to in the parent model.
+        """
+        # Save defect parameters
+        model[self.modelroot] = surf = DM()
+        surf['key'] = self.key
+        surf['id'] = self.id
+        surf['system-family'] = self.family
+        surf['calculation-parameter'] = cp = DM()
+        if len(self.hkl) == 3:
+            cp['hkl'] = f'{self.hkl[0]} {self.hkl[1]} {self.hkl[2]}'
+        else:
+            cp['hkl'] = f'{self.hkl[0]} {self.hkl[1]} {self.hkl[2]} {self.hkl[3]}'
+        cp['shiftindex'] = str(self.shiftindex)
+        if len(self.a1vect_uvw) == 3:
+            cp['a1vect_uvw'] = f'{self.a1vect_uvw[0]} {self.a1vect_uvw[1]} {self.a1vect_uvw[2]}'
+        else:
+            cp['a1vect_uvw'] = f'{self.a1vect_uvw[0]} {self.a1vect_uvw[1]} {self.a1vect_uvw[2]} {self.a1vect_uvw[3]}'
+        if len(self.a2vect_uvw) == 3:
+            cp['a2vect_uvw'] = f'{self.a2vect_uvw[0]} {self.a2vect_uvw[1]} {self.a2vect_uvw[2]}'
+        else:
+            cp['a2vect_uvw'] = f'{self.a2vect_uvw[0]} {self.a2vect_uvw[1]} {self.a2vect_uvw[2]} {self.a2vect_uvw[3]}'
+        cp['cutboxvector'] = self.cutboxvector
+        cp['faultpos_rel'] = str(self.faultpos_rel)
+        cp['cellsetting'] = self.cellsetting
+
+        # Build paths if needed
+        if 'calculation' not in model:
+            model['calculation'] = DM()
+        if 'run-parameter' not in model['calculation']:
+            model['calculation']['run-parameter'] = DM()
+
+        run_params = model['calculation']['run-parameter']
+
+        run_params[f'{self.modelprefix}size-multipliers'] = DM()
+        run_params[f'{self.modelprefix}size-multipliers']['a'] = sorted([0, self.sizemults[0]])
+        run_params[f'{self.modelprefix}size-multipliers']['b'] = sorted([0, self.sizemults[1]])
+        run_params[f'{self.modelprefix}size-multipliers']['c'] = sorted([0, self.sizemults[2]])
+        run_params[f'{self.modelprefix}minimum-width'] = uc.model(self.minwidth,
+                                                             self.parent.units.length_unit)
+
     @property
-    def compare_fterms(self):
-        """dict: The terms to compare metadata values using a tolerance."""
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
+
+        root = f'{self.parent.modelroot}.{self.modelroot}'
+        runparampath = f'{self.parent.modelroot}.calculation.run-parameter.{self.modelprefix}'
+
         return {
-            'symmetryprecision':1e-7,
+            'stackingfault_id': load_query(
+                style='str_match',
+                name=f'{self.prefix}stackingfault_id',
+                path=f'{root}.id',
+                description='search by stacking fault parameter set id'),
+            'stackingfault_key': load_query(
+                style='str_match',
+                name=f'{self.prefix}stackingfault_key',
+                path=f'{root}.key',
+                description='search by stacking fault parameter set UUID key'),
+            'stackingfault_family': load_query(
+                style='str_match',
+                name=f'{self.prefix}dislocation_family',
+                path=f'{root}.system-family',
+                description='search by crystal prototype that the stacking fault parameter set is for'),
+            'a_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult1',
+                path=f'{runparampath}size-multipliers.a.0',
+                description='search by lower a_mult value'),
+            'a_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult2',
+                path=f'{runparampath}size-multipliers.a.1',
+                description='search by upper a_mult value'),
+            'b_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult1',
+                path=f'{runparampath}size-multipliers.b.0',
+                description='search by lower b_mult value'),
+            'b_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult2',
+                path=f'{runparampath}size-multipliers.b.1',
+                description='search by upper b_mult value'),
+            'c_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult1',
+                path=f'{runparampath}size-multipliers.c.0',
+                description='search by lower c_mult value'),
+            'c_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult2',
+                path=f'{runparampath}size-multipliers.c.1',
+                description='search by upper c_mult value'),
         }
 
-    def pandasfilter(self, dataframe, strainrange=None, numstrains=None,
-                     symmetryprecision=None, displacementdistance=None,
-                     **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
+########################## Metadata interactions ##############################
 
+    def metadata(self, meta: dict):
+        """
+        Converts the structured content to a simpler dictionary.
+        
         Parameters
         ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        strainrange : float or list, optional
-            strainrange values to parse by.
-        numstrains : int or list, optional
-            numstrains values to parse by.
-        symmetryprecision : float or list, optional
-            symmetryprecision values to parse by.
-        displacementdistance : float or list, optional
-            displacementdistance values to parse by.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
+        meta : dict
+            The dictionary to add the subset content to
+        """
+        prefix = self.prefix
 
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        matches = (matches
-            &query.str_match.pandas(dataframe, 'strainrange', strainrange)
-            &query.str_match.pandas(dataframe, 'numstrains', numstrains)
-            &query.str_match.pandas(dataframe, 'symmetryprecision', symmetryprecision)
-            &query.str_match.pandas(dataframe, 'displacementdistance', displacementdistance)
-        )
-        
-        return matches
+        meta[f'{prefix}stackingfault_key'] = self.key
+        meta[f'{prefix}stackingfault_id'] = self.id
+        meta[f'{prefix}stackingfault_family'] = self.family
+        meta[f'{prefix}stackingfault_hkl'] = self.hkl
+        meta[f'{prefix}stackingfault_shiftindex'] = self.shiftindex
+        meta[f'{prefix}stackingfault_a1vect_uvw'] = self.a1vect_uvw
+        meta[f'{prefix}stackingfault_a2vect_uvw'] = self.a2vect_uvw
+        meta[f'{prefix}a_mult1'] = 0
+        meta[f'{prefix}a_mult2'] = self.sizemults[0]
+        meta[f'{prefix}b_mult1'] = 0
+        meta[f'{prefix}b_mult2'] = self.sizemults[1]
+        meta[f'{prefix}c_mult1'] = 0
+        meta[f'{prefix}c_mult2'] = self.sizemults[2]
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
-        """Builds calculation inputs from the class's attributes"""
-        
-        # Initialize input_dict
-        input_dict = {}
-
-        # Add subset inputs
-        for subset in self.subsets:
-            subset.calc_inputs(input_dict)
-
-        # Add calculation-specific inputs
-        input_dict['distance'] = self.displacementdistance
-        input_dict['symprec'] = self.symmetryprecision
-        input_dict['strainrange'] = self.strainrange
-        input_dict['numstrains'] = self.numstrains
-        input_dict['a_mult'] = self.a_mult
-        input_dict['b_mult'] = self.b_mult
-        input_dict['c_mult'] = self.c_mult
-
-        # Return input_dict
-        return input_dict
-    
-    def process_results(self, results_dict):
+    def calc_inputs(self, input_dict: dict):
         """
-        Processes calculation results and saves them to the object's results
-        attributes.
+        Generates calculation function input parameters based on the values
+        assigned to attributes of the subset.
 
         Parameters
         ----------
-        results_dict: dict
-            The dictionary returned by the calc() method.
+        input_dict : dict
+            The dictionary of input parameters to add subset terms to.
         """
-        self.__phonons = results_dict['phonon_objects']
-        self.__qha = results_dict['qha_object']
-        self.__bandstructure = results_dict['band_structure']
-        self.__dos = results_dict['density_of_states']
-        self.__thermal = results_dict['thermal_properties']
-        if 'volume_scan' in results_dict:
-            self.__volumescan = results_dict['volume_scan']
-            self.__E0 = results_dict['E0']
-            self.__B0 = results_dict['B0']
-            self.__B0prime = results_dict['B0prime']
-            self.__V0 = results_dict['V0']
+        if self.hkl is None:
+            raise ValueError('hkl not set')
+
+        input_dict['hkl'] = self.hkl
+
+        input_dict['sizemults'] = self.sizemults
+        input_dict['minwidth'] = self.minwidth
+        input_dict['even'] = self.even
+        input_dict['a1vect_uvw'] = self.a1vect_uvw
+        input_dict['a2vect_uvw'] = self.a2vect_uvw
+        input_dict['conventional_setting'] = self.cellsetting
+        input_dict['cutboxvector'] = self.cutboxvector
+        input_dict['faultpos_rel'] = self.faultpos_rel
+        input_dict['shiftindex'] = self.shiftindex
```

### Comparing `iprPy-0.11.4/iprPy/calculation/phonon/README.md` & `iprPy-0.11.5/iprPy/calculation/phonon/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/phonon/calc_phonon.py` & `iprPy-0.11.5/iprPy/calculation/phonon/calc_phonon.py`

 * *Files 3% similar despite different names*

```diff
@@ -260,17 +260,26 @@
         results['thermal_properties']['heat_capacity_p_numerical'] = uc.set_in_units(np.hstack([qha.heat_capacity_P_numerical, np.nan]), 'J/K/mol')
         results['thermal_properties']['heat_capacity_p_polyfit'] = uc.set_in_units(np.hstack([qha.heat_capacity_P_polyfit, np.nan]), 'J/K/mol')
         results['thermal_properties']['gruneisen'] = np.hstack([qha.gruneisen_temperature, np.nan])
     
     return results
 
 
-def phononcalc(lammps_command, ucell, potential, mpi_command=None,
-               a_mult=2, b_mult=2, c_mult=2, distance=0.01, symprec=1e-5, 
-               istrain='', plot=True, lammps_date=None):
+def phononcalc(lammps_command: str,
+               ucell: am.System,
+               potential: lmp.Potential,
+               mpi_command: Optional[str] = None,
+               a_mult: int = 2,
+               b_mult: int = 2,
+               c_mult: int = 2,
+               distance: float = 0.01,
+               symprec: float = 1e-5,
+               istrain: str = '',
+               plot: bool = True,
+               lammps_date: Optional[datetime.date] = None) -> dict:
     """
     Uses phonopy to compute the phonons for a unit cell structure using a
     LAMMPS interatomic potential.
 
     Parameters
     ----------
     lammps_command :str
```

### Comparing `iprPy-0.11.4/iprPy/calculation/phonon/theory.md` & `iprPy-0.11.5/iprPy/calculation/phonon/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/PointDefectDiffusion.py` & `iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/PointDefectDiffusion.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,58 +1,72 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 import random
 
-import numpy as np
-
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .point_defect_diffusion import pointdiffusion
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate, PointDefect)
 
 class PointDefectDiffusion(Calculation):
     """Class for managing point defect diffusion calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
         self.__defect = PointDefect(self)
         subsets = (self.commands, self.potential, self.system,
                    self.system_mods, self.defect, self.units)
 
-        # Initialize unique calculation attributes  
+        # Initialize unique calculation attributes
         self.temperature = 0.0
         self.thermosteps = 100
         self.dumpsteps = None
         self.runsteps = 200000
         self.equilsteps = 20000
-        self.randomseed = None     
+        self.randomseed = None
 
         self.__nsamples = None
         self.__natoms = None
         self.__potential_energy = None
         self.__potential_energy_std = None
         self.__total_energy = None
         self.__total_energy_std = None
@@ -64,264 +78,266 @@
         self.__measured_pressure_zz_std = None
         self.__measured_temperature = None
         self.__measured_temperature_std = None
         self.__dx = None
         self.__dy = None
         self.__dz = None
         self.__d = None
-        
+
         # Define calc shortcut
         self.calc = pointdiffusion
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'point_defect_diffusion.py',
             'diffusion.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
 
     @property
-    def defect(self):
+    def defect(self) -> PointDefect:
         """PointDefect subset"""
         return self.__defect
 
     @property
-    def temperature(self):
+    def temperature(self) -> float:
         """float: Target relaxation temperature"""
         return self.__temperature
 
     @temperature.setter
-    def temperature(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__temperature = value
+    def temperature(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__temperature = val
 
     @property
-    def thermosteps(self):
+    def thermosteps(self) -> int:
         """int : How often termo data is recorded"""
         return self.__thermosteps
 
     @thermosteps.setter
-    def thermosteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__thermosteps = value
+    def thermosteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__thermosteps = val
 
     @property
-    def dumpsteps(self):
+    def dumpsteps(self) -> int:
         """int : How often atomic configurations are dumped"""
         if self.__dumpsteps is None:
             return self.runsteps
         else:
             return self.__dumpsteps
 
     @dumpsteps.setter
-    def dumpsteps(self, value):
-        if value is None:
+    def dumpsteps(self, val: Optional[float]):
+        if val is None:
             self.__dumpsteps = None
         else:
-            value = int(value)
-            assert value >= 0
-            self.__dumpsteps = value
+            val = int(val)
+            assert val >= 0
+            self.__dumpsteps = val
 
     @property
-    def runsteps(self):
+    def runsteps(self) -> int:
         """int : The number of NVE MD steps where diffusion is evaluated"""
         return self.__runsteps
 
     @runsteps.setter
-    def runsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__runsteps = value
+    def runsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__runsteps = val
 
     @property
-    def equilsteps(self):
+    def equilsteps(self) -> int:
         """int : The number of NVT MD steps performed before the NVE runsteps"""
         return self.__equilsteps
 
     @equilsteps.setter
-    def equilsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__equilsteps = value
+    def equilsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__equilsteps = val
 
     @property
-    def randomseed(self):
+    def randomseed(self) -> int:
         """int: A random generator seed"""
         return self.__randomseed
 
     @randomseed.setter
-    def randomseed(self, value):
-        if value is None:
-            value = random.randint(1, 900000000)
+    def randomseed(self, val: Optional[int]):
+        if val is None:
+            val = random.randint(1, 900000000)
         else:
-            value = int(value)
-            assert value > 0 and value <= 900000000
-        self.__randomseed = value
+            val = int(val)
+            assert val > 0 and val <= 900000000
+        self.__randomseed = val
 
     @property
-    def natoms(self):
+    def natoms(self) -> int:
         """int: Number of atoms in the defect system"""
         if self.__natoms is None:
             raise ValueError('No results yet!')
         return self.__natoms
 
     @property
-    def nsamples(self):
+    def nsamples(self) -> int:
         """int: Number of measurement samples used in mean, std values"""
         if self.__nsamples is None:
             raise ValueError('No results yet!')
         return self.__nsamples
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: Potential energy for the relaxed system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
     @property
-    def potential_energy_std(self):
+    def potential_energy_std(self) -> float:
         """float: Standard deviation for potential_energy"""
         if self.__potential_energy_std is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_std
 
     @property
-    def total_energy(self):
+    def total_energy(self) -> float:
         """float: Total energy for the relaxed system"""
         if self.__total_energy is None:
             raise ValueError('No results yet!')
         return self.__total_energy
 
     @property
-    def total_energy_std(self):
+    def total_energy_std(self) -> float:
         """float: Standard deviation for total_energy"""
         if self.__total_energy_std is None:
             raise ValueError('No results yet!')
         return self.__total_energy_std
 
     @property
-    def measured_pressure_xx(self):
+    def measured_pressure_xx(self) -> float:
         """float: Measured relaxation pressure component xx"""
         if self.__measured_pressure_xx is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xx
-    
+
     @property
-    def measured_pressure_xx_std(self):
+    def measured_pressure_xx_std(self) -> float:
         """float: Standard deviation for measured_pressure_xx"""
         if self.__measured_pressure_xx_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xx_std
 
     @property
-    def measured_pressure_yy(self):
+    def measured_pressure_yy(self) -> float:
         """float: Measured relaxation pressure component yy"""
         if self.__measured_pressure_yy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yy
-    
+
     @property
-    def measured_pressure_yy_std(self):
+    def measured_pressure_yy_std(self) -> float:
         """float: Standard deviation for measured_pressure_yy"""
         if self.__measured_pressure_yy_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yy_std
 
     @property
-    def measured_pressure_zz(self):
+    def measured_pressure_zz(self) -> float:
         """float: Measured relaxation pressure component zz"""
         if self.__measured_pressure_zz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_zz
-    
+
     @property
-    def measured_pressure_zz_std(self):
+    def measured_pressure_zz_std(self) -> float:
         """float: Standard deviation for measured_pressure_zz"""
         if self.__measured_pressure_zz_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_zz_std
 
     @property
-    def measured_temperature(self):
+    def measured_temperature(self) -> float:
         """float: Measured temperature for the relaxed system"""
         if self.__measured_temperature is None:
             raise ValueError('No results yet!')
         return self.__measured_temperature
 
     @property
-    def measured_temperature_std(self):
+    def measured_temperature_std(self) -> float:
         """float: Standard deviation for measured_temperature"""
         if self.__measured_temperature_std is None:
             raise ValueError('No results yet!')
         return self.__measured_temperature_std
 
     @property
-    def dx(self):
+    def dx(self) -> float:
         """float: Diffusion constant in the x direction"""
         if self.__dx is None:
             raise ValueError('No results yet!')
         return self.__dx
 
     @property
-    def dy(self):
+    def dy(self) -> float:
         """float: Diffusion constant in the y direction"""
         if self.__dy is None:
             raise ValueError('No results yet!')
         return self.__dy
 
     @property
-    def dz(self):
+    def dz(self) -> float:
         """float: Diffusion constant in the z direction"""
         if self.__dz is None:
             raise ValueError('No results yet!')
         return self.__dz
 
     @property
-    def d(self):
+    def d(self) -> float:
         """float: Average diffusion constant"""
         if self.__d is None:
             raise ValueError('No results yet!')
         return self.__d
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -359,59 +375,74 @@
         if 'runsteps' in kwargs:
             self.runsteps = kwargs['runsteps']
         if 'equilsteps' in kwargs:
             self.equilsteps = kwargs['equilsteps']
         if 'randomseed' in kwargs:
             self.randomseed = kwargs['randomseed']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '12 12 12')
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.runsteps = int(input_dict.get('runsteps', 200000))
         self.thermosteps = int(input_dict.get('thermosteps', 100))
         self.dumpsteps = int(input_dict.get('dumpsteps', 0))
         self.equilsteps = int(input_dict.get('equilsteps', 20000))
         self.randomseed = input_dict.get('randomseed', None)
 
         # Load calculation-specific unitless floats
         self.temperature = float(input_dict.get('temperature', 0.0))
 
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
-        
+
         # Load defect parameters
         self.defect.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -429,15 +460,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicparent load_file parent',
                 'defect pointdefect_file'
@@ -446,30 +477,30 @@
             params['parent_method'] = 'dynamic'
             params['parent_standing'] = 'good'
             params['defect_record'] = 'point_defect'
             params['sizemults'] = '12 12 12'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'temperature': ' '.join([
                 "Target temperature for the simulations.  The NVT equilibrium",
                 "steps will use this for the thermostat, then the energy scaled",
                 "to try to capture this temperature for the NVE runs."]),
@@ -484,43 +515,43 @@
                 "The number of MD integration steps to perform in the NVE run."]),
             'equilsteps': ' '.join([
                 "The number of NVT MD integration steps to perform prior to the",
                 "NVE runsteps to allow the system to equilibriate."]),
             'randomseed': ' '.join([
                 "An int random number seed to use for generating initial velocities.",
                 "A random int will be selected if not given."]),
-        }    
-    
+        }
+
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""        
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
-    
+        return keys
+
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
@@ -537,25 +568,25 @@
                     'thermosteps',
                     'dumpsteps',
                     'runsteps',
                     'equilsteps',
                     'randomseed',
                 ]
             ]
-        )                     
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-point-defect-diffusion'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -568,31 +599,31 @@
 
         # Build calculation-specific content
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
-        
+
         run_params['thermosteps'] = self.thermosteps
         run_params['dumpsteps'] = self.dumpsteps
         run_params['runsteps'] = self.runsteps
         run_params['equilsteps'] = self.equilsteps
         run_params['randomseed'] = self.randomseed
 
         # Save phase-state info
         calc['phase-state'] = DM()
         calc['phase-state']['temperature'] = uc.model(self.temperature, 'K')
 
         # Build results
         if self.status == 'finished':
-            
+
             calc['number-of-measurements'] = self.nsamples
             calc['number-of-atoms'] = self.natoms
-            
+
             # Save measured phase-state info
             calc['measured-phase-state'] = mps = DM()
             mps['temperature'] = uc.model(self.measured_temperature, 'K',
                                           self.measured_temperature_std)
             mps['pressure-xx'] = uc.model(self.measured_pressure_xx,
                                           self.units.pressure_unit,
                                           self.measured_pressure_xx_std)
@@ -609,22 +640,24 @@
                                            self.units.energy_unit,
                                            self.total_energy_std)
 
             # Save the diffusion constants
             calc['diffusion-rate'] = dr = DM()
             diffusion_unit = f'{self.units.length_unit}^2/s'
             dr['total'] = uc.model(self.d, diffusion_unit)
-            dr['x-direction'] = uc.model(self.dx, diffusion_unit) 
+            dr['x-direction'] = uc.model(self.dx, diffusion_unit)
             dr['y-direction'] = uc.model(self.dy, diffusion_unit)
             dr['z-direction'] = uc.model(self.dz, diffusion_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -645,15 +678,15 @@
         self.randomseed = run_params['randomseed']
 
         # Load phase-state info
         self.temperature = uc.value_unit(calc['phase-state']['temperature'])
 
         # Load results
         if self.status == 'finished':
-            
+
             self.__nsamples = calc['number-of-measurements']
             self.__natoms = calc['number-of-atoms']
 
             mps = calc['measured-phase-state']
             self.__measured_temperature = uc.value_unit(mps['temperature'])
             self.__measured_temperature_std = uc.error_unit(mps['temperature'])
             self.__measured_pressure_xx = uc.value_unit(mps['pressure-xx'])
@@ -669,161 +702,86 @@
 
             dr = calc['diffusion-rate']
             self.__d = uc.value_unit(dr['total'])
             self.__dx = uc.value_unit(dr['x-direction'])
             self.__dy = uc.value_unit(dr['y-direction'])
             self.__dz = uc.value_unit(dr['z-direction'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
-
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
         meta['temperature'] = self.temperature
-        
+
         # Extract results
         if self.status == 'finished':
             meta['nsamples'] = self.nsamples
             meta['natoms'] = self.natoms
-            
+
             meta['E_pot'] = self.potential_energy
             meta['E_pot_std'] = self.potential_energy_std
             meta['E_total'] = self.total_energy
             meta['E_total_std'] = self.total_energy_std
 
             meta['measured_temperature'] = self.measured_temperature
             meta['measured_temperature_std'] = self.measured_temperature_std
             meta['measured_pressure_xx'] = self.measured_pressure_xx
             meta['measured_pressure_xx_std'] = self.measured_pressure_xx_std
             meta['measured_pressure_yy'] = self.measured_pressure_yy
             meta['measured_pressure_yy_std'] = self.measured_pressure_yy_std
             meta['measured_pressure_zz'] = self.measured_pressure_zz
             meta['measured_pressure_zz_std'] = self.measured_pressure_zz_std
-            
+
             meta['d'] = self.d
             meta['dx'] = self.dx
             meta['dy'] = self.dy
             meta['dz'] = self.dz
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
+
             'parent_key',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
+
             'a_mult',
             'b_mult',
             'c_mult',
 
             'pointdefect_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'temperature':1,
         }
 
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
@@ -837,40 +795,40 @@
         input_dict['thermosteps'] = self.thermosteps
         input_dict['dumpsteps'] = self.dumpsteps
         input_dict['equilsteps'] = self.equilsteps
         input_dict['randomseed'] = self.randomseed
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
-            
+
         self.__nsamples = results_dict['nsamples']
         self.__natoms = results_dict['natoms']
-        
+
         self.__potential_energy = results_dict['E_pot']
         self.__potential_energy_std = results_dict['E_pot_std']
         self.__total_energy = results_dict['E_total']
         self.__total_energy_std = results_dict['E_total_std']
 
         self.__measured_pressure_xx = results_dict['pxx']
         self.__measured_pressure_xx_std = results_dict['pxx_std']
         self.__measured_pressure_yy = results_dict['pyy']
         self.__measured_pressure_yy_std = results_dict['pyy_std']
         self.__measured_pressure_zz = results_dict['pzz']
         self.__measured_pressure_zz_std = results_dict['pzz_std']
         self.__measured_temperature = results_dict['temp']
         self.__measured_temperature_std = results_dict['temp_std']
-    
-        self.__d = results_dict['d'] 
+
+        self.__d = results_dict['d']
         self.__dx = results_dict['dx']
         self.__dy = results_dict['dy']
-        self.__dz = results_dict['dz']
+        self.__dz = results_dict['dz']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/README.md` & `iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/diffusion.template` & `iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/diffusion.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/point_defect_diffusion.py` & `iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/point_defect_diffusion.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_diffusion/theory.md` & `iprPy-0.11.5/iprPy/calculation/point_defect_diffusion/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_static/PointDefectStatic.py` & `iprPy-0.11.5/iprPy/calculation/point_defect_static/PointDefectStatic.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,52 +1,70 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 import numpy as np
 
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .point_defect_static import calc
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate,
+                                   LammpsMinimize, PointDefect)
 
 class PointDefectStatic(Calculation):
     """Class for managing point defect formation calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
         self.__minimize = LammpsMinimize(self)
         self.__defect = PointDefect(self)
         subsets = (self.commands, self.potential, self.system,
                    self.system_mods, self.minimize, self.defect, self.units)
 
-        # Initialize unique calculation attributes        
+        # Initialize unique calculation attributes
         self.__system_base = None
         self.__system_defect = None
         self.__dumpfile_base = None
         self.__dumpfile_defect = None
         self.__symbols_base = None
         self.__symbols_defect = None
         self.__natoms_base = None
@@ -56,208 +74,212 @@
         self.__potential_energy = None
         self.__formation_energy = None
         self.__dipole_tensor = None
         self.__has_reconfigured = None
         self.__centrosummation = None
         self.__position_shift = None
         self.__db_vect_shift = None
-        
+
         # Define calc shortcut
         self.calc = calc
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'point_defect_static.py',
             'min.template'
         ]
 
 ############################## Class attributes ################################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
 
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def defect(self):
+    def defect(self) -> PointDefect:
         """PointDefect subset"""
         return self.__defect
 
     @property
-    def dumpfile_base(self):
+    def dumpfile_base(self) -> str:
         """str: Name of the LAMMPS dump file of the base system"""
         if self.__dumpfile_base is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_base
-    
+
     @property
-    def dumpfile_defect(self):
+    def dumpfile_defect(self) -> str:
         """str: Name of the LAMMPS dump file of the defect system"""
         if self.__dumpfile_defect is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_defect
 
     @property
-    def symbols_base(self):
+    def symbols_base(self) -> list:
         """list: Model symbols for the base system"""
         if self.__symbols_base is None:
             raise ValueError('No results yet!')
         return self.__symbols_base
-    
+
     @property
-    def symbols_defect(self):
+    def symbols_defect(self) -> list:
         """list: Model symbols for the defect system"""
         if self.__symbols_defect is None:
             raise ValueError('No results yet!')
         return self.__symbols_defect
 
     @property
-    def natoms_base(self):
+    def natoms_base(self) -> int:
         """int: Number of atoms in the base system"""
         if self.__natoms_base is None:
             raise ValueError('No results yet!')
         return self.__natoms_base
-    
+
     @property
-    def natoms_defect(self):
+    def natoms_defect(self) -> int:
         """int: Number of atoms in the defect system"""
         if self.__natoms_defect is None:
             raise ValueError('No results yet!')
         return self.__natoms_defect
 
     @property
-    def system_base(self):
+    def system_base(self) -> am.System:
         """atomman.System: The base system"""
         if self.__system_base is None:
             raise ValueError('System not set/loaded!')
         return self.__system_base
-            
+
     @property
-    def system_defect(self):
+    def system_defect(self) -> am.System:
         """atomman.System: The defect system"""
         if self.__system_defect is None:
             raise ValueError('System not set/loaded!')
         return self.__system_defect
 
     @system_defect.setter
-    def system_defect(self, value):
-        if isinstance(value, am.System) or value is None:
-            self.__system_defect = value
+    def system_defect(self, val: Optional[am.System]):
+        if isinstance(val, am.System) or val is None:
+            self.__system_defect = val
         else:
             raise ValueError('system_defect must be a System or None')
 
     @property
-    def potential_energy_base(self):
+    def potential_energy_base(self) -> float:
         """float: Potential energy of the base system"""
         if self.__potential_energy_base is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_base
 
     @property
-    def potential_energy_defect(self):
+    def potential_energy_defect(self) -> float:
         """float: Potential energy of the defect system"""
         if self.__potential_energy_defect is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_defect
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: Potential energy per atom for the base system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
     @property
-    def formation_energy(self):
+    def formation_energy(self) -> float:
         """float: Point defect formation energy"""
         if self.__formation_energy is None:
             raise ValueError('No results yet!')
         return self.__formation_energy
 
     @property
-    def dipole_tensor(self):
+    def dipole_tensor(self) -> np.ndarray:
         """numpy.NDArray: The elastic dipole tensor for the point defect"""
         if self.__dipole_tensor is None:
             raise ValueError('No results yet!')
         return self.__dipole_tensor
 
     @property
-    def has_reconfigured(self):
+    def has_reconfigured(self) -> bool:
         """bool: Flag for if checks indicate the defect has reconfigured"""
         if self.__has_reconfigured is None:
             raise ValueError('No results yet!')
         return self.__has_reconfigured
-        
+
     @property
-    def centrosummation(self):
+    def centrosummation(self) -> np.ndarray:
         """numpy.NDArray: sum of relative neighbor coordinates after relaxing"""
         if self.__centrosummation is None:
             raise ValueError('No results yet!')
         return self.__centrosummation
-        
+
     @property
-    def position_shift(self):
+    def position_shift(self) -> np.ndarray:
         """numpy.NDArray: shift in defect's position after relaxing"""
         if self.__position_shift is None:
             raise ValueError('Value not set!')
         return self.__position_shift
-    
+
     @property
-    def db_vect_shift(self):
+    def db_vect_shift(self) -> np.ndarray:
         """numpy.NDArray: Change in dumbbell vector after relaxing"""
         if self.__db_vect_shift is None:
             raise ValueError('Value not set!')
         return self.__db_vect_shift
 
     def load_system_base(self):
+        """Load the base system from the database"""
         if self.__system_base is None:
             fname = self.dumpfile_base
             tar = self.database.get_tar(record=self)
             f = tar.extractfile(fname)
             self.__system_base = am.load('atom_dump', f, symbols=self.symbols_base)
 
     def load_system_defect(self):
+        """Load the defect system from the database"""
         if self.__system_defect is None:
             fname = self.dumpfile_defect
             tar = self.database.get_tar(record=self)
             f = tar.extractfile(fname)
             self.__system_defect = am.load('atom_dump', f, symbols=self.symbols_defect)
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -268,59 +290,74 @@
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
         super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '5 5 5')
         input_dict['forcetolerance'] = input_dict.get('forcetolerance',
                                                   '1.0e-6 eV/angstrom')
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
 
         # Load calculation-specific unitless floats
 
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load minimization parameters
         self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
-        
+
         # Load defect parameters
         self.defect.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -338,15 +375,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicparent load_file parent',
                 'defect pointdefect_file'
@@ -356,55 +393,55 @@
             params['parent_standing'] = 'good'
             params['defect_record'] = 'point_defect'
             params['sizemults'] = '12 12 12'
             params['forcetolerance'] = '1e-8'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
- 
+
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
@@ -414,25 +451,25 @@
                 self.defect.keyset
             ] +
 
             # Minimization keys
             [
                 self.minimize.keyset
             ]
-        )                     
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-point-defect-static'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -447,47 +484,49 @@
         # Build results
         if self.status == 'finished':
             calc['defect-free-system'] = DM()
             calc['defect-free-system']['artifact'] = DM()
             calc['defect-free-system']['artifact']['file'] = self.dumpfile_base
             calc['defect-free-system']['artifact']['format'] = 'atom_dump'
             calc['defect-free-system']['symbols'] = self.symbols_base
-            calc['defect-free-system']['potential-energy'] = uc.model(self.potential_energy_base, 
+            calc['defect-free-system']['potential-energy'] = uc.model(self.potential_energy_base,
                                                                       self.units.energy_unit)
-            
+
             calc['defect-system'] = DM()
             calc['defect-system']['artifact'] = DM()
             calc['defect-system']['artifact']['file'] = self.dumpfile_defect
             calc['defect-system']['artifact']['format'] = 'atom_dump'
             calc['defect-system']['symbols'] = self.symbols_defect
             calc['defect-system']['potential-energy'] = uc.model(self.potential_energy_defect,
                                                                  self.units.energy_unit)
-            
+
             # Save the calculation results
             calc['cohesive-energy'] = uc.model(self.potential_energy,
                                                self.units.energy_unit)
             calc['number-of-atoms'] = self.natoms_defect
             calc['defect-formation-energy'] = uc.model(self.formation_energy,
                                                        self.units.energy_unit)
             calc['defect-elastic-dipole-tensor'] = uc.model(self.dipole_tensor,
                                                             self.units.energy_unit)
-            
+
             # Save the reconfiguration checks
             calc['reconfiguration-check'] = r_c = DM()
             r_c['has_reconfigured'] = self.has_reconfigured
             r_c['centrosummation'] = self.centrosummation.tolist()
             if self.__position_shift is not None:
                 r_c['position_shift'] = self.position_shift.tolist()
             if self.__db_vect_shift is not None:
                 r_c['db_vect_shift'] = self.db_vect_shift.tolist()
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -501,196 +540,121 @@
 
         # Load results
         if self.status == 'finished':
             self.__dumpfile_base = calc['defect-free-system']['artifact']['file']
             self.__symbols_base = calc['defect-free-system']['symbols']
             self.__potential_energy_base = uc.value_unit(calc['defect-free-system']['potential-energy'])
             self.__natoms_base = None
-            
+
             self.__dumpfile_defect= calc['defect-system']['artifact']['file']
             self.__symbols_defect = calc['defect-system']['symbols']
             self.__potential_energy_defect = uc.value_unit(calc['defect-system']['potential-energy'])
             self.__natoms_defect = calc['number-of-atoms']
-            
+
             self.__potential_energy = uc.value_unit(calc['cohesive-energy'])
             self.__formation_energy = uc.value_unit(calc['defect-formation-energy'])
             self.__dipole_tensor = uc.value_unit(calc['defect-elastic-dipole-tensor'])
-            
+
             # Save the reconfiguration checks
             r_c = calc['reconfiguration-check']
             self.__has_reconfigured = r_c['has_reconfigured']
             self.__centrosummation = np.array(r_c['centrosummation'])
             if 'position_shift' in r_c:
                 self.__position_shift = np.array(r_c['position_shift'])
             else:
                 self.__position_shift = None
             if 'db_vect_shift' in r_c:
                 self.__db_vect_shift = np.array(r_c['db_vect_shift'])
             else:
                 self.__db_vect_shift = None
-            
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        
+
         # Extract results
         if self.status == 'finished':            
             meta['dumpfile_base'] = self.dumpfile_base
             meta['dumpfile_defect'] = self.dumpfile_defect
             meta['E_pot_base'] = self.potential_energy_base
             meta['E_pot_defect'] = self.potential_energy_defect
             meta['E_pot'] = self.potential_energy
             meta['E_ptd_f'] = self.formation_energy
             meta['pij'] = self.dipole_tensor
             meta['has_reconfigured'] = self.has_reconfigured
             meta['centrosummation'] = self.centrosummation
             try:
                 meta['position_shift'] = self.position_shift
-            except:
+            except ValueError:
                 pass
             try:
                 meta['db_vect_shift'] = self.db_vect_shift
-            except:
+            except ValueError:
                 pass
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
+
             'a_mult',
             'b_mult',
             'c_mult',
-            
+
             'pointdefect_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def isvalid(self):
+    def isvalid(self) -> bool:
         return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
         # Modify inputs for calculation
         input_dict['cutoff'] = 1.05 * input_dict['ucell'].box.a
         del input_dict['ucell']
         del input_dict['transform']
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_static/README.md` & `iprPy-0.11.5/iprPy/calculation/point_defect_static/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_static/point_defect_static.py` & `iprPy-0.11.5/iprPy/calculation/point_defect_static/point_defect_static.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/point_defect_static/theory.md` & `iprPy-0.11.5/iprPy/calculation/point_defect_static/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_box/README.md` & `iprPy-0.11.5/iprPy/calculation/relax_box/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_box/RelaxBox.py` & `iprPy-0.11.5/iprPy/calculation/relax_box/RelaxBox.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,38 +1,56 @@
 # coding: utf-8
 # Standard Python libraries
-from copy import deepcopy
-
-import numpy as np
-
-from yabadaba import query
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .relax_box import relax_box
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate)
+from ...input import value
 
 class RelaxBox(Calculation):
     """Class for managing box-only relaxations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
+
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
         subsets = (self.commands, self.potential, self.system,
@@ -61,184 +79,186 @@
         self.calc = relax_box
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'relax_box.py',
             'cij.template'
         ]
 
 ############################## Class attributes ################################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
-    
+
     @property
-    def pressure_xx(self):
+    def pressure_xx(self) -> float:
         """float: Target relaxation pressure component xx"""
         return self.__pressure_xx
 
     @pressure_xx.setter
-    def pressure_xx(self, value):
-        self.__pressure_xx = float(value)
+    def pressure_xx(self, val: float):
+        self.__pressure_xx = float(val)
 
     @property
-    def pressure_yy(self):
+    def pressure_yy(self) -> float:
         """float: Target relaxation pressure component yy"""
         return self.__pressure_yy
 
     @pressure_yy.setter
-    def pressure_yy(self, value):
-        self.__pressure_yy = float(value)
-    
+    def pressure_yy(self, val: float):
+        self.__pressure_yy = float(val)
+
     @property
-    def pressure_zz(self):
+    def pressure_zz(self) -> float:
         """float: Target relaxation pressure component zz"""
         return self.__pressure_zz
 
     @pressure_zz.setter
-    def pressure_zz(self, value):
-        self.__pressure_zz = float(value)
+    def pressure_zz(self, val: float):
+        self.__pressure_zz = float(val)
 
     @property
-    def pressure_xy(self):
+    def pressure_xy(self) -> float:
         """float: Target relaxation pressure component xy"""
         return self.__pressure_xy
 
     @pressure_xy.setter
-    def pressure_xy(self, value):
-        self.__pressure_xy = float(value)
+    def pressure_xy(self, val: float):
+        self.__pressure_xy = float(val)
 
     @property
-    def pressure_xz(self):
+    def pressure_xz(self) -> float:
         """float: Target relaxation pressure component xz"""
         return self.__pressure_xz
 
     @pressure_xz.setter
-    def pressure_xz(self, value):
-        self.__pressure_xz = float(value)
+    def pressure_xz(self, val: float):
+        self.__pressure_xz = float(val)
 
     @property
-    def pressure_yz(self):
+    def pressure_yz(self) -> float:
         """float: Target relaxation pressure component yz"""
         return self.__pressure_yz
 
     @pressure_yz.setter
-    def pressure_yz(self, value):
-        self.__pressure_yz = float(value)
+    def pressure_yz(self, val: float):
+        self.__pressure_yz = float(val)
 
     @property
-    def strainrange(self):
+    def strainrange(self) -> float:
         """float: Strain range size used during box relaxation"""
         return self.__strainrange
 
     @strainrange.setter
-    def strainrange(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__strainrange = value
+    def strainrange(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__strainrange = val
 
     @property
-    def initial_dump(self):
+    def initial_dump(self) -> dict:
         """dict: Info about the initial dump file"""
         if self.__initial_dump is None:
             raise ValueError('No results yet!')
         return self.__initial_dump
 
     @property
-    def final_dump(self):
+    def final_dump(self) -> dict:
         """dict: Info about the final dump file"""
         if self.__final_dump is None:
             raise ValueError('No results yet!')
         return self.__final_dump
-    
+
     @property
-    def final_box(self):
+    def final_box(self) -> am.Box:
         """atomman.Box: Relaxed unit cell box"""
         if self.__final_box is None:
             raise ValueError('No results yet!')
         return self.__final_box
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: Potential energy per atom for the relaxed system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
     @property
-    def measured_pressure_xx(self):
+    def measured_pressure_xx(self) -> float:
         """float: Measured relaxation pressure component xx"""
         if self.__measured_pressure_xx is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xx
-    
+
     @property
-    def measured_pressure_yy(self):
+    def measured_pressure_yy(self) -> float:
         """float: Measured relaxation pressure component yy"""
         if self.__measured_pressure_yy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yy
-    
+
     @property
-    def measured_pressure_zz(self):
+    def measured_pressure_zz(self) -> float:
         """float: Measured relaxation pressure component zz"""
         if self.__measured_pressure_zz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_zz
-    
+
     @property
-    def measured_pressure_xy(self):
+    def measured_pressure_xy(self) -> float:
         """float: Measured relaxation pressure component xy"""
         if self.__measured_pressure_xy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xy
-    
+
     @property
-    def measured_pressure_xz(self):
+    def measured_pressure_xz(self) -> float:
         """float: Measured relaxation pressure component xz"""
         if self.__measured_pressure_xz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xz
-    
+
     @property
-    def measured_pressure_yz(self):
+    def measured_pressure_yz(self) -> float:
         """float: Measured relaxation pressure component yz"""
         if self.__measured_pressure_yz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yz
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -278,37 +298,50 @@
         if 'pressure_xz' in kwargs:
             self.pressure_xz = kwargs['pressure_xz']
         if 'pressure_yz' in kwargs:
             self.pressure_yz = kwargs['pressure_yz']
         if 'strainrange' in kwargs:
             self.strainrange = kwargs['strainrange']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '1 1 1')
 
-        # Load calculation-specific strings       
+        # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.number_of_steps_r = int(input_dict.get('number_of_steps_r', 201))
 
         # Load calculation-specific unitless floats
         self.strainrange = float(input_dict.get('strainrange', 1e-6))
-        
+
         # Load calculation-specific floats with units
         self.pressure_xx = value(input_dict, 'pressure_xx',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
         self.pressure_yy = value(input_dict, 'pressure_yy',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
@@ -320,28 +353,30 @@
                                  default_term='0.0 GPa')
         self.pressure_xz = value(input_dict, 'pressure_xz',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
         self.pressure_yz = value(input_dict, 'pressure_yz',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -359,15 +394,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicreference load_file reference',
                 'atomicparent load_file parent'
@@ -377,31 +412,31 @@
             params['parent_status'] = 'finished'
             params['sizemults'] = '10 10 10'
             params['atomshift'] = '0.05 0.05 0.05'
             params['strainrange'] = '1e-6'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'reference_{key}'] = kwargs[key]
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
-        
+
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'pressure_xx': ' '.join([
                 "The Pxx normal pressure component to relax the box to.",
                 "Default value is 0.0 GPa."]),
             'pressure_yy': ' '.join([
@@ -418,43 +453,43 @@
                 "Default value is 0.0 GPa."]),
             'pressure_yz': ' '.join([
                 "The Pyz normal pressure component to relax the box to.",
                 "Default value is 0.0 GPa."]),
             'strainrange': ' '.join([
                 "The strain range to use when estimating the elastic constants",
                 "used to relax the box dimensions.  Default value is 1e-6."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
@@ -473,25 +508,25 @@
 
             # Strainrange
             [
                 [
                     'strainrange',
                 ]
             ]
-        ) 
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-relax-box'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -529,30 +564,30 @@
         if self.status == 'finished':
             # Save info on initial and final configuration files
             calc['initial-system'] = DM()
             calc['initial-system']['artifact'] = DM()
             calc['initial-system']['artifact']['file'] = self.initial_dump['filename']
             calc['initial-system']['artifact']['format'] = 'atom_dump'
             calc['initial-system']['symbols'] = self.initial_dump['symbols']
-            
+
             calc['final-system'] = DM()
             calc['final-system']['artifact'] = DM()
             calc['final-system']['artifact']['file'] = self.final_dump['filename']
             calc['final-system']['artifact']['format'] = 'atom_dump'
             calc['final-system']['symbols'] = self.final_dump['symbols']
-            
+
             # Save measured box parameter info
-            calc['measured-box-parameter'] = mbp = DM()            
+            calc['measured-box-parameter'] = mbp = DM()
             mbp['lx'] = uc.model(self.final_box.lx, self.units.length_unit)
             mbp['ly'] = uc.model(self.final_box.ly, self.units.length_unit)
             mbp['lz'] = uc.model(self.final_box.lz, self.units.length_unit)
             mbp['xy'] = uc.model(self.final_box.xy, self.units.length_unit)
             mbp['xz'] = uc.model(self.final_box.xz, self.units.length_unit)
             mbp['yz'] = uc.model(self.final_box.yz, self.units.length_unit)
-            
+
             # Save measured phase-state info
             calc['measured-phase-state'] = mps = DM()
             mps['temperature'] = uc.model(0.0, 'K')
             mps['pressure-xx'] = uc.model(self.measured_pressure_xx,
                                           self.units.pressure_unit)
             mps['pressure-yy'] = uc.model(self.measured_pressure_yy,
                                           self.units.pressure_unit)
@@ -560,24 +595,26 @@
                                           self.units.pressure_unit)
             mps['pressure-xy'] = uc.model(self.measured_pressure_xy,
                                           self.units.pressure_unit)
             mps['pressure-xz'] = uc.model(self.measured_pressure_xz,
                                           self.units.pressure_unit)
             mps['pressure-yz'] = uc.model(self.measured_pressure_yz,
                                           self.units.pressure_unit)
-            
+
             # Save the final cohesive energy
             calc['cohesive-energy'] = uc.model(self.potential_energy,
                                                self.units.energy_unit,
                                                None)
-        
+
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -600,15 +637,14 @@
 
         # Load results
         if self.status == 'finished':
             self.__initial_dump = {
                 'filename': calc['initial-system']['artifact']['file'],
                 'symbols': calc['initial-system']['symbols']
             }
-            
 
             self.__final_dump = {
                 'filename': calc['final-system']['artifact']['file'],
                 'symbols': calc['final-system']['symbols']
             }
 
             lx = uc.value_unit(calc['measured-box-parameter']['lx'])
@@ -616,73 +652,26 @@
             lz = uc.value_unit(calc['measured-box-parameter']['lz'])
             xy = uc.value_unit(calc['measured-box-parameter']['xy'])
             xz = uc.value_unit(calc['measured-box-parameter']['xz'])
             yz = uc.value_unit(calc['measured-box-parameter']['yz'])
             self.__final_box = am.Box(lx=lx, ly=ly, lz=lz, xy=xy, xz=xz, yz=yz)
 
             self.__potential_energy = uc.value_unit(calc['cohesive-energy'])
-            
+
             mps = calc['measured-phase-state']
             self.__measured_pressure_xx = uc.value_unit(mps['pressure-xx'])
             self.__measured_pressure_yy = uc.value_unit(mps['pressure-yy'])
             self.__measured_pressure_zz = uc.value_unit(mps['pressure-zz'])
             self.__measured_pressure_xy = uc.value_unit(mps['pressure-xy'])
             self.__measured_pressure_xz = uc.value_unit(mps['pressure-xz'])
             self.__measured_pressure_yz = uc.value_unit(mps['pressure-yz'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
-
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
@@ -691,106 +680,74 @@
         meta['temperature'] = 0.0
         meta['pressure_xx'] = self.pressure_xx
         meta['pressure_yy'] = self.pressure_yy
         meta['pressure_zz'] = self.pressure_zz
         meta['pressure_xy'] = self.pressure_xy
         meta['pressure_xz'] = self.pressure_xz
         meta['pressure_yz'] = self.pressure_yz
-        
+
         # Extract results
         if self.status == 'finished':
             meta['lx'] = self.final_box.lx
             meta['ly'] = self.final_box.ly
             meta['lz'] = self.final_box.lz
             meta['xy'] = self.final_box.xy
             meta['xz'] = self.final_box.xz
             meta['yz'] = self.final_box.yz
-            
+
             meta['E_pot'] = self.potential_energy
             meta['measured_temperature'] = 0.0
             meta['measured_pressure_xx'] = self.measured_pressure_xx
             meta['measured_pressure_yy'] = self.measured_pressure_yy
             meta['measured_pressure_zz'] = self.measured_pressure_zz
             meta['measured_pressure_xy'] = self.measured_pressure_xy
             meta['measured_pressure_xz'] = self.measured_pressure_xz
             meta['measured_pressure_yz'] = self.measured_pressure_yz
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
+
             'parent_key',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
-        #    'a_mult',
-        #    'b_mult',
-        #    'c_mult',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'temperature':1e-2,
             'pressure_xx':1e-2,
             'pressure_yy':1e-2,
             'pressure_zz':1e-2,
             'pressure_xy':1e-2,
             'pressure_xz':1e-2,
             'pressure_yz':1e-2,
         }
 
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
-        
+
         # Remove unused subset inputs
         del input_dict['transform']
         del input_dict['ucell']
 
         # Add calculation-specific inputs
         input_dict['strainrange'] = self.strainrange
         input_dict['p_xx'] = self.pressure_xx
@@ -798,16 +755,16 @@
         input_dict['p_zz'] = self.pressure_zz
         input_dict['p_xy'] = self.pressure_xy
         input_dict['p_xz'] = self.pressure_xz
         input_dict['p_yz'] = self.pressure_yz
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
@@ -830,8 +787,8 @@
         self.__final_box = am.Box(lx=lx, ly=ly, lz=lz, xy=xy, xz=xz, yz=yz)
         self.__potential_energy = results_dict['E_pot']
         self.__measured_pressure_xx = results_dict['measured_pxx']
         self.__measured_pressure_yy = results_dict['measured_pyy']
         self.__measured_pressure_zz = results_dict['measured_pzz']
         self.__measured_pressure_xy = results_dict['measured_pxy']
         self.__measured_pressure_xz = results_dict['measured_pxz']
-        self.__measured_pressure_yz = results_dict['measured_pyz']
+        self.__measured_pressure_yz = results_dict['measured_pyz']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_box/cij_run0.template` & `iprPy-0.11.5/iprPy/calculation/relax_box/cij_run0.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_box/relax_box.py` & `iprPy-0.11.5/iprPy/calculation/relax_box/relax_box.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_box/theory.md` & `iprPy-0.11.5/iprPy/calculation/relax_box/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_dynamic/README.md` & `iprPy-0.11.5/iprPy/calculation/relax_dynamic/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_dynamic/RelaxDynamic.py` & `iprPy-0.11.5/iprPy/calculation/relax_dynamic/RelaxDynamic.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,40 +1,61 @@
 # coding: utf-8
 # Standard Python libraries
-import uuid
+from io import IOBase
+from pathlib import Path
 from copy import deepcopy
+from typing import Optional, Union
 import random
 
 import numpy as np
 
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .relax_dynamic import relax_dynamic
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate)
+from ...input import value
 
 class RelaxDynamic(Calculation):
     """Class for managing dynamic relaxations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
         subsets = (self.commands, self.potential, self.system,
@@ -51,15 +72,15 @@
         self.integrator = None
         self.thermosteps = 100
         self.dumpsteps = None
         self.restartsteps = None
         self.runsteps = 220000
         self.equilsteps = 20000
         self.randomseed = None
-        
+
         self.__initial_dump = None
         self.__final_dump = None
         self.__final_box = None
         self.__lx_mean = None
         self.__ly_mean = None
         self.__lz_mean = None
         self.__xy_mean = None
@@ -95,442 +116,449 @@
         self.calc = relax_dynamic
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'relax_dynamic.py',
             'full_relax.template'
         ]
 
 ############################## Class attributes ################################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
 
     @property
-    def pressure_xx(self):
+    def pressure_xx(self) -> float:
         """float: Target relaxation pressure component xx"""
         return self.__pressure_xx
 
     @pressure_xx.setter
-    def pressure_xx(self, value):
-        self.__pressure_xx = float(value)
+    def pressure_xx(self, val: float):
+        self.__pressure_xx = float(val)
 
     @property
-    def pressure_yy(self):
+    def pressure_yy(self) -> float:
         """float: Target relaxation pressure component yy"""
         return self.__pressure_yy
 
     @pressure_yy.setter
-    def pressure_yy(self, value):
-        self.__pressure_yy = float(value)
-    
+    def pressure_yy(self, val: float):
+        self.__pressure_yy = float(val)
+
     @property
-    def pressure_zz(self):
+    def pressure_zz(self) -> float:
         """float: Target relaxation pressure component zz"""
         return self.__pressure_zz
 
     @pressure_zz.setter
-    def pressure_zz(self, value):
-        self.__pressure_zz = float(value)
+    def pressure_zz(self, val: float):
+        self.__pressure_zz = float(val)
 
     @property
-    def pressure_xy(self):
+    def pressure_xy(self) -> float:
         """float: Target relaxation pressure component xy"""
         return self.__pressure_xy
 
     @pressure_xy.setter
-    def pressure_xy(self, value):
-        self.__pressure_xy = float(value)
+    def pressure_xy(self, val: float):
+        self.__pressure_xy = float(val)
 
     @property
-    def pressure_xz(self):
+    def pressure_xz(self) -> float:
         """float: Target relaxation pressure component xz"""
         return self.__pressure_xz
 
     @pressure_xz.setter
-    def pressure_xz(self, value):
-        self.__pressure_xz = float(value)
-    
+    def pressure_xz(self, val: float):
+        self.__pressure_xz = float(val)
+
     @property
-    def pressure_yz(self):
+    def pressure_yz(self) -> float:
         """float: Target relaxation pressure component yz"""
         return self.__pressure_yz
 
     @pressure_yz.setter
-    def pressure_yz(self, value):
-        self.__pressure_yz = float(value)
+    def pressure_yz(self, val: float):
+        self.__pressure_yz = float(val)
 
     @property
-    def temperature(self):
+    def temperature(self) -> float:
         """float: Target relaxation temperature"""
         return self.__temperature
 
     @temperature.setter
-    def temperature(self, value):
-        value = float(value)
-        assert value >= 0.0
-        self.__temperature = value
+    def temperature(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__temperature = val
 
     @property
-    def integrator(self):
+    def integrator(self) -> str:
         """str: MD integration scheme"""
         return self.__integrator
 
     @integrator.setter
-    def integrator(self, value):
-        if value is None:
+    def integrator(self, val: Optional[str]):
+        if val is None:
             if self.temperature == 0.0:
-                value = 'nph+l'
+                val = 'nph+l'
             else:
-                value = 'npt'
-        self.__integrator = str(value)
+                val = 'npt'
+        self.__integrator = str(val)
 
     @property
-    def thermosteps(self):
+    def thermosteps(self) -> int:
+        """int : How often termo data is recorded"""
         return self.__thermosteps
 
     @thermosteps.setter
-    def thermosteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__thermosteps = value
+    def thermosteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__thermosteps = val
 
     @property
-    def dumpsteps(self):
+    def dumpsteps(self) -> int:
+        """int : How often atomic configurations are dumped"""
         if self.__dumpsteps is None:
             return self.runsteps
         else:
             return self.__dumpsteps
 
     @dumpsteps.setter
-    def dumpsteps(self, value):
-        if value is None:
+    def dumpsteps(self, val: int):
+        if val is None:
             self.__dumpsteps = None
         else:
-            value = int(value)
-            assert value >= 0
-            self.__dumpsteps = value
+            val = int(val)
+            assert val >= 0
+            self.__dumpsteps = val
 
     @property
-    def restartsteps(self):
+    def restartsteps(self) -> int:
+        """int : How often restart files are dumped"""
         if self.__restartsteps is None:
             return self.runsteps
         else:
             return self.__restartsteps
 
     @restartsteps.setter
-    def restartsteps(self, value):
-        if value is None:
+    def restartsteps(self, val: int):
+        if val is None:
             self.__restartsteps = None
         else:
-            value = int(value)
-            assert value >= 0
-            self.__restartsteps = value
+            val = int(val)
+            assert val >= 0
+            self.__restartsteps = val
 
     @property
-    def runsteps(self):
+    def runsteps(self) -> int:
+        """int : The number of MD steps where properties are evaluated"""
         return self.__runsteps
 
     @runsteps.setter
-    def runsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__runsteps = value
+    def runsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__runsteps = val
 
     @property
-    def equilsteps(self):
+    def equilsteps(self) -> int:
+        """int : The number of MD steps to perform prior to runsteps"""
         return self.__equilsteps
 
     @equilsteps.setter
-    def equilsteps(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__equilsteps = value
+    def equilsteps(self, val: int):
+        val = int(val)
+        assert val >= 0
+        self.__equilsteps = val
 
     @property
-    def randomseed(self):
-        """str: MD integration scheme"""
+    def randomseed(self) -> int:
+        """int: Random number generator seed"""
         return self.__randomseed
 
     @randomseed.setter
-    def randomseed(self, value):
-        if value is None:
-            value = random.randint(1, 900000000)
+    def randomseed(self, val: int):
+        if val is None:
+            val = random.randint(1, 900000000)
         else:
-            value = int(value)
-            assert value > 0 and value <= 900000000
-        self.__randomseed = value
+            val = int(val)
+            assert val > 0 and val <= 900000000
+        self.__randomseed = val
 
     @property
-    def initial_dump(self):
+    def initial_dump(self) -> dict:
         """dict: Info about the initial dump file"""
         if self.__initial_dump is None:
             raise ValueError('No results yet!')
         return self.__initial_dump
 
     @property
-    def final_dump(self):
+    def final_dump(self) -> dict:
         """dict: Info about the final dump file"""
         if self.__final_dump is None:
             raise ValueError('No results yet!')
         return self.__final_dump
-    
+
     @property
-    def final_box(self):
+    def final_box(self) -> am.Box:
         """atomman.Box: Relaxed unit cell box"""
         if self.__final_box is None:
             raise ValueError('No results yet!')
         return self.__final_box
 
     @property
-    def lx_mean(self):
+    def lx_mean(self) -> float:
         """float: Mean lx length used for final_box"""
         if self.__lx_mean is None:
             raise ValueError('No results yet!')
         return self.__lx_mean
 
     @property
-    def lx_std(self):
+    def lx_std(self) -> float:
         """float: Standard deviation for final_box's lx length"""
         if self.__lx_std is None:
             raise ValueError('No results yet!')
         return self.__lx_std
 
     @property
-    def ly_mean(self):
+    def ly_mean(self) -> float:
         """float: Mean ly length used for final_box"""
         if self.__ly_mean is None:
             raise ValueError('No results yet!')
         return self.__ly_mean
 
     @property
-    def ly_std(self):
+    def ly_std(self) -> float:
         """float: Standard deviation for final_box's ly length"""
         if self.__ly_std is None:
             raise ValueError('No results yet!')
         return self.__ly_std
-    
+
     @property
-    def lz_mean(self):
+    def lz_mean(self) -> float:
         """float: Mean lz length used for final_box"""
         if self.__lz_mean is None:
             raise ValueError('No results yet!')
         return self.__lz_mean
 
     @property
-    def lz_std(self):
+    def lz_std(self) -> float:
         """float: Standard deviation for final_box's lz length"""
         if self.__lz_std is None:
             raise ValueError('No results yet!')
         return self.__lz_std
 
     @property
-    def xy_mean(self):
+    def xy_mean(self) -> float:
         """float: Mean xy tilt used for final_box"""
         if self.__xy_mean is None:
             raise ValueError('No results yet!')
         return self.__xy_mean
 
     @property
-    def xy_std(self):
+    def xy_std(self) -> float:
         """float: Standard deviation for final_box's xy tilt"""
         if self.__xy_std is None:
             raise ValueError('No results yet!')
         return self.__xy_std
 
     @property
-    def xz_mean(self):
+    def xz_mean(self) -> float:
         """float: Mean xz tilt used for final_box"""
         if self.__xz_mean is None:
             raise ValueError('No results yet!')
         return self.__xz_mean
 
     @property
-    def xz_std(self):
+    def xz_std(self) -> float:
         """float: Standard deviation for final_box's xz tilt"""
         if self.__xz_std is None:
             raise ValueError('No results yet!')
         return self.__xz_std
 
     @property
-    def yz_mean(self):
+    def yz_mean(self) -> float:
         """float: Mean yz tilt used for final_box"""
         if self.__yz_mean is None:
             raise ValueError('No results yet!')
         return self.__yz_mean
 
     @property
-    def yz_std(self):
+    def yz_std(self) -> float:
         """float: Standard deviation for final_box's yz tilt"""
         if self.__yz_std is None:
             raise ValueError('No results yet!')
         return self.__yz_std
 
     @property
-    def numsamples(self):
+    def numsamples(self) -> int:
         """int: Number of measurement samples used in mean, std values"""
         if self.__numsamples is None:
             raise ValueError('No results yet!')
         return self.__numsamples
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: Potential energy per atom for the relaxed system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
     @property
-    def potential_energy_std(self):
+    def potential_energy_std(self) -> float:
         """float: Standard deviation for potential_energy"""
         if self.__potential_energy_std is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_std
 
     @property
-    def total_energy(self):
+    def total_energy(self) -> float:
         """float: Total energy per atom for the relaxed system"""
         if self.__total_energy is None:
             raise ValueError('No results yet!')
         return self.__total_energy
 
     @property
-    def total_energy_std(self):
+    def total_energy_std(self) -> float:
         """float: Standard deviation for total_energy"""
         if self.__total_energy_std is None:
             raise ValueError('No results yet!')
         return self.__total_energy_std
 
     @property
-    def measured_pressure_xx(self):
+    def measured_pressure_xx(self) -> float:
         """float: Measured relaxation pressure component xx"""
         if self.__measured_pressure_xx is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xx
-    
+
     @property
-    def measured_pressure_xx_std(self):
+    def measured_pressure_xx_std(self) -> float:
         """float: Standard deviation for measured_pressure_xx"""
         if self.__measured_pressure_xx_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xx_std
 
     @property
-    def measured_pressure_yy(self):
+    def measured_pressure_yy(self) -> float:
         """float: Measured relaxation pressure component yy"""
         if self.__measured_pressure_yy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yy
-    
+
     @property
-    def measured_pressure_yy_std(self):
+    def measured_pressure_yy_std(self) -> float:
         """float: Standard deviation for measured_pressure_yy"""
         if self.__measured_pressure_yy_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yy_std
 
     @property
-    def measured_pressure_zz(self):
+    def measured_pressure_zz(self) -> float:
         """float: Measured relaxation pressure component zz"""
         if self.__measured_pressure_zz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_zz
-    
+
     @property
-    def measured_pressure_zz_std(self):
+    def measured_pressure_zz_std(self) -> float:
         """float: Standard deviation for measured_pressure_zz"""
         if self.__measured_pressure_zz_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_zz_std
 
     @property
-    def measured_pressure_xy(self):
+    def measured_pressure_xy(self) -> float:
         """float: Measured relaxation pressure component xy"""
         if self.__measured_pressure_xy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xy
-    
+
     @property
-    def measured_pressure_xy_std(self):
+    def measured_pressure_xy_std(self) -> float:
         """float: Standard deviation for measured_pressure_xy"""
         if self.__measured_pressure_xy_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xy_std
 
     @property
-    def measured_pressure_xz(self):
+    def measured_pressure_xz(self) -> float:
         """float: Measured relaxation pressure component xz"""
         if self.__measured_pressure_xz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xz
-    
+
     @property
-    def measured_pressure_xz_std(self):
+    def measured_pressure_xz_std(self) -> float:
         """float: Standard deviation for measured_pressure_xz"""
         if self.__measured_pressure_xz_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xz_std
 
     @property
-    def measured_pressure_yz(self):
+    def measured_pressure_yz(self) -> float:
         """float: Measured relaxation pressure component yz"""
         if self.__measured_pressure_yz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yz
 
     @property
-    def measured_pressure_yz_std(self):
+    def measured_pressure_yz_std(self) -> float:
         """float: Standard deviation for measured_pressure_yz"""
         if self.__measured_pressure_yz_std is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yz_std
 
     @property
-    def measured_temperature(self):
+    def measured_temperature(self) -> float:
         """float: Measured temperature for the relaxed system"""
         if self.__measured_temperature is None:
             raise ValueError('No results yet!')
         return self.__measured_temperature
 
     @property
-    def measured_temperature_std(self):
+    def measured_temperature_std(self) -> float:
         """float: Standard deviation for measured_temperature"""
         if self.__measured_temperature_std is None:
             raise ValueError('No results yet!')
         return self.__measured_temperature_std
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -601,32 +629,45 @@
         if 'runsteps' in kwargs:
             self.runsteps = kwargs['runsteps']
         if 'equilsteps' in kwargs:
             self.equilsteps = kwargs['equilsteps']
         if 'randomseed' in kwargs:
             self.randomseed = kwargs['randomseed']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '10 10 10')
-        
+
         # Load calculation-specific strings
         self.integrator = input_dict.get('integrator', None)
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.runsteps = int(input_dict.get('runsteps', 220000))
         self.thermosteps = int(input_dict.get('thermosteps', 100))
         self.dumpsteps = input_dict.get('dumpsteps', None)
         self.restartsteps = input_dict.get('restartsteps', None)
         self.equilsteps = int(input_dict.get('equilsteps', 20000))
         if self.equilsteps >= self.runsteps:
@@ -651,28 +692,30 @@
                                  default_term='0.0 GPa')
         self.pressure_xz = value(input_dict, 'pressure_xz',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
         self.pressure_yz = value(input_dict, 'pressure_yz',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -690,15 +733,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicreference load_file reference',
                 'atomicparent load_file parent'
@@ -713,26 +756,26 @@
             params['thermosteps'] = '1000'
             params['runsteps'] = '10000'
             params['equilsteps'] = '0'
 
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'reference_{key}'] = kwargs[key]
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
-        
+
         elif branch == 'at_temp':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'atomicparent load_file parent'
             params['parent_record'] = 'relaxed_crystal'
             params['parent_method'] = 'dynamic'
@@ -745,34 +788,34 @@
                 '2100','2200','2300','2400','2500','2600','2700','2800','2900','3000',
             ]
             params['integrator'] = 'npt'
             params['thermosteps'] = '100'
             params['runsteps'] = '1000000'
             params['restartsteps'] = '50000'
             params['equilsteps'] = '0'
-            
+
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     if key != 'potential_pair_style':
                         params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'temperature': ' '.join([
                 "Target temperature for the simulations.  Default value is 0."]),
             'pressure_xx': ' '.join([
                 "The Pxx normal pressure component to relax the box to.",
@@ -812,43 +855,43 @@
             'equilsteps': ' '.join([
                 "The number of MD integration steps at the beginning of",
                 "the simulation to ignore as equilibration time."]),
             'randomseed': ' '.join([
                 "An int random number seed to use for generating initial velocities.",
                 "A random int will be selected if not given."]),
 
-        }  
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
-        
+
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
@@ -886,19 +929,19 @@
             ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-relax-dynamic'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -910,15 +953,15 @@
 
         # Build calculation-specific content
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
-        
+
         run_params['integrator'] = self.integrator
         run_params['thermosteps'] = self.thermosteps
         run_params['dumpsteps'] = self.dumpsteps
         run_params['restartsteps'] = self.restartsteps
         run_params['runsteps'] = self.runsteps
         run_params['equilsteps'] = self.equilsteps
         run_params['randomseed'] = self.randomseed
@@ -943,21 +986,21 @@
         if self.status == 'finished':
             # Save info on initial and final configuration files
             calc['initial-system'] = DM()
             calc['initial-system']['artifact'] = DM()
             calc['initial-system']['artifact']['file'] = self.initial_dump['filename']
             calc['initial-system']['artifact']['format'] = 'atom_dump'
             calc['initial-system']['symbols'] = self.initial_dump['symbols']
-            
+
             calc['final-system'] = DM()
             calc['final-system']['artifact'] = DM()
             calc['final-system']['artifact']['file'] = self.final_dump['filename']
             calc['final-system']['artifact']['format'] = 'atom_dump'
             calc['final-system']['symbols'] = self.final_dump['symbols']
-            
+
             calc['number-of-measurements'] = self.numsamples
 
             # Save measured box parameter info
             calc['measured-box-parameter'] = mbp = DM()
             mbp['lx'] = uc.model(self.lx_mean, self.units.length_unit,
                                  self.lx_std)
             mbp['ly'] = uc.model(self.ly_mean, self.units.length_unit,
@@ -966,15 +1009,15 @@
                                  self.lz_std)
             mbp['xy'] = uc.model(self.xy_mean, self.units.length_unit,
                                  self.xy_std)
             mbp['xz'] = uc.model(self.xz_mean, self.units.length_unit,
                                  self.xz_std)
             mbp['yz'] = uc.model(self.yz_mean, self.units.length_unit,
                                  self.yz_std)
-            
+
             # Save measured phase-state info
             calc['measured-phase-state'] = mps = DM()
             mps['temperature'] = uc.model(self.measured_temperature, 'K',
                                           self.measured_temperature_std)
             mps['pressure-xx'] = uc.model(self.measured_pressure_xx,
                                           self.units.pressure_unit,
                                           self.measured_pressure_xx_std)
@@ -989,28 +1032,30 @@
                                           self.measured_pressure_xy_std)
             mps['pressure-xz'] = uc.model(self.measured_pressure_xz,
                                           self.units.pressure_unit,
                                           self.measured_pressure_xz_std)
             mps['pressure-yz'] = uc.model(self.measured_pressure_yz,
                                           self.units.pressure_unit,
                                           self.measured_pressure_yz_std)
-            
+
             # Save the final cohesive and total energies
             calc['cohesive-energy'] = uc.model(self.potential_energy,
                                                self.units.energy_unit,
                                                self.potential_energy_std)
             if not np.isnan(self.total_energy):
                 calc['average-total-energy'] = uc.model(self.total_energy,
                                                         self.units.energy_unit,
                                                         self.total_energy_std)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -1043,15 +1088,14 @@
 
         # Load results
         if self.status == 'finished':
             self.__initial_dump = {
                 'filename': calc['initial-system']['artifact']['file'],
                 'symbols': calc['initial-system']['symbols']
             }
-            
 
             self.__final_dump = {
                 'filename': calc['final-system']['artifact']['file'],
                 'symbols': calc['final-system']['symbols']
             }
 
             self.__numsamples = calc['number-of-measurements']
@@ -1078,15 +1122,15 @@
                 self.__total_energy_std = uc.error_unit(calc['average-total-energy'])
             elif self.temperature == 0.0:
                 self.__total_energy = self.__potential_energy
                 self.__total_energy_std = self.__potential_energy_std
             else:
                 self.__total_energy = np.nan
                 self.__total_energy_std = np.nan
-            
+
             mps = calc['measured-phase-state']
             self.__measured_temperature = uc.value_unit(mps['temperature'])
             self.__measured_temperature_std = uc.error_unit(mps['temperature'])
             self.__measured_pressure_xx = uc.value_unit(mps['pressure-xx'])
             self.__measured_pressure_xx_std = uc.error_unit(mps['pressure-xx'])
             self.__measured_pressure_yy = uc.value_unit(mps['pressure-yy'])
             self.__measured_pressure_yy_std = uc.error_unit(mps['pressure-yy'])
@@ -1095,64 +1139,29 @@
             self.__measured_pressure_xy = uc.value_unit(mps['pressure-xy'])
             self.__measured_pressure_xy_std = uc.error_unit(mps['pressure-xy'])
             self.__measured_pressure_xz = uc.value_unit(mps['pressure-xz'])
             self.__measured_pressure_xz_std = uc.error_unit(mps['pressure-xz'])
             self.__measured_pressure_yz = uc.value_unit(mps['pressure-yz'])
             self.__measured_pressure_yz_std = uc.error_unit(mps['pressure-yz'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
+    @property
+    def queries(self) -> dict:
+        queries = deepcopy(super().queries)
+        queries.update({
+            'temperature': load_query(
+                style='float_match',
+                name='temperature',
+                path=f'{self.modelroot}.phase-state.temperature.value',
+                description='search by temperature in Kelvin'),
+        })
+        return queries
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
@@ -1161,32 +1170,32 @@
         meta['temperature'] = self.temperature
         meta['pressure_xx'] = self.pressure_xx
         meta['pressure_yy'] = self.pressure_yy
         meta['pressure_zz'] = self.pressure_zz
         meta['pressure_xy'] = self.pressure_xy
         meta['pressure_xz'] = self.pressure_xz
         meta['pressure_yz'] = self.pressure_yz
-        
+
         # Extract results
         if self.status == 'finished':
             meta['numsamples'] = self.numsamples
-            
+
             meta['lx'] = self.lx_mean
             meta['lx_std'] = self.lx_std
             meta['ly'] = self.ly_mean
             meta['ly_std'] = self.ly_std
             meta['lz'] = self.lz_mean
             meta['lz_std'] = self.lz_std
             meta['xy'] = self.xy_mean
             meta['xy_std'] = self.xy_std
             meta['xz'] = self.xz_mean
             meta['xz_std'] = self.xz_std
             meta['yz'] = self.yz_mean
             meta['yz_std'] = self.yz_std
-            
+
             meta['E_pot'] = self.potential_energy
             meta['E_pot_std'] = self.potential_energy_std
             meta['E_total'] = self.total_energy
             meta['E_total_std'] = self.total_energy_std
             meta['measured_temperature'] = self.measured_temperature
             meta['measured_temperature_std'] = self.measured_temperature_std
             meta['measured_pressure_xx'] = self.measured_pressure_xx
@@ -1201,77 +1210,45 @@
             meta['measured_pressure_xz_std'] = self.measured_pressure_xz_std
             meta['measured_pressure_yz'] = self.measured_pressure_yz
             meta['measured_pressure_yz_std'] = self.measured_pressure_yz_std
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
+
             'parent_key',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
-        #    'a_mult',
-        #    'b_mult',
-        #    'c_mult',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'temperature':1e-2,
             'pressure_xx':1e-2,
             'pressure_yy':1e-2,
             'pressure_zz':1e-2,
             'pressure_xy':1e-2,
             'pressure_xz':1e-2,
             'pressure_yz':1e-2,
         }
 
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
@@ -1293,16 +1270,16 @@
         input_dict['dumpsteps'] = self.dumpsteps
         input_dict['restartsteps'] = self.restartsteps
         input_dict['equilsteps'] = self.equilsteps
         input_dict['randomseed'] = self.randomseed
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
@@ -1321,22 +1298,22 @@
         self.__ly_mean = results_dict['ly'] / (self.system_mods.b_mults[1] - self.system_mods.b_mults[0])
         self.__lz_mean = results_dict['lz'] / (self.system_mods.c_mults[1] - self.system_mods.c_mults[0])
         self.__xy_mean = results_dict['xy'] / (self.system_mods.b_mults[1] - self.system_mods.b_mults[0])
         self.__xz_mean = results_dict['xz'] / (self.system_mods.c_mults[1] - self.system_mods.c_mults[0])
         self.__yz_mean = results_dict['yz'] / (self.system_mods.c_mults[1] - self.system_mods.c_mults[0])
         self.__final_box = am.Box(lx=self.lx_mean, ly=self.ly_mean, lz=self.lz_mean,
                                   xy=self.xy_mean, xz=self.xz_mean, yz=self.yz_mean)
-        
+
         self.__lx_std = results_dict['lx_std']
         self.__ly_std = results_dict['ly_std']
         self.__lz_std = results_dict['lz_std']
         self.__xy_std = results_dict['xy_std']
         self.__xz_std = results_dict['xz_std']
         self.__yz_std = results_dict['yz_std']
-        
+
         self.__potential_energy = results_dict['E_pot']
         self.__potential_energy_std = results_dict['E_pot_std']
         self.__total_energy = results_dict['E_total']
         self.__total_energy_std = results_dict['E_total_std']
 
         self.__measured_pressure_xx = results_dict['measured_pxx']
         self.__measured_pressure_xx_std = results_dict['measured_pxx_std']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_dynamic/full_relax.template` & `iprPy-0.11.5/iprPy/calculation/relax_dynamic/full_relax.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_dynamic/full_relax_restart.template` & `iprPy-0.11.5/iprPy/calculation/relax_dynamic/full_relax_restart.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_dynamic/relax_dynamic.py` & `iprPy-0.11.5/iprPy/calculation/relax_dynamic/relax_dynamic.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_dynamic/theory.md` & `iprPy-0.11.5/iprPy/calculation/relax_dynamic/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_static/README.md` & `iprPy-0.11.5/iprPy/calculation/relax_static/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_static/RelaxStatic.py` & `iprPy-0.11.5/iprPy/calculation/relax_static/RelaxStatic.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,57 @@
 # coding: utf-8
 # Standard Python libraries
-import uuid
-from copy import deepcopy
-
-import numpy as np
-
-from yabadaba import query
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .relax_static import relax_static
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, AtommanSystemManipulate,
+                                   LammpsMinimize)
+from ...input import value
 
 class RelaxStatic(Calculation):
     """Class for managing static relaxations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
+
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__system_mods = AtommanSystemManipulate(self)
         self.__minimize = LammpsMinimize(self)
@@ -44,230 +62,232 @@
         self.pressure_xx = 0.0
         self.pressure_yy = 0.0
         self.pressure_zz = 0.0
         self.pressure_xy = 0.0
         self.pressure_xz = 0.0
         self.pressure_yz = 0.0
         self.displacementkick = 0.0
-        self.maxcycles = 100     
+        self.maxcycles = 100
         self.cycletolerance = 1e-10
 
         self.__initial_dump = None
         self.__final_dump = None
         self.__final_box = None
         self.__potential_energy = None
         self.__measured_pressure_xx = None
         self.__measured_pressure_yy = None
         self.__measured_pressure_zz = None
         self.__measured_pressure_xy = None
         self.__measured_pressure_xz = None
         self.__measured_pressure_yz = None
-        
+
         # Define calc shortcut
         self.calc = relax_static
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'relax_static.py',
             'minbox.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
 
     @property
-    def system_mods(self):
+    def system_mods(self) -> AtommanSystemManipulate:
         """AtommanSystemManipulate subset"""
         return self.__system_mods
-    
+
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def pressure_xx(self):
+    def pressure_xx(self) -> float:
         """float: Target relaxation pressure component xx"""
         return self.__pressure_xx
 
     @pressure_xx.setter
-    def pressure_xx(self, value):
-        self.__pressure_xx = float(value)
+    def pressure_xx(self, val: float):
+        self.__pressure_xx = float(val)
 
     @property
-    def pressure_yy(self):
+    def pressure_yy(self) -> float:
         """float: Target relaxation pressure component yy"""
         return self.__pressure_yy
 
     @pressure_yy.setter
-    def pressure_yy(self, value):
-        self.__pressure_yy = float(value)
-    
+    def pressure_yy(self, val: float):
+        self.__pressure_yy = float(val)
+
     @property
-    def pressure_zz(self):
+    def pressure_zz(self) -> float:
         """float: Target relaxation pressure component zz"""
         return self.__pressure_zz
 
     @pressure_zz.setter
-    def pressure_zz(self, value):
-        self.__pressure_zz = float(value)
+    def pressure_zz(self, val: float):
+        self.__pressure_zz = float(val)
 
     @property
-    def pressure_xy(self):
+    def pressure_xy(self) -> float:
         """float: Target relaxation pressure component xy"""
         return self.__pressure_xy
 
     @pressure_xy.setter
-    def pressure_xy(self, value):
-        self.__pressure_xy = float(value)
+    def pressure_xy(self, val: float):
+        self.__pressure_xy = float(val)
 
     @property
-    def pressure_xz(self):
+    def pressure_xz(self) -> float:
         """float: Target relaxation pressure component xz"""
         return self.__pressure_xz
 
     @pressure_xz.setter
-    def pressure_xz(self, value):
-        self.__pressure_xz = float(value)
-    
+    def pressure_xz(self, val: float):
+        self.__pressure_xz = float(val)
+
     @property
-    def pressure_yz(self):
+    def pressure_yz(self) -> float:
         """float: Target relaxation pressure component yz"""
         return self.__pressure_yz
 
     @pressure_yz.setter
-    def pressure_yz(self, value):
-        self.__pressure_yz = float(value)
+    def pressure_yz(self, val: float):
+        self.__pressure_yz = float(val)
 
     @property
-    def displacementkick(self):
+    def displacementkick(self) -> float:
         """float: Magnitude of random displacements to use"""
         return self.__displacementkick
 
     @displacementkick.setter
-    def displacementkick(self, value):
-        if isinstance(value, str):
-            self.__displacementkick = uc.set_literal(value)
+    def displacementkick(self, val: Union[float, str]):
+        if isinstance(val, str):
+            self.__displacementkick = uc.set_literal(val)
         else:
-            self.__displacementkick = float(value)
-    
+            self.__displacementkick = float(val)
+
     @property
-    def maxcycles(self):
+    def maxcycles(self) -> int:
         """int: Maximum number of relaxation cycles"""
         return self.__maxcycles
 
     @maxcycles.setter
-    def maxcycles(self, value):
-        self.__maxcycles = int(value)
+    def maxcycles(self, val: int):
+        self.__maxcycles = int(val)
 
     @property
-    def cycletolerance(self):
+    def cycletolerance(self) -> float:
         """float: Stopping tolerance associated with the relaxation cycles"""
         return self.__cycletolerance
 
     @cycletolerance.setter
-    def cycletolerance(self, value):
-        self.__cycletolerance = float(value)
+    def cycletolerance(self, val: float):
+        self.__cycletolerance = float(val)
 
     @property
-    def initial_dump(self):
+    def initial_dump(self) -> dict:
         """dict: Info about the initial dump file"""
         if self.__initial_dump is None:
             raise ValueError('No results yet!')
         return self.__initial_dump
 
     @property
-    def final_dump(self):
+    def final_dump(self) -> dict:
         """dict: Info about the final dump file"""
         if self.__final_dump is None:
             raise ValueError('No results yet!')
         return self.__final_dump
-    
+
     @property
-    def final_box(self):
+    def final_box(self) -> am.Box:
         """atomman.Box: Relaxed unit cell box"""
         if self.__final_box is None:
             raise ValueError('No results yet!')
         return self.__final_box
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: Potential energy per atom for the relaxed system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
     @property
-    def measured_pressure_xx(self):
+    def measured_pressure_xx(self) -> float:
         """float: Measured relaxation pressure component xx"""
         if self.__measured_pressure_xx is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xx
-    
+
     @property
-    def measured_pressure_yy(self):
+    def measured_pressure_yy(self) -> float:
         """float: Measured relaxation pressure component yy"""
         if self.__measured_pressure_yy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yy
-    
+
     @property
-    def measured_pressure_zz(self):
+    def measured_pressure_zz(self) -> float:
         """float: Measured relaxation pressure component zz"""
         if self.__measured_pressure_zz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_zz
-    
+
     @property
-    def measured_pressure_xy(self):
+    def measured_pressure_xy(self) -> float:
         """float: Measured relaxation pressure component xy"""
         if self.__measured_pressure_xy is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xy
-    
+
     @property
-    def measured_pressure_xz(self):
+    def measured_pressure_xz(self) -> float:
         """float: Measured relaxation pressure component xz"""
         if self.__measured_pressure_xz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_xz
-    
+
     @property
-    def measured_pressure_yz(self):
+    def measured_pressure_yz(self) -> float:
         """float: Measured relaxation pressure component yz"""
         if self.__measured_pressure_yz is None:
             raise ValueError('No results yet!')
         return self.__measured_pressure_yz
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -315,33 +335,46 @@
         if 'displacementkick' in kwargs:
             self.displacementkick = kwargs['displacementkick']
         if 'maxcycles' in kwargs:
             self.maxcycles = kwargs['maxcycles']
         if 'cycletolerance' in kwargs:
             self.cycletolerance = kwargs['cycletolerance']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '1 1 1')
         input_dict['forcetolerance'] = input_dict.get('forcetolerance',
                                                   '1.0e-6 eV/angstrom')
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.maxcycles = int(input_dict.get('maxcycles', 100))
 
         # Load calculation-specific unitless floats
         self.cycletolerance = float(input_dict.get('cycletolerance', 1e-10))
 
         # Load calculation-specific floats with units
@@ -362,31 +395,33 @@
                                  default_term='0.0 GPa')
         self.pressure_yz = value(input_dict, 'pressure_yz',
                                  default_unit=self.units.pressure_unit,
                                  default_term='0.0 GPa')
         self.displacementkick = value(input_dict, 'displacementkick',
                                  default_unit=self.units.length_unit,
                                  default_term='0.0 angstrom')
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load minimization parameters
         self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Manipulate system
         self.system_mods.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -404,15 +439,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicreference load_file reference',
                 'atomicparent load_file parent'
@@ -428,32 +463,32 @@
             params['maxevaluations'] = '100000'
             params['maxatommotion'] = '0.01 angstrom'
             params['maxcycles'] = '100'
             params['cycletolerance'] = '1e-10'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'reference_{key}'] = kwargs[key]
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         elif branch == 'from_dynamic':
 
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = 'atomicarchive load_file archive'
-            
+
             params['archive_record'] = 'calculation_relax_dynamic'
             params['archive_branch'] = 'main'
             params['archive_load_key'] = 'final-system'
             params['archive_status'] = 'finished'
             params['sizemults'] = '1 1 1'
             params['energytolerance'] = '0.0'
             params['forcetolerance'] = '1e-10 eV/angstrom'
@@ -461,30 +496,30 @@
             params['maxevaluations'] = '100000'
             params['maxatommotion'] = '0.01 angstrom'
             params['maxcycles'] = '100'
             params['cycletolerance'] = '1e-10'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'archive_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'pressure_xx': ' '.join([
                 "The Pxx normal pressure component to relax the box to.",
                 "Default value is 0.0 GPa."]),
             'pressure_yy': ' '.join([
@@ -512,43 +547,43 @@
                 "The maximum number of minimization runs (cycles) to perform.",
                 "Specifying '1' means that only one minimization is performed",
                 "and no check is made for convergence.  Default value is '100'."]),
             'cycletolerance': ' '.join([
                 "The tolerance to use in determining if the lattice constants",
                 "have converged between two minimization runs (cycles).  Default",
                 "value is '1e-10 angstrom'."]),
-        }     
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # System mods keys
             [
                 self.system_mods.keyset
             ] +
@@ -569,25 +604,25 @@
             [
                 self.minimize.keyset + [
                     'displacementkick',
                     'maxcycles',
                     'cycletolerance',
                 ]
             ]
-        )       
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-relax-static'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -618,30 +653,30 @@
         if self.status == 'finished':
             # Save info on initial and final configuration files
             calc['initial-system'] = DM()
             calc['initial-system']['artifact'] = DM()
             calc['initial-system']['artifact']['file'] = self.initial_dump['filename']
             calc['initial-system']['artifact']['format'] = 'atom_dump'
             calc['initial-system']['symbols'] = self.initial_dump['symbols']
-            
+
             calc['final-system'] = DM()
             calc['final-system']['artifact'] = DM()
             calc['final-system']['artifact']['file'] = self.final_dump['filename']
             calc['final-system']['artifact']['format'] = 'atom_dump'
             calc['final-system']['symbols'] = self.final_dump['symbols']
-            
+
             # Save measured box parameter info
-            calc['measured-box-parameter'] = mbp = DM()            
+            calc['measured-box-parameter'] = mbp = DM()
             mbp['lx'] = uc.model(self.final_box.lx, self.units.length_unit)
             mbp['ly'] = uc.model(self.final_box.ly, self.units.length_unit)
             mbp['lz'] = uc.model(self.final_box.lz, self.units.length_unit)
             mbp['xy'] = uc.model(self.final_box.xy, self.units.length_unit)
             mbp['xz'] = uc.model(self.final_box.xz, self.units.length_unit)
             mbp['yz'] = uc.model(self.final_box.yz, self.units.length_unit)
-            
+
             # Save measured phase-state info
             calc['measured-phase-state'] = mps = DM()
             mps['temperature'] = uc.model(0.0, 'K')
             mps['pressure-xx'] = uc.model(self.measured_pressure_xx,
                                           self.units.pressure_unit)
             mps['pressure-yy'] = uc.model(self.measured_pressure_yy,
                                           self.units.pressure_unit)
@@ -649,24 +684,26 @@
                                           self.units.pressure_unit)
             mps['pressure-xy'] = uc.model(self.measured_pressure_xy,
                                           self.units.pressure_unit)
             mps['pressure-xz'] = uc.model(self.measured_pressure_xz,
                                           self.units.pressure_unit)
             mps['pressure-yz'] = uc.model(self.measured_pressure_yz,
                                           self.units.pressure_unit)
-            
+
             # Save the final cohesive energy
             calc['cohesive-energy'] = uc.model(self.potential_energy,
                                                self.units.energy_unit,
                                                None)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -688,15 +725,14 @@
 
         # Load results
         if self.status == 'finished':
             self.__initial_dump = {
                 'filename': calc['initial-system']['artifact']['file'],
                 'symbols': calc['initial-system']['symbols']
             }
-            
 
             self.__final_dump = {
                 'filename': calc['final-system']['artifact']['file'],
                 'symbols': calc['final-system']['symbols']
             }
 
             lx = uc.value_unit(calc['measured-box-parameter']['lx'])
@@ -704,73 +740,26 @@
             lz = uc.value_unit(calc['measured-box-parameter']['lz'])
             xy = uc.value_unit(calc['measured-box-parameter']['xy'])
             xz = uc.value_unit(calc['measured-box-parameter']['xz'])
             yz = uc.value_unit(calc['measured-box-parameter']['yz'])
             self.__final_box = am.Box(lx=lx, ly=ly, lz=lz, xy=xy, xz=xz, yz=yz)
 
             self.__potential_energy = uc.value_unit(calc['cohesive-energy'])
-            
+
             mps = calc['measured-phase-state']
             self.__measured_pressure_xx = uc.value_unit(mps['pressure-xx'])
             self.__measured_pressure_yy = uc.value_unit(mps['pressure-yy'])
             self.__measured_pressure_zz = uc.value_unit(mps['pressure-zz'])
             self.__measured_pressure_xy = uc.value_unit(mps['pressure-xy'])
             self.__measured_pressure_xz = uc.value_unit(mps['pressure-xz'])
             self.__measured_pressure_yz = uc.value_unit(mps['pressure-yz'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
-
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
@@ -779,99 +768,67 @@
         meta['temperature'] = 0.0
         meta['pressure_xx'] = self.pressure_xx
         meta['pressure_yy'] = self.pressure_yy
         meta['pressure_zz'] = self.pressure_zz
         meta['pressure_xy'] = self.pressure_xy
         meta['pressure_xz'] = self.pressure_xz
         meta['pressure_yz'] = self.pressure_yz
-        
+
         # Extract results
         if self.status == 'finished':
             meta['lx'] = self.final_box.lx
             meta['ly'] = self.final_box.ly
             meta['lz'] = self.final_box.lz
             meta['xy'] = self.final_box.xy
             meta['xz'] = self.final_box.xz
             meta['yz'] = self.final_box.yz
-            
+
             meta['E_pot'] = self.potential_energy
             meta['measured_temperature'] = 0.0
             meta['measured_pressure_xx'] = self.measured_pressure_xx
             meta['measured_pressure_yy'] = self.measured_pressure_yy
             meta['measured_pressure_zz'] = self.measured_pressure_zz
             meta['measured_pressure_xy'] = self.measured_pressure_xy
             meta['measured_pressure_xz'] = self.measured_pressure_xz
             meta['measured_pressure_yz'] = self.measured_pressure_yz
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-        
+
             'parent_key',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
-        #    'a_mult',
-        #    'b_mult',
-        #    'c_mult',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'temperature':1e-2,
             'pressure_xx':1e-2,
             'pressure_yy':1e-2,
             'pressure_zz':1e-2,
             'pressure_xy':1e-2,
             'pressure_xz':1e-2,
             'pressure_yz':1e-2,
         }
 
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
@@ -888,16 +845,16 @@
         input_dict['p_yz'] = self.pressure_yz
         input_dict['dispmult'] = self.displacementkick
         input_dict['maxcycles'] = self.maxcycles
         input_dict['ctol'] = self.cycletolerance
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
@@ -920,8 +877,8 @@
         self.__final_box = am.Box(lx=lx, ly=ly, lz=lz, xy=xy, xz=xz, yz=yz)
         self.__potential_energy = results_dict['E_pot']
         self.__measured_pressure_xx = results_dict['measured_pxx']
         self.__measured_pressure_yy = results_dict['measured_pyy']
         self.__measured_pressure_zz = results_dict['measured_pzz']
         self.__measured_pressure_xy = results_dict['measured_pxy']
         self.__measured_pressure_xz = results_dict['measured_pxz']
-        self.__measured_pressure_yz = results_dict['measured_pyz']
+        self.__measured_pressure_yz = results_dict['measured_pyz']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_static/minbox.template` & `iprPy-0.11.5/iprPy/calculation/relax_static/minbox.template`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_static/relax_static.py` & `iprPy-0.11.5/iprPy/calculation/relax_static/relax_static.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/relax_static/theory.md` & `iprPy-0.11.5/iprPy/calculation/relax_static/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/README.md` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/StackingFaultMap2D.py` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/StackingFaultMap2D.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,88 +1,104 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 import numpy as np
 
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .stacking_fault_map_2D import stackingfaultmap
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, LammpsMinimize,
+                                   StackingFault)
 
 class StackingFaultPath():
     """Class for managing a path along a stacking fault map"""
 
-    def __init__(self, sp):
+    def __init__(self, sp: DM):
         self.__direction = sp['direction']
         self.__error = sp.get('error', None)
 
         if self.__error is None:
             self.__coord = uc.value_unit(sp['minimum-energy-path'])
-            #self.__path = self.gamma.path(self.coord)
             self.__usf_mep = uc.value_unit(sp['unstable-fault-energy-mep'])
             self.__usf_urp = uc.value_unit(sp['unstable-fault-energy-unrelaxed-path'])
             self.__shear_mep = uc.value_unit(sp['ideal-shear-stress-mep'])
             self.__shear_urp = uc.value_unit(sp['ideal-shear-stress-unrelaxed-path'])
 
         else:
             self.__coord = None
-            #self.__path = None
+
             self.__usf_mep = None
             self.__usf_urp = None
             self.__shear_mep = None
             self.__shear_urp = None
 
     @property
-    def direction(self):
+    def direction(self) -> str:
+        """str: The direction of slip"""
         return self.__direction
 
     @property
-    def coord(self):
+    def coord(self) -> np.ndarray:
+        """numpy.ndarray: Coordinates along the path"""
         return self.__coord
 
-    #@property
-    #def path(self):
-    #    return self.__path
-
     @property
-    def usf_mep(self):
+    def usf_mep(self) -> float:
+        """float: The USF energy found along the minimum energy path"""
         return self.__usf_mep
 
     @property
-    def usf_urp(self):
+    def usf_urp(self) -> float:
+        """float: The USF energy found along the unrelaxed (ideal) path"""
         return self.__usf_urp
 
     @property
-    def shear_mep(self):
+    def shear_mep(self) -> float:
+        """float: The ideal shear stress found along the minimum energy path"""
         return self.__shear_mep
 
     @property
-    def shear_urp(self):
+    def shear_urp(self) -> float:
+        """float: The ideal shear stress found along the unrelaxed (ideal) path"""
         return self.__shear_urp
 
     @property
-    def error(self):
+    def error(self) -> Optional[str]:
+        """str or None: Any error that may have been issued during the MEP calculation"""
         return self.__error
 
-    def build_model(self, length_unit='angstrom', energyperarea_unit='mJ/m^2', stress_unit='GPa'):
+    def build_model(self,
+                    length_unit: str = 'angstrom',
+                    energyperarea_unit: str = 'mJ/m^2',
+                    stress_unit: str = 'GPa') -> DM:
+        """
+        Constructs the model contents associated with the path.
+
+        Parameters
+        ----------
+        length_unit : str, optional
+            The unit of length to use when outputting the path coordinates.
+        energyperarea_unit : str, optional
+            The unit of energy per area to use when outputting the unstable fault
+            energies.
+        stress_unit : str, optional
+            The unit of stress to use when outputting the ideal shear stresses.
+        """
         sp = DM()
         sp['direction'] = self.direction
 
         if self.error is None:
             sp['minimum-energy-path'] = uc.model(self.coord, length_unit)
             sp['unstable-fault-energy-mep'] = uc.model(self.usf_mep, energyperarea_unit)
             sp['unstable-fault-energy-unrelaxed-path'] = uc.model(self.usf_urp, energyperarea_unit)
@@ -95,17 +111,38 @@
         return sp
 
 class StackingFaultMap2D(Calculation):
     """Class for managing 2D maps of stacking fault energy calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
+
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__minimize = LammpsMinimize(self)
         self.__defect = StackingFault(self)
@@ -123,92 +160,95 @@
         self.calc = stackingfaultmap
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'stacking_fault_map_2D.py',
             'sfmin.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def defect(self):
+    def defect(self) -> StackingFault:
         """StackingFault subset"""
         return self.__defect
 
     @property
-    def num_a1(self):
+    def num_a1(self) -> int:
         """int: Number of fractional shifts along the a1vect direction to evaluate"""
         return self.__num_a1
 
     @num_a1.setter
-    def num_a1(self, value):
-        self.__num_a1 = int(value)
+    def num_a1(self, val: int):
+        self.__num_a1 = int(val)
 
     @property
-    def num_a2(self):
+    def num_a2(self) -> int:
         """int: Number of fractional shifts along the a2vect direction to evaluate"""
         return self.__num_a2
 
     @num_a2.setter
-    def num_a2(self, value):
-        self.__num_a2 = int(value)
+    def num_a2(self, val: int):
+        self.__num_a2 = int(val)
 
     @property
-    def gamma(self):
+    def gamma(self) -> am.defect.GammaSurface:
         """atomman.defect.GammaSurface: GSF results"""
         if self.__gamma is None:
             raise ValueError('No results yet!')
         if not isinstance(self.__gamma, am.defect.GammaSurface):
             self.__gamma = am.defect.GammaSurface(model=self.__gamma)
         return self.__gamma
 
     @property
-    def paths(self):
+    def paths(self) -> list:
+        """list: Any StackingFaultPath results"""
         if self.__paths is None:
             raise ValueError('No path results!')
         return self.__paths
-            
+
     @property
-    def E_isf(self):
+    def E_isf(self) -> Optional[float]:
         """float or None: Intrinsic stacking fault energy for the plane, if exists and found."""
         return self.__E_isf
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -227,57 +267,72 @@
 
         # Set calculation-specific values
         if 'num_a1' in kwargs:
             self.num_a1 = kwargs['num_a1']
         if 'num_a2' in kwargs:
             self.num_a2 = kwargs['num_a2']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
+
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load_parameters(self, params, key=None):
-        
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '3 3 3')
         input_dict['forcetolerance'] = input_dict.get('forcetolerance',
                                                   '1.0e-6 eV/angstrom')
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
         self.num_a1 = int(input_dict.get('stackingfault_num_a1', 10))
         self.num_a2 = int(input_dict.get('stackingfault_num_a2', 10))
 
         # Load calculation-specific unitless floats
-        
+
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load minimization parameters
         self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Load defect parameters
         self.defect.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -295,15 +350,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicparent load_file parent',
                 'defect stackingfault_file'
@@ -311,100 +366,100 @@
             params['parent_record'] = 'relaxed_crystal'
             params['parent_method'] = 'dynamic'
             params['parent_standing'] = 'good'
             params['defect_record'] = 'stacking_fault'
             params['sizemults'] = '5 5 10'
             params['stackingfault_num_a1'] = '30'
             params['stackingfault_num_a2'] = '30'
-            
+
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
         return params
-    
+
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'stackingfault_num_a1': ' '.join([
                 "The number of fractional shift steps to measure along the a1",
                 "shift vector. Default value is 10."]),
             'stackingfault_num_a2': ' '.join([
                 "The number of fractional shift steps to measure along the a2",
                 "shift vector. Default value is 10."]),
-        }  
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # Defect multikeys
-            self.defect.multikeys + 
-                
+            self.defect.multikeys +
+
             # Run parameter keys
-            [    
+            [
                 [
                     'stackingfault_num_a1',
                     'stackingfault_num_a2',
                 ]
-            ] +   
-                
+            ] +
+
             # Minimize keys
             [
                 self.minimize.keyset
             ]
-        ) 
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-stacking-fault-map-2D'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -419,15 +474,15 @@
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
         run_params['stackingfault_num_a1'] = self.num_a1
         run_params['stackingfault_num_a2'] = self.num_a2
-        
+
         # Build results
         if self.status == 'finished':
             energy_per_area_unit = f'{self.units.energy_unit}/{self.units.length_unit}^2'
             gamma_model = self.gamma.model(length_unit=self.units.length_unit,
                                            energyperarea_unit=energy_per_area_unit)
             calc['stacking-fault-map'] = gamma_model['stacking-fault-map']
 
@@ -441,15 +496,17 @@
             else:
                 for path in paths:
                     calc.append('slip-path', path.build_model())
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -471,78 +528,31 @@
             self.__gamma = calc
 
             if 'intrinsic-fault-energy' in calc:
                 self.__E_isf = uc.value_unit(calc['intrinsic-fault-energy'])
             if 'slip-path' in calc:
                 self.__paths = []
                 for sp in calc.iteraslist('slip-path'):
-                    self.paths.append(StackingFaultPath(sp))  
-
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
+                    self.paths.append(StackingFaultPath(sp))
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        
+
         # Extract results
-        if self.status == 'finished':      
+        if self.status == 'finished':
             if self.E_isf is not None:
                 meta['E_isf'] = self.E_isf
 
             try:
                 paths = self.paths
             except:
                 pass
@@ -557,95 +567,67 @@
                         meta[f'_ideal_urp {direction}'] = path.shear_urp
                     else:
                         meta[f'error {direction}'] = path.error
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
+
             'a_mult',
             'b_mult',
             'c_mult',
-            
+
             'stackingfault_key',
 
             'num_a1',
             'num_a2'
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def isvalid(self):
+    def isvalid(self) -> bool:
         return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
         # Add calculation-specific inputs
         input_dict['num_a1'] = self.num_a1
         input_dict['num_a2'] = self.num_a2
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
             The dictionary returned by the calc() method.
         """
-        self.__gamma = results_dict['gamma']
+        self.__gamma = results_dict['gamma']
```

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/stacking_fault_map_2D.py` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/stacking_fault_map_2D.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_map_2D/theory.md` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_map_2D/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_static/README.md` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_static/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_static/StackingFaultStatic.py` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_static/StackingFaultStatic.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,40 +1,55 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
-
-import numpy as np
-
-from yabadaba import query
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .stacking_fault_static import stackingfault
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, LammpsMinimize,
+                                   StackingFault)
 
 class StackingFaultStatic(Calculation):
     """Class for managing stacking fault energy calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__minimize = LammpsMinimize(self)
         self.__defect = StackingFault(self)
@@ -46,123 +61,125 @@
         self.a2 = 0.0
         self.__dumpfile_base = None
         self.__dumpfile_defect = None
         self.__potential_energy_base = None
         self.__potential_energy_defect = None
         self.__gsf_energy = None
         self.__gsf_displacement = None
-        
+
         # Define calc shortcut
         self.calc = stackingfault
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'stacking_fault_static.py',
             'sfmin.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def defect(self):
+    def defect(self) -> StackingFault:
         """StackingFault subset"""
         return self.__defect
 
     @property
-    def a1(self):
+    def a1(self) -> float:
         """float: Fractional shift along the a1vect direction to apply"""
         return self.__a1
 
     @a1.setter
-    def a1(self, value):
-        self.__a1 = float(value)
+    def a1(self, val: float):
+        self.__a1 = float(val)
 
     @property
-    def a2(self):
+    def a2(self)-> float:
         """float: Fractional shift along the a2vect direction to apply"""
         return self.__a2
 
     @a2.setter
-    def a2(self, value):
-        self.__a2 = float(value)
+    def a2(self, val: float):
+        self.__a2 = float(val)
 
     @property
-    def dumpfile_base(self):
+    def dumpfile_base(self) -> str:
         """str: Name of the LAMMPS dump file of the 0 shift reference system"""
         if self.__dumpfile_base is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_base
-    
+
     @property
-    def dumpfile_defect(self):
+    def dumpfile_defect(self) -> str:
         """str: Name of the LAMMPS dump file of the defect system"""
         if self.__dumpfile_defect is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_defect
 
     @property
-    def potential_energy_base(self):
+    def potential_energy_base(self)-> float:
         """float: Potential energy of the 0 shift reference system"""
         if self.__potential_energy_base is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_base
 
     @property
-    def potential_energy_defect(self):
+    def potential_energy_defect(self)-> float:
         """float: Potential energy of the defect system"""
         if self.__potential_energy_defect is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_defect
 
     @property
-    def gsf_displacement(self):
+    def gsf_displacement(self)-> float:
         """float: Difference in planar displacement between reference and defect systems"""
         if self.__gsf_displacement is None:
             raise ValueError('No results yet!')
         return self.__gsf_displacement
 
     @property
-    def gsf_energy(self):
+    def gsf_energy(self)-> float:
         """float: Generalized stacking fault energy associated with the defect system"""
         if self.__gsf_energy is None:
             raise ValueError('No results yet!')
         return self.__gsf_energy
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -181,18 +198,31 @@
 
         # Set calculation-specific values
         if 'a1' in kwargs:
             self.a1 = kwargs['a1']
         if 'a2' in kwargs:
             self.a2 = kwargs['a2']
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
         
         # Load input/output units
         self.units.load_parameters(input_dict)
         
         # Change default values for subset terms
@@ -223,15 +253,17 @@
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Load defect parameters
         self.defect.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -244,82 +276,82 @@
 
         Returns
         -------
         params : dict
             The full set of prepare parameters based on the workflow branch
         """
         raise NotImplementedError('Not implemented for this calculation style')
-    
+
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The calculation-specific input keys and their descriptions."""
 
         return {
             'stackingfault_a1': ' '.join([
                 "The fractional shift to apply along the a1 direction."]),
             'stackingfault_a2': ' '.join([
                 "The fractional shift to apply along the a2 direction."]),
-        } 
+        }
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # Defect multikeys
-            self.defect.multikeys + 
-                
+            self.defect.multikeys +
+
             # Run parameter keys
-            [    
+            [
                 [
                     'stackingfault_a1',
                     'stackingfault_a2',
                 ]
-            ] +   
-                
+            ] +
+
             # Minimize keys
             [
                 self.minimize.keyset
             ]
-        ) 
+        )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-stacking-fault-static'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -332,49 +364,51 @@
 
         # Build calculation-specific content
         if 'calculation' not in calc:
             calc['calculation'] = DM()
         if 'run-parameter' not in calc['calculation']:
             calc['calculation']['run-parameter'] = DM()
         run_params = calc['calculation']['run-parameter']
-        
+
         run_params['stackingfault_a1'] = self.a1
         run_params['stackingfault_a2'] = self.a2
-        
+
         # Build results
         if self.status == 'finished':
             calc['defect-free-system'] = DM()
             calc['defect-free-system']['artifact'] = DM()
             calc['defect-free-system']['artifact']['file'] = self.dumpfile_base
             calc['defect-free-system']['artifact']['format'] = 'atom_dump'
             calc['defect-free-system']['symbols'] = self.system.ucell.symbols
-            calc['defect-free-system']['potential-energy'] = uc.model(self.potential_energy_base, 
+            calc['defect-free-system']['potential-energy'] = uc.model(self.potential_energy_base,
                                                                       self.units.energy_unit)
-            
+
             calc['defect-system'] = DM()
             calc['defect-system']['artifact'] = DM()
             calc['defect-system']['artifact']['file'] = self.dumpfile_defect
             calc['defect-system']['artifact']['format'] = 'atom_dump'
             calc['defect-system']['symbols'] = self.system.ucell.symbols
             calc['defect-system']['potential-energy'] = uc.model(self.potential_energy_defect,
                                                                  self.units.energy_unit)
-            
+
             # Save the stacking fault energy
             energy_per_area_unit = f'{self.units.energy_unit}/{self.units.length_unit}^2'
             calc['stacking-fault-energy'] = uc.model(self.gsf_energy,
                                                      energy_per_area_unit)
-            
+
             # Save the plane separation
             calc['plane-separation'] = uc.model(self.gsf_displacement,
                                                 self.units.length_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -391,171 +425,96 @@
         self.a1 = run_params['stackingfault_a1']
         self.a2 = run_params['stackingfault_a2']
 
         # Load results
         if self.status == 'finished':
             self.__dumpfile_base = calc['defect-free-system']['artifact']['file']
             self.__potential_energy_base = uc.value_unit(calc['defect-free-system']['potential-energy'])
-            
+
             self.__dumpfile_defect= calc['defect-system']['artifact']['file']
             self.__potential_energy_defect = uc.value_unit(calc['defect-system']['potential-energy'])
 
             self.__gsf_energy = uc.value_unit(calc['stacking-fault-energy'])
             self.__gsf_displacement = uc.value_unit(calc['plane-separation'])
-            
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        
+
         # Extract results
         if self.status == 'finished':            
             meta['dumpfile_base'] = self.dumpfile_base
             meta['dumpfile_defect'] = self.dumpfile_defect
             meta['E_pot_base'] = self.potential_energy_base
             meta['E_pot_defect'] = self.potential_energy_defect
             meta['E_gsf'] = self.gsf_energy
             meta['delta_gsf'] = self.gsf_displacement
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
+
             'a_mult',
             'b_mult',
             'c_mult',
-            
+
             'stackingfault_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {
             'a1':1e-5,
             'a2':1e-5,
         }
 
-    def isvalid(self):
+    def isvalid(self) -> bool:
         return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
         # Add calculation-specific inputs
         input_dict['a1'] = self.a1
         input_dict['a2'] = self.a2
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_static/stacking_fault_static.py` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_static/stacking_fault_static.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/stacking_fault_static/theory.md` & `iprPy-0.11.5/iprPy/calculation/stacking_fault_static/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/surface_energy_static/README.md` & `iprPy-0.11.5/iprPy/calculation/surface_energy_static/README.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/surface_energy_static/SurfaceEnergyStatic.py` & `iprPy-0.11.5/iprPy/calculation/surface_energy_static/SurfaceEnergyStatic.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,40 +1,55 @@
 # coding: utf-8
 
 # Standard Python libraries
-import uuid
-from copy import deepcopy
-
-import numpy as np
-
-from yabadaba import query
+from io import IOBase
+from pathlib import Path
+from typing import Optional, Union
 
 # https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.lammps as lmp
 import atomman.unitconvert as uc
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # iprPy imports
 from .. import Calculation
 from .surface_energy_static import surface_energy_static
-from ...calculation_subset import *
-from ...input import value, boolean
-from ...tools import aslist, dict_insert
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, LammpsMinimize,
+                                   FreeSurface)
 
 class SurfaceEnergyStatic(Calculation):
     """Class for managing free surface energy calculations"""
 
 ############################# Core properties #################################
 
-    def __init__(self, model=None, name=None, params=None, **kwargs):
-        """Initializes a Calculation object for a given style."""
-        
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
         # Initialize subsets used by the calculation
         self.__potential = LammpsPotential(self)
         self.__commands = LammpsCommands(self)
         self.__units = Units(self)
         self.__system = AtommanSystemLoad(self)
         self.__minimize = LammpsMinimize(self)
         self.__defect = FreeSurface(self)
@@ -44,105 +59,107 @@
         # Initialize unique calculation attributes
         self.__dumpfile_base = None
         self.__dumpfile_defect = None
         self.__potential_energy_base = None
         self.__potential_energy_defect = None
         self.__potential_energy = None
         self.__surface_energy = None
-        
+
         # Define calc shortcut
         self.calc = surface_energy_static
 
         # Call parent constructor
         super().__init__(model=model, name=name, params=params,
                          subsets=subsets, **kwargs)
 
     @property
-    def filenames(self):
+    def filenames(self) -> list:
         """list: the names of each file used by the calculation."""
         return [
             'surface_energy_static.py',
             'min.template'
         ]
 
 ############################## Class attributes ###############################
 
     @property
-    def commands(self):
+    def commands(self) -> LammpsCommands:
         """LammpsCommands subset"""
         return self.__commands
 
     @property
-    def potential(self):
+    def potential(self) -> LammpsPotential:
         """LammpsPotential subset"""
         return self.__potential
 
     @property
-    def units(self):
+    def units(self) -> Units:
         """Units subset"""
         return self.__units
 
     @property
-    def system(self):
+    def system(self) -> AtommanSystemLoad:
         """AtommanSystemLoad subset"""
         return self.__system
-    
+
     @property
-    def minimize(self):
+    def minimize(self) -> LammpsMinimize:
         """LammpsMinimize subset"""
         return self.__minimize
 
     @property
-    def defect(self):
+    def defect(self) -> FreeSurface:
         """FreeSurface subset"""
         return self.__defect
 
     @property
-    def dumpfile_base(self):
+    def dumpfile_base(self) -> str:
         """str: Name of the LAMMPS dump file of the base system"""
         if self.__dumpfile_base is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_base
-    
+
     @property
-    def dumpfile_defect(self):
+    def dumpfile_defect(self) -> str:
         """str: Name of the LAMMPS dump file of the defect system"""
         if self.__dumpfile_defect is None:
             raise ValueError('No results yet!')
         return self.__dumpfile_defect
 
     @property
-    def potential_energy_base(self):
+    def potential_energy_base(self) -> float:
         """float: Potential energy of the base system"""
         if self.__potential_energy_base is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_base
 
     @property
-    def potential_energy_defect(self):
+    def potential_energy_defect(self) -> float:
         """float: Potential energy of the defect system"""
         if self.__potential_energy_defect is None:
             raise ValueError('No results yet!')
         return self.__potential_energy_defect
 
     @property
-    def potential_energy(self):
+    def potential_energy(self) -> float:
         """float: Potential energy per atom for the base system"""
         if self.__potential_energy is None:
             raise ValueError('No results yet!')
         return self.__potential_energy
 
     @property
-    def surface_energy(self):
+    def surface_energy(self) -> float:
         """float: Surface formation energy"""
         if self.__surface_energy is None:
             raise ValueError('No results yet!')
         return self.__surface_energy
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
         """
         Set calculation values directly.  Any terms not given will be set
         or reset to the calculation's default values.
 
         Parameters
         ----------
         name : str, optional
@@ -153,55 +170,70 @@
             the parent Calculation class and the subset classes.
         """
         # Call super to set universal and subset content
         super().set_values(name=name, **kwargs)
 
         # Set calculation-specific values
 
-####################### Parameter file interactions ########################### 
+####################### Parameter file interactions ###########################
 
-    def load_parameters(self, params, key=None):
-        
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
+
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
+        """
         # Load universal content
         input_dict = super().load_parameters(params, key=key)
-        
+
         # Load input/output units
         self.units.load_parameters(input_dict)
-        
+
         # Change default values for subset terms
         input_dict['sizemults'] = input_dict.get('sizemults', '3 3 3')
         input_dict['forcetolerance'] = input_dict.get('forcetolerance',
                                                   '1.0e-6 eV/angstrom')
 
         # Load calculation-specific strings
 
         # Load calculation-specific booleans
-        
+
         # Load calculation-specific integers
 
         # Load calculation-specific unitless floats
 
         # Load calculation-specific floats with units
-        
+
         # Load LAMMPS commands
         self.commands.load_parameters(input_dict)
-        
+
         # Load minimization parameters
         self.minimize.load_parameters(input_dict)
 
         # Load LAMMPS potential
         self.potential.load_parameters(input_dict)
 
         # Load initial system
         self.system.load_parameters(input_dict)
 
         # Load defect parameters
         self.defect.load_parameters(input_dict)
 
-    def master_prepare_inputs(self, branch='main', **kwargs):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
         Utility method that build input parameters for prepare according to the
         workflows used by the NIST Interatomic Potentials Repository.  In other
         words, transforms inputs from master_prepare into inputs for prepare.
 
         Parameters
         ----------
@@ -219,15 +251,15 @@
         """
         # Initialize params and copy over branch
         params = {}
         params['branch'] = branch
 
         # main branch
         if branch == 'main':
-            
+
             # Check for required kwargs
             assert 'lammps_command' in kwargs
 
             # Set default workflow settings
             params['buildcombos'] = [
                 'atomicparent load_file parent',
                 'defect surface_file'
@@ -236,76 +268,76 @@
             params['parent_method'] = 'dynamic'
             params['parent_standing'] = 'good'
             params['defect_record'] = 'free_surface'
             params['sizemults'] = '3 3 8'
 
             # Copy kwargs to params
             for key in kwargs:
-                
+
                 # Rename potential-related terms for buildcombos
                 if key[:10] == 'potential_':
                     params[f'parent_{key}'] = kwargs[key]
-                
+
                 # Copy/overwrite other terms
                 else:
                     params[key] = kwargs[key]
 
         else:
             raise ValueError(f'Unknown branch {branch}')
 
-        return params 
+        return params
 
     @property
-    def singularkeys(self):
+    def singularkeys(self) -> list:
         """list: Calculation keys that can have single values during prepare."""
-        
+
         keys = (
             # Universal keys
             super().singularkeys
 
             # Subset keys
             + self.commands.keyset
             + self.units.keyset
 
             # Calculation-specific keys
         )
-        return keys 
+        return keys
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """list: Calculation key sets that can have multiple values during prepare."""
 
         keys = (
             # Universal multikeys
             super().multikeys +
 
             # Combination of potential and system keys
             [
-                self.potential.keyset + 
+                self.potential.keyset +
                 self.system.keyset
             ] +
 
             # Defect multikeys
-            self.defect.multikeys + 
+            self.defect.multikeys +
 
             # Minimize keys
             [
                 self.minimize.keyset
             ]
         )
         return keys
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'calculation-surface-energy-static'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Generates and returns model content based on the values set to object.
         """
         # Build universal content
         model = super().build_model()
         calc = model[self.modelroot]
 
@@ -319,38 +351,40 @@
         # Build results
         if self.status == 'finished':
             calc['defect-free-system'] = DM()
             calc['defect-free-system']['artifact'] = DM()
             calc['defect-free-system']['artifact']['file'] = self.dumpfile_base
             calc['defect-free-system']['artifact']['format'] = 'atom_dump'
             calc['defect-free-system']['symbols'] = self.system.ucell.symbols
-            calc['defect-free-system']['potential-energy'] = uc.model(self.potential_energy_base, 
+            calc['defect-free-system']['potential-energy'] = uc.model(self.potential_energy_base,
                                                                       self.units.energy_unit)
-            
+
             calc['defect-system'] = DM()
             calc['defect-system']['artifact'] = DM()
             calc['defect-system']['artifact']['file'] = self.dumpfile_defect
             calc['defect-system']['artifact']['format'] = 'atom_dump'
             calc['defect-system']['symbols'] = self.system.ucell.symbols
             calc['defect-system']['potential-energy'] = uc.model(self.potential_energy_defect,
                                                                  self.units.energy_unit)
-            
+
             # Save the cohesive energy
             calc['cohesive-energy'] = uc.model(self.potential_energy,
                                                self.units.energy_unit)
-            
+
             # Save the free surface energy
             energy_per_area_unit = f'{self.units.energy_unit}/{self.units.length_unit}^2'
             calc['free-surface-energy'] = uc.model(self.surface_energy,
                                                    energy_per_area_unit)
 
         self._set_model(model)
         return model
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -362,166 +396,91 @@
         super().load_model(model, name=name)
         calc = self.model[self.modelroot]
 
         # Load results
         if self.status == 'finished':
             self.__dumpfile_base = calc['defect-free-system']['artifact']['file']
             self.__potential_energy_base = uc.value_unit(calc['defect-free-system']['potential-energy'])
-            
+
             self.__dumpfile_defect= calc['defect-system']['artifact']['file']
             self.__potential_energy_defect = uc.value_unit(calc['defect-system']['potential-energy'])
 
             self.__potential_energy = uc.value_unit(calc['cohesive-energy'])
             self.__surface_energy = uc.value_unit(calc['free-surface-energy'])
 
-    def mongoquery(self, **kwargs):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().mongoquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = f'content.{self.modelroot}'
-       
-        return mquery
-
-    def cdcsquery(self, **kwargs):
-        
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-
-        Parameters
-        ----------
-        **kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets.        
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query.
-        """
-        # Call super to build universal and subset terms
-        mquery = super().cdcsquery(**kwargs)
-
-        # Build calculation-specific terms
-        root = self.modelroot
-        
-        return mquery
-
 ########################## Metadata interactions ##############################
 
-    def metadata(self):
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
         # Call super to extract universal and subset content
         meta = super().metadata()
 
         # Extract calculation-specific content
-        
+
         # Extract results
-        if self.status == 'finished':            
+        if self.status == 'finished':
             meta['dumpfile_base'] = self.dumpfile_base
             meta['dumpfile_defect'] = self.dumpfile_defect
             meta['E_pot_base'] = self.potential_energy_base
             meta['E_pot_defect'] = self.potential_energy_defect
             meta['E_pot'] = self.potential_energy
             meta['E_surface_f'] = self.surface_energy
 
         return meta
 
     @property
-    def compare_terms(self):
+    def compare_terms(self) -> list:
         """list: The terms to compare metadata values absolutely."""
         return [
             'script',
-            
+
             'load_file',
             'load_options',
             'symbols',
-            
+
             'potential_LAMMPS_key',
             'potential_key',
-            
+
             'a_mult',
             'b_mult',
             'c_mult',
-            
+
             'surface_key',
         ]
-    
+
     @property
-    def compare_fterms(self):
+    def compare_fterms(self) -> dict:
         """dict: The terms to compare metadata values using a tolerance."""
         return {}
 
-    def isvalid(self):
+    def isvalid(self) -> bool:
         return self.system.family == self.defect.family
-    
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            Any extra query terms that are universal for all calculations
-            or associated with one of the calculation's subsets. 
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        # Call super to filter by universal and subset terms
-        matches = super().pandasfilter(dataframe, **kwargs)
-
-        # Filter by calculation-specific terms
-        
-        return matches
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self):
+    def calc_inputs(self) -> dict:
         """Builds calculation inputs from the class's attributes"""
-        
+
         # Initialize input_dict
         input_dict = {}
 
         # Add subset inputs
         for subset in self.subsets:
             subset.calc_inputs(input_dict)
 
         # Add calculation-specific inputs
 
         # Return input_dict
         return input_dict
-    
-    def process_results(self, results_dict):
+
+    def process_results(self, results_dict: dict):
         """
         Processes calculation results and saves them to the object's results
         attributes.
 
         Parameters
         ----------
         results_dict: dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation/surface_energy_static/surface_energy_static.py` & `iprPy-0.11.5/iprPy/calculation/surface_energy_static/surface_energy_static.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation/surface_energy_static/theory.md` & `iprPy-0.11.5/iprPy/calculation/surface_energy_static/theory.md`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/AtommanElasticConstants.py` & `iprPy-0.11.5/iprPy/calculation_subset/AtommanElasticConstants.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,33 +1,33 @@
+# coding: utf-8
+
 # Standard Python libraries
 from pathlib import Path
-
-# http://www.numpy.org/
-import numpy as np
+from typing import Optional, Union
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.unitconvert as uc
 
+# Local imports
 from . import CalculationSubset
-from ..tools import dict_insert, aslist
-from ..input import termtodict, dicttoterm, value
+from ..input import value
 
 class AtommanElasticConstants(CalculationSubset):
     """Handles calculation terms for loading elastic constants using atomman"""
-    
+
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -46,40 +46,43 @@
                          templatedescription=templatedescription)
 
         self.elasticconstants_file = None
         self.__elasticconstants_content = None
         self.__C = None
 
 ############################## Class attributes ################################
-    
+
     @property
-    def elasticconstants_file(self):
+    def elasticconstants_file(self) -> Optional[Path]:
+        """Path or None: The path to the elastic constants file"""
         return self.__elasticconstants_file
 
     @elasticconstants_file.setter
-    def elasticconstants_file(self, value):
-        if value is None:
+    def elasticconstants_file(self,
+                              val: Union[str, Path, None]):
+        if val is None:
             self.__elasticconstants_file = None
         else:
-            self.__elasticconstants_file = Path(value)
+            self.__elasticconstants_file = Path(val)
 
     @property
-    def elasticconstants_content(self):
+    def elasticconstants_content(self) -> Optional[str]:
+        """str or None: File contents to use instead of reading the file"""
         return self.__elasticconstants_content
 
     @property
-    def C(self):
+    def C(self) -> Optional[am.ElasticConstants]:
+        """atomman.ElasticConstants or None: The elastic constants values"""
         return self.__C
 
-    def set_values(self, **kwargs):
-        pass
-
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -95,21 +98,20 @@
             templatedescription = ' '.join([
                 "Specifies the computed elastic constants for the interatomic potential",
                 "and crystal structure, relative to the loaded system's orientation.",
                 "If the values are specified with the Voigt Cij terms and the system",
                 "is in a standard setting for a crystal type, then only the unique",
                 "Cij values for that crystal type are necessary.  If isotropic",
                 "values are used, only two idependent parameters are necessary."])
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-                
         return  {
             'elasticconstants_file': ' '.join([
                 "The path to a record containing the elastic constants to use.  If",
                 "neither this or the individual Cij components (below) are given",
                 "and load_style is 'system_model', this will be set to load_file."]),
             'C11':
                 "The C11 component of the 6x6 Cij Voigt Cij elastic stiffness tensor (units of pressure).",
@@ -164,108 +166,113 @@
             'C_nu': 
                 "The isotropic Poisson's ratio (unitless).",
             'C_K': 
                 "The isotropic bulk modulus (units of pressure)."
         }
 
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return  list(self.templatekeys.keys()) + [
                     'elasticconstants_content',
                 ]
+
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return  self.preparekeys + [
                     'load_file',
                     'load_content',
                     'pressure_unit',
                     'C',
                 ]
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         Ckey = keymap.get('Ckey', 'C')
         self.elasticconstants_file = input_dict.get(keymap['elasticconstants_file'], None)
         self.__elasticconstants_content = input_dict.get(keymap['elasticconstants_content'], None)
-        
+
         # Replace model with content if given
         cij_file = self.elasticconstants_file
         if self.elasticconstants_content is not None:
             cij_file = self.elasticconstants_content
-        
+
         # Pull out any single elastic constant terms
         Cdict = {}
         for key in input_dict:
             keyhead = key[:len(Ckey)]
             keytail = key[len(Ckey):]
             if keyhead == Ckey:
                 if keytail[0] == '_':
-                    Cdict[keytail[1:]] = value(input_dict, key, default_unit=self.parent.units.pressure_unit)
+                    Cdict[keytail[1:]] = value(input_dict, key,
+                                               default_unit=self.parent.units.pressure_unit)
                 else:
-                    Cdict['C'+keytail] = value(input_dict, key, default_unit=self.parent.units.pressure_unit)
-        
+                    Cdict['C'+keytail] = value(input_dict, key,
+                                               default_unit=self.parent.units.pressure_unit)
+
         # Load from cij file
         if cij_file is not None:
             if len(Cdict) != 0:
                 raise ValueError(f"{keyhead}ij values and {keymap['elasticconstants_file']} cannot both be specified.")
-            
+
             self.__C = am.ElasticConstants(model=cij_file)
-        
+
         # Load from explicit parameters
         elif len(Cdict) > 0:
             self.__C = am.ElasticConstants(**Cdict)
-        
+
         # Check load_file for elastic constants
         else:
             load_file = self.parent.system.load_file
             if self.parent.system.load_content is not None:
                 load_file = self.parent.system.load_content
-            
+
             self.__C = am.ElasticConstants(model=load_file)
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = 'elastic-constants'
         return f'{self.modelprefix}{baseroot}'
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         try:
             c_model = DM([('elastic-constants', model[self.modelroot] )])
         except:
             self.__C = None
         else:
             self.__C = am.ElasticConstants(model=c_model)
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -275,15 +282,15 @@
         """
         # Save info on system file loaded
         c_model = self.C.model(unit=self.parent.units.pressure_unit)
         model[self.modelroot] = c_model['elastic-constants']
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
@@ -310,15 +317,15 @@
             meta[f'{self.prefix}C46'] = self.C.Cij[3,5]
             meta[f'{self.prefix}C55'] = self.C.Cij[4,4]
             meta[f'{self.prefix}C56'] = self.C.Cij[4,5]
             meta[f'{self.prefix}C66'] = self.C.Cij[5,5]
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/AtommanGammaSurface.py` & `iprPy-0.11.5/iprPy/calculation_subset/AtommanGammaSurface.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,33 +1,32 @@
+# coding: utf-8
+
 # Standard Python libraries
 from pathlib import Path
-
-# http://www.numpy.org/
-import numpy as np
+from typing import Optional, Union
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.unitconvert as uc
 
+# Local imports
 from . import CalculationSubset
-from ..tools import dict_insert, aslist
-from ..input import termtodict, dicttoterm, value, boolean
 
 class AtommanGammaSurface(CalculationSubset):
     """Handles calculation terms for loading gamma surface results using atomman"""
-    
+
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -43,52 +42,56 @@
             An alternate description of the subset for the templatedoc.
         """
         super().__init__(parent, prefix=prefix, templateheader=templateheader,
                          templatedescription=templatedescription)
 
         self.gammasurface_file = None
         self.__gammasurface_content = None
-        self.__gamma = None    
+        self.__gamma = None
         self.__calc_key = None
 
 ############################## Class attributes ################################
-    
+
     @property
-    def gammasurface_file(self):
+    def gammasurface_file(self) -> Optional[Path]:
+        """Path or None: The path to the gamma surface file"""
         return self.__gammasurface_file
 
     @gammasurface_file.setter
-    def gammasurface_file(self, value):
-        if value is None:
+    def gammasurface_file(self,
+                          val: Union[str, Path, None]):
+        if val is None:
             self.__gammasurface_file = None
         else:
-            self.__gammasurface_file = Path(value)
+            self.__gammasurface_file = Path(val)
 
     @property
-    def gammasurface_content(self):
+    def gammasurface_content(self) -> Optional[str]:
+        """str or None: File contents to use instead of reading the file"""
         return self.__gammasurface_content
 
     @property
-    def gamma(self):
+    def gamma(self) -> Optional[am.defect.GammaSurface]:
+        """atomman.defect.GammaSurface or None: Gamma surface values"""
         if self.__gamma is None:
             return None
         elif not isinstance(self.__gamma, am.defect.GammaSurface):
             self.__gamma = am.defect.GammaSurface(model=self.__gamma)
         return self.__gamma
 
     @property
-    def calc_key(self):
+    def calc_key(self) -> Optional[str]:
+        """str or None: Calculation UUID key associated with the gamma surface values"""
         return self.__calc_key
 
-    def set_values(self, **kwargs):
-        pass
-
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -98,94 +101,96 @@
         # Set default template header
         if templateheader is None:
             templateheader = 'Gamma Surface'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = "Specifies the gamma surface results to load."
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
+
         return {
             'gammasurface_file': ' '.join([
                 "The path to a file that contains a data model associated with",
                 "an atomman.defect.GammaSurface object.  Can be a record for a",
                 "finished stacking_fault_map_2D calculation."])
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return list(self.templatekeys.keys()) + [
             'gammasurface_content',
         ]
 
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return self.preparekeys + [
             'gamma',
         ]
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         self.gammasurface_file = input_dict.get(keymap['gammasurface_file'], None)
         self.__gammasurface_content = input_dict.get(keymap['gammasurface_content'], None)
-        
+
         # Replace defect model with defect content if given
         gamma_file = self.gammasurface_file
         if self.gammasurface_content is not None:
             gamma_file = self.gammasurface_content
-        
+
         # If defect model is given
         if gamma_file is not None:
             g_model = DM(gamma_file)
             self.__gamma = g_model
             self.__calc_key = g_model.finds('key')[0]
         else:
             raise ValueError('gammasurface_file is required')
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = 'stacking-fault-map'
         return f'{self.modelprefix}{baseroot}'
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         g_model = DM([('stacking-fault-map', model.find(self.modelroot) )])
         self.__gamma = am.defect.GammaSurface(model=g_model)
         self.__calc_key = g_model['stacking-fault-map']['calc_key']
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -196,32 +201,32 @@
         # Save info on system file loaded
         g_model = self.gamma.model(length_unit=self.parent.units.length_unit)
         model[self.modelroot] = g_model['stacking-fault-map']
         model[self.modelroot]['calc_key'] = self.calc_key
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
         """
         meta[f'{self.prefix}gamma'] = self.gamma
         meta[f'{self.prefix}gammasurface_calc_key'] = self.calc_key
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
             The dictionary of input parameters to add subset terms to.
         """
-        input_dict['gamma'] = self.gamma
+        input_dict['gamma'] = self.gamma
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/AtommanSystemLoad.py` & `iprPy-0.11.5/iprPy/calculation/dislocation_periodic_array/DislocationPeriodicArray.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,755 +1,758 @@
+# coding: utf-8
+
 # Standard Python libraries
+from io import IOBase
 from pathlib import Path
+from typing import Optional, Union
+import random
 
-# http://www.numpy.org/
 import numpy as np
 
-# https://github.com/usnistgov/DataModelDict
-from DataModelDict import DataModelDict as DM
-
 # https://github.com/usnistgov/atomman
 import atomman as am
 import atomman.unitconvert as uc
 
-from yabadaba import query
+# https://github.com/usnistgov/DataModelDict
+from DataModelDict import DataModelDict as DM
 
-from . import CalculationSubset
-from ..tools import dict_insert, aslist
-from ..input import termtodict, dicttoterm
+# iprPy imports
+from .. import Calculation
+from .dislocation_periodic_array import dislocation_array
+from ...calculation_subset import (LammpsPotential, LammpsCommands, Units,
+                                   AtommanSystemLoad, LammpsMinimize, Dislocation,
+                                   AtommanElasticConstants)
+from ...input import value, boolean
 
-class AtommanSystemLoad(CalculationSubset):
-    """Handles calculation terms for loading atomic systems using atomman"""
+class DislocationPeriodicArray(Calculation):
+    """Class for managing periodic array of dislocations constructions and relaxations"""
 
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
-        """
-        Initializes a calculation record subset object.
 
-        Parameters
-        ----------
-        parent : iprPy.calculation.Calculation
-            The parent calculation object that the subset object is part of.
-            This allows for the subset methods to access parameters set to the
-            calculation itself or other subsets.
-        prefix : str, optional
-            An optional prefix to add to metadata field names to allow for
-            differentiating between multiple subsets of the same style within
-            a single record
-        templateheader : str, optional
-            An alternate header to use in the template file for the subset.
-        templatedescription : str, optional
-            An alternate description of the subset for the templatedoc.
-        """
-        super().__init__(parent, prefix=prefix, templateheader=templateheader,
-                         templatedescription=templatedescription)
-
-        self.load_file = None
-        self.load_style = 'system_model'
-        self.__load_options = {}
-        self.__load_content = None
-        self.family = None
-        self.symbols = None
-        self.__ucell = None
-        self.box_parameters = None
-        self.composition = None
-        
-############################## Class attributes ################################
+    def __init__(self,
+                 model: Union[str, Path, IOBase, DM, None]=None,
+                 name: Optional[str]=None,
+                 params: Union[str, Path, IOBase, dict] = None,
+                 **kwargs: any):
+        """
+        Initializes a Calculation object for a given style.
+
+        Parameters
+        ----------
+        model : str, file-like object or DataModelDict, optional
+            Record content in data model format to read in.  Cannot be given
+            with params.
+        name : str, optional
+            The name to use for saving the record.  By default, this should be
+            the calculation's key.
+        params : str, file-like object or dict, optional
+            Calculation input parameters or input parameter file.  Cannot be
+            given with model.
+        **kwargs : any
+            Any other core Calculation record attributes to set.  Cannot be
+            given with model.
+        """
+        # Initialize subsets used by the calculation
+        self.__potential = LammpsPotential(self)
+        self.__commands = LammpsCommands(self)
+        self.__units = Units(self)
+        self.__system = AtommanSystemLoad(self)
+        self.__minimize = LammpsMinimize(self)
+        self.__defect = Dislocation(self)
+        self.__elastic = AtommanElasticConstants(self)
+        subsets = (self.commands, self.potential, self.system,
+                   self.elastic, self.minimize, self.defect, self.units)
+
+        # Initialize unique calculation attributes
+        self.annealtemperature = 0.0
+        self.annealsteps = None
+        self.randomseed = None
+        self.duplicatecutoff = uc.set_in_units(0.5, 'angstrom')
+        self.boundarywidth = 0.0
+        self.boundaryscale = False
+        self.onlylinear = False
+        self.__dumpfile_base = None
+        self.__dumpfile_defect = None
+        self.__symbols_base = None
+        self.__symbols_defect = None
+        self.__potential_energy_defect = None
+        self.__dislocation = None
+        self.__preln = None
+        self.__K_tensor = None
+
+        # Define calc shortcut
+        self.calc = dislocation_array
+
+        # Call parent constructor
+        super().__init__(model=model, name=name, params=params,
+                         subsets=subsets, **kwargs)
+
+    @property
+    def filenames(self) -> list:
+        """list: the names of each file used by the calculation."""
+        return [
+            'dislocation_periodic_array.py',
+            'disl_relax.template'
+        ]
+
+############################## Class attributes ###############################
+
+    @property
+    def commands(self) -> LammpsCommands:
+        """LammpsCommands subset"""
+        return self.__commands
+
+    @property
+    def potential(self) -> LammpsPotential:
+        """LammpsPotential subset"""
+        return self.__potential
+
+    @property
+    def units(self) -> Units:
+        """Units subset"""
+        return self.__units
+
+    @property
+    def system(self) -> AtommanSystemLoad:
+        """AtommanSystemLoad subset"""
+        return self.__system
     
     @property
-    def load_file(self):
-        return self.__load_file
-
-    @load_file.setter
-    def load_file(self, value):
-        if value is None:
-            self.__load_file = None
-        else:
-            self.__load_file = Path(value)
+    def minimize(self) -> LammpsMinimize:
+        """LammpsMinimize subset"""
+        return self.__minimize
 
     @property
-    def load_style(self):
-        return self.__load_style
-
-    @load_style.setter
-    def load_style(self, value):
-        if value is None:
-            self.__load_style = 'system_model'
-        else:
-            self.__load_style = str(value)
+    def defect(self) -> Dislocation:
+        """Dislocation subset"""
+        return self.__defect
 
     @property
-    def load_options(self):
-        return self.__load_options
+    def elastic(self) -> AtommanElasticConstants:
+        """AtommanElasticConstants subset"""
+        return self.__elastic
 
     @property
-    def load_content(self):
-        return self.__load_content
+    def annealtemperature(self) -> float:
+        """float: Temperature to use for annealing the system"""
+        return self.__annealtemperature
 
-    @property
-    def family(self):
-        return self.__family
-
-    @family.setter
-    def family(self, value):
-        if value is None:
-            self.__family = None
-        else:
-            self.__family = str(value)
+    @annealtemperature.setter
+    def annealtemperature(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__annealtemperature = float(val)
 
     @property
-    def symbols(self):
-        """The potential symbols to use"""
-        return self.__symbols
-
-    @symbols.setter
-    def symbols(self, value):
-        if value is None:
-            self.__symbols = None
+    def annealsteps(self) -> int:
+        """int: Number of time steps to use for annealing the system"""
+        if self.__annealsteps is None:
+            if self.annealtemperature == 0.0:
+                return 0
+            else:
+                return 10000
         else:
-            value = aslist(value)
-            self.__symbols = value
+            return self.__annealsteps
 
-    @property
-    def box_parameters(self):
-        return self.__box_parameters
+    @annealsteps.setter
+    def annealsteps(self, val: int):
+        if val is None:
+            self.__annealsteps = None
+        else:
+            self.__annealsteps = int(val)
+
+    @property
+    def randomseed(self) -> int:
+        """int: random number generator seed to use"""
+        return self.__randomseed
+
+    @randomseed.setter
+    def randomseed(self, val: int):
+        if val is None:
+            val = random.randint(1, 900000000)
+        else:
+            val = int(val)
+            assert val > 0 and val <= 900000000
+        self.__randomseed = val
+
+    @property
+    def duplicatecutoff(self) -> float:
+        """float: The cutoff used to identify duplicate atoms"""
+        return self.__duplicatecutoff
+
+    @duplicatecutoff.setter
+    def duplicatecutoff(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__duplicatecutoff = val
+
+    @property
+    def boundarywidth(self) -> float:
+        """float: The minimum width of the boundary region"""
+        return self.__boundarywidth
+
+    @boundarywidth.setter
+    def boundarywidth(self, val: float):
+        val = float(val)
+        assert val >= 0.0
+        self.__boundarywidth = float(val)
+
+    @property
+    def boundaryscale(self) -> bool:
+        """bool: Flag indicating if boundarywidth is scaled versus the system or absolute"""
+        return self.__boundaryscale
+
+    @boundaryscale.setter
+    def boundaryscale(self, val: bool):
+        self.__boundaryscale = boolean(val)
+
+    @property
+    def onlylinear(self) -> bool:
+        """bool: Flag indicating if only linear gradient displacements are used"""
+        return self.__onlylinear
+
+    @onlylinear.setter
+    def onlylinear(self, val: bool):
+        self.__onlylinear = boolean(val)
+
+    @property
+    def dumpfile_base(self) -> str:
+        """str: Name of the LAMMPS dump file of the 0 shift reference system"""
+        if self.__dumpfile_base is None:
+            raise ValueError('No results yet!')
+        return self.__dumpfile_base
+   
+    @property
+    def dumpfile_defect(self) -> str:
+        """str: Name of the LAMMPS dump file of the defect system"""
+        if self.__dumpfile_defect is None:
+            raise ValueError('No results yet!')
+        return self.__dumpfile_defect
+
+    @property
+    def symbols_base(self) -> list:
+        """list: Model symbols for the base system"""
+        if self.__symbols_base is None:
+            raise ValueError('No results yet!')
+        return self.__symbols_base
+
+    @property
+    def symbols_defect(self) -> list:
+        """list: Model symbols for the defect system"""
+        if self.__symbols_defect is None:
+            raise ValueError('No results yet!')
+        return self.__symbols_defect
+
+    @property
+    def potential_energy_defect(self) -> float:
+        """float: Potential energy of the defect system"""
+        if self.__potential_energy_defect is None:
+            raise ValueError('No results yet!')
+        return self.__potential_energy_defect
+
+    @property
+    def dislocation(self) -> am.defect.Dislocation:
+        """atomman.defect.Dislocation: Volterra dislocation solution"""
+        if self.__dislocation is None:
+            raise ValueError('No results yet!')
+        return self.__dislocation
+
+    @property
+    def preln(self) -> float:
+        """float: The dislocation's elastic pre-ln energy factor"""
+        if self.__preln is None:
+            return self.dislocation.dislsol.preln
+        else:
+            return self.__preln
+
+    @property
+    def K_tensor(self) -> np.ndarray:
+        """numpy.ndarray: The dislocation's elastic K tensor"""
+        if self.__K_tensor is None:
+            return self.dislocation.dislsol.K_tensor
+        else:
+            return self.__K_tensor
+
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
+        """
+        Set calculation values directly.  Any terms not given will be set
+        or reset to the calculation's default values.
+
+        Parameters
+        ----------
+        name : str, optional
+            The name to assign to the calculation.  By default, this is set as
+            the calculation's key.
+        annealtemperature : float, optional
+            The temperature to use for MD annealing steps.
+        annealsteps : int, optional
+            The number of MD annealing steps to perform.
+        randomseed : int, optional
+            A random number seed to use for generating the initial velocities
+            for the MD anneal.
+        duplicatecutoff : float, optional
+            Distance tolerance to use for identifying duplicate atoms when the
+            dislocation has an edge component.
+        boundarywidth : float, optional
+            The minimum width of the boundary region.
+        boundaryscale : bool, optional
+            Indicates if boundarywidth is absolute (False) or relative to the
+            unit cell's a lattice parameter (True).
+        onlylinear : bool, optional
+            If True, the dislocation solution used will only be based on a
+            linear gradient of displacements rather than the Volterra
+            dislocation solution.
+        **kwargs : any, optional
+            Any keyword parameters supported by the set_values() methods of
+            the parent Calculation class and the subset classes.
+        """
+        # Call super to set universal and subset content
+        super().set_values(name=name, **kwargs)
+
+        # Set calculation-specific values
+        if 'annealtemperature' in kwargs:
+            self.annealtemperature = kwargs['annealtemperature']
+        if 'annealsteps' in kwargs:
+            self.annealsteps = kwargs['annealsteps']
+        if 'randomseed' in kwargs:
+            self.randomseed = kwargs['randomseed']
+        if 'duplicatecutoff' in kwargs:
+            self.duplicatecutoff = kwargs['duplicatecutoff']
+        if 'boundarywidth' in kwargs:
+            self.boundarywidth = kwargs['boundarywidth']
+        if 'boundaryscale' in kwargs:
+            self.boundaryscale = kwargs['boundaryscale']
+        if 'onlylinear' in kwargs:
+            self.onlylinear = kwargs['onlylinear']
 
-    @box_parameters.setter
-    def box_parameters(self, value):
-        if value is None:
-            self.__box_parameters = None
-        else:
-            value = aslist(value)
-            assert len(value) == 3 or len(value) == 6
-            self.__box_parameters = value
-        if self.__ucell is not None:
-            self.scale_ucell()
+####################### Parameter file interactions ###########################
 
-    @property
-    def ucell(self):
-        if self.__ucell is None:
-            self.load_ucell()
-        return self.__ucell
-    
-    @property
-    def composition(self):
-        if self.__composition is None:
-            try:
-                comp = self.ucell.composition
-            except:
-                pass
-            else:
-                self.composition = comp
-        return self.__composition
-                
-    @composition.setter
-    def composition(self, value):
-        if value is None or isinstance(value, str):
-            self.__composition = value
-        else:
-            raise TypeError('composition must be str or None')
+    def load_parameters(self,
+                        params: Union[dict, str, IOBase],
+                        key: Optional[str] = None):
+        """
+        Reads in and sets calculation parameters.
 
-    def load(self, style, *args, **kwargs):
+        Parameters
+        ----------
+        params : dict, str or file-like object
+            The parameters or parameter file to read in.
+        key : str, optional
+            A new key value to assign to the object.  If not given, will use
+            calc_key field in params if it exists, or leave the key value
+            unchanged.
         """
-        Wrapper around atomman.load() for loading files that also saves the
-        file loading options as class attributes.  Any parameters not given
-        will use the values already set to the object.
-        """
-        
-        # Load ucell
-        self.__ucell = am.load(style, *args, **kwargs)
-        self.ucell.wrap()
-
-        # Check if first variable positional argument is a file
-        try:
-            load_file = Path(args[0])
-        except:
-            self.load_file = None
-        else:
-            if load_file.is_file():
-                self.load_file = load_file
-            else:
-                self.load_file = None
+        # Load universal content
+        input_dict = super().load_parameters(params, key=key)
 
-        # Set load style
-        if self.load_file is None:
-            self.load_style = style
-        else:
-            self.load_style = 'system_model'
-        
+        # Load input/output units
+        self.units.load_parameters(input_dict)
 
+        # Change default values for subset terms
+        input_dict['forcetolerance'] = input_dict.get('forcetolerance',
+                                                  '1.0e-6 eV/angstrom')
 
-    def load_ucell(self, **kwargs):
-        """
-        Wrapper around atomman.load() for loading files that also saves the
-        file loading options as class attributes.  Any parameters not given
-        will use the values already set to the object.
+        # Load calculation-specific strings
+        self.boundaryshape = input_dict.get('dislocation_boundaryshape',
+                                            'cylinder')
 
-        Parameters
-        ----------
-        load_style : str, optional
-            The style for atomman.load() to use.
-        load_file : str, optional
-            The path to the file to load.
-        symbols : list or None, optional
-            The list of interaction model symbols to associate with the atom
-            types in the load file.  A value of None will default to the
-            symbols listed in the load file if the style contains that
-            information.
-        load_options : dict, optional
-            Any other atomman.load() keyword options to use when loading.
-        box_parameters : list or None, optional
-            A list of 3 orthorhombic box parameters or 6 trigonal box length
-            and angle parameters to scale the loaded system by.  Setting a
-            value of None will perform no scaling.
-        family : str or None, optional
-            The system's family identifier.  If None, then the family will be
-            set according to the family value in the load file if it has one,
-            or as the load file's name otherwise.
-        """
-        self.set_values(**kwargs)
-
-        # Check for file and contents
-        if self.load_content is not None:
-            load_file = self.load_content
-        elif self.load_file is not None:
-            load_file = self.load_file
-        else:
-            raise ValueError('load_file not set')
+        # Load calculation-specific booleans
+        self.onlylinear = boolean(input_dict.get('dislocation_onlylinear', False))
+        self.boundaryscale = boolean(input_dict.get('dislocation_boundaryscale',
+                                                    False))
 
-        # Change load symbols kwarg to None if symbols attribute is empty
-        if self.symbols is None or len(self.symbols) == 0:
-            symbols = None
-        else:
-            symbols = self.symbols
+        # Load calculation-specific integers
+        self.randomseed = input_dict.get('randomseed', None)
+        self.annealsteps = input_dict.get('annealsteps', None)
 
-        # Load ucell
-        self.__ucell = am.load(self.load_style, load_file,
-                               symbols=symbols, **self.load_options)
-        self.ucell.wrap()
-        
-        # Update object's symbols and composition
-        self.symbols = self.ucell.symbols
-        self.composition
-        self.scale_ucell()
-
-        # Add model-specific charges if needed
-        try:
-            potential = self.parent.potential.potential
-            if 'charge' not in self.ucell.atoms_prop():
-                self.ucell.atoms.prop_atype('charge', potential.charges(self.ucell.symbols))
-        except:
-            pass
-
-    def scale_ucell(self):
-        """Scale ucell by box_parameters"""
-        if self.box_parameters is not None:
-                            
-            # Three box_parameters means a, b, c
-            if len(self.box_parameters) == 3:
-                self.ucell.box_set(a=self.box_parameters[0],
-                                   b=self.box_parameters[1],
-                                   c=self.box_parameters[2], scale=True)
-            
-            # Six box_parameters means a, b, c, alpha, beta, gamma
-            elif len(self.box_parameters) == 6:
-                self.ucell.box_set(a=self.box_parameters[0],
-                                   b=self.box_parameters[1],
-                                   c=self.box_parameters[2],
-                                   alpha=self.box_parameters[3],
-                                   beta=self.box_parameters[4],
-                                   gamma=self.box_parameters[5], scale=True) 
+        # Load calculation-specific unitless floats
+        self.annealtemperature = float(input_dict.get('annealtemperature', 0.0))
 
+        # Load calculation-specific floats with units
+        self.boundarywidth = value(input_dict, 'dislocation_boundarywidth',
+                                   default_unit=self.units.length_unit,
+                                   default_term='0 angstrom')
+        self.duplicatecutoff = value(input_dict, 'dislocation_duplicatecutoff',
+                                     default_unit=self.units.length_unit,
+                                     default_term='0.5 angstrom')
 
-    def set_values(self, **kwargs):
-        """
-        Allows for multiple class attribute values to be updated at once.
+        # Load LAMMPS commands
+        self.commands.load_parameters(input_dict)
 
-        Parameters
-        ----------
-        load_style : str, optional
-            The style for atomman.load() to use.
-        load_file : str, optional
-            The path to the file to load.
-        symbols : list or None, optional
-            The list of interaction model symbols to associate with the atom
-            types in the load file.  A value of None will default to the
-            symbols listed in the load file if the style contains that
-            information.
-        load_options : dict, optional
-            Any other atomman.load() keyword options to use when loading.
-        load_content : str or DataModelDict, optional
-            The contents of load_file.  Allows for ucell and symbols/family
-            to be extracted without the file being accessible at the moment.
-        box_parameters : list or None, optional
-            A list of 3 orthorhombic box parameters or 6 trigonal box length
-            and angle parameters to scale the loaded system by.  Setting a
-            value of None will perform no scaling.
-        family : str or None, optional
-            The system's family identifier.  If None, then the family will be
-            set according to the family value in the load file if it has one,
-            or as the load file's name otherwise.
-        """
-        if 'load_style' in kwargs:
-            self.load_style = kwargs['load_style']
-        if 'load_content' in kwargs:
-            self.__load_content = kwargs['load_content']
-        if 'load_file' in kwargs:
-            self.load_file = kwargs['load_file']
-        if 'load_options' in kwargs:
-            assert isinstance(kwargs['load_options'], dict)
-            self.__load_options = kwargs['load_options']
-        if 'family' in kwargs:
-            self.family = kwargs['family']
-        if 'symbols' in kwargs:
-            self.symbols = kwargs['symbols']
-        if 'box_parameters' in kwargs:
-            self.box_parameters = kwargs['box_parameters']
-        if 'composition' in kwargs:
-            self.composition = kwargs['composition']
-
-        if self.load_file is not None:
-            if self.family is None or self.symbols is None:
-                self.__extract_model_terms()
-
-    def __extract_model_terms(self):
-        """Extracts family and symbols values from load_file if needed"""
-
-        # Check for file and contents
-        if self.load_content is not None:
-            load_file = self.load_content
-        elif self.load_file is not None:
-            load_file = self.load_file.as_posix()
-        else:
-            raise ValueError('load_file not set')
+        # Load minimization parameters
+        self.minimize.load_parameters(input_dict)
 
-        # Try to extract info from system_model files
-        if self.load_style == 'system_model':
-            
-            try:
-                model = DM(load_file).finds(f'{self.modelprefix}system-info')[0]
-            except:
-                pass
-            else:
-                # Extract family value or set as load_file's name
-                if self.family is None:
-                    self.family = model.get('family', Path(self.load_file).stem)
-
-                if self.symbols is None:
-                    symbols = model.get('symbol', None)
-                    if symbols is not None and len(symbols) > 0:
-                        self.symbols = symbols
-
-                if self.composition is None:
-                    self.composition = model.get('composition', None)
-        
-        # Try to extract info from other files
-        else:
-            if self.family is None:
-                self.family = Path(self.load_file).stem
-            
-            if self.symbols is None:
-                symbols = self.ucell.symbols
-            self.composition
+        # Load LAMMPS potential
+        self.potential.load_parameters(input_dict)
 
-####################### Parameter file interactions ###########################
+        # Load initial system
+        self.system.load_parameters(input_dict)
 
-    def _template_init(self, templateheader=None, templatedescription=None):
-        """
-        Sets the template header and description values.
+        # Load defect parameters
+        self.defect.load_parameters(input_dict)
 
-        Parameters
-        ----------
-        templateheader : str, optional
-            An alternate header to use in the template file for the subset.
-        templatedescription : str, optional
-            An alternate description of the subset for the templatedoc.
-        """
-        # Set default template header
-        if templateheader is None:
-            templateheader = 'Initial System Configuration'
-
-        # Set default template description
-        if templatedescription is None:
-            templatedescription = ' '.join([
-                "Specifies the file and options to load for the initial",
-                "atomic configuration."])
-        
-        super()._template_init(templateheader, templatedescription)
-
-    @property
-    def templatekeys(self):
-        """dict : The subset-specific input keys and their descriptions."""
-        
-        return  {
-            'load_file': 
-                "The path to the initial configuration file to load.",
-            'load_style': 
-                "The atomman.load() style indicating the format of the load_file.",
-            'load_options': ' '.join([
-                "A space-delimited list of key-value pairs for optional",
-                "style-specific arguments used by atomman.load()."]),
-            'family': ' '.join([
-                "A metadata descriptor for relating the load_file back to the",
-                "original crystal structure or prototype that the load_file was",
-                "based on.  If not given, will use the family field in load_file",
-                "if load_style is 'system_model', or the file's name otherwise."]),
-            'symbols': ' '.join([
-                "A space-delimited list of the potential's atom-model symbols to",
-                "associate with the loaded system's atom types.  Required if",
-                "load_file does not contain symbol/species information."]),
-            'box_parameters': ' '.join([
-                "Specifies new box parameters to scale the loaded configuration by.",
-                "Can be given either as a list of three or six numbers: 'a b c' for",
-                "orthogonal boxes, or 'a b c alpha beta gamma' for triclinic boxes.",
-                "The a, b, c parameters are in units of length and the alpha, beta,",
-                "gamma angles are in degrees."]),
-        }
-    
-    @property
-    def preparekeys(self):
-        """
-        list : The input keys (without prefix) used when preparing a calculation.
-        Typically, this is templatekeys plus *_content keys so prepare can access
-        content before it exists in the calc folders being prepared.
-        """
-        return  list(self.templatekeys.keys()) + [
-                    'load_content',
-                ]
-    @property
-    def interpretkeys(self):
-        """
-        list : The input keys (without prefix) accessed when interpreting the 
-        calculation input file.  Typically, this is preparekeys plus any extra
-        keys used or generated when processing the inputs.
-        """
-        return  self.preparekeys + [
-                    'ucell',
-                    'potential',
-                    'elasticconstants_content',
-                ]
+        # Load elastic constants
+        self.elastic.load_parameters(input_dict)
 
-    def load_parameters(self, input_dict):
+    def master_prepare_inputs(self,
+                              branch: str = 'main',
+                              **kwargs: any) -> dict:
         """
-        Interprets calculation parameters.
-        
+        Utility method that build input parameters for prepare according to the
+        workflows used by the NIST Interatomic Potentials Repository.  In other
+        words, transforms inputs from master_prepare into inputs for prepare.
+
         Parameters
         ----------
-        input_dict : dict
-            Dictionary containing input parameter key-value pairs.
+        branch : str, optional
+            Indicates the workflow branch to prepare calculations for.  Default
+            value is 'main'.
+        **kwargs : any
+            Any parameter modifications to make to the standard workflow
+            prepare scripts.
+
+        Returns
+        -------
+        params : dict
+            The full set of prepare parameters based on the workflow branch
         """
+        # Initialize params and copy over branch
+        params = {}
+        params['branch'] = branch
+
+        # Check for required kwargs
+        assert 'lammps_command' in kwargs
+
+        # Set common workflow settings
+        params['buildcombos'] = [
+            'atomicarchive load_file parent',
+            'defect dislocation_file'
+        ]
+        params['parent_record'] = 'calculation_elastic_constants_static'
+        params['parent_load_key'] = 'system-info'
+        params['parent_strainrange'] = 1e-7
+        params['defect_record'] = 'dislocation'
+
+        params['dislocation_boundarywidth'] = '3'
+        params['dislocation_boundaryscale'] = 'True'
+        params['dislocation_duplicatecutoff'] = '1 angstrom'
+        params['annealtemperature'] = '10'
+        params['annealsteps'] = '10000000'
+        params['maxiterations'] = '10000'
+        params['maxevaluations'] = '100000'
+
+        # Set branch-specific parameters
+        if branch == 'fcc_edge_mix':
+            params['parent_family'] = 'A1--Cu--fcc'
+            params['defect_id'] = 'A1--Cu--fcc--a-2-110--90-edge--{111}'
+            params['sizemults'] = '1 200 50'
+            params['dislocation_onlylinear'] = 'False'
+
+        elif branch == 'fcc_screw':
+            params['parent_family'] = 'A1--Cu--fcc'
+            params['defect_id'] = 'A1--Cu--fcc--a-2-110--0-screw--{111}'
+            params['sizemults'] = '1 200 50'
+            params['dislocation_onlylinear'] = 'True'
+
+        else:
+            raise ValueError(f'Unknown branch {branch}')
+
+        # Copy kwargs to params
+        for key in kwargs:
+
+            # Rename potential-related terms for buildcombos
+            if key[:10] == 'potential_':
+                params[f'parent_{key}'] = kwargs[key]
 
-        # Set default keynames
-        keymap = self.keymap
-        
-        # Extract input values and assign default values
-        load_style = input_dict.get(keymap['load_style'], 'system_model')
-        load_file = input_dict[keymap['load_file']]
-        load_options = input_dict.get(keymap['load_options'], None)
-        load_content = input_dict.get(keymap['load_content'], None)
-        family = input_dict.get(keymap['family'], None)
-        symbols = input_dict.get(keymap['symbols'], None)
-        box_parameters = input_dict.get(keymap['box_parameters'], None)
-    
-        # Build dict for set_values()
-        d = {}
-        d['load_style'] = load_style
-        d['load_file'] = load_file
-        
-        if load_content is not None:
-            d['load_content'] = load_content
-            
-        # Set family
-        if family is not None:
-            d['family'] = family
-
-        # Process load_options into load_options
-        if load_options is not None:
-            d['load_options'] = {}
-            load_options_keys = ['key', 'index', 'data_set', 'pbc', 'atom_style',
-                                'units', 'prop_info']
-            d['load_options'] = termtodict(load_options, load_options_keys)
-            if 'index' in d['load_options']:
-                d['load_options']['index'] = int(d['load_options']['index'])
-        
-        # Process symbols
-        if symbols is not None:
-            d['symbols'] = symbols.strip().split()
-
-        # Process box_parameters
-        if box_parameters is not None:
-            box_params = box_parameters.split()
-            
-            # Pull out unit value
-            if len(box_params) == 4 or len(box_params) == 7:
-                unit = box_params[-1]
-                box_params = box_params[:-1]
-            
-            # Use calculation's length_unit if unit not given in box_parameters
+            # Copy/overwrite other terms
             else:
-                unit = self.parent.units.length_unit
+                params[key] = kwargs[key]
 
-            # Convert box lengths to the specified units
-            box_params = np.array(box_params, dtype=float)
-            box_params[:3] = uc.set_in_units(box_params[:3], unit)
+        return params
 
-            d['box_parameters'] = box_params.tolist()
+    @property
+    def templatekeys(self) -> dict:
+        """dict : The calculation-specific input keys and their descriptions."""
 
-        # Set values
-        self.set_values(**d)
+        return {
+            'annealtemperature': ' '.join([
+                "The temperature at which to anneal the dislocation system",
+                "If 0, then no MD anneal will be performed."]),
+            'annealsteps': ' '.join([
+                "The number of MD steps to perform at  the anneal temperature",
+                "before running the energy/force minimization.  Default value",
+                "is 0 if annealtemperature=0, and 10,000 if annealtemperature > 0."]),
+            'randomseed': ' '.join([
+                "An int random number seed to use for generating initial velocities.",
+                "A random int will be selected if not given."]),
+            'dislocation_duplicatecutoff': ' '.join([
+                "The cutoff distance to use for determining duplicate atoms to delete",
+                "associated with the extra half-plane formed by a dislocation's edge",
+                "component.  Default value is 0.5 Angstroms."]),
+            'dislocation_boundarywidth': ' '.join([
+                "The minimum thickness of the boundary region."]),
+            'dislocation_boundaryscale': ' '.join([
+                "Boolean indicating if boundarywidth is taken as Cartesian (False)",
+                "or scaled by the loaded unit cell's a lattice parameter."]),
+            'dislocation_onlylinear': ' '.join([
+                "Boolean, which if True will only use linear gradient displacements",
+                "to form the dislocation and not the Volterra solution displacements.",
+                "Setting this to be True is useful for screw dislocations that",
+                "dissociate as it ensures that the resulting structure will dissociate",
+                "along the correct slip plane."]),
+        }
 
-########################### Data model interactions ###########################
+    @property
+    def singularkeys(self) -> list:
+        """list: Calculation keys that can have single values during prepare."""
+
+        keys = (
+            # Universal keys
+            super().singularkeys
+
+            # Subset keys
+            + self.commands.keyset
+            + self.units.keyset
+
+            # Calculation-specific keys
+            + [
+                'dislocation_duplicatecutoff',
+                'dislocation_boundarywidth',
+                'dislocation_boundaryscale',
+                'dislocation_onlylinear',
+            ]
+        )
+        return keys
 
     @property
-    def modelroot(self):
-        """str : The root element name for the subset terms."""
-        baseroot = 'system-info'
-        return f'{self.modelprefix}{baseroot}'
-
-    def load_model(self, model):
-        """Loads subset attributes from an existing model."""
-        sub = model[self.modelroot]
-
-        d = {}
-        d['family'] = sub['family']
-
-        if 'artifact' in sub:
-            if  'initial-atomic-system' in sub:
-                ValueError('found both load file and embedded content for the initial system')
-            d['load_style'] = sub['artifact']['format']
-            d['load_file'] = sub['artifact']['file']
-            load_options = sub['artifact'].get('load_options', None)
-        elif 'initial-atomic-system' in sub:
-            d['ucell'] = am.load('system_model', sub, key='initial-atomic-system')
-        else:
-            ValueError('neither load file nor embedded content found for the initial system')
+    def multikeys(self) -> list:
+        """list: Calculation key sets that can have multiple values during prepare."""
+        keys = (
+            # Universal multikeys
+            super().multikeys +
+
+            # Combination of potential, system and elastic keys
+            [
+                self.potential.keyset +
+                self.system.keyset +
+                self.elastic.keyset
+            ] +
+
+            # Defect multikeys
+            self.defect.multikeys +
+
+            # Combination of minimize and run parameter keys
+            [
+                self.minimize.keyset + [
+                    'randomseed',
+                    'annealtemperature',
+                    'annealsteps',
+                ]
+            ]
+        )
 
-        d['symbols'] = sub['symbol']
-        d['composition'] = sub.get('composition', None)
+        return keys
 
-        if load_options is not None:
-            d['load_options'] = {}
-            load_options_keys = ['key', 'index', 'data_set', 'pbc', 'atom_style',
-                                'units', 'prop_info']
-            d['load_options'] = termtodict(load_options, load_options_keys)
-            if 'index' in d['load_options']:
-                d['load_options']['index'] = int(d['load_options']['index'])
+########################### Data model interactions ###########################
 
-        self.set_values(**d)
+    @property
+    def modelroot(self) -> str:
+        """str: The root element of the content"""
+        return 'calculation-dislocation-periodic-array'
+
+    def build_model(self) -> DM:
+        """
+        Generates and returns model content based on the values set to object.
+        """
+        # Build universal content
+        model = super().build_model()
+        calc = model[self.modelroot]
+
+        # Build subset content
+        self.commands.build_model(calc, after='atomman-version')
+        self.potential.build_model(calc, after='calculation')
+        self.system.build_model(calc, after='potential-LAMMPS')
+        self.defect.build_model(calc, after='system-info')
+        self.minimize.build_model(calc)
+        self.elastic.build_model(calc)
+
+        # Build calculation-specific content
+        if 'calculation' not in calc:
+            calc['calculation'] = DM()
+        if 'run-parameter' not in calc['calculation']:
+            calc['calculation']['run-parameter'] = DM()
+        run_params = calc['calculation']['run-parameter']
+
+        run_params['dislocation_boundarywidth'] = self.boundarywidth
+        run_params['dislocation_boundaryscale'] = self.boundaryscale
+        run_params['dislocation_onlylinear'] = self.onlylinear
+        run_params['annealtemperature'] = self.annealtemperature
+        run_params['annealsteps'] = self.annealsteps
+
+        # Build results
+        if self.status == 'finished':
+            calc['base-system'] = DM()
+            calc['base-system']['artifact'] = DM()
+            calc['base-system']['artifact']['file'] = self.dumpfile_base
+            calc['base-system']['artifact']['format'] = 'atom_dump'
+            calc['base-system']['symbols'] = self.symbols_base
+
+            calc['defect-system'] = DM()
+            calc['defect-system']['artifact'] = DM()
+            calc['defect-system']['artifact']['file'] = self.dumpfile_defect
+            calc['defect-system']['artifact']['format'] = 'atom_dump'
+            calc['defect-system']['symbols'] = self.symbols_defect
+            calc['defect-system']['potential-energy'] = uc.model(self.potential_energy_defect,
+                                                                 self.units.energy_unit)
+
+            calc['elastic-solution'] = elsol = DM()
+            elsol['pre-ln-factor'] = uc.model(self.preln,
+                                             f"{self.units.energy_unit}/{self.units.length_unit}")
+
+            elsol['K-tensor'] = uc.model(self.K_tensor,
+                                         self.units.pressure_unit)
+
+        self._set_model(model)
+        return model
+
+    def load_model(self,
+                   model: Union[str, DM],
+                   name: Optional[str] = None):
+        """
+        Loads record contents from a given model.
+
+        Parameters
+        ----------
+        model : str or DataModelDict
+            The model contents of the record to load.
+        name : str, optional
+            The name to assign to the record.  Often inferred from other
+            attributes if not given.
+        """
+        # Load universal and subset content
+        super().load_model(model, name=name)
+        calc = self.model[self.modelroot]
+
+        # Load calculation-specific content
+        run_params = calc['calculation']['run-parameter']
+        self.boundarywidth = run_params['dislocation_boundarywidth']
+        self.boundaryscale = run_params['dislocation_boundaryscale']
+        self.onlylinear = run_params['dislocation_onlylinear']
+        self.annealtemperature = run_params['annealtemperature']
+        self.annealsteps = run_params['annealsteps']
+
+        # Load results
+        if self.status == 'finished':
+            self.__dumpfile_base = calc['base-system']['artifact']['file']
+            self.__symbols_base = calc['base-system']['symbols']
+
+            self.__dumpfile_defect = calc['defect-system']['artifact']['file']
+            self.__symbols_defect = calc['defect-system']['symbols']
+
+            elsol = calc['elastic-solution']
+            self.__preln = uc.value_unit(elsol['pre-ln-factor'])
+            self.__K_tensor = uc.value_unit(elsol['K-tensor'])
 
-    def build_model(self, model, **kwargs):
+########################## Metadata interactions ##############################
+
+    def metadata(self) -> dict:
         """
-        Adds the subset model to the parent model.
-        
-        Parameters
-        ----------
-        model : DataModelDict.DataModelDict
-            The record content (after root element) to add content to.
-        kwargs : any
-            Any options to pass on to dict_insert that specify where the subset
-            content gets added to in the parent model.
-        """
-        # Check required parameters
-        if self.load_file is None:
-            raise ValueError('load_file not set')
-
-        system = DM()
-
-        system['family'] = self.family
-        
-        if self.load_file is not None:
-            system['artifact'] = DM()
-            system['artifact']['file'] = self.load_file.as_posix()
-            system['artifact']['format'] = self.load_style
-            if len(self.load_options) == 0:
-                system['artifact']['load_options'] = None
-            else:
-                system['artifact']['load_options'] = dicttoterm(self.load_options)
-        else:
-            system['initial-atomic-system'] = self.ucell.model()['atomic-system']
+        Generates a dict of simple metadata values associated with the record.
+        Useful for quickly comparing records and for building pandas.DataFrames
+        for multiple records of the same style.
+        """
+        # Call super to extract universal and subset content
+        meta = super().metadata()
 
-        system['symbol'] = self.symbols
-        if self.composition is not None:
-            system['composition'] = self.composition
+        # Extract calculation-specific content
+        meta['boundarywidth'] = self.boundarywidth
+        meta['boundaryscale'] = self.boundaryscale
+        meta['onlylinear'] = self.onlylinear
+        meta['annealtemperature'] = self.annealtemperature
+        meta['annealsteps'] = self.annealsteps
 
-        dict_insert(model, self.modelroot, system, **kwargs)
+        # Extract results
+        if self.status == 'finished':            
+            meta['dumpfile_base'] = self.dumpfile_base
+            meta['dumpfile_defect'] = self.dumpfile_defect
+            meta['symbols_base'] = self.symbols_base
+            meta['symbols_defect'] = self.symbols_defect
+            #meta['potential_energy_defect'] = self.potential_energy_defect
+            meta['preln'] = self.preln
+            meta['K_tensor'] = self.K_tensor
 
-    def mongoquery(self, load_file=None, family=None, symbol=None,
-                   composition=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
-        
-        Parameters
-        ----------
-        load_file : str, optional
-            The name of the loaded structure file.
-        family : str, optional
-            The family crystal structure/prototype associated with the loaded
-            file.
-        symbol : str, optional
-            Element model symbols.
-        composition : str, optional
-            The reduced composition of the structure.
-        kwargs : any, optional
-            The parent query terms and values ignored by the subset.
+        return meta
 
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.artifact.file', load_file)
-        query.str_match.mongo(mquery, f'{root}.family', family)
-        query.str_match.mongo(mquery, f'{root}.symbol', symbol)
-        query.str_match.mongo(mquery, f'{root}.composition', composition)
-        
-        # Return query dict
-        return mquery
-
-    def cdcsquery(self, load_file=None, family=None, symbol=None,
-                  composition=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        load_file : str, optional
-            The name of the loaded structure file.
-        family : str, optional
-            The family crystal structure/prototype associated with the loaded
-            file.
-        symbol : str, optional
-            Element model symbols.
-        composition : str, optional
-            The reduced composition of the structure.
-        kwargs : any, optional
-            The parent query terms and values ignored by the subset.
+    @property
+    def compare_terms(self) -> list:
+        """list: The terms to compare metadata values absolutely."""
+        return [
+            'script',
 
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = self.parent.modelroot
-        root = f'{parentroot}.{self.modelroot}'
-
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.artifact.file', load_file)
-        query.str_match.mongo(mquery, f'{root}.family', family)
-        query.str_match.mongo(mquery, f'{root}.symbol', symbol)
-        query.str_match.mongo(mquery, f'{root}.composition', composition)
-        
-        # Return query dict
-        return mquery
+            'load_file',
+            'load_options',
+            'symbols',
 
-########################## Metadata interactions ##############################
+            'potential_LAMMPS_key',
+            'potential_key',
 
-    def metadata(self, meta):
-        """
-        Converts the structured content to a simpler dictionary.
-        
-        Parameters
-        ----------
-        meta : dict
-            The dictionary to add the subset content to
-        """
-        # Check required parameters
-        if self.load_file is None:
-            meta[f'{self.prefix}load_file'] = None
-            meta[f'{self.prefix}load_style'] = None
-            meta[f'{self.prefix}load_options'] = None
-            meta[f'{self.prefix}parent_key'] = None
-        else:
-            meta[f'{self.prefix}load_file'] = self.load_file.as_posix()
-            meta[f'{self.prefix}load_style'] = self.load_style
-            meta[f'{self.prefix}load_options'] = dicttoterm(self.load_options)
-            if self.load_file.parent.as_posix() == '.':
-                parent = self.load_file.stem
-            else:
-                parent = self.load_file.parent.name
-            meta[f'{self.prefix}parent_key'] = parent
-        
-        meta[f'{self.prefix}family'] = self.family
-        if self.symbols is None:
-            symbolstr = ''
-        else:
-            symbolstr = ''
-            for s in self.symbols:
-                if s is not None:
-                    symbolstr += f'{s} '
-            symbolstr = symbolstr.strip()
-        meta[f'{self.prefix}symbols'] = symbolstr
-
-        if self.composition is not None:
-            meta[f'{self.prefix}composition'] = self.composition
-
-    def pandasfilter(self, dataframe, load_file=None, family=None, symbol=None,
-                     composition=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
+            'a_mult',
+            'b_mult',
+            'c_mult',
 
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        load_file : str, optional
-            The name of the loaded structure file.
-        family : str, optional
-            The family crystal structure/prototype associated with the loaded
-            file.
-        symbol : str, optional
-            Element model symbols.
-        composition : str, optional
-            The reduced composition of the structure.
-        kwargs : any, optional
-            The parent query terms and values ignored by the subset.
+            'dislocation_key',
 
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        prefix = self.prefix
-        matches = (
-            query.str_match.pandas(dataframe, f'{prefix}load_file',
-                                   load_file)
-            &query.str_match.pandas(dataframe, f'{prefix}family',
-                                    family)
-            &query.str_contains.pandas(dataframe, f'{prefix}symbols',
-                                       symbol)
-            &query.str_match.pandas(dataframe, f'{prefix}composition',
-                                    composition)
-        )
-        return matches
+            'annealsteps',
+        ]
+
+    @property
+    def compare_fterms(self) -> dict:
+        """dict: The terms to compare metadata values using a tolerance."""
+        return {
+            'annealtemperature':1,
+        }
+
+    def isvalid(self) -> bool:
+        return self.system.family == self.defect.family
 
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self) -> dict:
+        """Builds calculation inputs from the class's attributes"""
+
+        # Initialize input_dict
+        input_dict = {}
+
+        # Add subset inputs
+        for subset in self.subsets:
+            subset.calc_inputs(input_dict)
+
+        # Modify inputs for calculation
+        input_dict['annealtemp'] = self.annealtemperature
+        input_dict['annealsteps'] = self.annealsteps
+        input_dict['randomseed'] = self.randomseed
+        input_dict['linear'] = self.onlylinear
+        input_dict['cutoff'] = self.duplicatecutoff
+        input_dict['boundarywidth'] = self.boundarywidth
+        input_dict['boundaryscale'] = self.boundaryscale
+
+        # Return input_dict
+        return input_dict
+
+    def process_results(self, results_dict: dict):
         """
-        Generates calculation function input parameters based on the values
-        assigned to attributes of the subset.
+        Processes calculation results and saves them to the object's results
+        attributes.
 
         Parameters
         ----------
-        input_dict : dict
-            The dictionary of input parameters to add subset terms to.
+        results_dict: dict
+            The dictionary returned by the calc() method.
         """
-        if self.ucell is None:
-            raise ValueError('ucell not loaded')
-
-        input_dict['ucell'] = self.ucell
+        self.__dumpfile_base = results_dict['dumpfile_base']
+        self.__dumpfile_defect = results_dict['dumpfile_disl']
+        self.__symbols_base = results_dict['symbols_base']
+        self.__symbols_defect = results_dict['symbols_disl']
+        self.__potential_energy_defect = results_dict['E_total_disl']
+        self.__dislocation = results_dict['dislocation']
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/AtommanSystemManipulate.py` & `iprPy-0.11.5/iprPy/calculation_subset/AtommanSystemManipulate.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,32 +1,36 @@
+# coding: utf-8
+
 # Standard Python libraries
-from pathlib import Path
+from typing import Optional, Union
 
 # http://www.numpy.org/
 import numpy as np
+import numpy.typing as npt
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
+from yabadaba import load_query
 
-# https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.unitconvert as uc
 
 from . import CalculationSubset
-from ..tools import dict_insert, aslist
+from ..tools import aslist
 
 class AtommanSystemManipulate(CalculationSubset):
     """Handles calculation terms for modifying the loaded atomic systems"""
-    
+
 ############################# Core properties #################################
 
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -50,240 +54,239 @@
         self.atomshift = [0.0, 0.0, 0.0]
         self.a_mults = 1
         self.b_mults = 1
         self.c_mults = 1
         self.__transform = None
         self.__rcell = None
         self.__system = None
-        
 
 ############################## Class attributes ################################
 
     @property
-    def a_uvw(self):
-        """numpy.NDArray: Crystal vector of ucell to align with the a box vector"""
+    def a_uvw(self) -> np.ndarray:
+        """numpy.ndarray: Crystal vector of ucell to align with the a box vector"""
         return self.__a_uvw
-    
+
     @a_uvw.setter
-    def a_uvw(self, value):
+    def a_uvw(self, value: npt.ArrayLike):
         value = np.asarray(value, dtype=int)
         assert value.shape == (3,) or value.shape == (4,)
         self.__a_uvw = value
-            
+
     @property
-    def b_uvw(self):
-        """numpy.NDArray: Crystal vector of ucell to align with the b box vector"""
+    def b_uvw(self) -> np.ndarray:
+        """numpy.ndarray: Crystal vector of ucell to align with the b box vector"""
         return self.__b_uvw
-    
+
     @b_uvw.setter
-    def b_uvw(self, value):
+    def b_uvw(self, value: npt.ArrayLike):
         value = np.asarray(value, dtype=int)
         assert value.shape == (3,) or value.shape == (4,)
         self.__b_uvw = value
-            
+
     @property
-    def c_uvw(self):
-        """numpy.NDArray: Crystal vector of ucell to align with the c box vector"""
+    def c_uvw(self) -> np.ndarray:
+        """numpy.ndarray: Crystal vector of ucell to align with the c box vector"""
         return self.__c_uvw
-    
+
     @c_uvw.setter
-    def c_uvw(self, value):
+    def c_uvw(self, value: npt.ArrayLike):
         value = np.asarray(value, dtype=int)
         assert value.shape == (3,) or value.shape == (4,)
         self.__c_uvw = value
 
     @property
     def uvws(self):
-        """numpy.NDArray: Array of the three crystal vectors to align with the box vectors"""
+        """numpy.ndarray: Array of the three crystal vectors to align with the box vectors"""
         return np.vstack([self.a_uvw, self.b_uvw, self.c_uvw])
-    
+
     @uvws.setter
-    def uvws(self, value):
+    def uvws(self, value: npt.ArrayLike):
         value = np.asarray(value, dtype=int)
         assert value.shape == (3,3) or value.shape == (3,4)
         self.__a_uvw = value[0]
         self.__b_uvw = value[1]
         self.__c_uvw = value[2]
 
     @property
     def atomshift(self):
-        """numpy.NDArray: Rigid shift to apply to all atoms after rotating to uvws orientation"""
+        """numpy.ndarray: Rigid shift to apply to all atoms after rotating to uvws orientation"""
         return self.__atomshift
-    
+
     @atomshift.setter
-    def atomshift(self, value):
+    def atomshift(self, value: npt.ArrayLike):
         value = np.asarray(value, dtype=float)
         assert value.shape == (3,)
         self.__atomshift = value
-            
+
     @property
-    def a_mults(self):
+    def a_mults(self) -> tuple:
         """tuple: Size multipliers for the rotated a box vector"""
         return self.__a_mults
 
     @a_mults.setter
-    def a_mults(self, value):
+    def a_mults(self, value: Union[int, list, tuple]):
         value = aslist(value)
-        
+
         if len(value) == 1:
             value[0] = int(value[0])
             if value[0] > 0:
                 value = [0, value[0]]
-            
+
             # Add 0 after if value is negative
             elif value[0] < 0:
                 value = [value[0], 0]
-            
+
             else:
                 raise ValueError('a_mults values cannot both be 0')
-        
+
         elif len(value) == 2:
             value[0] = int(value[0])
             value[1] = int(value[1])
             if value[0] > 0:
                 raise ValueError('First a_mults value must be <= 0')
             if value[1] < 0:
                 raise ValueError('Second a_mults value must be >= 0')
             if value[0] == value[1]:
                 raise ValueError('a_mults values cannot both be 0')
-        
+
         self.__a_mults = tuple(value)
 
     @property
-    def b_mults(self):
+    def b_mults(self) -> tuple:
         """tuple: Size multipliers for the rotated b box vector"""
         return self.__b_mults
 
     @b_mults.setter
-    def b_mults(self, value):
+    def b_mults(self, value: Union[int, list, tuple]):
         value = aslist(value)
-        
+
         if len(value) == 1:
             value[0] = int(value[0])
             if value[0] > 0:
                 value = [0, value[0]]
-            
+
             # Add 0 after if value is negative
             elif value[0] < 0:
                 value = [value[0], 0]
-            
+
             else:
                 raise ValueError('b_mults values cannot both be 0')
-        
+
         elif len(value) == 2:
             value[0] = int(value[0])
             value[1] = int(value[1])
             if value[0] > 0:
                 raise ValueError('First b_mults value must be <= 0')
             if value[1] < 0:
                 raise ValueError('Second b_mults value must be >= 0')
             if value[0] == value[1]:
                 raise ValueError('b_mults values cannot both be 0')
-        
+
         self.__b_mults = tuple(value)
-    
+
     @property
-    def c_mults(self):
+    def c_mults(self) -> tuple:
         """tuple: Size multipliers for the rotated c box vector"""
         return self.__c_mults
 
     @c_mults.setter
-    def c_mults(self, value):
+    def c_mults(self, value: Union[int, list, tuple]):
         value = aslist(value)
-        
+
         if len(value) == 1:
             value[0] = int(value[0])
             if value[0] > 0:
                 value = [0, value[0]]
-            
+
             # Add 0 after if value is negative
             elif value[0] < 0:
                 value = [value[0], 0]
-            
+
             else:
                 raise ValueError('c_mults values cannot both be 0')
-        
+
         elif len(value) == 2:
             value[0] = int(value[0])
             value[1] = int(value[1])
             if value[0] > 0:
                 raise ValueError('First c_mults value must be <= 0')
             if value[1] < 0:
                 raise ValueError('Second c_mults value must be >= 0')
             if value[0] == value[1]:
                 raise ValueError('c_mults values cannot both be 0')
-        
+
         self.__c_mults = tuple(value)
 
     @property
-    def sizemults(self):
+    def sizemults(self) -> tuple:
         """tuple: All three sets of size multipliers"""
         return (self.a_mults, self.b_mults, self.c_mults)
 
     @sizemults.setter
-    def sizemults(self, value):
+    def sizemults(self, value: Union[list, tuple]):
         if len(value) == 3:
             self.a_mults = value[0]
             self.b_mults = value[1]
             self.c_mults = value[2]
         elif len(value) == 6:
             self.a_mults = value[0:2]
             self.b_mults = value[2:4]
             self.c_mults = value[4:6]
         else:
             raise ValueError('len of sizemults must be 3 or 6')
-    
+
     @property
-    def transform(self):
-        """numpy.NDArray: The Cartesian transformation matrix between ucell and rcell"""
+    def transform(self) -> np.ndarray:
+        """numpy.ndarray: The Cartesian transformation matrix between ucell and rcell"""
         if self.__transform is None:
             self.__manipulatesystem()
         return self.__transform
 
     @property
-    def rcell(self):
+    def rcell(self) -> am.System:
         """atomman.System: The rotated and shifted cell"""
         if self.__rcell is None:
             self.__manipulatesystem()
         return self.__rcell
 
     @property
-    def system(self):
+    def system(self) -> am.System:
         """atomman.System: The rotated and shifted supercell"""
         if self.__system is None:
             self.__manipulatesystem()
         return self.__system
 
     def __manipulatesystem(self):
         """
         Creates the atomic system by manipulating the loaded ucell according
         to the set attribute values.
         """
         # Get ucell
         ucell = self.parent.system.ucell
-        
+
         # Rotate to specified uvws
         rcell, transform = ucell.rotate(self.uvws, return_transform=True)
-        
+
         # Scale atomshift by rcell vectors
         shift = np.dot(self.atomshift, rcell.box.vects)
-        
+
         # Shift atoms
         rcell.atoms.pos += shift
-        
+
         # Apply sizemults
         system = rcell.supersize(self.a_mults, self.b_mults, self.c_mults)
         system.wrap()
 
         # Update class attributes
         self.__transform = transform
         self.__system = system
         self.__rcell = rcell
 
-    def set_values(self, **kwargs):
+    def set_values(self, **kwargs: any):
         """
         Allows for multiple class attribute values to be updated at once.
 
         Parameters
         ----------
         uvws : array-like object, optional
             All three crystal vectors to align the rotated cell's box vectors
@@ -293,15 +296,14 @@
             Cannot be given with uvws.
         b_uvw : array-like object, optional
             The crystal vector to align with the rotated cell's b box vector.
             Cannot be given with uvws.
         c_uvw : array-like object, optional
             The crystal vector to align with the rotated cell's c box vector.
             Cannot be given with uvws.
-        
         """
         if 'uvws' in kwargs:
             if 'a_uvw' in kwargs or 'b_uvw' in kwargs or 'c_uvw' in kwargs:
                 raise ValueError('uvws cannot be given with the individual uvw terms')
             self.uvws = kwargs['uvws']
         if 'a_uvw' in kwargs:
             self.a_uvw = kwargs['a_uvw']
@@ -318,18 +320,19 @@
         if 'a_mults' in kwargs:
             self.a_mults = kwargs['a_mults']
         if 'b_mults' in kwargs:
             self.b_mults = kwargs['b_mults']
         if 'c_mults' in kwargs:
             self.c_mults = kwargs['c_mults']
 
-
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -339,21 +342,20 @@
         # Set default template header
         if templateheader is None:
             templateheader = 'System Manipulations'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = 'Performs simple manipulations on the loaded initial system.'
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return  {
             'a_uvw': ' '.join([
                 "The Miller(-Bravais) crystal vector relative to the loaded system",
                 "to orient with the a box vector of a resulting rotated system.",
                 "Specified as three or four space-delimited numbers.",
                 "Either all or none of the uvw parameters must be given."]),
             'b_uvw': ' '.join([
@@ -379,93 +381,91 @@
                 "For three integers, each value indicates the number of replicas",
                 "to make along the corresponding a, b, c box vector with negative",
                 "values replicating in the negative Cartesian space.",
                 "For six integers, the values are divided into three pairs with",
                 "each pair indicating the number of 'negative' and 'positive'",
                 "replications to make for a given a, b, c box vector."])
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return list(self.templatekeys.keys()) + []
 
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return self.preparekeys + [
             'ucell',
             'uvws',
             'transformationmatrix',
             'initialsystem',
         ]
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         a_uvw = input_dict.get(keymap['a_uvw'], None)
         b_uvw = input_dict.get(keymap['b_uvw'], None)
         c_uvw = input_dict.get(keymap['c_uvw'], None)
         atomshift = input_dict.get(keymap['atomshift'], '0 0 0')
         sizemults = input_dict.get(keymap['sizemults'], '1 1 1')
-        
+
         # Assign default uvws only if all are None
         if a_uvw is None and b_uvw is None and c_uvw is None:
             a_uvw = '1 0 0'
             b_uvw = '0 1 0'
             c_uvw = '0 0 1'
-        
+
         # Issue error for incomplete uvws set
         elif a_uvw is None or b_uvw is None or c_uvw is None:
             raise TypeError('incomplete set of uvws terms')
-        
+
         # Process uvws
         self.a_uvw = np.array(a_uvw.strip().split(), dtype=float)
         self.b_uvw = np.array(b_uvw.strip().split(), dtype=float)
         self.c_uvw = np.array(c_uvw.strip().split(), dtype=float)
-        
+
         # Process sizemults
         self.sizemults = np.array(sizemults.strip().split(), dtype=int)
 
         # Process atomshift
         self.atomshift = np.array(atomshift.strip().split(), dtype=float)
 
 ########################### Data model interactions ###########################
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         run_params = model['calculation']['run-parameter']
         self.a_mults = run_params[f'{self.modelprefix}size-multipliers']['a']
         self.b_mults = run_params[f'{self.modelprefix}size-multipliers']['b']
         self.c_mults = run_params[f'{self.modelprefix}size-multipliers']['c']
-        #self.atomshift = run_params[f'{self.modelprefix}atom-shift']
-        #self.a_uvw = run_params[f'{self.modelprefix}rotation-vector']['a']
-        #self.b_uvw = run_params[f'{self.modelprefix}rotation-vector']['b']
-        #self.c_uvw = run_params[f'{self.modelprefix}rotation-vector']['c']
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -477,116 +477,60 @@
         # Build paths if needed
         if 'calculation' not in model:
             model['calculation'] = DM()
         if 'run-parameter' not in model['calculation']:
             model['calculation']['run-parameter'] = DM()
 
         run_params = model['calculation']['run-parameter']
-        
+
         run_params[f'{self.modelprefix}size-multipliers'] = DM()
         run_params[f'{self.modelprefix}size-multipliers']['a'] = list(self.a_mults)
         run_params[f'{self.modelprefix}size-multipliers']['b'] = list(self.b_mults)
         run_params[f'{self.modelprefix}size-multipliers']['c'] = list(self.c_mults)
-        #run_params[f'{self.modelprefix}atom-shift'] = self.atomshift.tolist()
-        #run_params[f'{self.modelprefix}rotation-vector'] = DM()
-        #run_params[f'{self.modelprefix}rotation-vector']['a'] = self.a_uvw.tolist()
-        #run_params[f'{self.modelprefix}rotation-vector']['b'] = self.b_uvw.tolist()
-        #run_params[f'{self.modelprefix}rotation-vector']['c'] = self.c_uvw.tolist()
-        
-    def mongoquery(self, a_mult1=None, a_mult2=None, b_mult1=None,
-                       b_mult2=None, c_mult1=None, c_mult2=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
-        
-        Parameters
-        ----------
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
 
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-
-        # Build query terms
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.0', a_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.1', a_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.0', b_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.1', b_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.0', c_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.1', c_mult2)
-        
-        # Return query dict
-        return mquery
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
 
-    def cdcsquery(self, a_mult1=None, a_mult2=None, b_mult1=None,
-                       b_mult2=None, c_mult1=None, c_mult2=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
+        path = f'{self.parent.modelroot}.calculation.run-parameter.{self.modelprefix}'
 
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = self.parent.modelroot
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-
-        # Build query terms
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.0', a_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.1', a_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.0', b_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.1', b_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.0', c_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.1', c_mult2)
-        
-        # Return query dict
-        return mquery
+        return {
+            'a_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult1',
+                path=f'{path}size-multipliers.a.0',
+                description='search by lower a_mult value'),
+            'a_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult2',
+                path=f'{path}size-multipliers.a.1',
+                description='search by upper a_mult value'),
+            'b_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult1',
+                path=f'{path}size-multipliers.b.0',
+                description='search by lower b_mult value'),
+            'b_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult2',
+                path=f'{path}size-multipliers.b.1',
+                description='search by upper b_mult value'),
+            'c_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult1',
+                path=f'{path}size-multipliers.c.0',
+                description='search by lower c_mult value'),
+            'c_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult2',
+                path=f'{path}size-multipliers.c.1',
+                description='search by upper c_mult value'),
+        }
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
@@ -602,66 +546,21 @@
 
         meta[f'{prefix}atomshift'] = self.atomshift.tolist()
 
         meta[f'{prefix}a_uvw'] = self.a_uvw.tolist()
         meta[f'{prefix}b_uvw'] = self.b_uvw.tolist()
         meta[f'{prefix}c_uvw'] = self.c_uvw.tolist()
 
-    def pandasfilter(self, dataframe, a_mult1=None, a_mult2=None,
-                     b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                     **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        prefix = self.prefix
-        matches = (
-            query.int_match.pandas(dataframe,  f'{prefix}a_mult1', a_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}a_mult2', a_mult2)
-            &query.int_match.pandas(dataframe, f'{prefix}b_mult1', b_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}b_mult2', b_mult2)
-            &query.int_match.pandas(dataframe, f'{prefix}c_mult1', c_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}c_mult2', c_mult2)
-        )
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
             The dictionary of input parameters to add subset terms to.
         """
         input_dict['transform'] = self.transform
-        input_dict['system'] = self.system
+        input_dict['system'] = self.system
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/CalculationSubset.py` & `iprPy-0.11.5/iprPy/calculation_subset/CalculationSubset.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,28 @@
+# coding: utf-8
+
+# Standard Python libraries
+from typing import Optional, Union
+
+# https://github.com/usnistgov/DataModelDict
+from DataModelDict import DataModelDict as DM
+
 class CalculationSubset():
     """
     A CalcRecordSubset helps define common sets of calculation record fields
     that are shared across multiple calculation record styles.
     """
 
 ############################# Core properties #################################
 
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -25,241 +36,208 @@
             An alternate header to use in the template file for the subset.
         templatedescription : str, optional
             An alternate description of the subset for the templatedoc.
         """
         # Get module information for current class
         if self.__module__ == __name__:
             raise TypeError("Don't use Subset itself, only use derived classes")
-        
+
         self.__parent = parent
         self.__prefix = prefix
         self._template_init(templateheader=templateheader,
                             templatedescription=templatedescription)
 
     @property
     def parent(self):
-        """str: The parent calculation object for the subset."""
+        """Calculation: The parent calculation object for the subset."""
         return self.__parent
 
     @property
-    def prefix(self):
+    def prefix(self) -> str:
         """str: The prefix added before metadata field names."""
         return self.__prefix
 
-    def _pre(self, keys):
+    def _pre(self, keys: Union[str, list]) -> Union[str, list]:
         """Adds prefix to a key or list of keys"""
         if isinstance(keys, str):
             return f'{self.prefix}{keys}'
         else:
             return [f'{self.prefix}{key}' for key in keys]
 
     @property
-    def keyset(self):
+    def keyset(self) -> list:
         """list : The input keyset for preparing."""
         return self._pre(self.preparekeys)
 
     @property
-    def keymap(self):
+    def keymap(self) -> dict:
         """dict : Maps the keys to the basekeys"""
         km = {}
         for key in self.interpretkeys:
             km[key] = self._pre(key)
         return km
 
+############################## Class attributes ################################
+
+    def set_values(self, **kwargs: any):
+        """
+        Allows for multiple class attribute values to be updated at once.
+
+        Parameters
+        ----------
+        **kwargs : any 
+            Keyword arguments supported by the subclass
+        """
+
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
         templatedescription : str, optional
             An alternate description of the subset for the templatedoc.
         """
         self.__templateheader = templateheader
         self.__templatedescription = templatedescription
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
         return {}
 
     @property
-    def templateheader(self):
+    def preparekeys(self) -> list:
+        """
+        list : The input keys (without prefix) used when preparing a calculation.
+        Typically, this is templatekeys plus *_content keys so prepare can access
+        content before it exists in the calc folders being prepared.
+        """
+        return list(self.templatekeys.keys()) + []
+
+    @property
+    def interpretkeys(self) -> list:
+        """
+        list : The input keys (without prefix) accessed when interpreting the 
+        calculation input file.  Typically, this is preparekeys plus any extra
+        keys used or generated when processing the inputs.
+        """
+        return self.preparekeys + []
+
+    @property
+    def templateheader(self) -> str:
         """str : The header to use in the template file for the subset"""
         return self.__templateheader
-    
+
     @property
-    def templatedescription(self):
+    def templatedescription(self) -> str:
         """str : Provides a description of the subset for the templatedoc."""
         return self.__templatedescription
 
     @property
-    def template(self):
+    def template(self) -> str:
         """str : The input file template lines for the subset."""
 
         # Specify keys to include
         keys = self._pre(list(self.templatekeys.keys()))
-        
+
         # Define lines and specify content header
         lines = [f'# {self.templateheader}']
 
         # Build input template lines
         for key in keys:
             spacelen = 32 - len(key)
             if spacelen < 1:
                 spacelen = 1
             space = ' ' * spacelen
             lines.append(f'{key}{space}<{key}>')
-        
+
         # Join and return lines
         return '\n'.join(lines) + '\n'
 
     @property
-    def templatedoc(self):
+    def templatedoc(self) -> str:
         """str : The documentation for the template lines for this subset."""
 
         # Define lines and specify content header and description
         lines = [f'## {self.templateheader}', '', self.templatedescription, '']
 
         # Build lines for each template key
         for key, doc in self.templatekeys.items():
             lines.append(f'- __{self._pre(key)}__: {doc}')
 
         # Join and return lines
         return '\n'.join(lines) + '\n'
 
-    def set_values(self, **kwargs):
-        pass
-
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = ''
         return f'{self.modelprefix}{baseroot}'
 
     @property
-    def modelprefix(self):
+    def modelprefix(self) -> str:
         """str: The prefix added to the model root for the subset."""
         return self.prefix.replace('_', '-')
 
-    def load_model(self, model):
-        """Loads subset attributes from an existing model."""
-        pass
-
-    def build_model(self, model, **kwargs):
+    def load_model(self, model: DM):
         """
-        Adds the subset model to the parent model.
+        Loads subset attributes from an existing model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
-            The record content (after root element) to add content to.
-        kwargs : any
-            Any options to pass on to dict_insert that specify where the subset
-            content gets added to in the parent model.
+            The record content to extract content from.
         """
-        pass
 
-    def mongoquery(self, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
+        Adds the subset model to the parent model.
         
         Parameters
         ----------
+        model : DataModelDict.DataModelDict
+            The record content (after root element) to add content to.
         kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-        
-        # Build query terms
-
-        # Return query dict
-        return mquery
-
-    def cdcsquery(self, **kwargs):
+            Any options to pass on to dict_insert that specify where the subset
+            content gets added to in the parent model.
         """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-        
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = {self.parent.modelroot}
-        root = f'{parentroot}.{self.modelroot}'
-        
-        # Build query terms
 
-        # Return query dict
-        return mquery
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
+        return {}
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
         """
-        pass
-
-    def pandasfilter(self, dataframe, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        return dataframe.apply(lambda series:True, axis=1)
 
 ########################### Calculation interactions ##########################
-    
-    def calc_inputs(self, input_dict):
+
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
             The dictionary of input parameters to add subset terms to.
         """
-        pass
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/Dislocation.py` & `iprPy-0.11.5/iprPy/calculation_subset/Dislocation.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,33 +1,37 @@
+# coding: utf-8
+
 # Standard Python libraries
 from pathlib import Path
+from typing import Optional, Union
 
 # http://www.numpy.org/
 import numpy as np
+import numpy.typing as npt
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
-
-# https://github.com/usnistgov/atomman
-import atomman as am
-import atomman.unitconvert as uc
+from yabadaba import load_query
 
+# Local imports
 from . import CalculationSubset
-from ..tools import dict_insert, aslist
-from ..input import termtodict, dicttoterm, boolean, value
+from ..tools import aslist
+from ..input import boolean, value
 
 class Dislocation(CalculationSubset):
     """Handles calculation terms for dislocation parameters"""
 
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -61,320 +65,335 @@
         self.bmin = 0.0
         self.cmin = 0.0
         self.family = None
         self.__content = None
         self.__model = None
 
 ############################## Class attributes ################################
-    
+
     @property
-    def param_file(self):
+    def param_file(self) -> Optional[Path]:
+        """Path or None: The path to the dislocation parameter file"""
         return self.__param_file
 
     @param_file.setter
-    def param_file(self, value):
-        if value is None:
+    def param_file(self, val: Union[str, Path, None]):
+        if val is None:
             self.__param_file = None
         else:
-            self.__param_file = Path(value)
+            self.__param_file = Path(val)
 
     @property
-    def key(self):
+    def key(self) -> Optional[str]:
+        """str or None: UUID key of the dislocation parameter set"""
         return self.__key
 
     @key.setter
-    def key(self, value):
-        if value is None:
+    def key(self, val: Optional[str]):
+        if val is None:
             self.__key = None
         else:
-            self.__key = str(value)
+            self.__key = str(val)
 
     @property
-    def id(self):
+    def id(self) -> Optional[str]:
+        """str or None: id of the dislocation parameter set"""
         return self.__id
 
     @id.setter
-    def id(self, value):
-        if value is None:
+    def id(self, val: Optional[str]):
+        if val is None:
             self.__id = None
         else:
-            self.__id = str(value)
+            self.__id = str(val)
 
     @property
-    def slip_hkl(self):
+    def slip_hkl(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic (hkl) or (hkil) slip plane"""
         return self.__slip_hkl
 
     @slip_hkl.setter
-    def slip_hkl(self, value):
-        if value is None:
+    def slip_hkl(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.__slip_hkl = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,) or value.shape == (4,)
-            self.__slip_hkl = value.tolist()
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.__slip_hkl = val.tolist()
 
     @property
-    def _uvw(self):
+    def _uvw(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic [uvw] or [uvtw] line direction"""
         return self.___uvw
 
     @_uvw.setter
-    def _uvw(self, value):
-        if value is None:
+    def _uvw(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.___uvw = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,) or value.shape == (4,)
-            self.___uvw = value.tolist()
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.___uvw = val.tolist()
 
     @property
-    def burgers(self):
+    def burgers(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic [uvw] or [uvtw] Burgers vector"""
         return self.__burgers
 
     @burgers.setter
-    def burgers(self, value):
-        if value is None:
+    def burgers(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.__burgers = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,) or value.shape == (4,)
-            self.__burgers = value
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.__burgers = val
 
     @property
-    def m(self):
+    def m(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The Cartesian vector that corresponds to the dislocation solution's m-axis"""
         return self.__m
 
     @m.setter
-    def m(self, value):
-        if value is None:
+    def m(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.__m = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,)
-            assert np.isclose(value[0], 1.0) or np.isclose(value[1], 1.0) or np.isclose(value[2], 1.0)
-            assert np.isclose(np.linalg.norm(value), 1.0)
-            self.__m = value
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,)
+            assert np.isclose(val[0], 1.0) or np.isclose(val[1], 1.0) or np.isclose(val[2], 1.0)
+            assert np.isclose(np.linalg.norm(val), 1.0)
+            self.__m = val
 
     @property
-    def n(self):
+    def n(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The Cartesian vector that corresponds to the dislocation solution's n-axis"""
         return self.__n
 
     @n.setter
-    def n(self, value):
-        if value is None:
+    def n(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.__n = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,)
-            assert np.isclose(value[0], 1.0) or np.isclose(value[1], 1.0) or np.isclose(value[2], 1.0)
-            assert np.isclose(np.linalg.norm(value), 1.0)
-            self.__n = value
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,)
+            assert np.isclose(val[0], 1.0) or np.isclose(val[1], 1.0) or np.isclose(val[2], 1.0)
+            assert np.isclose(np.linalg.norm(val), 1.0)
+            self.__n = val
 
     @property
-    def shift(self):
+    def shift(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The rigid body shift to position the dislocation solution relative to the atomic configuration"""
         return self.__shift
 
     @shift.setter
-    def shift(self, value):
-        if value is None:
+    def shift(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.__shift = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape[0] == 3
-            self.__shift = value
+                val = np.asarray(val, dtype=float)
+            assert val.shape[0] == 3
+            self.__shift = val
 
     @property
-    def shiftscale(self):
+    def shiftscale(self) -> bool:
+        """bool: Indicates if shift is absolute Cartesian or scaled relative to rcell"""
         return self.__shiftscale
 
     @shiftscale.setter
-    def shiftscale(self, value):
-        self.__shiftscale = boolean(value)
+    def shiftscale(self, val: bool):
+        self.__shiftscale = boolean(val)
 
     @property
-    def shiftindex(self):
+    def shiftindex(self) -> Optional[int]:
+        """int or None: The index of the pre-determined shifts values to use for shift"""
         return self.__shiftindex
 
     @shiftindex.setter
-    def shiftindex(self, value):
-        if value is None:
+    def shiftindex(self, val: Optional[int]):
+        if val is None:
             self.__shiftindex = None
         else:
-            self.__shiftindex = int(value)
+            self.__shiftindex = int(val)
 
     @property
-    def a_mults(self):
+    def a_mults(self) -> tuple:
         """tuple: Size multipliers for the rotated a box vector"""
         return self.__a_mults
 
     @a_mults.setter
-    def a_mults(self, value):
-        value = aslist(value)
-        
-        if len(value) == 1:
-            value[0] = int(value[0])
-            if value[0] > 0:
-                value = [0, value[0]]
-            
-            # Add 0 after if value is negative
-            elif value[0] < 0:
-                value = [value[0], 0]
-            
+    def a_mults(self, val: Union[int, list, tuple]):
+        val = aslist(val)
+
+        if len(val) == 1:
+            val[0] = int(val[0])
+            if val[0] > 0:
+                val = [0, val[0]]
+
+            # Add 0 after if val is negative
+            elif val[0] < 0:
+                val = [val[0], 0]
+
             else:
                 raise ValueError('a_mults values cannot both be 0')
-        
-        elif len(value) == 2:
-            value[0] = int(value[0])
-            value[1] = int(value[1])
-            if value[0] > 0:
+
+        elif len(val) == 2:
+            val[0] = int(val[0])
+            val[1] = int(val[1])
+            if val[0] > 0:
                 raise ValueError('First a_mults value must be <= 0')
-            if value[1] < 0:
+            if val[1] < 0:
                 raise ValueError('Second a_mults value must be >= 0')
-            if value[0] == value[1]:
+            if val[0] == val[1]:
                 raise ValueError('a_mults values cannot both be 0')
-        
-        self.__a_mults = tuple(value)
+
+        self.__a_mults = tuple(val)
 
     @property
-    def b_mults(self):
+    def b_mults(self) -> tuple:
         """tuple: Size multipliers for the rotated b box vector"""
         return self.__b_mults
 
     @b_mults.setter
-    def b_mults(self, value):
-        value = aslist(value)
-        
-        if len(value) == 1:
-            value[0] = int(value[0])
-            if value[0] > 0:
-                value = [0, value[0]]
-            
-            # Add 0 after if value is negative
-            elif value[0] < 0:
-                value = [value[0], 0]
-            
+    def b_mults(self, val: Union[int, list, tuple]):
+        val = aslist(val)
+
+        if len(val) == 1:
+            val[0] = int(val[0])
+            if val[0] > 0:
+                val = [0, val[0]]
+
+            # Add 0 after if val is negative
+            elif val[0] < 0:
+                val = [val[0], 0]
+
             else:
                 raise ValueError('b_mults values cannot both be 0')
-        
-        elif len(value) == 2:
-            value[0] = int(value[0])
-            value[1] = int(value[1])
-            if value[0] > 0:
+
+        elif len(val) == 2:
+            val[0] = int(val[0])
+            val[1] = int(val[1])
+            if val[0] > 0:
                 raise ValueError('First b_mults value must be <= 0')
-            if value[1] < 0:
+            if val[1] < 0:
                 raise ValueError('Second b_mults value must be >= 0')
-            if value[0] == value[1]:
+            if val[0] == val[1]:
                 raise ValueError('b_mults values cannot both be 0')
-        
-        self.__b_mults = tuple(value)
-    
+
+        self.__b_mults = tuple(val)
+
     @property
-    def c_mults(self):
+    def c_mults(self) -> tuple:
         """tuple: Size multipliers for the rotated c box vector"""
         return self.__c_mults
 
     @c_mults.setter
-    def c_mults(self, value):
-        value = aslist(value)
+    def c_mults(self, val: Union[int, list, tuple]):
+        val = aslist(val)
         
-        if len(value) == 1:
-            value[0] = int(value[0])
-            if value[0] > 0:
-                value = [0, value[0]]
-            
-            # Add 0 after if value is negative
-            elif value[0] < 0:
-                value = [value[0], 0]
-            
+        if len(val) == 1:
+            val[0] = int(val[0])
+            if val[0] > 0:
+                val = [0, val[0]]
+
+            # Add 0 after if val is negative
+            elif val[0] < 0:
+                val = [val[0], 0]
+
             else:
                 raise ValueError('c_mults values cannot both be 0')
-        
-        elif len(value) == 2:
-            value[0] = int(value[0])
-            value[1] = int(value[1])
-            if value[0] > 0:
+
+        elif len(val) == 2:
+            val[0] = int(val[0])
+            val[1] = int(val[1])
+            if val[0] > 0:
                 raise ValueError('First c_mults value must be <= 0')
-            if value[1] < 0:
+            if val[1] < 0:
                 raise ValueError('Second c_mults value must be >= 0')
-            if value[0] == value[1]:
+            if val[0] == val[1]:
                 raise ValueError('c_mults values cannot both be 0')
         
-        self.__c_mults = tuple(value)
+        self.__c_mults = tuple(val)
 
     @property
-    def sizemults(self):
+    def sizemults(self) -> tuple:
         """tuple: All three sets of size multipliers"""
         return (self.a_mults, self.b_mults, self.c_mults)
 
     @sizemults.setter
-    def sizemults(self, value):
-        if len(value) == 3:
-            self.a_mults = value[0]
-            self.b_mults = value[1]
-            self.c_mults = value[2]
-        elif len(value) == 6:
-            self.a_mults = value[0:2]
-            self.b_mults = value[2:4]
-            self.c_mults = value[4:6]
+    def sizemults(self, val: Union[list, tuple]):
+        if len(val) == 3:
+            self.a_mults = val[0]
+            self.b_mults = val[1]
+            self.c_mults = val[2]
+        elif len(val) == 6:
+            self.a_mults = val[0:2]
+            self.b_mults = val[2:4]
+            self.c_mults = val[4:6]
         else:
             raise ValueError('len of sizemults must be 3 or 6')
 
     @property
-    def amin(self):
+    def amin(self) -> float:
         return self.__amin
 
     @amin.setter
-    def amin(self, value):
-        self.__amin = float(value)
+    def amin(self, val: float):
+        """float: Minimum distance allowed along the a box vector direction"""
+        self.__amin = float(val)
 
     @property
-    def bmin(self):
+    def bmin(self) -> float:
         return self.__bmin
 
     @bmin.setter
-    def bmin(self, value):
-        self.__bmin = float(value)
-    
+    def bmin(self, val: float):
+        """float: Minimum distance allowed along the b box vector direction"""
+        self.__bmin = float(val)
+
     @property
-    def cmin(self):
+    def cmin(self) -> float:
         return self.__cmin
 
     @cmin.setter
-    def cmin(self, value):
-        self.__cmin = float(value)
+    def cmin(self, val: float):
+        """float: Minimum distance allowed along the c box vector direction"""
+        self.__cmin = float(val)
 
     @property
-    def family(self):
+    def family(self) -> Optional[str]:
+        """str or None: The prototype or reference crystal the dislocation parameter set is for"""
         return self.__family
 
     @family.setter
-    def family(self, value):
-        if value is None:
+    def family(self, val: Optional[str]):
+        if val is None:
             self.__family = None
         else:
-            self.__family = str(value)
+            self.__family = str(val)
 
-    def set_values(self, **kwargs):
+    def set_values(self, **kwargs: any):
         """
         Allows for multiple class attribute values to be updated at once.
 
         Parameters
         ----------
         param_file : str, optional
             The path to a file that fully defines the input parameters for
@@ -443,21 +462,23 @@
         if 'sizemults' in kwargs:
             self.sizemults = kwargs['sizemults']
         if 'amin' in kwargs:
             self.amin = kwargs['amin']
         if 'bmin' in kwargs:
             self.bmin = kwargs['bmin']
         if 'cmin' in kwargs:
-            self.cmin = kwargs['cmin']        
+            self.cmin = kwargs['cmin']
         if 'family' in kwargs:
-            self.family = kwargs['family']         
-        
-####################### Parameter file interactions ###########################
+            self.family = kwargs['family']
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    ###################### Parameter file interactions ########################
+
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -473,17 +494,16 @@
             templatedescription = ' '.join([
                 "Specifies the parameter set that defines a dislocation type",
                 "and how to orient it relative to the atomic system."])
         
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return {
             'dislocation_file': ' '.join([
                 "The path to a dislocation record file that collects the",
                 "parameters for a specific dislocation type."]),
             'dislocation_slip_hkl': ' '.join([
                 "The Miller (hkl) slip plane for the dislocation given as three",
                 "space-delimited integers."]),
@@ -540,147 +560,147 @@
             'cmin': ' '.join([
                 "Specifies a minimum width in length units that the resulting",
                 "system's c box vector must have.  The associated sizemult value",
                 "will be increased if necessary to ensure this. Default value is 0.0."]),
         }
     
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return list(self.templatekeys.keys()) + [
             'dislocation_family',
             'dislocation_content',
         ]
 
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return self.preparekeys + [
             'dislocation_model', 
         ]
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """
         list: Calculation subset key sets that can have multiple values during prepare.
-        """ 
+        """
         # Define key set for system size parameters
         sizekeys = ['sizemults', 'amin', 'bmin', 'cmin']
-        
+
         # Define key set for defect parameters as the remainder
         defectkeys = []
         for key in self.preparekeys:
             if key not in sizekeys:
                 defectkeys.append(key)
 
         # Add prefixes and return
         return [
             self._pre(sizekeys),
             self._pre(defectkeys)
         ]
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         self.param_file = input_dict.get(keymap['dislocation_file'], None)
         self.__content = input_dict.get(keymap['dislocation_content'], None)
-        
+
         # Replace defect model with defect content if given
         param_file = self.param_file
         if self.__content is not None:
             param_file = self.__content
-        
+
         # Extract parameters from a file
         if param_file is not None:
-            
+
             # Verify competing parameters are not defined
             for key in ('dislocation_slip_hkl',
                         'dislocation__uvw',
                         'dislocation_burgers',
                         'dislocation_m',
                         'dislocation_n',
                         'dislocation_shift',
                         'dislocation_shiftscale',
                         'dislocation_shiftindex'):
                 if keymap[key] in input_dict:
                     raise ValueError(f"{keymap[key]} and {keymap['dislocation_file']} cannot both be supplied")
-            
+
             # Load defect model
             self.__model = model = DM(param_file).find('dislocation')
-            
+
             # Extract parameter values from defect model
             self.key = model['key']
             self.id = model['id']
             self.family = model['system-family']
             self.slip_hkl = model['calculation-parameter']['slip_hkl']
             self._uvw = model['calculation-parameter']['_uvw']
             self.burgers = model['calculation-parameter']['burgers']
             self.m = model['calculation-parameter']['m']
             self.n = model['calculation-parameter']['n']
             self.shift = model['calculation-parameter'].get('shift', None)
             self.shiftindex = model['calculation-parameter'].get('shiftindex', None)
             self.shiftscale = boolean(model['calculation-parameter'].get('shiftscale', False))
-        
+
         # Set parameter values directly
-        else: 
+        else:
             self.__model = None
             self.key = None
             self.id = None
             self.family = self.parent.system.family
             self.slip_hkl = input_dict[keymap['dislocation_slip_hkl']]
             self._uvw = input_dict[keymap['dislocation__uvw']]
             self.burgers = input_dict[keymap['dislocation_burgers']]
             self.m = input_dict.get(keymap['dislocation_m'], '0 1 0')
             self.n = input_dict.get(keymap['dislocation_n'], '0 0 1')
             self.shift = input_dict.get(keymap['dislocation_shift'], None)
             self.shiftscale = boolean(input_dict.get(keymap['dislocation_shiftscale'], False))
             self.shiftindex = input_dict.get(keymap['dislocation_shiftindex'], None)
-                    
+
         # Check defect parameters
         if not np.isclose(self.m.dot(self.n), 0.0):
             raise ValueError("dislocation_m and dislocation_n must be orthogonal")
 
         # Set default values for fault system manipulations
         sizemults = input_dict.get(keymap['sizemults'], '1 1 1')
         self.sizemults = np.array(sizemults.strip().split(), dtype=int)
-        
+
         self.amin = value(input_dict, keymap['amin'], default_term='0.0 angstrom',
                           default_unit=self.parent.units.length_unit)
         self.bmin = value(input_dict, keymap['bmin'], default_term='0.0 angstrom',
                           default_unit=self.parent.units.length_unit)
         self.cmin = value(input_dict, keymap['cmin'], default_term='0.0 angstrom',
                           default_unit=self.parent.units.length_unit)
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = 'dislocation'
         return f'{self.modelprefix}{baseroot}'
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         disl = model[self.modelroot]
 
         self.__model = None
         self.__param_file = None
         self.key = disl['key']
         self.id = disl['id']
@@ -695,20 +715,22 @@
         if 'shift' in cp:
             self.shift = cp['shift']
         if 'shiftindex' in cp:
             self.shiftindex = cp['shiftindex']
         self.shiftscale = cp['shiftscale']
 
         run_params = model['calculation']['run-parameter']
-        
+
         self.a_mults = run_params[f'{self.modelprefix}size-multipliers']['a']
         self.b_mults = run_params[f'{self.modelprefix}size-multipliers']['b']
         self.c_mults = run_params[f'{self.modelprefix}size-multipliers']['c']
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -746,131 +768,72 @@
 
         run_params = model['calculation']['run-parameter']
         run_params[f'{self.modelprefix}size-multipliers'] = DM()
         run_params[f'{self.modelprefix}size-multipliers']['a'] = list(self.a_mults)
         run_params[f'{self.modelprefix}size-multipliers']['b'] = list(self.b_mults)
         run_params[f'{self.modelprefix}size-multipliers']['c'] = list(self.c_mults)
 
-    def mongoquery(self, dislocation_key=None, dislocation_id=None,
-                   dislocation_family=None, a_mult1=None, a_mult2=None,
-                   b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                   **kwargs):
-        """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
-        
-        Parameters
-        ----------
-        dislocation_id : str
-            The id associated with a dislocation parameter set.
-        dislocation_key : str
-            The key associated with a dislocation parameter set.
-        dislocation_family : str
-            The "family" crystal structure/prototype that the dislocation
-            is defined for.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
 
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.dislocation.key', dislocation_key)
-        query.str_match.mongo(mquery, f'{root}.dislocation.id', dislocation_id)
-        query.str_match.mongo(mquery, f'{root}.system-family', dislocation_family)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.0', a_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.1', a_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.0', b_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.1', b_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.0', c_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.1', c_mult2)
-
-        # Return query dict
-        return mquery
-
-    def cdcsquery(self, dislocation_key=None, dislocation_id=None,
-                  dislocation_family=None, a_mult1=None, a_mult2=None,
-                  b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                  **kwargs):
-        """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        dislocation_id : str
-            The id associated with a dislocation parameter set.
-        dislocation_key : str
-            The key associated with a dislocation parameter set.
-        dislocation_family : str
-            The "family" crystal structure/prototype that the dislocation
-            is defined for.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-        
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = self.parent.modelroot
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-        
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.dislocation.key', dislocation_key)
-        query.str_match.mongo(mquery, f'{root}.dislocation.id', dislocation_id)
-        query.str_match.mongo(mquery, f'{root}.system-family', dislocation_family)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.0', a_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.1', a_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.0', b_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.1', b_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.0', c_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.1', c_mult2)
+        root = f'{self.parent.modelroot}.{self.modelroot}'
+        runparampath = f'{self.parent.modelroot}.calculation.run-parameter.{self.modelprefix}'
 
-        # Return query dict
-        return mquery      
+        return {
+            'dislocation_id': load_query(
+                style='str_match',
+                name=f'{self.prefix}dislocation_id',
+                path=f'{root}.id',
+                description='search by dislocation parameter set id'),
+            'dislocation_key': load_query(
+                style='str_match',
+                name=f'{self.prefix}dislocation_key',
+                path=f'{root}.key',
+                description='search by dislocation parameter set UUID key'),
+            'dislocation_family': load_query(
+                style='str_match',
+                name=f'{self.prefix}dislocation_family',
+                path=f'{root}.system-family',
+                description='search by crystal prototype that the dislocation parameter set is for'),
+            'a_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult1',
+                path=f'{runparampath}size-multipliers.a.0',
+                description='search by lower a_mult value'),
+            'a_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult2',
+                path=f'{runparampath}size-multipliers.a.1',
+                description='search by upper a_mult value'),
+            'b_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult1',
+                path=f'{runparampath}size-multipliers.b.0',
+                description='search by lower b_mult value'),
+            'b_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult2',
+                path=f'{runparampath}size-multipliers.b.1',
+                description='search by upper b_mult value'),
+            'c_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult1',
+                path=f'{runparampath}size-multipliers.c.0',
+                description='search by lower c_mult value'),
+            'c_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult2',
+                path=f'{runparampath}size-multipliers.c.1',
+                description='search by upper c_mult value'),
+        }
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
@@ -891,76 +854,17 @@
         meta[f'{prefix}a_mult1'] = self.a_mults[0]
         meta[f'{prefix}a_mult2'] = self.a_mults[1]
         meta[f'{prefix}b_mult1'] = self.b_mults[0]
         meta[f'{prefix}b_mult2'] = self.b_mults[1]
         meta[f'{prefix}c_mult1'] = self.c_mults[0]
         meta[f'{prefix}c_mult2'] = self.c_mults[1]
 
-    def pandasfilter(self, dataframe, dislocation_key=None, dislocation_id=None,
-                     dislocation_family=None, a_mult1=None, a_mult2=None,
-                     b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                     **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        dislocation_id : str
-            The id associated with a dislocation parameter set.
-        dislocation_key : str
-            The key associated with a dislocation parameter set.
-        dislocation_family : str
-            The "family" crystal structure/prototype that the dislocation
-            is defined for.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        prefix = self.prefix
-        matches = (
-            query.str_match.pandas(dataframe, f'{prefix}dislocation_key',
-                                   dislocation_key)
-            &query.str_match.pandas(dataframe, f'{prefix}dislocation_id',
-                                    dislocation_id)
-            &query.str_match.pandas(dataframe, f'{prefix}dislocation_family',
-                                    dislocation_family)
-            &query.int_match.pandas(dataframe, f'{prefix}a_mult1', a_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}a_mult2', a_mult2)
-            &query.int_match.pandas(dataframe, f'{prefix}b_mult1', b_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}b_mult2', b_mult2)
-            &query.int_match.pandas(dataframe, f'{prefix}c_mult1', c_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}c_mult2', c_mult2) 
-        )
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/FreeSurface.py` & `iprPy-0.11.5/iprPy/calculation_subset/FreeSurface.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,35 +1,39 @@
 # coding: utf-8
 
 # Standard Python libraries
 from pathlib import Path
+from typing import Optional, Union
 
 # http://www.numpy.org/
 import numpy as np
+import numpy.typing as npt
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
+from yabadaba import load_query
 
 # https://github.com/usnistgov/atomman
-import atomman as am
 import atomman.unitconvert as uc
 
+# Local imports
 from . import CalculationSubset
-from ..tools import dict_insert, aslist
 from ..input import boolean, value
 
 class FreeSurface(CalculationSubset):
     """Handles calculation terms for free surface parameters"""
 
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -58,134 +62,145 @@
         self.minwidth = 0.0
         self.even = False
         self.family = None
         self.__content = None
         self.__model = None
 
 ############################## Class attributes ################################
-    
+
     @property
-    def param_file(self):
+    def param_file(self) -> Optional[Path]:
+        """Path or None: The path to the free surface parameter file"""
         return self.__param_file
 
     @param_file.setter
-    def param_file(self, value):
-        if value is None:
+    def param_file(self, val: Union[str, Path, None]):
+        if val is None:
             self.__param_file = None
         else:
-            self.__param_file = Path(value)
+            self.__param_file = Path(val)
 
     @property
-    def key(self):
+    def key(self) -> Optional[str]:
+        """str or None: UUID key of the free surface parameter set"""
         return self.__key
 
     @key.setter
-    def key(self, value):
-        if value is None:
+    def key(self, val: Optional[str]):
+        if val is None:
             self.__key = None
         else:
-            self.__key = str(value)
+            self.__key = str(val)
 
     @property
-    def id(self):
+    def id(self) -> Optional[str]:
+        """str or None: id of the free surface parameter set"""
         return self.__id
 
     @id.setter
-    def id(self, value):
-        if value is None:
+    def id(self, val: Optional[str]):
+        if val is None:
             self.__id = None
         else:
-            self.__id = str(value)
+            self.__id = str(val)
 
     @property
-    def hkl(self):
+    def hkl(self) -> Optional[np.ndarray]:
+        """numpy.ndarray or None: The crystallographic (hkl) or (hkil) cut plane"""
         return self.__hkl
 
     @hkl.setter
-    def hkl(self, value):
-        if value is None:
+    def hkl(self, val: Optional[npt.ArrayLike]):
+        if val is None:
             self.__hkl = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,) or value.shape == (4,)
-            self.__hkl = value.tolist()
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,) or val.shape == (4,)
+            self.__hkl = val.tolist()
 
     @property
-    def cellsetting(self):
+    def cellsetting(self) -> str:
+        """str: The reference unit cell setting"""
         return self.__cellsetting
 
     @cellsetting.setter
-    def cellsetting(self, value):
-        if value not in ['p', 'a', 'b', 'c', 'i', 'f']:
+    def cellsetting(self, val: str):
+        if val not in ['p', 'a', 'b', 'c', 'i', 'f']:
             raise ValueError('invalid surface cellsetting')
-        self.__cellsetting = str(value)
+        self.__cellsetting = str(val)
 
     @property
-    def cutboxvector(self):
+    def cutboxvector(self) -> str:
+        """str: The cell box vector that the cut occurs along"""
         return self.__cutboxvector
 
     @cutboxvector.setter
-    def cutboxvector(self, value):
-        if value not in ['a', 'b', 'c']:
+    def cutboxvector(self, val: str):
+        if val not in ['a', 'b', 'c']:
             raise ValueError('invalid surface cutboxvector')
-        self.__cutboxvector = str(value)
+        self.__cutboxvector = str(val)
 
     @property
-    def shiftindex(self):
+    def shiftindex(self) -> int:
+        """int: The index of the pre-determined shifts values to use for shift"""
         return self.__shiftindex
 
     @shiftindex.setter
-    def shiftindex(self, value):
-        self.__shiftindex = int(value)
+    def shiftindex(self, val: int):
+        self.__shiftindex = int(val)
 
     @property
-    def sizemults(self):
+    def sizemults(self) -> list:
+        """list: The three size multipliers of rcell used"""
         return self.__sizemults
 
     @sizemults.setter
-    def sizemults(self, value):
-        if isinstance(value, str):
-            value = np.array(value.strip().split(), dtype=int)
+    def sizemults(self, val: Union[str, list, tuple]):
+        if isinstance(val, str):
+            val = np.array(val.strip().split(), dtype=int)
         else:
-            value = np.asarray(value, dtype=int)
-        if value.shape != (3,):
+            val = np.asarray(val, dtype=int)
+        if val.shape != (3,):
             raise ValueError('Invalid sizemults command: exactly 3 sizemults required for this calculation')
-        self.__sizemults = value.tolist()
+        self.__sizemults = val.tolist()
 
     @property
-    def minwidth(self):
+    def minwidth(self) -> float:
+        """float: The minimum width allowed perpendicular to the cut"""
         return self.__minwidth
 
     @minwidth.setter
-    def minwidth(self, value):
-        self.__minwidth = float(value)
+    def minwidth(self, val: float):
+        self.__minwidth = float(val)
 
     @property
-    def even(self):
+    def even(self) -> bool:
+        """bool: If True, the number of replicas along the cutboxvector will be kept even"""
         return self.__even
 
     @even.setter
-    def even(self, value):
-        self.__even = boolean(value)
+    def even(self, val: bool):
+        self.__even = boolean(val)
 
     @property
-    def family(self):
+    def family(self) -> Optional[str]:
+        """str or None: The prototype or reference crystal the free surface parameter set is for"""
         return self.__family
 
     @family.setter
-    def family(self, value):
-        if value is None:
+    def family(self, val: Optional[str]):
+        if val is None:
             self.__family = None
         else:
-            self.__family = str(value)
+            self.__family = str(val)
 
-    def set_values(self, **kwargs):
+    def set_values(self, **kwargs: any):
         """
         Allows for multiple class attribute values to be updated at once.
 
         Parameters
         ----------
         param_file : str, optional
             The path to a file that fully defines the input parameters for
@@ -235,19 +250,21 @@
         if 'sizemults' in kwargs:
             self.sizemults = kwargs['sizemults']
         if 'minwidth' in kwargs:
             self.minwidth = kwargs['minwidth']
         if 'even' in kwargs:
             self.even = kwargs['even']
         if 'family' in kwargs:
-            self.family = kwargs['family']           
+            self.family = kwargs['family']
 
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -258,21 +275,20 @@
         if templateheader is None:
             templateheader = 'Free Surface'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = ' '.join([
                 "Specifies the parameter set that defines a free surface."])
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return {
             'surface_file': ' '.join([
                 "The path to a free_surface record file that collects the",
                 "parameters associated with a specific free surface."]),
             'surface_hkl': ' '.join([
                 "The Miller (hkl) plane for the surface given as three",
                 "space-delimited integers."]),
@@ -297,129 +313,129 @@
                 "Specifies a mimimum width in length units that the system must be",
                 "along the cutboxvector direction. The associated sizemult value",
                 "will be increased if necessary to ensure this. Default value is 0.0."]),
             'surface_even': ' '.join([
                 "If True, the number of replicas in the cutboxvector direction will"
                 "be even. Default value is False."]),
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return list(self.templatekeys.keys()) + [
             'surface_family',
             'surface_content'
         ]
+
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return self.preparekeys + [
             'surface_model',
         ]
 
     @property
-    def multikeys(self):
+    def multikeys(self) -> list:
         """
         list: Calculation subset key sets that can have multiple values during prepare.
-        """ 
+        """
         # Define key set for system size parameters
         sizekeys = ['sizemults', 'surface_minwidth', 'surface_even']
-        
+
         # Define key set for defect parameters as the remainder
         defectkeys = []
         for key in self.preparekeys:
             if key not in sizekeys:
                 defectkeys.append(key)
 
         # Add prefixes and return
         return [
             self._pre(sizekeys),
             self._pre(defectkeys)
         ]
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         self.param_file = input_dict.get(keymap['surface_file'], None)
         self.__content = input_dict.get(keymap['surface_content'], None)
-        
+
         # Replace defect model with defect content if given
         param_file = self.param_file
         if self.__content is not None:
             param_file = self.__content
 
         # Extract parameters from a file
         if param_file is not None:
-            
+
             # Verify competing parameters are not defined
             for key in ('surface_hkl',
                         'surface_shiftindex',
                         'surface_cellsetting',
                         'surface_cutboxvector'):
                 if keymap[key] in input_dict:
                     raise ValueError(f"{keymap[key]} and {keymap['surface_file']} cannot both be supplied")
-            
+
             # Load defect model
             self.__model = model = DM(param_file).find('free-surface')
-                
+
             # Extract parameter values from defect model
             self.key = model['key']
             self.id = model['id']
             self.family = model['system-family']
             self.hkl = model['calculation-parameter']['hkl']
             self.shiftindex = int(model['calculation-parameter'].get('shiftindex', 0))
             self.cutboxvector = model['calculation-parameter']['cutboxvector']
             self.cellsetting = model['calculation-parameter'].get('cellsetting', 'p')
-        
+
         # Set parameter values directly
         else:
             self.__model = None
             self.key = None
             self.id = None
             self.family = self.parent.system.family
             self.hkl = input_dict[keymap['surface_hkl']]
             self.shiftindex = int(input_dict.get(keymap['surface_shiftindex'], 0))
             self.cutboxvector = input_dict.get(keymap['surface_cutboxvector'], 'c')
             self.cellsetting = input_dict.get(keymap['surface_cellsetting'], 'p')
-    
+
         # Set default values for fault system manipulations
         self.sizemults = input_dict.get(keymap['sizemults'], '1 1 1')
         self.minwidth = value(input_dict, keymap['surface_minwidth'], default_term='0.0 angstrom',
                               default_unit=self.parent.units.length_unit)
         self.even = boolean(input_dict.get(keymap['surface_even'], False))
 
-
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = 'free-surface'
         return f'{self.modelprefix}{baseroot}'
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         surf = model[self.modelroot]
 
         self.__model = None
         self.__param_file = None
         self.key = surf['key']
         self.id = surf['id']
@@ -428,22 +444,24 @@
         cp = surf['calculation-parameter']
         self.hkl = cp['hkl']
         self.shiftindex = int(cp['shiftindex'])
         self.cutboxvector = cp['cutboxvector']
         self.cellsetting = cp['cellsetting'] 
 
         run_params = model['calculation']['run-parameter']
-        
+
         a_mult = run_params[f'{self.modelprefix}size-multipliers']['a'][1]
         b_mult = run_params[f'{self.modelprefix}size-multipliers']['b'][1]
         c_mult = run_params[f'{self.modelprefix}size-multipliers']['c'][1]
         self.sizemults = [a_mult, b_mult, c_mult]
         self.minwidth = uc.value_unit(run_params[f'{self.modelprefix}minimum-width'])
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -468,139 +486,80 @@
         # Build paths if needed
         if 'calculation' not in model:
             model['calculation'] = DM()
         if 'run-parameter' not in model['calculation']:
             model['calculation']['run-parameter'] = DM()
 
         run_params = model['calculation']['run-parameter']
-        
+
         run_params[f'{self.modelprefix}size-multipliers'] = DM()
         run_params[f'{self.modelprefix}size-multipliers']['a'] = sorted([0, self.sizemults[0]])
         run_params[f'{self.modelprefix}size-multipliers']['b'] = sorted([0, self.sizemults[1]])
         run_params[f'{self.modelprefix}size-multipliers']['c'] = sorted([0, self.sizemults[2]])
         run_params[f'{self.modelprefix}minimum-width'] = uc.model(self.minwidth,
                                                              self.parent.units.length_unit)
 
-    def mongoquery(self, surface_key=None, surface_id=None,
-                   surface_family=None, a_mult1=None, a_mult2=None,
-                   b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                   **kwargs):
-        """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
-        
-        Parameters
-        ----------
-        surface_id : str
-            The id associated with a free surface parameter set.
-        surface_key : str
-            The key associated with a free surface parameter set.
-        surface_family : str
-            The "family" crystal structure/prototype that the free surface
-            is defined for.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
 
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.free-surface.key', surface_key)
-        query.str_match.mongo(mquery, f'{root}.free-surface.id', surface_id)
-        query.str_match.mongo(mquery, f'{root}.system-family', surface_family)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.0', a_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.1', a_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.0', b_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.1', b_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.0', c_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.1', c_mult2)
-
-        # Return query dict
-        return mquery
-
-    def cdcsquery(self, surface_key=None, surface_id=None,
-                  surface_family=None, a_mult1=None, a_mult2=None,
-                  b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                  **kwargs):
-        """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        surface_id : str
-            The id associated with a free surface parameter set.
-        surface_key : str
-            The key associated with a free surface parameter set.
-        surface_family : str
-            The "family" crystal structure/prototype that the free surface
-            is defined for.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-        
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = self.parent.modelroot
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-        
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.free-surface.key', surface_key)
-        query.str_match.mongo(mquery, f'{root}.free-surface.id', surface_id)
-        query.str_match.mongo(mquery, f'{root}.system-family', surface_family)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.0', a_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.a.1', a_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.0', b_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.b.1', b_mult2)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.0', c_mult1)
-        query.int_match.mongo(mquery, f'{runparam_prefix}size-multipliers.c.1', c_mult2)
+        root = f'{self.parent.modelroot}.{self.modelroot}'
+        runparampath = f'{self.parent.modelroot}.calculation.run-parameter.{self.modelprefix}'
 
-        # Return query dict
-        return mquery      
+        return {
+            'surface_id': load_query(
+                style='str_match',
+                name=f'{self.prefix}surface_id',
+                path=f'{root}.id',
+                description='search by free surface parameter set id'),
+            'surface_key': load_query(
+                style='str_match',
+                name=f'{self.prefix}surface_key',
+                path=f'{root}.key',
+                description='search by free surface parameter set UUID key'),
+            'surface_family': load_query(
+                style='str_match',
+                name=f'{self.prefix}surface_family',
+                path=f'{root}.system-family',
+                description='search by crystal prototype that the free surface parameter set is for'),
+            'a_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult1',
+                path=f'{runparampath}size-multipliers.a.0',
+                description='search by lower a_mult value'),
+            'a_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}a_mult2',
+                path=f'{runparampath}size-multipliers.a.1',
+                description='search by upper a_mult value'),
+            'b_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult1',
+                path=f'{runparampath}size-multipliers.b.0',
+                description='search by lower b_mult value'),
+            'b_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}b_mult2',
+                path=f'{runparampath}size-multipliers.b.1',
+                description='search by upper b_mult value'),
+            'c_mult1': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult1',
+                path=f'{runparampath}size-multipliers.c.0',
+                description='search by lower c_mult value'),
+            'c_mult2': load_query(
+                style='int_match',
+                name=f'{self.prefix}c_mult2',
+                path=f'{runparampath}size-multipliers.c.1',
+                description='search by upper c_mult value'),
+        }
 
 ########################## Metadata interactions ##############################
-          
-    def metadata(self, meta):
+
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
@@ -615,89 +574,30 @@
         meta[f'{prefix}a_mult1'] = 0
         meta[f'{prefix}a_mult2'] = self.sizemults[0]
         meta[f'{prefix}b_mult1'] = 0
         meta[f'{prefix}b_mult2'] = self.sizemults[1]
         meta[f'{prefix}c_mult1'] = 0
         meta[f'{prefix}c_mult2'] = self.sizemults[2]
 
-    def pandasfilter(self, dataframe, surface_key=None, surface_id=None,
-                     surface_family=None, a_mult1=None, a_mult2=None,
-                     b_mult1=None, b_mult2=None, c_mult1=None, c_mult2=None,
-                     **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        surface_id : str
-            The id associated with a free surface parameter set.
-        surface_key : str
-            The key associated with a free surface parameter set.
-        surface_family : str
-            The "family" crystal structure/prototype that the free surface
-            is defined for.
-        a_mult1 : int
-            The lower size multiplier for the a box direction.
-        a_mult2 : int
-            The upper size multiplier for the a box direction.
-        b_mult1 : int
-            The lower size multiplier for the b box direction.
-        b_mult2 : int
-            The upper size multiplier for the b box direction.
-        c_mult1 : int
-            The lower size multiplier for the c box direction.
-        c_mult2 : int
-            The upper size multiplier for the c box direction.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        prefix = self.prefix
-        matches = (
-            query.str_match.pandas(dataframe, f'{prefix}surface_key',
-                                   surface_key)
-            &query.str_match.pandas(dataframe, f'{prefix}surface_id',
-                                    surface_id)
-            &query.str_match.pandas(dataframe, f'{prefix}surface_family',
-                                    surface_family)
-            &query.int_match.pandas(dataframe, f'{prefix}a_mult1', a_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}a_mult2', a_mult2)
-            &query.int_match.pandas(dataframe, f'{prefix}b_mult1', b_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}b_mult2', b_mult2)
-            &query.int_match.pandas(dataframe, f'{prefix}c_mult1', c_mult1)
-            &query.int_match.pandas(dataframe, f'{prefix}c_mult2', c_mult2) 
-        )
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
             The dictionary of input parameters to add subset terms to.
         """
         if self.hkl is None:
             raise ValueError('hkl not set')
 
         input_dict['hkl'] = self.hkl
-        
+
         input_dict['sizemults'] = self.sizemults
         input_dict['minwidth'] = self.minwidth
         input_dict['even'] = self.even
         input_dict['conventional_setting'] = self.cellsetting
         input_dict['cutboxvector'] = self.cutboxvector
-        input_dict['shiftindex'] = self.shiftindex
+        input_dict['shiftindex'] = self.shiftindex
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/LammpsCommands.py` & `iprPy-0.11.5/iprPy/calculation_subset/LammpsCommands.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,694 +1,603 @@
-00000000: 0d0a 2320 6874 7470 733a 2f2f 6769 7468  ..# https://gith
-00000010: 7562 2e63 6f6d 2f75 736e 6973 7467 6f76  ub.com/usnistgov
-00000020: 2f61 746f 6d6d 616e 0d0a 696d 706f 7274  /atomman..import
-00000030: 2061 746f 6d6d 616e 2061 7320 616d 0d0a   atomman as am..
-00000040: 696d 706f 7274 2061 746f 6d6d 616e 2e6c  import atomman.l
-00000050: 616d 6d70 7320 6173 206c 6d70 0d0a 696d  ammps as lmp..im
-00000060: 706f 7274 2061 746f 6d6d 616e 2e75 6e69  port atomman.uni
-00000070: 7463 6f6e 7665 7274 2061 7320 7563 0d0a  tconvert as uc..
-00000080: 0d0a 6672 6f6d 2079 6162 6164 6162 6120  ..from yabadaba 
-00000090: 696d 706f 7274 2071 7565 7279 0d0a 0d0a  import query....
-000000a0: 2320 6874 7470 733a 2f2f 6769 7468 7562  # https://github
-000000b0: 2e63 6f6d 2f75 736e 6973 7467 6f76 2f44  .com/usnistgov/D
-000000c0: 6174 614d 6f64 656c 4469 6374 0d0a 6672  ataModelDict..fr
-000000d0: 6f6d 2044 6174 614d 6f64 656c 4469 6374  om DataModelDict
-000000e0: 2069 6d70 6f72 7420 4461 7461 4d6f 6465   import DataMode
-000000f0: 6c44 6963 7420 6173 2044 4d0d 0a0d 0a23  lDict as DM....#
-00000100: 2069 7072 5079 2069 6d70 6f72 7473 0d0a   iprPy imports..
-00000110: 6672 6f6d 202e 2069 6d70 6f72 7420 4361  from . import Ca
-00000120: 6c63 756c 6174 696f 6e53 7562 7365 740d  lculationSubset.
-00000130: 0a66 726f 6d20 2e2e 746f 6f6c 7320 696d  .from ..tools im
-00000140: 706f 7274 2064 6963 745f 696e 7365 7274  port dict_insert
-00000150: 0d0a 0d0a 0d0a 636c 6173 7320 4c61 6d6d  ......class Lamm
-00000160: 7073 436f 6d6d 616e 6473 2843 616c 6375  psCommands(Calcu
-00000170: 6c61 7469 6f6e 5375 6273 6574 293a 0d0a  lationSubset):..
-00000180: 2020 2020 2222 2248 616e 646c 6573 2063      """Handles c
-00000190: 616c 6375 6c61 7469 6f6e 2074 6572 6d73  alculation terms
-000001a0: 2066 6f72 204c 414d 4d50 5320 6578 6563   for LAMMPS exec
-000001b0: 7574 6162 6c65 2063 6f6d 6d61 6e64 7322  utable commands"
-000001c0: 2222 0d0a 0d0a 2323 2323 2323 2323 2323  ""....##########
-000001d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000001e0: 2323 2320 436f 7265 2070 726f 7065 7274  ### Core propert
-000001f0: 6965 7320 2323 2323 2323 2323 2323 2323  ies ############
-00000200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000210: 2323 2323 230d 0a20 2020 2020 0d0a 2020  #####..     ..  
-00000220: 2020 6465 6620 5f5f 696e 6974 5f5f 2873    def __init__(s
-00000230: 656c 662c 2070 6172 656e 742c 2070 7265  elf, parent, pre
-00000240: 6669 783d 2727 2c20 7465 6d70 6c61 7465  fix='', template
-00000250: 6865 6164 6572 3d4e 6f6e 652c 0d0a 2020  header=None,..  
-00000260: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00000270: 656d 706c 6174 6564 6573 6372 6970 7469  emplatedescripti
-00000280: 6f6e 3d4e 6f6e 6529 3a0d 0a20 2020 2020  on=None):..     
-00000290: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-000002a0: 496e 6974 6961 6c69 7a65 7320 6120 6361  Initializes a ca
-000002b0: 6c63 756c 6174 696f 6e20 7265 636f 7264  lculation record
-000002c0: 2073 7562 7365 7420 6f62 6a65 6374 2e0d   subset object..
-000002d0: 0a0d 0a20 2020 2020 2020 2050 6172 616d  ...        Param
-000002e0: 6574 6572 730d 0a20 2020 2020 2020 202d  eters..        -
-000002f0: 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020 2020  ---------..     
-00000300: 2020 2070 6172 656e 7420 3a20 6970 7250     parent : iprP
-00000310: 792e 6361 6c63 756c 6174 696f 6e2e 4361  y.calculation.Ca
-00000320: 6c63 756c 6174 696f 6e0d 0a20 2020 2020  lculation..     
-00000330: 2020 2020 2020 2054 6865 2070 6172 656e         The paren
-00000340: 7420 6361 6c63 756c 6174 696f 6e20 6f62  t calculation ob
-00000350: 6a65 6374 2074 6861 7420 7468 6520 7375  ject that the su
-00000360: 6273 6574 206f 626a 6563 7420 6973 2070  bset object is p
-00000370: 6172 7420 6f66 2e0d 0a20 2020 2020 2020  art of...       
-00000380: 2020 2020 2054 6869 7320 616c 6c6f 7773       This allows
-00000390: 2066 6f72 2074 6865 2073 7562 7365 7420   for the subset 
-000003a0: 6d65 7468 6f64 7320 746f 2061 6363 6573  methods to acces
-000003b0: 7320 7061 7261 6d65 7465 7273 2073 6574  s parameters set
-000003c0: 2074 6f20 7468 650d 0a20 2020 2020 2020   to the..       
-000003d0: 2020 2020 2063 616c 6375 6c61 7469 6f6e       calculation
-000003e0: 2069 7473 656c 6620 6f72 206f 7468 6572   itself or other
-000003f0: 2073 7562 7365 7473 2e0d 0a20 2020 2020   subsets...     
-00000400: 2020 2070 7265 6669 7820 3a20 7374 722c     prefix : str,
-00000410: 206f 7074 696f 6e61 6c0d 0a20 2020 2020   optional..     
-00000420: 2020 2020 2020 2041 6e20 6f70 7469 6f6e         An option
-00000430: 616c 2070 7265 6669 7820 746f 2061 6464  al prefix to add
-00000440: 2074 6f20 6d65 7461 6461 7461 2066 6965   to metadata fie
-00000450: 6c64 206e 616d 6573 2074 6f20 616c 6c6f  ld names to allo
-00000460: 7720 666f 720d 0a20 2020 2020 2020 2020  w for..         
-00000470: 2020 2064 6966 6665 7265 6e74 6961 7469     differentiati
-00000480: 6e67 2062 6574 7765 656e 206d 756c 7469  ng between multi
-00000490: 706c 6520 7375 6273 6574 7320 6f66 2074  ple subsets of t
-000004a0: 6865 2073 616d 6520 7374 796c 6520 7769  he same style wi
-000004b0: 7468 696e 0d0a 2020 2020 2020 2020 2020  thin..          
-000004c0: 2020 6120 7369 6e67 6c65 2072 6563 6f72    a single recor
-000004d0: 640d 0a20 2020 2020 2020 2074 656d 706c  d..        templ
-000004e0: 6174 6568 6561 6465 7220 3a20 7374 722c  ateheader : str,
-000004f0: 206f 7074 696f 6e61 6c0d 0a20 2020 2020   optional..     
-00000500: 2020 2020 2020 2041 6e20 616c 7465 726e         An altern
-00000510: 6174 6520 6865 6164 6572 2074 6f20 7573  ate header to us
-00000520: 6520 696e 2074 6865 2074 656d 706c 6174  e in the templat
-00000530: 6520 6669 6c65 2066 6f72 2074 6865 2073  e file for the s
-00000540: 7562 7365 742e 0d0a 2020 2020 2020 2020  ubset...        
-00000550: 7465 6d70 6c61 7465 6465 7363 7269 7074  templatedescript
-00000560: 696f 6e20 3a20 7374 722c 206f 7074 696f  ion : str, optio
-00000570: 6e61 6c0d 0a20 2020 2020 2020 2020 2020  nal..           
-00000580: 2041 6e20 616c 7465 726e 6174 6520 6465   An alternate de
-00000590: 7363 7269 7074 696f 6e20 6f66 2074 6865  scription of the
-000005a0: 2073 7562 7365 7420 666f 7220 7468 6520   subset for the 
-000005b0: 7465 6d70 6c61 7465 646f 632e 0d0a 2020  templatedoc...  
-000005c0: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-000005d0: 2020 2073 7570 6572 2829 2e5f 5f69 6e69     super().__ini
-000005e0: 745f 5f28 7061 7265 6e74 2c20 7072 6566  t__(parent, pref
-000005f0: 6978 3d70 7265 6669 782c 2074 656d 706c  ix=prefix, templ
-00000600: 6174 6568 6561 6465 723d 7465 6d70 6c61  ateheader=templa
-00000610: 7465 6865 6164 6572 2c0d 0a20 2020 2020  teheader,..     
-00000620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000630: 2020 2020 7465 6d70 6c61 7465 6465 7363      templatedesc
-00000640: 7269 7074 696f 6e3d 7465 6d70 6c61 7465  ription=template
-00000650: 6465 7363 7269 7074 696f 6e29 0d0a 0d0a  description)....
-00000660: 2020 2020 2020 2020 7365 6c66 2e5f 5f6c          self.__l
-00000670: 616d 6d70 735f 636f 6d6d 616e 6420 3d20  ammps_command = 
-00000680: 4e6f 6e65 0d0a 2020 2020 2020 2020 7365  None..        se
-00000690: 6c66 2e5f 5f6d 7069 5f63 6f6d 6d61 6e64  lf.__mpi_command
-000006a0: 203d 204e 6f6e 650d 0a20 2020 2020 2020   = None..       
-000006b0: 2073 656c 662e 5f5f 6c61 6d6d 7073 5f76   self.__lammps_v
-000006c0: 6572 7369 6f6e 203d 204e 6f6e 650d 0a20  ersion = None.. 
-000006d0: 2020 2020 2020 2073 656c 662e 5f5f 6c61         self.__la
-000006e0: 6d6d 7073 5f64 6174 6520 3d20 4e6f 6e65  mmps_date = None
-000006f0: 0d0a 0d0a 2323 2323 2323 2323 2323 2323  ....############
-00000700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000710: 2323 2043 6c61 7373 2061 7474 7269 6275  ## Class attribu
-00000720: 7465 7320 2323 2323 2323 2323 2323 2323  tes ############
-00000730: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000740: 2323 2323 0d0a 2020 2020 0d0a 2020 2020  ####..    ..    
-00000750: 4070 726f 7065 7274 790d 0a20 2020 2064  @property..    d
-00000760: 6566 206c 616d 6d70 735f 636f 6d6d 616e  ef lammps_comman
-00000770: 6428 7365 6c66 293a 0d0a 2020 2020 2020  d(self):..      
-00000780: 2020 7265 7475 726e 2073 656c 662e 5f5f    return self.__
-00000790: 6c61 6d6d 7073 5f63 6f6d 6d61 6e64 0d0a  lammps_command..
-000007a0: 0d0a 2020 2020 406c 616d 6d70 735f 636f  ..    @lammps_co
-000007b0: 6d6d 616e 642e 7365 7474 6572 0d0a 2020  mmand.setter..  
-000007c0: 2020 6465 6620 6c61 6d6d 7073 5f63 6f6d    def lammps_com
-000007d0: 6d61 6e64 2873 656c 662c 2076 616c 7565  mand(self, value
-000007e0: 293a 0d0a 2020 2020 2020 2020 7365 6c66  ):..        self
-000007f0: 2e5f 5f6c 616d 6d70 735f 636f 6d6d 616e  .__lammps_comman
-00000800: 6420 3d20 7374 7228 7661 6c75 6529 0d0a  d = str(value)..
-00000810: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00000820: 5f5f 6c61 6d6d 7073 5f76 6572 7369 6f6e  __lammps_version
-00000830: 2069 7320 6e6f 7420 4e6f 6e65 3a0d 0a20   is not None:.. 
-00000840: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00000850: 5f5f 6c61 6d6d 7073 5f76 6572 7369 6f6e  __lammps_version
-00000860: 203d 204e 6f6e 650d 0a20 2020 2020 2020   = None..       
-00000870: 2020 2020 2073 656c 662e 5f5f 6c61 6d6d       self.__lamm
-00000880: 7073 5f64 6174 6520 3d20 4e6f 6e65 0d0a  ps_date = None..
-00000890: 0d0a 2020 2020 4070 726f 7065 7274 790d  ..    @property.
-000008a0: 0a20 2020 2064 6566 206d 7069 5f63 6f6d  .    def mpi_com
-000008b0: 6d61 6e64 2873 656c 6629 3a0d 0a20 2020  mand(self):..   
-000008c0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000008d0: 2e5f 5f6d 7069 5f63 6f6d 6d61 6e64 0d0a  .__mpi_command..
-000008e0: 0d0a 2020 2020 406d 7069 5f63 6f6d 6d61  ..    @mpi_comma
-000008f0: 6e64 2e73 6574 7465 720d 0a20 2020 2064  nd.setter..    d
-00000900: 6566 206d 7069 5f63 6f6d 6d61 6e64 2873  ef mpi_command(s
-00000910: 656c 662c 2076 616c 7565 293a 0d0a 2020  elf, value):..  
-00000920: 2020 2020 2020 6966 2076 616c 7565 2069        if value i
-00000930: 7320 4e6f 6e65 3a0d 0a20 2020 2020 2020  s None:..       
-00000940: 2020 2020 2073 656c 662e 5f5f 6d70 695f       self.__mpi_
-00000950: 636f 6d6d 616e 6420 3d20 4e6f 6e65 0d0a  command = None..
-00000960: 2020 2020 2020 2020 656c 7365 3a0d 0a20          else:.. 
-00000970: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00000980: 5f5f 6d70 695f 636f 6d6d 616e 6420 3d20  __mpi_command = 
-00000990: 7374 7228 7661 6c75 6529 0d0a 0d0a 2020  str(value)....  
-000009a0: 2020 4070 726f 7065 7274 790d 0a20 2020    @property..   
-000009b0: 2064 6566 206c 616d 6d70 735f 7665 7273   def lammps_vers
-000009c0: 696f 6e28 7365 6c66 293a 0d0a 2020 2020  ion(self):..    
-000009d0: 2020 2020 6966 2073 656c 662e 5f5f 6c61      if self.__la
-000009e0: 6d6d 7073 5f76 6572 7369 6f6e 2069 7320  mmps_version is 
-000009f0: 4e6f 6e65 2061 6e64 2073 656c 662e 6c61  None and self.la
-00000a00: 6d6d 7073 5f63 6f6d 6d61 6e64 2069 7320  mmps_command is 
-00000a10: 6e6f 7420 4e6f 6e65 3a0d 0a20 2020 2020  not None:..     
-00000a20: 2020 2020 2020 206c 616d 6d70 735f 7665         lammps_ve
-00000a30: 7273 696f 6e20 3d20 6c6d 702e 6368 6563  rsion = lmp.chec
-00000a40: 6b76 6572 7369 6f6e 2873 656c 662e 6c61  kversion(self.la
-00000a50: 6d6d 7073 5f63 6f6d 6d61 6e64 290d 0a20  mmps_command).. 
-00000a60: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00000a70: 5f5f 6c61 6d6d 7073 5f76 6572 7369 6f6e  __lammps_version
-00000a80: 203d 206c 616d 6d70 735f 7665 7273 696f   = lammps_versio
-00000a90: 6e5b 2776 6572 7369 6f6e 275d 0d0a 2020  n['version']..  
-00000aa0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-00000ab0: 5f6c 616d 6d70 735f 6461 7465 203d 206c  _lammps_date = l
-00000ac0: 616d 6d70 735f 7665 7273 696f 6e5b 2764  ammps_version['d
-00000ad0: 6174 6527 5d0d 0a20 2020 2020 2020 2072  ate']..        r
-00000ae0: 6574 7572 6e20 7365 6c66 2e5f 5f6c 616d  eturn self.__lam
-00000af0: 6d70 735f 7665 7273 696f 6e0d 0a20 2020  mps_version..   
-00000b00: 200d 0a20 2020 2040 7072 6f70 6572 7479   ..    @property
-00000b10: 0d0a 2020 2020 6465 6620 6c61 6d6d 7073  ..    def lammps
-00000b20: 5f64 6174 6528 7365 6c66 293a 0d0a 2020  _date(self):..  
-00000b30: 2020 2020 2020 6966 2073 656c 662e 5f5f        if self.__
-00000b40: 6c61 6d6d 7073 5f76 6572 7369 6f6e 2069  lammps_version i
-00000b50: 7320 4e6f 6e65 2061 6e64 2073 656c 662e  s None and self.
-00000b60: 6c61 6d6d 7073 5f63 6f6d 6d61 6e64 2069  lammps_command i
-00000b70: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
-00000b80: 2020 2020 2020 2020 206c 616d 6d70 735f           lammps_
-00000b90: 7665 7273 696f 6e20 3d20 6c6d 702e 6368  version = lmp.ch
-00000ba0: 6563 6b76 6572 7369 6f6e 2873 656c 662e  eckversion(self.
-00000bb0: 6c61 6d6d 7073 5f63 6f6d 6d61 6e64 290d  lammps_command).
-00000bc0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00000bd0: 662e 5f5f 6c61 6d6d 7073 5f76 6572 7369  f.__lammps_versi
-00000be0: 6f6e 203d 206c 616d 6d70 735f 7665 7273  on = lammps_vers
-00000bf0: 696f 6e5b 2776 6572 7369 6f6e 275d 0d0a  ion['version']..
-00000c00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00000c10: 2e5f 5f6c 616d 6d70 735f 6461 7465 203d  .__lammps_date =
-00000c20: 206c 616d 6d70 735f 7665 7273 696f 6e5b   lammps_version[
-00000c30: 2764 6174 6527 5d0d 0a20 2020 2020 2020  'date']..       
-00000c40: 2072 6574 7572 6e20 7365 6c66 2e5f 5f6c   return self.__l
-00000c50: 616d 6d70 735f 6461 7465 0d0a 0d0a 2020  ammps_date....  
-00000c60: 2020 6465 6620 7365 745f 7661 6c75 6573    def set_values
-00000c70: 2873 656c 662c 202a 2a6b 7761 7267 7329  (self, **kwargs)
-00000c80: 3a0d 0a20 2020 2020 2020 200d 0a20 2020  :..        ..   
-00000c90: 2020 2020 2069 6620 276c 616d 6d70 735f       if 'lammps_
-00000ca0: 636f 6d6d 616e 6427 2069 6e20 6b77 6172  command' in kwar
-00000cb0: 6773 3a0d 0a20 2020 2020 2020 2020 2020  gs:..           
-00000cc0: 2073 656c 662e 6c61 6d6d 7073 5f63 6f6d   self.lammps_com
-00000cd0: 6d61 6e64 203d 206b 7761 7267 735b 276c  mand = kwargs['l
-00000ce0: 616d 6d70 735f 636f 6d6d 616e 6427 5d0d  ammps_command'].
-00000cf0: 0a20 2020 2020 2020 2069 6620 276d 7069  .        if 'mpi
-00000d00: 5f63 6f6d 6d61 6e64 2720 696e 206b 7761  _command' in kwa
-00000d10: 7267 733a 0d0a 2020 2020 2020 2020 2020  rgs:..          
-00000d20: 2020 7365 6c66 2e6d 7069 5f63 6f6d 6d61    self.mpi_comma
-00000d30: 6e64 203d 206b 7761 7267 735b 276d 7069  nd = kwargs['mpi
-00000d40: 5f63 6f6d 6d61 6e64 275d 0d0a 0d0a 2323  _command']....##
-00000d50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00000d60: 2323 2323 2320 5061 7261 6d65 7465 7220  ##### Parameter 
-00000d70: 6669 6c65 2069 6e74 6572 6163 7469 6f6e  file interaction
-00000d80: 7320 2323 2323 2323 2323 2323 2323 2323  s ##############
-00000d90: 2323 2323 2323 2323 2323 2323 230d 0a0d  #############...
-00000da0: 0a20 2020 2064 6566 205f 7465 6d70 6c61  .    def _templa
-00000db0: 7465 5f69 6e69 7428 7365 6c66 2c20 7465  te_init(self, te
-00000dc0: 6d70 6c61 7465 6865 6164 6572 3d4e 6f6e  mplateheader=Non
-00000dd0: 652c 2074 656d 706c 6174 6564 6573 6372  e, templatedescr
-00000de0: 6970 7469 6f6e 3d4e 6f6e 6529 3a0d 0a20  iption=None):.. 
-00000df0: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
-00000e00: 2020 2020 5365 7473 2074 6865 2074 656d      Sets the tem
-00000e10: 706c 6174 6520 6865 6164 6572 2061 6e64  plate header and
-00000e20: 2064 6573 6372 6970 7469 6f6e 2076 616c   description val
-00000e30: 7565 732e 0d0a 0d0a 2020 2020 2020 2020  ues.....        
-00000e40: 5061 7261 6d65 7465 7273 0d0a 2020 2020  Parameters..    
-00000e50: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a      ----------..
-00000e60: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-00000e70: 6865 6164 6572 203a 2073 7472 2c20 6f70  header : str, op
-00000e80: 7469 6f6e 616c 0d0a 2020 2020 2020 2020  tional..        
-00000e90: 2020 2020 416e 2061 6c74 6572 6e61 7465      An alternate
-00000ea0: 2068 6561 6465 7220 746f 2075 7365 2069   header to use i
-00000eb0: 6e20 7468 6520 7465 6d70 6c61 7465 2066  n the template f
-00000ec0: 696c 6520 666f 7220 7468 6520 7375 6273  ile for the subs
-00000ed0: 6574 2e0d 0a20 2020 2020 2020 2074 656d  et...        tem
-00000ee0: 706c 6174 6564 6573 6372 6970 7469 6f6e  platedescription
-00000ef0: 203a 2073 7472 2c20 6f70 7469 6f6e 616c   : str, optional
-00000f00: 0d0a 2020 2020 2020 2020 2020 2020 416e  ..            An
-00000f10: 2061 6c74 6572 6e61 7465 2064 6573 6372   alternate descr
-00000f20: 6970 7469 6f6e 206f 6620 7468 6520 7375  iption of the su
-00000f30: 6273 6574 2066 6f72 2074 6865 2074 656d  bset for the tem
-00000f40: 706c 6174 6564 6f63 2e0d 0a20 2020 2020  platedoc...     
-00000f50: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-00000f60: 2320 5365 7420 6465 6661 756c 7420 7465  # Set default te
-00000f70: 6d70 6c61 7465 2068 6561 6465 720d 0a20  mplate header.. 
-00000f80: 2020 2020 2020 2069 6620 7465 6d70 6c61         if templa
-00000f90: 7465 6865 6164 6572 2069 7320 4e6f 6e65  teheader is None
-00000fa0: 3a0d 0a20 2020 2020 2020 2020 2020 2074  :..            t
-00000fb0: 656d 706c 6174 6568 6561 6465 7220 3d20  emplateheader = 
-00000fc0: 274c 414d 4d50 5320 616e 6420 4d50 4920  'LAMMPS and MPI 
-00000fd0: 436f 6d6d 616e 6473 270d 0a0d 0a20 2020  Commands'....   
-00000fe0: 2020 2020 2023 2053 6574 2064 6566 6175       # Set defau
-00000ff0: 6c74 2074 656d 706c 6174 6520 6465 7363  lt template desc
-00001000: 7269 7074 696f 6e0d 0a20 2020 2020 2020  ription..       
-00001010: 2069 6620 7465 6d70 6c61 7465 6465 7363   if templatedesc
-00001020: 7269 7074 696f 6e20 6973 204e 6f6e 653a  ription is None:
-00001030: 0d0a 2020 2020 2020 2020 2020 2020 7465  ..            te
-00001040: 6d70 6c61 7465 6465 7363 7269 7074 696f  mplatedescriptio
-00001050: 6e20 3d20 2720 272e 6a6f 696e 285b 0d0a  n = ' '.join([..
-00001060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001070: 2253 7065 6369 6669 6573 2074 6865 2065  "Specifies the e
-00001080: 7874 6572 6e61 6c20 636f 6d6d 616e 6473  xternal commands
-00001090: 2066 6f72 2072 756e 6e69 6e67 204c 414d   for running LAM
-000010a0: 4d50 5320 616e 6420 4d50 492e 225d 290d  MPS and MPI."]).
-000010b0: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
-000010c0: 2020 2073 7570 6572 2829 2e5f 7465 6d70     super()._temp
-000010d0: 6c61 7465 5f69 6e69 7428 7465 6d70 6c61  late_init(templa
-000010e0: 7465 6865 6164 6572 2c20 7465 6d70 6c61  teheader, templa
-000010f0: 7465 6465 7363 7269 7074 696f 6e29 0d0a  tedescription)..
-00001100: 0d0a 2020 2020 4070 726f 7065 7274 790d  ..    @property.
-00001110: 0a20 2020 2064 6566 2074 656d 706c 6174  .    def templat
-00001120: 656b 6579 7328 7365 6c66 293a 0d0a 2020  ekeys(self):..  
-00001130: 2020 2020 2020 2222 2264 6963 7420 3a20        """dict : 
-00001140: 5468 6520 7375 6273 6574 2d73 7065 6369  The subset-speci
-00001150: 6669 6320 696e 7075 7420 6b65 7973 2061  fic input keys a
-00001160: 6e64 2074 6865 6972 2064 6573 6372 6970  nd their descrip
-00001170: 7469 6f6e 732e 2222 220d 0a20 2020 2020  tions."""..     
-00001180: 2020 200d 0a20 2020 2020 2020 2072 6574     ..        ret
-00001190: 7572 6e20 207b 0d0a 2020 2020 2020 2020  urn  {..        
-000011a0: 2020 2020 276c 616d 6d70 735f 636f 6d6d      'lammps_comm
-000011b0: 616e 6427 3a20 2720 272e 6a6f 696e 285b  and': ' '.join([
-000011c0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000011d0: 2020 2254 6865 2070 6174 6820 746f 2074    "The path to t
-000011e0: 6865 2065 7865 6375 7461 626c 6520 666f  he executable fo
-000011f0: 7220 7275 6e6e 696e 6720 4c41 4d4d 5053  r running LAMMPS
-00001200: 206f 6e20 796f 7572 2073 7973 7465 6d2e   on your system.
-00001210: 222c 0d0a 2020 2020 2020 2020 2020 2020  ",..            
-00001220: 2020 2020 2244 6f6e 2774 2069 6e63 6c75      "Don't inclu
-00001230: 6465 2063 6f6d 6d61 6e64 206c 696e 6520  de command line 
-00001240: 6f70 7469 6f6e 732e 225d 292c 0d0a 2020  options."]),..  
-00001250: 2020 2020 2020 2020 2020 276d 7069 5f63            'mpi_c
-00001260: 6f6d 6d61 6e64 273a 2027 2027 2e6a 6f69  ommand': ' '.joi
-00001270: 6e28 5b0d 0a20 2020 2020 2020 2020 2020  n([..           
-00001280: 2020 2020 2022 5468 6520 7061 7468 2074       "The path t
-00001290: 6f20 7468 6520 4d50 4920 6578 6563 7574  o the MPI execut
-000012a0: 6162 6c65 2061 6e64 2061 6e79 2063 6f6d  able and any com
-000012b0: 6d61 6e64 206c 696e 6520 6f70 7469 6f6e  mand line option
-000012c0: 7320 746f 222c 0d0a 2020 2020 2020 2020  s to",..        
-000012d0: 2020 2020 2020 2020 2275 7365 2066 6f72          "use for
-000012e0: 2063 616c 6c69 6e67 204c 414d 4d50 5320   calling LAMMPS 
-000012f0: 746f 2072 756e 2069 6e20 7061 7261 6c6c  to run in parall
-00001300: 656c 206f 6e20 796f 7572 2073 7973 7465  el on your syste
-00001310: 6d2e 204c 414d 4d50 5322 2c0d 0a20 2020  m. LAMMPS",..   
-00001320: 2020 2020 2020 2020 2020 2020 2022 7769               "wi
-00001330: 6c6c 2072 756e 2061 7320 6120 7365 7269  ll run as a seri
-00001340: 616c 2070 726f 6365 7373 2069 6620 6e6f  al process if no
-00001350: 7420 6769 7665 6e2e 225d 292c 0d0a 2020  t given."]),..  
-00001360: 2020 2020 2020 7d0d 0a20 2020 200d 0a20        }..    .. 
-00001370: 2020 2040 7072 6f70 6572 7479 0d0a 2020     @property..  
-00001380: 2020 6465 6620 7072 6570 6172 656b 6579    def preparekey
-00001390: 7328 7365 6c66 293a 0d0a 2020 2020 2020  s(self):..      
-000013a0: 2020 2222 220d 0a20 2020 2020 2020 206c    """..        l
-000013b0: 6973 7420 3a20 5468 6520 696e 7075 7420  ist : The input 
-000013c0: 6b65 7973 2028 7769 7468 6f75 7420 7072  keys (without pr
-000013d0: 6566 6978 2920 7573 6564 2077 6865 6e20  efix) used when 
-000013e0: 7072 6570 6172 696e 6720 6120 6361 6c63  preparing a calc
-000013f0: 756c 6174 696f 6e2e 0d0a 2020 2020 2020  ulation...      
-00001400: 2020 5479 7069 6361 6c6c 792c 2074 6869    Typically, thi
-00001410: 7320 6973 2074 656d 706c 6174 656b 6579  s is templatekey
-00001420: 7320 706c 7573 202a 5f63 6f6e 7465 6e74  s plus *_content
-00001430: 206b 6579 7320 736f 2070 7265 7061 7265   keys so prepare
-00001440: 2063 616e 2061 6363 6573 730d 0a20 2020   can access..   
-00001450: 2020 2020 2063 6f6e 7465 6e74 2062 6566       content bef
-00001460: 6f72 6520 6974 2065 7869 7374 7320 696e  ore it exists in
-00001470: 2074 6865 2063 616c 6320 666f 6c64 6572   the calc folder
-00001480: 7320 6265 696e 6720 7072 6570 6172 6564  s being prepared
-00001490: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
-000014a0: 2020 2020 2020 2020 7265 7475 726e 206c          return l
-000014b0: 6973 7428 7365 6c66 2e74 656d 706c 6174  ist(self.templat
-000014c0: 656b 6579 732e 6b65 7973 2829 2920 2b20  ekeys.keys()) + 
-000014d0: 5b5d 0d0a 2020 2020 2020 2020 0d0a 2020  []..        ..  
-000014e0: 2020 4070 726f 7065 7274 790d 0a20 2020    @property..   
-000014f0: 2064 6566 2069 6e74 6572 7072 6574 6b65   def interpretke
-00001500: 7973 2873 656c 6629 3a0d 0a20 2020 2020  ys(self):..     
-00001510: 2020 2022 2222 0d0a 2020 2020 2020 2020     """..        
-00001520: 6c69 7374 203a 2054 6865 2069 6e70 7574  list : The input
-00001530: 206b 6579 7320 2877 6974 686f 7574 2070   keys (without p
-00001540: 7265 6669 7829 2061 6363 6573 7365 6420  refix) accessed 
-00001550: 7768 656e 2069 6e74 6572 7072 6574 696e  when interpretin
-00001560: 6720 7468 6520 0d0a 2020 2020 2020 2020  g the ..        
-00001570: 6361 6c63 756c 6174 696f 6e20 696e 7075  calculation inpu
-00001580: 7420 6669 6c65 2e20 2054 7970 6963 616c  t file.  Typical
-00001590: 6c79 2c20 7468 6973 2069 7320 7072 6570  ly, this is prep
-000015a0: 6172 656b 6579 7320 706c 7573 2061 6e79  arekeys plus any
-000015b0: 2065 7874 7261 0d0a 2020 2020 2020 2020   extra..        
-000015c0: 6b65 7973 2075 7365 6420 6f72 2067 656e  keys used or gen
-000015d0: 6572 6174 6564 2077 6865 6e20 7072 6f63  erated when proc
-000015e0: 6573 7369 6e67 2074 6865 2069 6e70 7574  essing the input
-000015f0: 732e 0d0a 2020 2020 2020 2020 2222 220d  s...        """.
-00001600: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00001610: 2073 656c 662e 7072 6570 6172 656b 6579   self.preparekey
-00001620: 7320 2b20 5b0d 0a20 2020 2020 2020 2020  s + [..         
-00001630: 2020 2020 2020 2020 2020 2027 6c61 6d6d             'lamm
-00001640: 7073 5f76 6572 7369 6f6e 272c 0d0a 2020  ps_version',..  
-00001650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001660: 2020 276c 616d 6d70 735f 6461 7465 270d    'lammps_date'.
-00001670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001680: 205d 0d0a 2020 2020 0d0a 2020 2020 6465   ]..    ..    de
-00001690: 6620 6c6f 6164 5f70 6172 616d 6574 6572  f load_parameter
-000016a0: 7328 7365 6c66 2c20 696e 7075 745f 6469  s(self, input_di
-000016b0: 6374 293a 0d0a 2020 2020 2020 2020 2222  ct):..        ""
-000016c0: 220d 0a20 2020 2020 2020 2049 6e74 6572  "..        Inter
-000016d0: 7072 6574 7320 6361 6c63 756c 6174 696f  prets calculatio
-000016e0: 6e20 7061 7261 6d65 7465 7273 2e0d 0a20  n parameters... 
-000016f0: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00001700: 2050 6172 616d 6574 6572 730d 0a20 2020   Parameters..   
-00001710: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0d       ----------.
-00001720: 0a20 2020 2020 2020 2069 6e70 7574 5f64  .        input_d
-00001730: 6963 7420 3a20 6469 6374 0d0a 2020 2020  ict : dict..    
-00001740: 2020 2020 2020 2020 4469 6374 696f 6e61          Dictiona
-00001750: 7279 2063 6f6e 7461 696e 696e 6720 696e  ry containing in
-00001760: 7075 7420 7061 7261 6d65 7465 7220 6b65  put parameter ke
-00001770: 792d 7661 6c75 6520 7061 6972 732e 0d0a  y-value pairs...
-00001780: 2020 2020 2020 2020 2222 220d 0a0d 0a20          """.... 
-00001790: 2020 2020 2020 2023 2053 6574 2064 6566         # Set def
-000017a0: 6175 6c74 206b 6579 6e61 6d65 730d 0a20  ault keynames.. 
-000017b0: 2020 2020 2020 206b 6579 6d61 7020 3d20         keymap = 
-000017c0: 7365 6c66 2e6b 6579 6d61 700d 0a20 2020  self.keymap..   
-000017d0: 2020 2020 200d 0a20 2020 2020 2020 2023       ..        #
-000017e0: 2045 7874 7261 6374 2069 6e70 7574 2076   Extract input v
-000017f0: 616c 7565 7320 616e 6420 6173 7369 676e  alues and assign
-00001800: 2064 6566 6175 6c74 2076 616c 7565 730d   default values.
-00001810: 0a20 2020 2020 2020 2073 656c 662e 6c61  .        self.la
-00001820: 6d6d 7073 5f63 6f6d 6d61 6e64 203d 2069  mmps_command = i
-00001830: 6e70 7574 5f64 6963 745b 6b65 796d 6170  nput_dict[keymap
-00001840: 5b27 6c61 6d6d 7073 5f63 6f6d 6d61 6e64  ['lammps_command
-00001850: 275d 5d0d 0a20 2020 2020 2020 2073 656c  ']]..        sel
-00001860: 662e 6d70 695f 636f 6d6d 616e 6420 3d20  f.mpi_command = 
-00001870: 696e 7075 745f 6469 6374 2e67 6574 286b  input_dict.get(k
-00001880: 6579 6d61 705b 276d 7069 5f63 6f6d 6d61  eymap['mpi_comma
-00001890: 6e64 275d 2c20 4e6f 6e65 290d 0a20 2020  nd'], None)..   
-000018a0: 200d 0a23 2323 2323 2323 2323 2323 2323   ..#############
-000018b0: 2323 2323 2323 2323 2323 2323 2323 2044  ############## D
-000018c0: 6174 6120 6d6f 6465 6c20 696e 7465 7261  ata model intera
-000018d0: 6374 696f 6e73 2023 2323 2323 2323 2323  ctions #########
-000018e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000018f0: 2323 0d0a 0d0a 2020 2020 4070 726f 7065  ##....    @prope
-00001900: 7274 790d 0a20 2020 2064 6566 206d 6f64  rty..    def mod
-00001910: 656c 726f 6f74 2873 656c 6629 3a0d 0a20  elroot(self):.. 
-00001920: 2020 2020 2020 2022 2222 7374 7220 3a20         """str : 
-00001930: 5468 6520 726f 6f74 2065 6c65 6d65 6e74  The root element
-00001940: 206e 616d 6520 666f 7220 7468 6520 7375   name for the su
-00001950: 6273 6574 2074 6572 6d73 2e22 2222 0d0a  bset terms."""..
-00001960: 2020 2020 2020 2020 6261 7365 726f 6f74          baseroot
-00001970: 203d 2027 4c41 4d4d 5053 2d76 6572 7369   = 'LAMMPS-versi
-00001980: 6f6e 270d 0a20 2020 2020 2020 2072 6574  on'..        ret
-00001990: 7572 6e20 6627 7b73 656c 662e 6d6f 6465  urn f'{self.mode
-000019a0: 6c70 7265 6669 787d 7b62 6173 6572 6f6f  lprefix}{baseroo
-000019b0: 747d 270d 0a0d 0a20 2020 2064 6566 206c  t}'....    def l
-000019c0: 6f61 645f 6d6f 6465 6c28 7365 6c66 2c20  oad_model(self, 
-000019d0: 6d6f 6465 6c29 3a0d 0a20 2020 2020 2020  model):..       
-000019e0: 2022 2222 4c6f 6164 7320 7375 6273 6574   """Loads subset
-000019f0: 2061 7474 7269 6275 7465 7320 6672 6f6d   attributes from
-00001a00: 2061 6e20 6578 6973 7469 6e67 206d 6f64   an existing mod
-00001a10: 656c 2e22 2222 0d0a 2020 2020 2020 2020  el."""..        
-00001a20: 7365 6c66 2e5f 5f6c 616d 6d70 735f 7665  self.__lammps_ve
-00001a30: 7273 696f 6e20 3d20 6d6f 6465 6c5b 2763  rsion = model['c
-00001a40: 616c 6375 6c61 7469 6f6e 275d 5b73 656c  alculation'][sel
-00001a50: 662e 6d6f 6465 6c72 6f6f 745d 0d0a 2020  f.modelroot]..  
-00001a60: 2020 0d0a 2020 2020 6465 6620 6275 696c    ..    def buil
-00001a70: 645f 6d6f 6465 6c28 7365 6c66 2c20 6d6f  d_model(self, mo
-00001a80: 6465 6c2c 202a 2a6b 7761 7267 7329 3a0d  del, **kwargs):.
-00001a90: 0a20 2020 2020 2020 2022 2222 0d0a 2020  .        """..  
-00001aa0: 2020 2020 2020 4164 6473 2074 6865 2073        Adds the s
-00001ab0: 7562 7365 7420 6d6f 6465 6c20 746f 2074  ubset model to t
-00001ac0: 6865 2070 6172 656e 7420 6d6f 6465 6c2e  he parent model.
-00001ad0: 0d0a 2020 2020 2020 2020 0d0a 2020 2020  ..        ..    
-00001ae0: 2020 2020 5061 7261 6d65 7465 7273 0d0a      Parameters..
-00001af0: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
-00001b00: 2d2d 0d0a 2020 2020 2020 2020 6d6f 6465  --..        mode
-00001b10: 6c20 3a20 4461 7461 4d6f 6465 6c44 6963  l : DataModelDic
-00001b20: 742e 4461 7461 4d6f 6465 6c44 6963 740d  t.DataModelDict.
-00001b30: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-00001b40: 2072 6563 6f72 6420 636f 6e74 656e 7420   record content 
-00001b50: 2861 6674 6572 2072 6f6f 7420 656c 656d  (after root elem
-00001b60: 656e 7429 2074 6f20 6164 6420 636f 6e74  ent) to add cont
-00001b70: 656e 7420 746f 2e0d 0a20 2020 2020 2020  ent to...       
-00001b80: 206b 7761 7267 7320 3a20 616e 790d 0a20   kwargs : any.. 
-00001b90: 2020 2020 2020 2020 2020 2041 6e79 206f             Any o
-00001ba0: 7074 696f 6e73 2074 6f20 7061 7373 206f  ptions to pass o
-00001bb0: 6e20 746f 2064 6963 745f 696e 7365 7274  n to dict_insert
-00001bc0: 2074 6861 7420 7370 6563 6966 7920 7768   that specify wh
-00001bd0: 6572 6520 7468 6520 7375 6273 6574 0d0a  ere the subset..
-00001be0: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-00001bf0: 656e 7420 6765 7473 2061 6464 6564 2074  ent gets added t
-00001c00: 6f20 696e 2074 6865 2070 6172 656e 7420  o in the parent 
-00001c10: 6d6f 6465 6c2e 0d0a 2020 2020 2020 2020  model...        
-00001c20: 2222 220d 0a20 2020 2020 2020 2064 6963  """..        dic
-00001c30: 745f 696e 7365 7274 286d 6f64 656c 5b27  t_insert(model['
-00001c40: 6361 6c63 756c 6174 696f 6e27 5d2c 2073  calculation'], s
-00001c50: 656c 662e 6d6f 6465 6c72 6f6f 742c 2073  elf.modelroot, s
-00001c60: 656c 662e 6c61 6d6d 7073 5f76 6572 7369  elf.lammps_versi
-00001c70: 6f6e 2c0d 0a20 2020 2020 2020 2020 2020  on,..           
-00001c80: 2020 2020 2020 2020 202a 2a6b 7761 7267           **kwarg
-00001c90: 7329 0d0a 0d0a 2020 2020 6465 6620 6d6f  s)....    def mo
-00001ca0: 6e67 6f71 7565 7279 2873 656c 662c 206c  ngoquery(self, l
-00001cb0: 616d 6d70 735f 7665 7273 696f 6e3d 4e6f  ammps_version=No
-00001cc0: 6e65 2c20 2a2a 6b77 6172 6773 293a 0d0a  ne, **kwargs):..
-00001cd0: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
-00001ce0: 2020 2020 2047 656e 6572 6174 6520 6120       Generate a 
-00001cf0: 7175 6572 7920 746f 2070 6172 7365 2072  query to parse r
-00001d00: 6563 6f72 6473 2077 6974 6820 7468 6520  ecords with the 
-00001d10: 7375 6273 6574 2066 726f 6d20 6120 4d6f  subset from a Mo
-00001d20: 6e67 6f2d 7374 796c 650d 0a20 2020 2020  ngo-style..     
-00001d30: 2020 2064 6174 6162 6173 652e 0d0a 2020     database...  
-00001d40: 2020 2020 2020 0d0a 2020 2020 2020 2020        ..        
-00001d50: 5061 7261 6d65 7465 7273 0d0a 2020 2020  Parameters..    
-00001d60: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a      ----------..
-00001d70: 2020 2020 2020 2020 6c61 6d6d 7073 5f76          lammps_v
-00001d80: 6572 7369 6f6e 203a 2073 7472 0d0a 2020  ersion : str..  
-00001d90: 2020 2020 2020 2020 2020 5468 6520 7665            The ve
-00001da0: 7273 696f 6e20 6f66 204c 414d 4d50 5320  rsion of LAMMPS 
-00001db0: 7573 6564 2e0d 0a20 2020 2020 2020 206b  used...        k
-00001dc0: 7761 7267 7320 3a20 616e 790d 0a20 2020  wargs : any..   
-00001dd0: 2020 2020 2020 2020 2054 6865 2070 6172           The par
-00001de0: 656e 7420 7175 6572 7920 7465 726d 7320  ent query terms 
-00001df0: 616e 6420 7661 6c75 6573 2069 676e 6f72  and values ignor
-00001e00: 6564 2062 7920 7468 6520 7375 6273 6574  ed by the subset
-00001e10: 2e0d 0a0d 0a20 2020 2020 2020 2052 6574  .....        Ret
-00001e20: 7572 6e73 0d0a 2020 2020 2020 2020 2d2d  urns..        --
-00001e30: 2d2d 2d2d 2d0d 0a20 2020 2020 2020 2064  -----..        d
-00001e40: 6963 740d 0a20 2020 2020 2020 2020 2020  ict..           
-00001e50: 2054 6865 204d 6f6e 676f 2d73 7479 6c65   The Mongo-style
-00001e60: 2066 696e 6420 7175 6572 7920 7465 726d   find query term
-00001e70: 732e 0d0a 2020 2020 2020 2020 2222 220d  s...        """.
-00001e80: 0a20 2020 2020 2020 2023 2049 6e69 7420  .        # Init 
-00001e90: 7175 6572 7920 616e 6420 7365 7420 726f  query and set ro
-00001ea0: 6f74 2070 6174 6873 0d0a 2020 2020 2020  ot paths..      
-00001eb0: 2020 6d71 7565 7279 203d 207b 7d0d 0a20    mquery = {}.. 
-00001ec0: 2020 2020 2020 2070 6172 656e 7472 6f6f         parentroo
-00001ed0: 7420 3d20 6627 636f 6e74 656e 742e 7b73  t = f'content.{s
-00001ee0: 656c 662e 7061 7265 6e74 2e6d 6f64 656c  elf.parent.model
-00001ef0: 726f 6f74 7d27 0d0a 2020 2020 2020 2020  root}'..        
-00001f00: 726f 6f74 203d 2066 277b 7061 7265 6e74  root = f'{parent
-00001f10: 726f 6f74 7d2e 6361 6c63 756c 6174 696f  root}.calculatio
-00001f20: 6e2e 7b73 656c 662e 6d6f 6465 6c72 6f6f  n.{self.modelroo
-00001f30: 747d 270d 0a20 2020 2020 2020 200d 0a20  t}'..        .. 
-00001f40: 2020 2020 2020 2023 2042 7569 6c64 2071         # Build q
-00001f50: 7565 7279 2074 6572 6d73 0d0a 2020 2020  uery terms..    
-00001f60: 2020 2020 7175 6572 792e 7374 725f 6d61      query.str_ma
-00001f70: 7463 682e 6d6f 6e67 6f28 6d71 7565 7279  tch.mongo(mquery
-00001f80: 2c20 726f 6f74 2c20 6c61 6d6d 7073 5f76  , root, lammps_v
-00001f90: 6572 7369 6f6e 290d 0a20 2020 2020 2020  ersion)..       
-00001fa0: 200d 0a20 2020 2020 2020 2023 2052 6574   ..        # Ret
-00001fb0: 7572 6e20 7175 6572 7920 6469 6374 0d0a  urn query dict..
-00001fc0: 2020 2020 2020 2020 7265 7475 726e 206d          return m
-00001fd0: 7175 6572 790d 0a0d 0a20 2020 2064 6566  query....    def
-00001fe0: 2063 6463 7371 7565 7279 2873 656c 662c   cdcsquery(self,
-00001ff0: 206c 616d 6d70 735f 7665 7273 696f 6e3d   lammps_version=
-00002000: 4e6f 6e65 2c20 2a2a 6b77 6172 6773 293a  None, **kwargs):
-00002010: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
-00002020: 2020 2020 2020 2047 656e 6572 6174 6520         Generate 
-00002030: 6120 7175 6572 7920 746f 2070 6172 7365  a query to parse
-00002040: 2072 6563 6f72 6473 2077 6974 6820 7468   records with th
-00002050: 6520 7375 6273 6574 2066 726f 6d20 6120  e subset from a 
-00002060: 4344 4353 2d73 7479 6c65 0d0a 2020 2020  CDCS-style..    
-00002070: 2020 2020 6461 7461 6261 7365 2e0d 0a20      database... 
-00002080: 2020 2020 2020 200d 0a20 2020 2020 2020         ..       
-00002090: 2050 6172 616d 6574 6572 730d 0a20 2020   Parameters..   
-000020a0: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0d       ----------.
-000020b0: 0a20 2020 2020 2020 206c 616d 6d70 735f  .        lammps_
-000020c0: 7665 7273 696f 6e20 3a20 7374 720d 0a20  version : str.. 
-000020d0: 2020 2020 2020 2020 2020 2054 6865 2076             The v
-000020e0: 6572 7369 6f6e 206f 6620 4c41 4d4d 5053  ersion of LAMMPS
-000020f0: 2075 7365 642e 0d0a 2020 2020 2020 2020   used...        
-00002100: 6b77 6172 6773 203a 2061 6e79 0d0a 2020  kwargs : any..  
-00002110: 2020 2020 2020 2020 2020 5468 6520 7061            The pa
-00002120: 7265 6e74 2071 7565 7279 2074 6572 6d73  rent query terms
-00002130: 2061 6e64 2076 616c 7565 7320 6967 6e6f   and values igno
-00002140: 7265 6420 6279 2074 6865 2073 7562 7365  red by the subse
-00002150: 742e 0d0a 2020 2020 2020 2020 0d0a 2020  t...        ..  
-00002160: 2020 2020 2020 5265 7475 726e 730d 0a20        Returns.. 
-00002170: 2020 2020 2020 202d 2d2d 2d2d 2d2d 0d0a         -------..
-00002180: 2020 2020 2020 2020 6469 6374 0d0a 2020          dict..  
-00002190: 2020 2020 2020 2020 2020 5468 6520 4344            The CD
-000021a0: 4353 2d73 7479 6c65 2066 696e 6420 7175  CS-style find qu
-000021b0: 6572 7920 7465 726d 732e 0d0a 2020 2020  ery terms...    
-000021c0: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-000021d0: 2023 2049 6e69 7420 7175 6572 7920 616e   # Init query an
-000021e0: 6420 7365 7420 726f 6f74 2070 6174 6873  d set root paths
-000021f0: 0d0a 2020 2020 2020 2020 6d71 7565 7279  ..        mquery
-00002200: 203d 207b 7d0d 0a20 2020 2020 2020 2070   = {}..        p
-00002210: 6172 656e 7472 6f6f 7420 3d20 7365 6c66  arentroot = self
-00002220: 2e70 6172 656e 742e 6d6f 6465 6c72 6f6f  .parent.modelroo
-00002230: 740d 0a20 2020 2020 2020 2072 6f6f 7420  t..        root 
-00002240: 3d20 6627 7b70 6172 656e 7472 6f6f 747d  = f'{parentroot}
-00002250: 2e63 616c 6375 6c61 7469 6f6e 2e7b 7365  .calculation.{se
-00002260: 6c66 2e6d 6f64 656c 726f 6f74 7d27 0d0a  lf.modelroot}'..
-00002270: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
-00002280: 2020 2320 4275 696c 6420 7175 6572 7920    # Build query 
-00002290: 7465 726d 730d 0a20 2020 2020 2020 2071  terms..        q
-000022a0: 7565 7279 2e73 7472 5f6d 6174 6368 2e6d  uery.str_match.m
-000022b0: 6f6e 676f 286d 7175 6572 792c 2072 6f6f  ongo(mquery, roo
-000022c0: 742c 206c 616d 6d70 735f 7665 7273 696f  t, lammps_versio
-000022d0: 6e29 0d0a 2020 2020 2020 2020 0d0a 2020  n)..        ..  
-000022e0: 2020 2020 2020 2320 5265 7475 726e 2071        # Return q
-000022f0: 7565 7279 2064 6963 740d 0a20 2020 2020  uery dict..     
-00002300: 2020 2072 6574 7572 6e20 6d71 7565 7279     return mquery
-00002310: 0d0a 0d0a 2323 2323 2323 2323 2323 2323  ....############
-00002320: 2323 2323 2323 2323 2323 2323 2323 204d  ############## M
-00002330: 6574 6164 6174 6120 696e 7465 7261 6374  etadata interact
-00002340: 696f 6e73 2023 2323 2323 2323 2323 2323  ions ###########
-00002350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002360: 2323 230d 0a0d 0a20 2020 2064 6566 206d  ###....    def m
-00002370: 6574 6164 6174 6128 7365 6c66 2c20 6d65  etadata(self, me
-00002380: 7461 293a 0d0a 2020 2020 2020 2020 2222  ta):..        ""
-00002390: 220d 0a20 2020 2020 2020 2043 6f6e 7665  "..        Conve
-000023a0: 7274 7320 7468 6520 7374 7275 6374 7572  rts the structur
-000023b0: 6564 2063 6f6e 7465 6e74 2074 6f20 6120  ed content to a 
-000023c0: 7369 6d70 6c65 7220 6469 6374 696f 6e61  simpler dictiona
-000023d0: 7279 2e0d 0a20 2020 2020 2020 200d 0a20  ry...        .. 
-000023e0: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-000023f0: 730d 0a20 2020 2020 2020 202d 2d2d 2d2d  s..        -----
-00002400: 2d2d 2d2d 2d0d 0a20 2020 2020 2020 206d  -----..        m
-00002410: 6574 6120 3a20 6469 6374 0d0a 2020 2020  eta : dict..    
-00002420: 2020 2020 2020 2020 5468 6520 6469 6374          The dict
-00002430: 696f 6e61 7279 2074 6f20 6164 6420 7468  ionary to add th
-00002440: 6520 696e 7465 7270 7265 7465 6420 636f  e interpreted co
-00002450: 6e74 656e 7420 746f 0d0a 2020 2020 2020  ntent to..      
-00002460: 2020 2222 220d 0a20 2020 2020 2020 206d    """..        m
-00002470: 6574 615b 6627 7b73 656c 662e 7072 6566  eta[f'{self.pref
-00002480: 6978 7d6c 616d 6d70 735f 7665 7273 696f  ix}lammps_versio
-00002490: 6e27 5d20 3d20 7365 6c66 2e6c 616d 6d70  n'] = self.lammp
-000024a0: 735f 7665 7273 696f 6e0d 0a20 2020 2020  s_version..     
-000024b0: 2020 200d 0a20 2020 2064 6566 2070 616e     ..    def pan
-000024c0: 6461 7366 696c 7465 7228 7365 6c66 2c20  dasfilter(self, 
-000024d0: 6461 7461 6672 616d 652c 206c 616d 6d70  dataframe, lammp
-000024e0: 735f 7665 7273 696f 6e3d 4e6f 6e65 2c20  s_version=None, 
-000024f0: 2a2a 6b77 6172 6773 293a 0d0a 2020 2020  **kwargs):..    
-00002500: 2020 2020 2222 220d 0a20 2020 2020 2020      """..       
-00002510: 2050 6172 7365 7320 6120 7061 6e64 6173   Parses a pandas
-00002520: 2064 6174 6166 7261 6d65 2063 6f6e 7461   dataframe conta
-00002530: 696e 696e 6720 7468 6520 7375 6273 6574  ining the subset
-00002540: 2773 206d 6574 6164 6174 6120 746f 2066  's metadata to f
-00002550: 696e 6420 0d0a 2020 2020 2020 2020 656e  ind ..        en
-00002560: 7472 6965 7320 6d61 7463 6869 6e67 2074  tries matching t
-00002570: 6865 2074 6572 6d73 2061 6e64 2076 616c  he terms and val
-00002580: 7565 7320 6769 7665 6e2e 2049 6465 616c  ues given. Ideal
-00002590: 6c79 2c20 7468 6973 2073 686f 756c 6420  ly, this should 
-000025a0: 6669 6e64 0d0a 2020 2020 2020 2020 7468  find..        th
-000025b0: 6520 7361 6d65 206d 6174 6368 6573 2061  e same matches a
-000025c0: 7320 7468 6520 6d6f 6e67 6f71 7565 7279  s the mongoquery
-000025d0: 2061 6e64 2063 6463 7371 7565 7279 206d   and cdcsquery m
-000025e0: 6574 686f 6473 2066 6f72 2074 6865 2073  ethods for the s
-000025f0: 616d 650d 0a20 2020 2020 2020 2073 6561  ame..        sea
-00002600: 7263 6820 7061 7261 6d65 7465 7273 2e0d  rch parameters..
-00002610: 0a0d 0a20 2020 2020 2020 2050 6172 616d  ...        Param
-00002620: 6574 6572 730d 0a20 2020 2020 2020 202d  eters..        -
-00002630: 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020 2020  ---------..     
-00002640: 2020 2064 6174 6166 7261 6d65 203a 2070     dataframe : p
-00002650: 616e 6461 732e 4461 7461 4672 616d 650d  andas.DataFrame.
-00002660: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-00002670: 206d 6574 6164 6174 6120 6461 7461 6672   metadata datafr
-00002680: 616d 6520 746f 2066 696c 7465 722e 0d0a  ame to filter...
-00002690: 2020 2020 2020 2020 6c61 6d6d 7073 5f76          lammps_v
-000026a0: 6572 7369 6f6e 203a 2073 7472 0d0a 2020  ersion : str..  
-000026b0: 2020 2020 2020 2020 2020 5468 6520 7665            The ve
-000026c0: 7273 696f 6e20 6f66 204c 414d 4d50 5320  rsion of LAMMPS 
-000026d0: 7573 6564 2e0d 0a20 2020 2020 2020 206b  used...        k
-000026e0: 7761 7267 7320 3a20 616e 790d 0a20 2020  wargs : any..   
-000026f0: 2020 2020 2020 2020 2054 6865 2070 6172           The par
-00002700: 656e 7420 7175 6572 7920 7465 726d 7320  ent query terms 
-00002710: 616e 6420 7661 6c75 6573 2069 676e 6f72  and values ignor
-00002720: 6564 2062 7920 7468 6520 7375 6273 6574  ed by the subset
-00002730: 2e0d 0a0d 0a20 2020 2020 2020 2052 6574  .....        Ret
-00002740: 7572 6e73 0d0a 2020 2020 2020 2020 2d2d  urns..        --
-00002750: 2d2d 2d2d 2d0d 0a20 2020 2020 2020 2070  -----..        p
-00002760: 616e 6461 732e 5365 7269 6573 206f 6620  andas.Series of 
-00002770: 626f 6f6c 0d0a 2020 2020 2020 2020 2020  bool..          
-00002780: 2020 5472 7565 2066 6f72 2065 6163 6820    True for each 
-00002790: 656e 7472 7920 7768 6572 6520 616c 6c20  entry where all 
-000027a0: 6669 6c74 6572 2074 6572 6d73 2b76 616c  filter terms+val
-000027b0: 7565 7320 6d61 7463 682c 2046 616c 7365  ues match, False
-000027c0: 2066 6f72 0d0a 2020 2020 2020 2020 2020   for..          
-000027d0: 2020 616c 6c20 6f74 6865 7220 656e 7472    all other entr
-000027e0: 6965 732e 0d0a 2020 2020 2020 2020 2222  ies...        ""
-000027f0: 220d 0a20 2020 2020 2020 2070 7265 6669  "..        prefi
-00002800: 7820 3d20 7365 6c66 2e70 7265 6669 780d  x = self.prefix.
-00002810: 0a20 2020 2020 2020 206d 6174 6368 6573  .        matches
-00002820: 203d 2028 0d0a 2020 2020 2020 2020 2020   = (..          
-00002830: 2020 7175 6572 792e 7374 725f 6d61 7463    query.str_matc
-00002840: 682e 7061 6e64 6173 2864 6174 6166 7261  h.pandas(datafra
-00002850: 6d65 2c20 6627 7b70 7265 6669 787d 6c61  me, f'{prefix}la
-00002860: 6d6d 7073 5f76 6572 7369 6f6e 272c 0d0a  mmps_version',..
-00002870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002890: 2020 206c 616d 6d70 735f 7665 7273 696f     lammps_versio
-000028a0: 6e29 0d0a 2020 2020 2020 2020 290d 0a20  n)..        ).. 
-000028b0: 2020 2020 2020 2072 6574 7572 6e20 6d61         return ma
-000028c0: 7463 6865 730d 0a0d 0a23 2323 2323 2323  tches....#######
-000028d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000028e0: 2323 2323 2043 616c 6375 6c61 7469 6f6e  #### Calculation
-000028f0: 2069 6e74 6572 6163 7469 6f6e 7320 2323   interactions ##
-00002900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00002910: 2323 2323 2323 2323 0d0a 2020 2020 0d0a  ########..    ..
-00002920: 2020 2020 6465 6620 6361 6c63 5f69 6e70      def calc_inp
-00002930: 7574 7328 7365 6c66 2c20 696e 7075 745f  uts(self, input_
-00002940: 6469 6374 293a 0d0a 2020 2020 2020 2020  dict):..        
-00002950: 2222 220d 0a20 2020 2020 2020 2047 656e  """..        Gen
-00002960: 6572 6174 6573 2063 616c 6375 6c61 7469  erates calculati
-00002970: 6f6e 2066 756e 6374 696f 6e20 696e 7075  on function inpu
-00002980: 7420 7061 7261 6d65 7465 7273 2062 6173  t parameters bas
-00002990: 6564 206f 6e20 7468 6520 7661 6c75 6573  ed on the values
-000029a0: 0d0a 2020 2020 2020 2020 6173 7369 676e  ..        assign
-000029b0: 6564 2074 6f20 6174 7472 6962 7574 6573  ed to attributes
-000029c0: 206f 6620 7468 6520 7375 6273 6574 2e0d   of the subset..
-000029d0: 0a0d 0a20 2020 2020 2020 2050 6172 616d  ...        Param
-000029e0: 6574 6572 730d 0a20 2020 2020 2020 202d  eters..        -
-000029f0: 2d2d 2d2d 2d2d 2d2d 2d0d 0a20 2020 2020  ---------..     
-00002a00: 2020 2069 6e70 7574 5f64 6963 7420 3a20     input_dict : 
-00002a10: 6469 6374 0d0a 2020 2020 2020 2020 2020  dict..          
-00002a20: 2020 5468 6520 6469 6374 696f 6e61 7279    The dictionary
-00002a30: 206f 6620 696e 7075 7420 7061 7261 6d65   of input parame
-00002a40: 7465 7273 2074 6f20 6164 6420 7375 6273  ters to add subs
-00002a50: 6574 2074 6572 6d73 2074 6f2e 0d0a 2020  et terms to...  
-00002a60: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
-00002a70: 2020 2069 6620 7365 6c66 2e6c 616d 6d70     if self.lammp
-00002a80: 735f 636f 6d6d 616e 6420 6973 204e 6f6e  s_command is Non
-00002a90: 653a 0d0a 2020 2020 2020 2020 2020 2020  e:..            
-00002aa0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00002ab0: 2827 6c61 6d6d 7073 5f63 6f6d 6d61 6e64  ('lammps_command
-00002ac0: 206e 6f74 2073 6574 2127 290d 0a20 2020   not set!')..   
-00002ad0: 2020 2020 2020 2020 200d 0a20 2020 2020           ..     
-00002ae0: 2020 2069 6e70 7574 5f64 6963 745b 276c     input_dict['l
-00002af0: 616d 6d70 735f 636f 6d6d 616e 6427 5d20  ammps_command'] 
-00002b00: 3d20 7365 6c66 2e6c 616d 6d70 735f 636f  = self.lammps_co
-00002b10: 6d6d 616e 640d 0a20 2020 2020 2020 2069  mmand..        i
-00002b20: 6e70 7574 5f64 6963 745b 276d 7069 5f63  nput_dict['mpi_c
-00002b30: 6f6d 6d61 6e64 275d 203d 2073 656c 662e  ommand'] = self.
-00002b40: 6d70 695f 636f 6d6d 616e 640d 0a20 2020  mpi_command..   
-00002b50: 2020 2020 20                                  
+00000000: 2320 636f 6469 6e67 3a20 7574 662d 380d  # coding: utf-8.
+00000010: 0a69 6d70 6f72 7420 6461 7465 7469 6d65  .import datetime
+00000020: 0d0a 0d0a 2320 5374 616e 6461 7264 2050  ....# Standard P
+00000030: 7974 686f 6e20 6c69 6272 6172 6965 730d  ython libraries.
+00000040: 0a66 726f 6d20 7479 7069 6e67 2069 6d70  .from typing imp
+00000050: 6f72 7420 4f70 7469 6f6e 616c 0d0a 0d0a  ort Optional....
+00000060: 2320 6874 7470 733a 2f2f 6769 7468 7562  # https://github
+00000070: 2e63 6f6d 2f75 736e 6973 7467 6f76 2f44  .com/usnistgov/D
+00000080: 6174 614d 6f64 656c 4469 6374 0d0a 6672  ataModelDict..fr
+00000090: 6f6d 2044 6174 614d 6f64 656c 4469 6374  om DataModelDict
+000000a0: 2069 6d70 6f72 7420 4461 7461 4d6f 6465   import DataMode
+000000b0: 6c44 6963 7420 6173 2044 4d0d 0a0d 0a23  lDict as DM....#
+000000c0: 2068 7474 7073 3a2f 2f67 6974 6875 622e   https://github.
+000000d0: 636f 6d2f 7573 6e69 7374 676f 762f 6174  com/usnistgov/at
+000000e0: 6f6d 6d61 6e0d 0a69 6d70 6f72 7420 6174  omman..import at
+000000f0: 6f6d 6d61 6e2e 6c61 6d6d 7073 2061 7320  omman.lammps as 
+00000100: 6c6d 700d 0a0d 0a66 726f 6d20 7961 6261  lmp....from yaba
+00000110: 6461 6261 2069 6d70 6f72 7420 6c6f 6164  daba import load
+00000120: 5f71 7565 7279 0d0a 0d0a 2320 6970 7250  _query....# iprP
+00000130: 7920 696d 706f 7274 730d 0a66 726f 6d20  y imports..from 
+00000140: 2e20 696d 706f 7274 2043 616c 6375 6c61  . import Calcula
+00000150: 7469 6f6e 5375 6273 6574 0d0a 6672 6f6d  tionSubset..from
+00000160: 202e 2e74 6f6f 6c73 2069 6d70 6f72 7420   ..tools import 
+00000170: 6469 6374 5f69 6e73 6572 740d 0a0d 0a63  dict_insert....c
+00000180: 6c61 7373 204c 616d 6d70 7343 6f6d 6d61  lass LammpsComma
+00000190: 6e64 7328 4361 6c63 756c 6174 696f 6e53  nds(CalculationS
+000001a0: 7562 7365 7429 3a0d 0a20 2020 2022 2222  ubset):..    """
+000001b0: 4861 6e64 6c65 7320 6361 6c63 756c 6174  Handles calculat
+000001c0: 696f 6e20 7465 726d 7320 666f 7220 4c41  ion terms for LA
+000001d0: 4d4d 5053 2065 7865 6375 7461 626c 6520  MMPS executable 
+000001e0: 636f 6d6d 616e 6473 2222 220d 0a0d 0a23  commands"""....#
+000001f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000200: 2323 2323 2323 2323 2323 2323 2043 6f72  ############ Cor
+00000210: 6520 7072 6f70 6572 7469 6573 2023 2323  e properties ###
+00000220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000230: 2323 2323 2323 2323 2323 2323 2323 0d0a  ##############..
+00000240: 0d0a 2020 2020 6465 6620 5f5f 696e 6974  ..    def __init
+00000250: 5f5f 2873 656c 662c 0d0a 2020 2020 2020  __(self,..      
+00000260: 2020 2020 2020 2020 2020 2070 6172 656e             paren
+00000270: 742c 0d0a 2020 2020 2020 2020 2020 2020  t,..            
+00000280: 2020 2020 2070 7265 6669 783a 2073 7472       prefix: str
+00000290: 203d 2027 272c 0d0a 2020 2020 2020 2020   = '',..        
+000002a0: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+000002b0: 6568 6561 6465 723a 204f 7074 696f 6e61  eheader: Optiona
+000002c0: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
+000002d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000002e0: 2074 656d 706c 6174 6564 6573 6372 6970   templatedescrip
+000002f0: 7469 6f6e 3a20 4f70 7469 6f6e 616c 5b73  tion: Optional[s
+00000300: 7472 5d20 3d20 4e6f 6e65 293a 0d0a 2020  tr] = None):..  
+00000310: 2020 2020 2020 2222 220d 0a20 2020 2020        """..     
+00000320: 2020 2049 6e69 7469 616c 697a 6573 2061     Initializes a
+00000330: 2063 616c 6375 6c61 7469 6f6e 2072 6563   calculation rec
+00000340: 6f72 6420 7375 6273 6574 206f 626a 6563  ord subset objec
+00000350: 742e 0d0a 0d0a 2020 2020 2020 2020 5061  t.....        Pa
+00000360: 7261 6d65 7465 7273 0d0a 2020 2020 2020  rameters..      
+00000370: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020    ----------..  
+00000380: 2020 2020 2020 7061 7265 6e74 203a 2069        parent : i
+00000390: 7072 5079 2e63 616c 6375 6c61 7469 6f6e  prPy.calculation
+000003a0: 2e43 616c 6375 6c61 7469 6f6e 0d0a 2020  .Calculation..  
+000003b0: 2020 2020 2020 2020 2020 5468 6520 7061            The pa
+000003c0: 7265 6e74 2063 616c 6375 6c61 7469 6f6e  rent calculation
+000003d0: 206f 626a 6563 7420 7468 6174 2074 6865   object that the
+000003e0: 2073 7562 7365 7420 6f62 6a65 6374 2069   subset object i
+000003f0: 7320 7061 7274 206f 662e 0d0a 2020 2020  s part of...    
+00000400: 2020 2020 2020 2020 5468 6973 2061 6c6c          This all
+00000410: 6f77 7320 666f 7220 7468 6520 7375 6273  ows for the subs
+00000420: 6574 206d 6574 686f 6473 2074 6f20 6163  et methods to ac
+00000430: 6365 7373 2070 6172 616d 6574 6572 7320  cess parameters 
+00000440: 7365 7420 746f 2074 6865 0d0a 2020 2020  set to the..    
+00000450: 2020 2020 2020 2020 6361 6c63 756c 6174          calculat
+00000460: 696f 6e20 6974 7365 6c66 206f 7220 6f74  ion itself or ot
+00000470: 6865 7220 7375 6273 6574 732e 0d0a 2020  her subsets...  
+00000480: 2020 2020 2020 7072 6566 6978 203a 2073        prefix : s
+00000490: 7472 2c20 6f70 7469 6f6e 616c 0d0a 2020  tr, optional..  
+000004a0: 2020 2020 2020 2020 2020 416e 206f 7074            An opt
+000004b0: 696f 6e61 6c20 7072 6566 6978 2074 6f20  ional prefix to 
+000004c0: 6164 6420 746f 206d 6574 6164 6174 6120  add to metadata 
+000004d0: 6669 656c 6420 6e61 6d65 7320 746f 2061  field names to a
+000004e0: 6c6c 6f77 2066 6f72 0d0a 2020 2020 2020  llow for..      
+000004f0: 2020 2020 2020 6469 6666 6572 656e 7469        differenti
+00000500: 6174 696e 6720 6265 7477 6565 6e20 6d75  ating between mu
+00000510: 6c74 6970 6c65 2073 7562 7365 7473 206f  ltiple subsets o
+00000520: 6620 7468 6520 7361 6d65 2073 7479 6c65  f the same style
+00000530: 2077 6974 6869 6e0d 0a20 2020 2020 2020   within..       
+00000540: 2020 2020 2061 2073 696e 676c 6520 7265       a single re
+00000550: 636f 7264 0d0a 2020 2020 2020 2020 7465  cord..        te
+00000560: 6d70 6c61 7465 6865 6164 6572 203a 2073  mplateheader : s
+00000570: 7472 2c20 6f70 7469 6f6e 616c 0d0a 2020  tr, optional..  
+00000580: 2020 2020 2020 2020 2020 416e 2061 6c74            An alt
+00000590: 6572 6e61 7465 2068 6561 6465 7220 746f  ernate header to
+000005a0: 2075 7365 2069 6e20 7468 6520 7465 6d70   use in the temp
+000005b0: 6c61 7465 2066 696c 6520 666f 7220 7468  late file for th
+000005c0: 6520 7375 6273 6574 2e0d 0a20 2020 2020  e subset...     
+000005d0: 2020 2074 656d 706c 6174 6564 6573 6372     templatedescr
+000005e0: 6970 7469 6f6e 203a 2073 7472 2c20 6f70  iption : str, op
+000005f0: 7469 6f6e 616c 0d0a 2020 2020 2020 2020  tional..        
+00000600: 2020 2020 416e 2061 6c74 6572 6e61 7465      An alternate
+00000610: 2064 6573 6372 6970 7469 6f6e 206f 6620   description of 
+00000620: 7468 6520 7375 6273 6574 2066 6f72 2074  the subset for t
+00000630: 6865 2074 656d 706c 6174 6564 6f63 2e0d  he templatedoc..
+00000640: 0a20 2020 2020 2020 2022 2222 0d0a 2020  .        """..  
+00000650: 2020 2020 2020 7375 7065 7228 292e 5f5f        super().__
+00000660: 696e 6974 5f5f 2870 6172 656e 742c 2070  init__(parent, p
+00000670: 7265 6669 783d 7072 6566 6978 2c20 7465  refix=prefix, te
+00000680: 6d70 6c61 7465 6865 6164 6572 3d74 656d  mplateheader=tem
+00000690: 706c 6174 6568 6561 6465 722c 0d0a 2020  plateheader,..  
+000006a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000006b0: 2020 2020 2020 2074 656d 706c 6174 6564         templated
+000006c0: 6573 6372 6970 7469 6f6e 3d74 656d 706c  escription=templ
+000006d0: 6174 6564 6573 6372 6970 7469 6f6e 290d  atedescription).
+000006e0: 0a0d 0a20 2020 2020 2020 2073 656c 662e  ...        self.
+000006f0: 5f5f 6c61 6d6d 7073 5f63 6f6d 6d61 6e64  __lammps_command
+00000700: 203d 204e 6f6e 650d 0a20 2020 2020 2020   = None..       
+00000710: 2073 656c 662e 5f5f 6d70 695f 636f 6d6d   self.__mpi_comm
+00000720: 616e 6420 3d20 4e6f 6e65 0d0a 2020 2020  and = None..    
+00000730: 2020 2020 7365 6c66 2e5f 5f6c 616d 6d70      self.__lammp
+00000740: 735f 7665 7273 696f 6e20 3d20 4e6f 6e65  s_version = None
+00000750: 0d0a 2020 2020 2020 2020 7365 6c66 2e5f  ..        self._
+00000760: 5f6c 616d 6d70 735f 6461 7465 203d 204e  _lammps_date = N
+00000770: 6f6e 650d 0a0d 0a23 2323 2323 2323 2323  one....#########
+00000780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00000790: 2323 2323 2320 436c 6173 7320 6174 7472  ##### Class attr
+000007a0: 6962 7574 6573 2023 2323 2323 2323 2323  ibutes #########
+000007b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000007c0: 2323 2323 2323 230d 0a0d 0a20 2020 2040  #######....    @
+000007d0: 7072 6f70 6572 7479 0d0a 2020 2020 6465  property..    de
+000007e0: 6620 6c61 6d6d 7073 5f63 6f6d 6d61 6e64  f lammps_command
+000007f0: 2873 656c 6629 202d 3e20 7374 723a 0d0a  (self) -> str:..
+00000800: 2020 2020 2020 2020 2222 2273 7472 3a20          """str: 
+00000810: 5468 6520 4c41 4d4d 5053 2065 7865 6375  The LAMMPS execu
+00000820: 7461 626c 6520 746f 2075 7365 2222 220d  table to use""".
+00000830: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00000840: 7365 6c66 2e5f 5f6c 616d 6d70 735f 636f  self.__lammps_co
+00000850: 6d6d 616e 640d 0a0d 0a20 2020 2040 6c61  mmand....    @la
+00000860: 6d6d 7073 5f63 6f6d 6d61 6e64 2e73 6574  mmps_command.set
+00000870: 7465 720d 0a20 2020 2064 6566 206c 616d  ter..    def lam
+00000880: 6d70 735f 636f 6d6d 616e 6428 7365 6c66  mps_command(self
+00000890: 2c20 7661 6c3a 2073 7472 293a 0d0a 2020  , val: str):..  
+000008a0: 2020 2020 2020 7365 6c66 2e5f 5f6c 616d        self.__lam
+000008b0: 6d70 735f 636f 6d6d 616e 6420 3d20 7374  mps_command = st
+000008c0: 7228 7661 6c29 0d0a 2020 2020 2020 2020  r(val)..        
+000008d0: 6966 2073 656c 662e 5f5f 6c61 6d6d 7073  if self.__lammps
+000008e0: 5f76 6572 7369 6f6e 2069 7320 6e6f 7420  _version is not 
+000008f0: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
+00000900: 2020 2073 656c 662e 5f5f 6c61 6d6d 7073     self.__lammps
+00000910: 5f76 6572 7369 6f6e 203d 204e 6f6e 650d  _version = None.
+00000920: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00000930: 662e 5f5f 6c61 6d6d 7073 5f64 6174 6520  f.__lammps_date 
+00000940: 3d20 4e6f 6e65 0d0a 0d0a 2020 2020 4070  = None....    @p
+00000950: 726f 7065 7274 790d 0a20 2020 2064 6566  roperty..    def
+00000960: 206d 7069 5f63 6f6d 6d61 6e64 2873 656c   mpi_command(sel
+00000970: 6629 202d 3e20 4f70 7469 6f6e 616c 5b73  f) -> Optional[s
+00000980: 7472 5d3a 0d0a 2020 2020 2020 2020 2222  tr]:..        ""
+00000990: 2273 7472 3a20 5468 6520 4d50 4920 6578  "str: The MPI ex
+000009a0: 6563 7574 6162 6c65 2061 6e64 206f 7074  ecutable and opt
+000009b0: 696f 6e73 2074 6f20 7573 6520 7768 656e  ions to use when
+000009c0: 2072 756e 6e69 6e67 204c 414d 4d50 5322   running LAMMPS"
+000009d0: 2222 0d0a 2020 2020 2020 2020 7265 7475  ""..        retu
+000009e0: 726e 2073 656c 662e 5f5f 6d70 695f 636f  rn self.__mpi_co
+000009f0: 6d6d 616e 640d 0a0d 0a20 2020 2040 6d70  mmand....    @mp
+00000a00: 695f 636f 6d6d 616e 642e 7365 7474 6572  i_command.setter
+00000a10: 0d0a 2020 2020 6465 6620 6d70 695f 636f  ..    def mpi_co
+00000a20: 6d6d 616e 6428 7365 6c66 2c20 7661 6c3a  mmand(self, val:
+00000a30: 204f 7074 696f 6e61 6c5b 7374 725d 293a   Optional[str]):
+00000a40: 0d0a 2020 2020 2020 2020 6966 2076 616c  ..        if val
+00000a50: 2069 7320 4e6f 6e65 3a0d 0a20 2020 2020   is None:..     
+00000a60: 2020 2020 2020 2073 656c 662e 5f5f 6d70         self.__mp
+00000a70: 695f 636f 6d6d 616e 6420 3d20 4e6f 6e65  i_command = None
+00000a80: 0d0a 2020 2020 2020 2020 656c 7365 3a0d  ..        else:.
+00000a90: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00000aa0: 662e 5f5f 6d70 695f 636f 6d6d 616e 6420  f.__mpi_command 
+00000ab0: 3d20 7374 7228 7661 6c29 0d0a 0d0a 2020  = str(val)....  
+00000ac0: 2020 4070 726f 7065 7274 790d 0a20 2020    @property..   
+00000ad0: 2064 6566 206c 616d 6d70 735f 7665 7273   def lammps_vers
+00000ae0: 696f 6e28 7365 6c66 2920 2d3e 2073 7472  ion(self) -> str
+00000af0: 3a0d 0a20 2020 2020 2020 2022 2222 7374  :..        """st
+00000b00: 723a 2054 6865 204c 414d 4d50 5320 7665  r: The LAMMPS ve
+00000b10: 7273 696f 6e20 7374 7222 2222 0d0a 2020  rsion str"""..  
+00000b20: 2020 2020 2020 6966 2073 656c 662e 5f5f        if self.__
+00000b30: 6c61 6d6d 7073 5f76 6572 7369 6f6e 2069  lammps_version i
+00000b40: 7320 4e6f 6e65 2061 6e64 2073 656c 662e  s None and self.
+00000b50: 6c61 6d6d 7073 5f63 6f6d 6d61 6e64 2069  lammps_command i
+00000b60: 7320 6e6f 7420 4e6f 6e65 3a0d 0a20 2020  s not None:..   
+00000b70: 2020 2020 2020 2020 206c 616d 6d70 735f           lammps_
+00000b80: 7665 7273 696f 6e20 3d20 6c6d 702e 6368  version = lmp.ch
+00000b90: 6563 6b76 6572 7369 6f6e 2873 656c 662e  eckversion(self.
+00000ba0: 6c61 6d6d 7073 5f63 6f6d 6d61 6e64 290d  lammps_command).
+00000bb0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00000bc0: 662e 5f5f 6c61 6d6d 7073 5f76 6572 7369  f.__lammps_versi
+00000bd0: 6f6e 203d 206c 616d 6d70 735f 7665 7273  on = lammps_vers
+00000be0: 696f 6e5b 2776 6572 7369 6f6e 275d 0d0a  ion['version']..
+00000bf0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00000c00: 2e5f 5f6c 616d 6d70 735f 6461 7465 203d  .__lammps_date =
+00000c10: 206c 616d 6d70 735f 7665 7273 696f 6e5b   lammps_version[
+00000c20: 2764 6174 6527 5d0d 0a20 2020 2020 2020  'date']..       
+00000c30: 2072 6574 7572 6e20 7365 6c66 2e5f 5f6c   return self.__l
+00000c40: 616d 6d70 735f 7665 7273 696f 6e0d 0a0d  ammps_version...
+00000c50: 0a20 2020 2040 7072 6f70 6572 7479 0d0a  .    @property..
+00000c60: 2020 2020 6465 6620 6c61 6d6d 7073 5f64      def lammps_d
+00000c70: 6174 6528 7365 6c66 2920 2d3e 2064 6174  ate(self) -> dat
+00000c80: 6574 696d 652e 6461 7465 3a0d 0a20 2020  etime.date:..   
+00000c90: 2020 2020 2022 2222 6461 7465 7469 6d65       """datetime
+00000ca0: 2e64 6174 653a 2054 6865 204c 414d 4d50  .date: The LAMMP
+00000cb0: 5320 7665 7273 696f 6e20 6461 7465 2222  S version date""
+00000cc0: 220d 0a20 2020 2020 2020 2069 6620 7365  "..        if se
+00000cd0: 6c66 2e5f 5f6c 616d 6d70 735f 7665 7273  lf.__lammps_vers
+00000ce0: 696f 6e20 6973 204e 6f6e 6520 616e 6420  ion is None and 
+00000cf0: 7365 6c66 2e6c 616d 6d70 735f 636f 6d6d  self.lammps_comm
+00000d00: 616e 6420 6973 206e 6f74 204e 6f6e 653a  and is not None:
+00000d10: 0d0a 2020 2020 2020 2020 2020 2020 6c61  ..            la
+00000d20: 6d6d 7073 5f76 6572 7369 6f6e 203d 206c  mmps_version = l
+00000d30: 6d70 2e63 6865 636b 7665 7273 696f 6e28  mp.checkversion(
+00000d40: 7365 6c66 2e6c 616d 6d70 735f 636f 6d6d  self.lammps_comm
+00000d50: 616e 6429 0d0a 2020 2020 2020 2020 2020  and)..          
+00000d60: 2020 7365 6c66 2e5f 5f6c 616d 6d70 735f    self.__lammps_
+00000d70: 7665 7273 696f 6e20 3d20 6c61 6d6d 7073  version = lammps
+00000d80: 5f76 6572 7369 6f6e 5b27 7665 7273 696f  _version['versio
+00000d90: 6e27 5d0d 0a20 2020 2020 2020 2020 2020  n']..           
+00000da0: 2073 656c 662e 5f5f 6c61 6d6d 7073 5f64   self.__lammps_d
+00000db0: 6174 6520 3d20 6c61 6d6d 7073 5f76 6572  ate = lammps_ver
+00000dc0: 7369 6f6e 5b27 6461 7465 275d 0d0a 2020  sion['date']..  
+00000dd0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00000de0: 662e 5f5f 6c61 6d6d 7073 5f64 6174 650d  f.__lammps_date.
+00000df0: 0a0d 0a20 2020 2064 6566 2073 6574 5f76  ...    def set_v
+00000e00: 616c 7565 7328 7365 6c66 2c20 2a2a 6b77  alues(self, **kw
+00000e10: 6172 6773 3a20 616e 7929 3a0d 0a20 2020  args: any):..   
+00000e20: 2020 2020 2022 2222 0d0a 2020 2020 2020       """..      
+00000e30: 2020 416c 6c6f 7773 2066 6f72 206d 756c    Allows for mul
+00000e40: 7469 706c 6520 636c 6173 7320 6174 7472  tiple class attr
+00000e50: 6962 7574 6520 7661 6c75 6573 2074 6f20  ibute values to 
+00000e60: 6265 2075 7064 6174 6564 2061 7420 6f6e  be updated at on
+00000e70: 6365 2e0d 0a0d 0a20 2020 2020 2020 2050  ce.....        P
+00000e80: 6172 616d 6574 6572 730d 0a20 2020 2020  arameters..     
+00000e90: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0d 0a20     ----------.. 
+00000ea0: 2020 2020 2020 206c 616d 6d70 735f 636f         lammps_co
+00000eb0: 6d6d 616e 643a 2073 7472 2c20 6f70 7469  mmand: str, opti
+00000ec0: 6f6e 616c 0d0a 2020 2020 2020 2020 2020  onal..          
+00000ed0: 2020 5468 6520 4c41 4d4d 5053 2065 7865    The LAMMPS exe
+00000ee0: 6375 7461 626c 6520 746f 2075 7365 0d0a  cutable to use..
+00000ef0: 2020 2020 2020 2020 6d70 695f 636f 6d6d          mpi_comm
+00000f00: 616e 643a 2073 7472 206f 7220 4e6f 6e65  and: str or None
+00000f10: 2c20 6f70 7469 6f6e 616c 0d0a 2020 2020  , optional..    
+00000f20: 2020 2020 2020 2020 5468 6520 4d50 4920          The MPI 
+00000f30: 6578 6563 7574 6162 6c65 2061 6e64 206f  executable and o
+00000f40: 7074 696f 6e73 2074 6f20 7573 6520 7768  ptions to use wh
+00000f50: 656e 2072 756e 6e69 6e67 204c 414d 4d50  en running LAMMP
+00000f60: 530d 0a20 2020 2020 2020 2022 2222 0d0a  S..        """..
+00000f70: 2020 2020 2020 2020 6966 2027 6c61 6d6d          if 'lamm
+00000f80: 7073 5f63 6f6d 6d61 6e64 2720 696e 206b  ps_command' in k
+00000f90: 7761 7267 733a 0d0a 2020 2020 2020 2020  wargs:..        
+00000fa0: 2020 2020 7365 6c66 2e6c 616d 6d70 735f      self.lammps_
+00000fb0: 636f 6d6d 616e 6420 3d20 6b77 6172 6773  command = kwargs
+00000fc0: 5b27 6c61 6d6d 7073 5f63 6f6d 6d61 6e64  ['lammps_command
+00000fd0: 275d 0d0a 2020 2020 2020 2020 6966 2027  ']..        if '
+00000fe0: 6d70 695f 636f 6d6d 616e 6427 2069 6e20  mpi_command' in 
+00000ff0: 6b77 6172 6773 3a0d 0a20 2020 2020 2020  kwargs:..       
+00001000: 2020 2020 2073 656c 662e 6d70 695f 636f       self.mpi_co
+00001010: 6d6d 616e 6420 3d20 6b77 6172 6773 5b27  mmand = kwargs['
+00001020: 6d70 695f 636f 6d6d 616e 6427 5d0d 0a0d  mpi_command']...
+00001030: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+00001040: 2323 2323 2323 2323 2050 6172 616d 6574  ######## Paramet
+00001050: 6572 2066 696c 6520 696e 7465 7261 6374  er file interact
+00001060: 696f 6e73 2023 2323 2323 2323 2323 2323  ions ###########
+00001070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001080: 0d0a 0d0a 2020 2020 6465 6620 5f74 656d  ....    def _tem
+00001090: 706c 6174 655f 696e 6974 2873 656c 662c  plate_init(self,
+000010a0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
+000010b0: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+000010c0: 6568 6561 6465 723a 204f 7074 696f 6e61  eheader: Optiona
+000010d0: 6c5b 7374 725d 203d 204e 6f6e 652c 0d0a  l[str] = None,..
+000010e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000010f0: 2020 2020 2020 2074 656d 706c 6174 6564         templated
+00001100: 6573 6372 6970 7469 6f6e 3a20 4f70 7469  escription: Opti
+00001110: 6f6e 616c 5b73 7472 5d20 3d20 4e6f 6e65  onal[str] = None
+00001120: 293a 0d0a 2020 2020 2020 2020 2222 220d  ):..        """.
+00001130: 0a20 2020 2020 2020 2053 6574 7320 7468  .        Sets th
+00001140: 6520 7465 6d70 6c61 7465 2068 6561 6465  e template heade
+00001150: 7220 616e 6420 6465 7363 7269 7074 696f  r and descriptio
+00001160: 6e20 7661 6c75 6573 2e0d 0a0d 0a20 2020  n values.....   
+00001170: 2020 2020 2050 6172 616d 6574 6572 730d       Parameters.
+00001180: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+00001190: 2d2d 2d0d 0a20 2020 2020 2020 2074 656d  ---..        tem
+000011a0: 706c 6174 6568 6561 6465 7220 3a20 7374  plateheader : st
+000011b0: 722c 206f 7074 696f 6e61 6c0d 0a20 2020  r, optional..   
+000011c0: 2020 2020 2020 2020 2041 6e20 616c 7465           An alte
+000011d0: 726e 6174 6520 6865 6164 6572 2074 6f20  rnate header to 
+000011e0: 7573 6520 696e 2074 6865 2074 656d 706c  use in the templ
+000011f0: 6174 6520 6669 6c65 2066 6f72 2074 6865  ate file for the
+00001200: 2073 7562 7365 742e 0d0a 2020 2020 2020   subset...      
+00001210: 2020 7465 6d70 6c61 7465 6465 7363 7269    templatedescri
+00001220: 7074 696f 6e20 3a20 7374 722c 206f 7074  ption : str, opt
+00001230: 696f 6e61 6c0d 0a20 2020 2020 2020 2020  ional..         
+00001240: 2020 2041 6e20 616c 7465 726e 6174 6520     An alternate 
+00001250: 6465 7363 7269 7074 696f 6e20 6f66 2074  description of t
+00001260: 6865 2073 7562 7365 7420 666f 7220 7468  he subset for th
+00001270: 6520 7465 6d70 6c61 7465 646f 632e 0d0a  e templatedoc...
+00001280: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
+00001290: 2020 2020 2023 2053 6574 2064 6566 6175       # Set defau
+000012a0: 6c74 2074 656d 706c 6174 6520 6865 6164  lt template head
+000012b0: 6572 0d0a 2020 2020 2020 2020 6966 2074  er..        if t
+000012c0: 656d 706c 6174 6568 6561 6465 7220 6973  emplateheader is
+000012d0: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
+000012e0: 2020 2020 7465 6d70 6c61 7465 6865 6164      templatehead
+000012f0: 6572 203d 2027 4c41 4d4d 5053 2061 6e64  er = 'LAMMPS and
+00001300: 204d 5049 2043 6f6d 6d61 6e64 7327 0d0a   MPI Commands'..
+00001310: 0d0a 2020 2020 2020 2020 2320 5365 7420  ..        # Set 
+00001320: 6465 6661 756c 7420 7465 6d70 6c61 7465  default template
+00001330: 2064 6573 6372 6970 7469 6f6e 0d0a 2020   description..  
+00001340: 2020 2020 2020 6966 2074 656d 706c 6174        if templat
+00001350: 6564 6573 6372 6970 7469 6f6e 2069 7320  edescription is 
+00001360: 4e6f 6e65 3a0d 0a20 2020 2020 2020 2020  None:..         
+00001370: 2020 2074 656d 706c 6174 6564 6573 6372     templatedescr
+00001380: 6970 7469 6f6e 203d 2027 2027 2e6a 6f69  iption = ' '.joi
+00001390: 6e28 5b0d 0a20 2020 2020 2020 2020 2020  n([..           
+000013a0: 2020 2020 2022 5370 6563 6966 6965 7320       "Specifies 
+000013b0: 7468 6520 6578 7465 726e 616c 2063 6f6d  the external com
+000013c0: 6d61 6e64 7320 666f 7220 7275 6e6e 696e  mands for runnin
+000013d0: 6720 4c41 4d4d 5053 2061 6e64 204d 5049  g LAMMPS and MPI
+000013e0: 2e22 5d29 0d0a 0d0a 2020 2020 2020 2020  ."])....        
+000013f0: 7375 7065 7228 292e 5f74 656d 706c 6174  super()._templat
+00001400: 655f 696e 6974 2874 656d 706c 6174 6568  e_init(templateh
+00001410: 6561 6465 722c 2074 656d 706c 6174 6564  eader, templated
+00001420: 6573 6372 6970 7469 6f6e 290d 0a0d 0a20  escription).... 
+00001430: 2020 2040 7072 6f70 6572 7479 0d0a 2020     @property..  
+00001440: 2020 6465 6620 7465 6d70 6c61 7465 6b65    def templateke
+00001450: 7973 2873 656c 6629 202d 3e20 6469 6374  ys(self) -> dict
+00001460: 3a0d 0a20 2020 2020 2020 2022 2222 6469  :..        """di
+00001470: 6374 203a 2054 6865 2073 7562 7365 742d  ct : The subset-
+00001480: 7370 6563 6966 6963 2069 6e70 7574 206b  specific input k
+00001490: 6579 7320 616e 6420 7468 6569 7220 6465  eys and their de
+000014a0: 7363 7269 7074 696f 6e73 2e22 2222 0d0a  scriptions."""..
+000014b0: 2020 2020 2020 2020 7265 7475 726e 2020          return  
+000014c0: 7b0d 0a20 2020 2020 2020 2020 2020 2027  {..            '
+000014d0: 6c61 6d6d 7073 5f63 6f6d 6d61 6e64 273a  lammps_command':
+000014e0: 2027 2027 2e6a 6f69 6e28 5b0d 0a20 2020   ' '.join([..   
+000014f0: 2020 2020 2020 2020 2020 2020 2022 5468               "Th
+00001500: 6520 7061 7468 2074 6f20 7468 6520 6578  e path to the ex
+00001510: 6563 7574 6162 6c65 2066 6f72 2072 756e  ecutable for run
+00001520: 6e69 6e67 204c 414d 4d50 5320 6f6e 2079  ning LAMMPS on y
+00001530: 6f75 7220 7379 7374 656d 2e22 2c0d 0a20  our system.",.. 
+00001540: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00001550: 446f 6e27 7420 696e 636c 7564 6520 636f  Don't include co
+00001560: 6d6d 616e 6420 6c69 6e65 206f 7074 696f  mmand line optio
+00001570: 6e73 2e22 5d29 2c0d 0a20 2020 2020 2020  ns."]),..       
+00001580: 2020 2020 2027 6d70 695f 636f 6d6d 616e       'mpi_comman
+00001590: 6427 3a20 2720 272e 6a6f 696e 285b 0d0a  d': ' '.join([..
+000015a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000015b0: 2254 6865 2070 6174 6820 746f 2074 6865  "The path to the
+000015c0: 204d 5049 2065 7865 6375 7461 626c 6520   MPI executable 
+000015d0: 616e 6420 616e 7920 636f 6d6d 616e 6420  and any command 
+000015e0: 6c69 6e65 206f 7074 696f 6e73 2074 6f22  line options to"
+000015f0: 2c0d 0a20 2020 2020 2020 2020 2020 2020  ,..             
+00001600: 2020 2022 7573 6520 666f 7220 6361 6c6c     "use for call
+00001610: 696e 6720 4c41 4d4d 5053 2074 6f20 7275  ing LAMMPS to ru
+00001620: 6e20 696e 2070 6172 616c 6c65 6c20 6f6e  n in parallel on
+00001630: 2079 6f75 7220 7379 7374 656d 2e20 4c41   your system. LA
+00001640: 4d4d 5053 222c 0d0a 2020 2020 2020 2020  MMPS",..        
+00001650: 2020 2020 2020 2020 2277 696c 6c20 7275          "will ru
+00001660: 6e20 6173 2061 2073 6572 6961 6c20 7072  n as a serial pr
+00001670: 6f63 6573 7320 6966 206e 6f74 2067 6976  ocess if not giv
+00001680: 656e 2e22 5d29 2c0d 0a20 2020 2020 2020  en."]),..       
+00001690: 207d 0d0a 0d0a 2020 2020 4070 726f 7065   }....    @prope
+000016a0: 7274 790d 0a20 2020 2064 6566 2070 7265  rty..    def pre
+000016b0: 7061 7265 6b65 7973 2873 656c 6629 202d  parekeys(self) -
+000016c0: 3e20 6c69 7374 3a0d 0a20 2020 2020 2020  > list:..       
+000016d0: 2022 2222 0d0a 2020 2020 2020 2020 6c69   """..        li
+000016e0: 7374 203a 2054 6865 2069 6e70 7574 206b  st : The input k
+000016f0: 6579 7320 2877 6974 686f 7574 2070 7265  eys (without pre
+00001700: 6669 7829 2075 7365 6420 7768 656e 2070  fix) used when p
+00001710: 7265 7061 7269 6e67 2061 2063 616c 6375  reparing a calcu
+00001720: 6c61 7469 6f6e 2e0d 0a20 2020 2020 2020  lation...       
+00001730: 2054 7970 6963 616c 6c79 2c20 7468 6973   Typically, this
+00001740: 2069 7320 7465 6d70 6c61 7465 6b65 7973   is templatekeys
+00001750: 2070 6c75 7320 2a5f 636f 6e74 656e 7420   plus *_content 
+00001760: 6b65 7973 2073 6f20 7072 6570 6172 6520  keys so prepare 
+00001770: 6361 6e20 6163 6365 7373 0d0a 2020 2020  can access..    
+00001780: 2020 2020 636f 6e74 656e 7420 6265 666f      content befo
+00001790: 7265 2069 7420 6578 6973 7473 2069 6e20  re it exists in 
+000017a0: 7468 6520 6361 6c63 2066 6f6c 6465 7273  the calc folders
+000017b0: 2062 6569 6e67 2070 7265 7061 7265 642e   being prepared.
+000017c0: 0d0a 2020 2020 2020 2020 2222 220d 0a20  ..        """.. 
+000017d0: 2020 2020 2020 2072 6574 7572 6e20 6c69         return li
+000017e0: 7374 2873 656c 662e 7465 6d70 6c61 7465  st(self.template
+000017f0: 6b65 7973 2e6b 6579 7328 2929 202b 205b  keys.keys()) + [
+00001800: 5d0d 0a0d 0a20 2020 2040 7072 6f70 6572  ]....    @proper
+00001810: 7479 0d0a 2020 2020 6465 6620 696e 7465  ty..    def inte
+00001820: 7270 7265 746b 6579 7328 7365 6c66 2920  rpretkeys(self) 
+00001830: 2d3e 206c 6973 743a 0d0a 2020 2020 2020  -> list:..      
+00001840: 2020 2222 220d 0a20 2020 2020 2020 206c    """..        l
+00001850: 6973 7420 3a20 5468 6520 696e 7075 7420  ist : The input 
+00001860: 6b65 7973 2028 7769 7468 6f75 7420 7072  keys (without pr
+00001870: 6566 6978 2920 6163 6365 7373 6564 2077  efix) accessed w
+00001880: 6865 6e20 696e 7465 7270 7265 7469 6e67  hen interpreting
+00001890: 2074 6865 200d 0a20 2020 2020 2020 2063   the ..        c
+000018a0: 616c 6375 6c61 7469 6f6e 2069 6e70 7574  alculation input
+000018b0: 2066 696c 652e 2020 5479 7069 6361 6c6c   file.  Typicall
+000018c0: 792c 2074 6869 7320 6973 2070 7265 7061  y, this is prepa
+000018d0: 7265 6b65 7973 2070 6c75 7320 616e 7920  rekeys plus any 
+000018e0: 6578 7472 610d 0a20 2020 2020 2020 206b  extra..        k
+000018f0: 6579 7320 7573 6564 206f 7220 6765 6e65  eys used or gene
+00001900: 7261 7465 6420 7768 656e 2070 726f 6365  rated when proce
+00001910: 7373 696e 6720 7468 6520 696e 7075 7473  ssing the inputs
+00001920: 2e0d 0a20 2020 2020 2020 2022 2222 0d0a  ...        """..
+00001930: 2020 2020 2020 2020 7265 7475 726e 2020          return  
+00001940: 7365 6c66 2e70 7265 7061 7265 6b65 7973  self.preparekeys
+00001950: 202b 205b 0d0a 2020 2020 2020 2020 2020   + [..          
+00001960: 2020 2020 2020 2020 2020 276c 616d 6d70            'lammp
+00001970: 735f 7665 7273 696f 6e27 2c0d 0a20 2020  s_version',..   
+00001980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001990: 2027 6c61 6d6d 7073 5f64 6174 6527 0d0a   'lammps_date'..
+000019a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000019b0: 5d0d 0a0d 0a20 2020 2064 6566 206c 6f61  ]....    def loa
+000019c0: 645f 7061 7261 6d65 7465 7273 2873 656c  d_parameters(sel
+000019d0: 662c 2069 6e70 7574 5f64 6963 743a 2064  f, input_dict: d
+000019e0: 6963 7429 3a0d 0a20 2020 2020 2020 2022  ict):..        "
+000019f0: 2222 0d0a 2020 2020 2020 2020 496e 7465  ""..        Inte
+00001a00: 7270 7265 7473 2063 616c 6375 6c61 7469  rprets calculati
+00001a10: 6f6e 2070 6172 616d 6574 6572 732e 0d0a  on parameters...
+00001a20: 2020 2020 2020 2020 0d0a 2020 2020 2020          ..      
+00001a30: 2020 5061 7261 6d65 7465 7273 0d0a 2020    Parameters..  
+00001a40: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
+00001a50: 0d0a 2020 2020 2020 2020 696e 7075 745f  ..        input_
+00001a60: 6469 6374 203a 2064 6963 740d 0a20 2020  dict : dict..   
+00001a70: 2020 2020 2020 2020 2044 6963 7469 6f6e           Diction
+00001a80: 6172 7920 636f 6e74 6169 6e69 6e67 2069  ary containing i
+00001a90: 6e70 7574 2070 6172 616d 6574 6572 206b  nput parameter k
+00001aa0: 6579 2d76 616c 7565 2070 6169 7273 2e0d  ey-value pairs..
+00001ab0: 0a20 2020 2020 2020 2022 2222 0d0a 0d0a  .        """....
+00001ac0: 2020 2020 2020 2020 2320 5365 7420 6465          # Set de
+00001ad0: 6661 756c 7420 6b65 796e 616d 6573 0d0a  fault keynames..
+00001ae0: 2020 2020 2020 2020 6b65 796d 6170 203d          keymap =
+00001af0: 2073 656c 662e 6b65 796d 6170 0d0a 0d0a   self.keymap....
+00001b00: 2020 2020 2020 2020 2320 4578 7472 6163          # Extrac
+00001b10: 7420 696e 7075 7420 7661 6c75 6573 2061  t input values a
+00001b20: 6e64 2061 7373 6967 6e20 6465 6661 756c  nd assign defaul
+00001b30: 7420 7661 6c75 6573 0d0a 2020 2020 2020  t values..      
+00001b40: 2020 7365 6c66 2e6c 616d 6d70 735f 636f    self.lammps_co
+00001b50: 6d6d 616e 6420 3d20 696e 7075 745f 6469  mmand = input_di
+00001b60: 6374 5b6b 6579 6d61 705b 276c 616d 6d70  ct[keymap['lammp
+00001b70: 735f 636f 6d6d 616e 6427 5d5d 0d0a 2020  s_command']]..  
+00001b80: 2020 2020 2020 7365 6c66 2e6d 7069 5f63        self.mpi_c
+00001b90: 6f6d 6d61 6e64 203d 2069 6e70 7574 5f64  ommand = input_d
+00001ba0: 6963 742e 6765 7428 6b65 796d 6170 5b27  ict.get(keymap['
+00001bb0: 6d70 695f 636f 6d6d 616e 6427 5d2c 204e  mpi_command'], N
+00001bc0: 6f6e 6529 0d0a 0d0a 2323 2323 2323 2323  one)....########
+00001bd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001be0: 2323 2320 4461 7461 206d 6f64 656c 2069  ### Data model i
+00001bf0: 6e74 6572 6163 7469 6f6e 7320 2323 2323  nteractions ####
+00001c00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00001c10: 2323 2323 2323 230d 0a0d 0a20 2020 2040  #######....    @
+00001c20: 7072 6f70 6572 7479 0d0a 2020 2020 6465  property..    de
+00001c30: 6620 6d6f 6465 6c72 6f6f 7428 7365 6c66  f modelroot(self
+00001c40: 2920 2d3e 2073 7472 3a0d 0a20 2020 2020  ) -> str:..     
+00001c50: 2020 2022 2222 7374 7220 3a20 5468 6520     """str : The 
+00001c60: 726f 6f74 2065 6c65 6d65 6e74 206e 616d  root element nam
+00001c70: 6520 666f 7220 7468 6520 7375 6273 6574  e for the subset
+00001c80: 2074 6572 6d73 2e22 2222 0d0a 2020 2020   terms."""..    
+00001c90: 2020 2020 6261 7365 726f 6f74 203d 2027      baseroot = '
+00001ca0: 4c41 4d4d 5053 2d76 6572 7369 6f6e 270d  LAMMPS-version'.
+00001cb0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00001cc0: 6627 7b73 656c 662e 6d6f 6465 6c70 7265  f'{self.modelpre
+00001cd0: 6669 787d 7b62 6173 6572 6f6f 747d 270d  fix}{baseroot}'.
+00001ce0: 0a0d 0a20 2020 2064 6566 206c 6f61 645f  ...    def load_
+00001cf0: 6d6f 6465 6c28 7365 6c66 2c20 6d6f 6465  model(self, mode
+00001d00: 6c3a 2044 4d29 3a0d 0a20 2020 2020 2020  l: DM):..       
+00001d10: 2022 2222 4c6f 6164 7320 7375 6273 6574   """Loads subset
+00001d20: 2061 7474 7269 6275 7465 7320 6672 6f6d   attributes from
+00001d30: 2061 6e20 6578 6973 7469 6e67 206d 6f64   an existing mod
+00001d40: 656c 2e22 2222 0d0a 2020 2020 2020 2020  el."""..        
+00001d50: 7365 6c66 2e5f 5f6c 616d 6d70 735f 7665  self.__lammps_ve
+00001d60: 7273 696f 6e20 3d20 6d6f 6465 6c5b 2763  rsion = model['c
+00001d70: 616c 6375 6c61 7469 6f6e 275d 5b73 656c  alculation'][sel
+00001d80: 662e 6d6f 6465 6c72 6f6f 745d 0d0a 0d0a  f.modelroot]....
+00001d90: 2020 2020 6465 6620 6275 696c 645f 6d6f      def build_mo
+00001da0: 6465 6c28 7365 6c66 2c0d 0a20 2020 2020  del(self,..     
+00001db0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00001dc0: 6f64 656c 3a20 444d 2c0d 0a20 2020 2020  odel: DM,..     
+00001dd0: 2020 2020 2020 2020 2020 2020 2020 202a                 *
+00001de0: 2a6b 7761 7267 733a 2061 6e79 293a 0d0a  *kwargs: any):..
+00001df0: 2020 2020 2020 2020 2222 220d 0a20 2020          """..   
+00001e00: 2020 2020 2041 6464 7320 7468 6520 7375       Adds the su
+00001e10: 6273 6574 206d 6f64 656c 2074 6f20 7468  bset model to th
+00001e20: 6520 7061 7265 6e74 206d 6f64 656c 2e0d  e parent model..
+00001e30: 0a20 2020 2020 2020 200d 0a20 2020 2020  .        ..     
+00001e40: 2020 2050 6172 616d 6574 6572 730d 0a20     Parameters.. 
+00001e50: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
+00001e60: 2d0d 0a20 2020 2020 2020 206d 6f64 656c  -..        model
+00001e70: 203a 2044 6174 614d 6f64 656c 4469 6374   : DataModelDict
+00001e80: 2e44 6174 614d 6f64 656c 4469 6374 0d0a  .DataModelDict..
+00001e90: 2020 2020 2020 2020 2020 2020 5468 6520              The 
+00001ea0: 7265 636f 7264 2063 6f6e 7465 6e74 2028  record content (
+00001eb0: 6166 7465 7220 726f 6f74 2065 6c65 6d65  after root eleme
+00001ec0: 6e74 2920 746f 2061 6464 2063 6f6e 7465  nt) to add conte
+00001ed0: 6e74 2074 6f2e 0d0a 2020 2020 2020 2020  nt to...        
+00001ee0: 6b77 6172 6773 203a 2061 6e79 0d0a 2020  kwargs : any..  
+00001ef0: 2020 2020 2020 2020 2020 416e 7920 6f70            Any op
+00001f00: 7469 6f6e 7320 746f 2070 6173 7320 6f6e  tions to pass on
+00001f10: 2074 6f20 6469 6374 5f69 6e73 6572 7420   to dict_insert 
+00001f20: 7468 6174 2073 7065 6369 6679 2077 6865  that specify whe
+00001f30: 7265 2074 6865 2073 7562 7365 740d 0a20  re the subset.. 
+00001f40: 2020 2020 2020 2020 2020 2063 6f6e 7465             conte
+00001f50: 6e74 2067 6574 7320 6164 6465 6420 746f  nt gets added to
+00001f60: 2069 6e20 7468 6520 7061 7265 6e74 206d   in the parent m
+00001f70: 6f64 656c 2e0d 0a20 2020 2020 2020 2022  odel...        "
+00001f80: 2222 0d0a 2020 2020 2020 2020 6469 6374  ""..        dict
+00001f90: 5f69 6e73 6572 7428 6d6f 6465 6c5b 2763  _insert(model['c
+00001fa0: 616c 6375 6c61 7469 6f6e 275d 2c20 7365  alculation'], se
+00001fb0: 6c66 2e6d 6f64 656c 726f 6f74 2c20 7365  lf.modelroot, se
+00001fc0: 6c66 2e6c 616d 6d70 735f 7665 7273 696f  lf.lammps_versio
+00001fd0: 6e2c 0d0a 2020 2020 2020 2020 2020 2020  n,..            
+00001fe0: 2020 2020 2020 2020 2a2a 6b77 6172 6773          **kwargs
+00001ff0: 290d 0a0d 0a20 2020 2040 7072 6f70 6572  )....    @proper
+00002000: 7479 0d0a 2020 2020 6465 6620 7175 6572  ty..    def quer
+00002010: 6965 7328 7365 6c66 2920 2d3e 2064 6963  ies(self) -> dic
+00002020: 743a 0d0a 2020 2020 2020 2020 2222 2264  t:..        """d
+00002030: 6963 743a 2051 7565 7279 206f 626a 6563  ict: Query objec
+00002040: 7473 2061 6e64 2074 6865 6972 2061 7373  ts and their ass
+00002050: 6f63 6961 7465 6420 7061 7261 6d65 7465  ociated paramete
+00002060: 7220 6e61 6d65 732e 2222 220d 0a20 2020  r names."""..   
+00002070: 2020 2020 2072 6574 7572 6e20 7b0d 0a20       return {.. 
+00002080: 2020 2020 2020 2020 2020 2027 6c61 6d6d             'lamm
+00002090: 7073 5f76 6572 7369 6f6e 273a 206c 6f61  ps_version': loa
+000020a0: 645f 7175 6572 7928 0d0a 2020 2020 2020  d_query(..      
+000020b0: 2020 2020 2020 2020 2020 7374 796c 653d            style=
+000020c0: 2773 7472 5f6d 6174 6368 272c 0d0a 2020  'str_match',..  
+000020d0: 2020 2020 2020 2020 2020 2020 2020 6e61                na
+000020e0: 6d65 3d66 277b 7365 6c66 2e70 7265 6669  me=f'{self.prefi
+000020f0: 787d 6c61 6d6d 7073 5f76 6572 7369 6f6e  x}lammps_version
+00002100: 272c 200d 0a20 2020 2020 2020 2020 2020  ', ..           
+00002110: 2020 2020 2070 6174 683d 6627 7b73 656c       path=f'{sel
+00002120: 662e 7061 7265 6e74 2e6d 6f64 656c 726f  f.parent.modelro
+00002130: 6f74 7d2e 6361 6c63 756c 6174 696f 6e2e  ot}.calculation.
+00002140: 7b73 656c 662e 6d6f 6465 6c72 6f6f 747d  {self.modelroot}
+00002150: 272c 0d0a 2020 2020 2020 2020 2020 2020  ',..            
+00002160: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
+00002170: 2773 6561 7263 6820 6279 204c 414d 4d50  'search by LAMMP
+00002180: 5320 7665 7273 696f 6e27 292c 0d0a 2020  S version'),..  
+00002190: 2020 2020 2020 7d0d 0a0d 0a23 2323 2323        }....#####
+000021a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000021b0: 2323 2323 2320 4d65 7461 6461 7461 2069  ##### Metadata i
+000021c0: 6e74 6572 6163 7469 6f6e 7320 2323 2323  nteractions ####
+000021d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000021e0: 2323 2323 2323 2323 2323 0d0a 0d0a 2020  ##########....  
+000021f0: 2020 6465 6620 6d65 7461 6461 7461 2873    def metadata(s
+00002200: 656c 662c 206d 6574 613a 2064 6963 7429  elf, meta: dict)
+00002210: 3a0d 0a20 2020 2020 2020 2022 2222 0d0a  :..        """..
+00002220: 2020 2020 2020 2020 436f 6e76 6572 7473          Converts
+00002230: 2074 6865 2073 7472 7563 7475 7265 6420   the structured 
+00002240: 636f 6e74 656e 7420 746f 2061 2073 696d  content to a sim
+00002250: 706c 6572 2064 6963 7469 6f6e 6172 792e  pler dictionary.
+00002260: 0d0a 0d0a 2020 2020 2020 2020 5061 7261  ....        Para
+00002270: 6d65 7465 7273 0d0a 2020 2020 2020 2020  meters..        
+00002280: 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a 2020 2020  ----------..    
+00002290: 2020 2020 6d65 7461 203a 2064 6963 740d      meta : dict.
+000022a0: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+000022b0: 2064 6963 7469 6f6e 6172 7920 746f 2061   dictionary to a
+000022c0: 6464 2074 6865 2069 6e74 6572 7072 6574  dd the interpret
+000022d0: 6564 2063 6f6e 7465 6e74 2074 6f0d 0a20  ed content to.. 
+000022e0: 2020 2020 2020 2022 2222 0d0a 2020 2020         """..    
+000022f0: 2020 2020 6d65 7461 5b66 277b 7365 6c66      meta[f'{self
+00002300: 2e70 7265 6669 787d 6c61 6d6d 7073 5f76  .prefix}lammps_v
+00002310: 6572 7369 6f6e 275d 203d 2073 656c 662e  ersion'] = self.
+00002320: 6c61 6d6d 7073 5f76 6572 7369 6f6e 0d0a  lammps_version..
+00002330: 0d0a 2323 2323 2323 2323 2323 2323 2323  ..##############
+00002340: 2323 2323 2323 2323 2323 2323 2320 4361  ############# Ca
+00002350: 6c63 756c 6174 696f 6e20 696e 7465 7261  lculation intera
+00002360: 6374 696f 6e73 2023 2323 2323 2323 2323  ctions #########
+00002370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00002380: 230d 0a0d 0a20 2020 2064 6566 2063 616c  #....    def cal
+00002390: 635f 696e 7075 7473 2873 656c 662c 2069  c_inputs(self, i
+000023a0: 6e70 7574 5f64 6963 743a 2064 6963 7429  nput_dict: dict)
+000023b0: 3a0d 0a20 2020 2020 2020 2022 2222 0d0a  :..        """..
+000023c0: 2020 2020 2020 2020 4765 6e65 7261 7465          Generate
+000023d0: 7320 6361 6c63 756c 6174 696f 6e20 6675  s calculation fu
+000023e0: 6e63 7469 6f6e 2069 6e70 7574 2070 6172  nction input par
+000023f0: 616d 6574 6572 7320 6261 7365 6420 6f6e  ameters based on
+00002400: 2074 6865 2076 616c 7565 730d 0a20 2020   the values..   
+00002410: 2020 2020 2061 7373 6967 6e65 6420 746f       assigned to
+00002420: 2061 7474 7269 6275 7465 7320 6f66 2074   attributes of t
+00002430: 6865 2073 7562 7365 742e 0d0a 0d0a 2020  he subset.....  
+00002440: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
+00002450: 0d0a 2020 2020 2020 2020 2d2d 2d2d 2d2d  ..        ------
+00002460: 2d2d 2d2d 0d0a 2020 2020 2020 2020 696e  ----..        in
+00002470: 7075 745f 6469 6374 203a 2064 6963 740d  put_dict : dict.
+00002480: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+00002490: 2064 6963 7469 6f6e 6172 7920 6f66 2069   dictionary of i
+000024a0: 6e70 7574 2070 6172 616d 6574 6572 7320  nput parameters 
+000024b0: 746f 2061 6464 2073 7562 7365 7420 7465  to add subset te
+000024c0: 726d 7320 746f 2e0d 0a20 2020 2020 2020  rms to...       
+000024d0: 2022 2222 0d0a 2020 2020 2020 2020 6966   """..        if
+000024e0: 2073 656c 662e 6c61 6d6d 7073 5f63 6f6d   self.lammps_com
+000024f0: 6d61 6e64 2069 7320 4e6f 6e65 3a0d 0a20  mand is None:.. 
+00002500: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00002510: 2056 616c 7565 4572 726f 7228 276c 616d   ValueError('lam
+00002520: 6d70 735f 636f 6d6d 616e 6420 6e6f 7420  mps_command not 
+00002530: 7365 7421 2729 0d0a 0d0a 2020 2020 2020  set!')....      
+00002540: 2020 696e 7075 745f 6469 6374 5b27 6c61    input_dict['la
+00002550: 6d6d 7073 5f63 6f6d 6d61 6e64 275d 203d  mmps_command'] =
+00002560: 2073 656c 662e 6c61 6d6d 7073 5f63 6f6d   self.lammps_com
+00002570: 6d61 6e64 0d0a 2020 2020 2020 2020 696e  mand..        in
+00002580: 7075 745f 6469 6374 5b27 6d70 695f 636f  put_dict['mpi_co
+00002590: 6d6d 616e 6427 5d20 3d20 7365 6c66 2e6d  mmand'] = self.m
+000025a0: 7069 5f63 6f6d 6d61 6e64 0d0a            pi_command..
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/LammpsMinimize.py` & `iprPy-0.11.5/iprPy/calculation_subset/LammpsMinimize.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,26 +1,32 @@
+# coding: utf-8
+
+# Standard Python libraries
+from typing import Optional, Union
+
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
-
 # https://github.com/usnistgov/atomman
-import atomman as am
 import atomman.unitconvert as uc
 
+# Local imports
 from . import CalculationSubset
 from ..input import value
 
 class LammpsMinimize(CalculationSubset):
     """Handles calculation terms for performing a LAMMPS energy/force minimization"""
-    
+
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -43,64 +49,69 @@
         self.maxiterations = 100000
         self.maxevaluations = 1000000
         self.maxatommotion = uc.set_in_units(0.01, 'angstrom') 
 
 ############################## Class attributes ################################
 
     @property
-    def energytolerance(self):
+    def energytolerance(self) -> float:
+        """float: The energy tolerance to use for minimization"""
         return self.__energytolerance
 
     @energytolerance.setter
-    def energytolerance(self, value):
-        self.__energytolerance = float(value)
+    def energytolerance(self, val: float):
+        self.__energytolerance = float(val)
 
     @property
-    def forcetolerance(self):
+    def forcetolerance(self) -> float:
+        """float: The force tolerance to use for minimization"""
         return self.__forcetolerance
 
     @forcetolerance.setter
-    def forcetolerance(self, value):
-        if isinstance(value, str):
-            self.__forcetolerance = uc.set_literal(value)
+    def forcetolerance(self, val: Union[str, float]):
+        if isinstance(val, str):
+            self.__forcetolerance = uc.set_literal(val)
         else:
-            self.__forcetolerance = float(value)
+            self.__forcetolerance = float(val)
 
     @property
-    def maxiterations(self):
+    def maxiterations(self) -> int:
+        """int: Max number of minimization iterations"""
         return self.__maxiterations
 
     @maxiterations.setter
-    def maxiterations(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__maxiterations = value
-    
+    def maxiterations(self, val: int):
+        val = int(val)
+        assert val >= 0, 'maxiterations must be >= 0'
+        self.__maxiterations = val
+
     @property
-    def maxevaluations(self):
+    def maxevaluations(self) -> int:
+        """int: Max number of minimization evaluations"""
         return self.__maxevaluations
 
     @maxevaluations.setter
-    def maxevaluations(self, value):
-        value = int(value)
-        assert value >= 0
-        self.__maxevaluations = value
+    def maxevaluations(self, val: int):
+        val = int(val)
+        assert val >= 0, 'maxevaluations must be >= 0'
+        self.__maxevaluations = val
 
     @property
-    def maxatommotion(self):
+    def maxatommotion(self) -> float:
+        """float: The max distance for atomic relaxations each iteration"""
         return self.__maxatommotion
 
     @maxatommotion.setter
-    def maxatommotion(self, value):
-        if isinstance(value, str):
-            self.__maxatommotion = uc.set_literal(value)
+    def maxatommotion(self, val: Union[str, float]):
+        if isinstance(val, str):
+            self.__maxatommotion = uc.set_literal(val)
         else:
-            self.__maxatommotion = float(value)
+            self.__maxatommotion = float(val)
 
-    def set_values(self, **kwargs):
+    def set_values(self, **kwargs: any):
         """
         Allows for multiple class attribute values to be updated at once.
 
         Parameters
         ----------
         energytolerance : float, optional
             The energy tolerance to set for the minimization.
@@ -124,15 +135,17 @@
         if 'maxevaluations' in kwargs:
             self.maxevaluations = kwargs['maxevaluations']
         if 'maxatommotion' in kwargs:
             self.maxatommotion = kwargs['maxatommotion']
 
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -144,21 +157,20 @@
             templateheader = 'LAMMPS Energy/Force Minimization'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = ' '.join([
                 "Specifies the parameters and options associated with performing",
                 "an energy and/or force minimization in LAMMPS."])
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return  {
             'energytolerance': ' '.join([
                 "The energy tolerance to use for the minimization. This value is",
                 "unitless and corresponds to the etol term for the LAMMPS",
                 "minimize command. Default value is 0.0."]),
             'forcetolerance': ' '.join([
                 "The force tolerance to use for the minimization. This value is",
@@ -174,77 +186,79 @@
                 "minimize command. Default value is 1000000."]),
             'maxatommotion': ' '.join([
                 "The maximum distance that any atom can move during a minimization",
                 "iteration. This value is in units length and corresponds to the",
                 "dmax term for the LAMMPS min_modify command. Default value is",
                 "'0.01 angstrom'."]),
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return  list(self.templatekeys.keys()) + []
 
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return  self.preparekeys + [
                     'force_unit',
                     'length_unit',
                 ]
 
-    def load_parameters(self, input_dict, build=True):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         self.energytolerance = input_dict.get(keymap['energytolerance'], 0.0)
         self.forcetolerance = value(input_dict, keymap['forcetolerance'],
                                     default_unit=self.parent.units.force_unit,
                                     default_term='0.0')
         self.maxiterations = input_dict.get(keymap['maxiterations'], 100000)
         self.maxevaluations = input_dict.get(keymap['maxevaluations'], 1000000)
         self.maxatommotion = value(input_dict, keymap['maxatommotion'],
                                    default_unit=self.parent.units.length_unit,
                                    default_term='0.01 angstrom')
-        
+
         # Check that one of the tolerances is set
         if self.energytolerance == 0.0 and self.forcetolerance == 0.0:
             raise ValueError('energytolerance and forcetolerance cannot both be 0.0')
 
 ########################### Data model interactions ###########################
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         run_params = model['calculation']['run-parameter']
 
         self.energytolerance = run_params[f'{self.modelprefix}energytolerance']
         self.forcetolerance = uc.value_unit(run_params[f'{self.modelprefix}forcetolerance'])
         self.maxiterations = run_params[f'{self.modelprefix}maxiterations']
         self.maxevaluations = run_params[f'{self.modelprefix}maxevaluations']
         self.maxatommotion = uc.value_unit(run_params[f'{self.modelprefix}maxatommotion'])
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -258,28 +272,28 @@
             raise ValueError('energytolerance and forcetolerance cannot both be 0.0')
 
         # Build paths if needed
         if 'calculation' not in model:
             model['calculation'] = DM()
         if 'run-parameter' not in model['calculation']:
             model['calculation']['run-parameter'] = DM()
-        
+
         # Save values
         run_params = model['calculation']['run-parameter']
         run_params[f'{self.modelprefix}energytolerance'] = self.energytolerance
         run_params[f'{self.modelprefix}forcetolerance'] = uc.model(self.forcetolerance,
                                                               self.parent.units.force_unit)
         run_params[f'{self.modelprefix}maxiterations']  = self.maxiterations
         run_params[f'{self.modelprefix}maxevaluations'] = self.maxevaluations
         run_params[f'{self.modelprefix}maxatommotion']  = uc.model(self.maxatommotion,
                                                               self.parent.units.length_unit)
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
@@ -290,30 +304,30 @@
 
         prefix = self.prefix
         meta[f'{prefix}energytolerance'] = self.energytolerance
         meta[f'{prefix}forcetolerance'] = self.forcetolerance
         meta[f'{prefix}maxiterations'] = self.maxiterations
         meta[f'{prefix}maxevaluations'] = self.maxevaluations
         meta[f'{prefix}maxatommotion'] = self.maxatommotion
-    
+
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
             The dictionary of input parameters to add subset terms to.
         """
         # Check that one of the tolerances is set
         if self.energytolerance == 0.0 and self.forcetolerance == 0.0:
             raise ValueError('energytolerance and forcetolerance cannot both be 0.0')
-        
+
         # Get ftol, dmax in LAMMPS units?
         input_dict['etol'] = self.energytolerance
         input_dict['ftol'] = self.forcetolerance
         input_dict['maxiter'] = self.maxiterations
         input_dict['maxeval'] = self.maxevaluations
-        input_dict['dmax'] = self.maxatommotion
+        input_dict['dmax'] = self.maxatommotion
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/LammpsPotential.py` & `iprPy-0.11.5/iprPy/calculation_subset/LammpsPotential.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,26 +1,37 @@
+# coding: utf-8
+
+# Standard Python libraries
+from typing import Optional, Union
+
+# https://github.com/usnistgov/atomman
 import atomman as am
 import atomman.lammps as lmp
 
-from yabadaba import query
+from yabadaba import load_query
 
+from potentials.record.BasePotentialLAMMPS import BasePotentialLAMMPS
 
+# https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
+# Local imports
 from . import CalculationSubset
-
 from ..tools import dict_insert
 
 class LammpsPotential(CalculationSubset):
     """Handles calculation terms for loading a LAMMPS-compatible potential"""
 
 ############################# Core properties #################################
 
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -43,74 +54,91 @@
         self.__potential_LAMMPS_key = None
         self.__potential_LAMMPS_id = None
         self.__potential = None
 
 ############################## Class attributes ################################
 
     @property
-    def potential_key(self):
+    def potential_key(self) -> str:
         """str: UUID4 key assigned to the potential model"""
         return self.__potential_key
-    
+
     @potential_key.setter
-    def potential_key(self, value):
-        self.__potential_key = str(value)
+    def potential_key(self, val: str):
+        self.__potential_key = str(val)
 
     @property
-    def potential_id(self):
+    def potential_id(self) -> str:
         """str: Unique id assigned to the potential model"""
         return self.__potential_id
 
     @potential_id.setter
-    def potential_id(self, value):
-        self.__potential_id = str(value)
+    def potential_id(self, val: str):
+        self.__potential_id = str(val)
 
     @property
-    def potential_LAMMPS_key(self):
+    def potential_LAMMPS_key(self) -> str:
         """str: UUID4 key assigned to the LAMMPS implementation"""
         return self.__potential_LAMMPS_key
 
     @potential_LAMMPS_key.setter
-    def potential_LAMMPS_key(self, value):
-        self.__potential_LAMMPS_key = str(value)
+    def potential_LAMMPS_key(self, val: str):
+        self.__potential_LAMMPS_key = str(val)
 
     @property
-    def potential_LAMMPS_id(self):
+    def potential_LAMMPS_id(self) -> str:
         """str: Unique id assigned to the LAMMPS implementation"""
         return self.__potential_LAMMPS_id
 
     @potential_LAMMPS_id.setter
-    def potential_LAMMPS_id(self, value):
-        self.__potential_LAMMPS_id = str(value)
+    def potential_LAMMPS_id(self, val: str):
+        self.__potential_LAMMPS_id = str(val)
 
     @property
-    def potential(self):
-        """potentials.PotentialLAMMPS: The record object for the LAMMPS implementation"""
+    def potential(self) -> BasePotentialLAMMPS:
+        """BasePotentialLAMMPS: The record object for the LAMMPS implementation"""
         if (self.__potential is None and (
                 self.potential_LAMMPS_id is not None
                 or self.potential_LAMMPS_key is not None)):
-            
+
             self.potential = am.load_lammps_potential(
                 id = self.potential_LAMMPS_id,
                 key = self.potential_LAMMPS_key,
                 pot_dir_style = 'local',
                 database = self.parent.database
             )
         return self.__potential
-    
+
     @potential.setter
-    def potential(self, value):
+    def potential(self, val: BasePotentialLAMMPS):
         # Set metadata values
-        self.potential_key = value.potkey
-        self.potential_id = value.potid
-        self.potential_LAMMPS_key = value.key
-        self.potential_LAMMPS_id = value.id
-        self.__potential = value
-    
-    def set_values(self, **kwargs):
+        self.potential_key = val.potkey
+        self.potential_id = val.potid
+        self.potential_LAMMPS_key = val.key
+        self.potential_LAMMPS_id = val.id
+        self.__potential = val
+
+    def set_values(self, **kwargs: any):
+        """
+        Allows for multiple class attribute values to be updated at once.
+
+        Parameters
+        ----------
+        potential: BasePotentialLAMMPS, optional
+            A potential implementation record to associate with the calculation.
+            Cannot be given with the other potential_ kwargs.
+        potential_key: str, optional
+            The UUID key for the potential to associate with the calculation.
+        potential_id: str, optional
+            The id for the potential to associate with the calculation.
+        potential_LAMMPS_key: str, optional
+            The UUID key for the potential implementation to associate with the calculation.
+        potential_LAMMPS_id: str, optional
+            The id for the potential implementation to associate with the calculation.
+        """
         if 'potential' in kwargs:
             try:
                 assert 'potential_key' not in kwargs
                 assert 'potential_id' not in kwargs
                 assert 'potential_LAMMPS_key' not in kwargs
                 assert 'potential_LAMMPS_id' not in kwargs
             except:
@@ -124,15 +152,17 @@
             if 'potential_LAMMPS_key' in kwargs:
                 self.potential_LAMMPS_key = kwargs['potential_LAMMPS_key']
             if 'potential_LAMMPS_id' in kwargs:
                 self.potential_LAMMPS_id = kwargs['potential_LAMMPS_id']
 
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -144,21 +174,20 @@
             templateheader = 'Interatomic Potential'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = ' '.join([
                 "Specifies the interatomic potential to use and the directory",
                 "where any associated parameter files are located."])
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return  {
             'potential_file': ' '.join([
                 "The path to the potential_LAMMPS or potential_LAMMPS_KIM record",
                 "that defines the interatomic potential to use for LAMMPS",
                 "calculations."]),
             'potential_kim_id': ' '.join([
                 "If potential_file is a potential_LAMMPS_KIM record, this allows",
@@ -173,84 +202,86 @@
                 "calculation."]),
             'potential_dir': ' '.join([
                 "The path to the directory containing any potential parameter files",
                 "(eg. eam.alloy setfl files) that are needed for the potential. If",
                 "not given, then any required files are expected to be in the",
                 "working directory where the calculation is executed."]),
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return  list(self.templatekeys.keys()) + [
                     'potential_content',
                     'potential_dir_content',
                 ]
 
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return  self.preparekeys + [
                     'potential',
                 ]
-    
-    def load_parameters(self, input_dict):
+
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-    
+
         # Extract input values and assign default values
         potential_file = input_dict[keymap['potential_file']]
         potential_kim_id = input_dict.get(keymap['potential_kim_id'], None)
         potential_kim_potid = input_dict.get(keymap['potential_kim_potid'], None)
         potential_dir = input_dict.get(keymap['potential_dir'], None)
         potential_content = input_dict.get(keymap['potential_content'], None)
 
         # Use potential_content instead of potential_file if given
         if potential_content is not None:
             potential_file = potential_content
-        
+
         # Read potential
         self.potential = lmp.Potential(potential_file, pot_dir=potential_dir, 
                                        kim_id=potential_kim_id, potid=potential_kim_potid)
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = 'potential-LAMMPS'
         return f'{self.modelprefix}{baseroot}'
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         sub = model[self.modelroot]
 
         self.potential_LAMMPS_key = sub['key']
         self.potential_LAMMPS_id = sub['id']
         self.potential_key = sub['potential']['key']
         self.potential_id = sub['potential']['id']
 
-    def build_model(self, model, **kwargs):
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -272,103 +303,52 @@
         pot = DM()
 
         pot['key'] = self.potential_LAMMPS_key
         pot['id'] = self.potential_LAMMPS_id
         pot['potential'] = DM()
         pot['potential']['key'] = self.potential_key
         pot['potential']['id'] = self.potential_id
-        
+
         dict_insert(model, self.modelroot, pot, **kwargs)
 
-    def mongoquery(self, potential_LAMMPS_key=None,
-                   potential_LAMMPS_id=None, potential_key=None,
-                   potential_id=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
-        
-        Parameters
-        ----------
-        potential_LAMMPS_key : str
-            The key associated with the LAMMPS potential implementation.
-        potential_LAMMPS_id : str
-            The id associated with the LAMMPS potential implementation.
-        potential_key : str
-            The key associated with the potential model.
-        potential_id : int
-            The id associated with the potential model.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
 
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.key', potential_LAMMPS_key)
-        query.str_match.mongo(mquery, f'{root}.id', potential_LAMMPS_id)
-        query.str_match.mongo(mquery, f'{root}.potential.key', potential_key)
-        query.str_match.mongo(mquery, f'{root}.potential.id', potential_id)
-        
-        # Return query dict
-        return mquery
+        root = f'{self.parent.modelroot}.{self.modelroot}'
 
-    def cdcsquery(self, potential_LAMMPS_key=None,
-                  potential_LAMMPS_id=None, potential_key=None,
-                  potential_id=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        potential_LAMMPS_key : str
-            The key associated with the LAMMPS potential implementation.
-        potential_LAMMPS_id : str
-            The id associated with the LAMMPS potential implementation.
-        potential_key : str
-            The key associated with the potential model.
-        potential_id : int
-            The id associated with the potential model.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-        
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = self.parent.modelroot
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-        
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.key', potential_LAMMPS_key)
-        query.str_match.mongo(mquery, f'{root}.id', potential_LAMMPS_id)
-        query.str_match.mongo(mquery, f'{root}.potential.key', potential_key)
-        query.str_match.mongo(mquery, f'{root}.potential.id', potential_id)
-        
-        # Return query dict
-        return mquery      
+        return {
+            'potential_LAMMPS_key': load_query(
+                style='str_match',
+                name=f'{self.prefix}potential_LAMMPS_key',
+                path=f'{root}.key',
+                description="search by potential implementation's UUID key"),
+            'potential_LAMMPS_id': load_query(
+                style='str_match',
+                name=f'{self.prefix}potential_LAMMPS_id',
+                path=f'{root}.id',
+                description="search by potential implementation's id"),
+            'potential_key': load_query(
+                style='str_match',
+                name=f'{self.prefix}potential_key',
+                path=f'{root}.potential.key',
+                description="search by potential's UUID key"),
+            'potential_id': load_query(
+                style='str_match',
+                name=f'{self.prefix}potential_id',
+                path=f'{root}.potential.id',
+                description="search by potential's id"),
+        }
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
-        
+
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
         """
         # Check required parameters
         if (self.potential_key is None or self.potential_id is None
@@ -381,66 +361,23 @@
                 raise ValueError('potential information not set')
 
         meta[f'{self.prefix}potential_LAMMPS_key'] = self.potential_LAMMPS_key
         meta[f'{self.prefix}potential_LAMMPS_id'] = self.potential_LAMMPS_id
         meta[f'{self.prefix}potential_key'] = self.potential_key
         meta[f'{self.prefix}potential_id'] = self.potential_id
 
-    def pandasfilter(self, dataframe, potential_LAMMPS_key=None,
-                     potential_LAMMPS_id=None, potential_key=None,
-                     potential_id=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        potential_LAMMPS_key : str
-            The key associated with the LAMMPS potential implementation.
-        potential_LAMMPS_id : str
-            The id associated with the LAMMPS potential implementation.
-        potential_key : str
-            The key associated with the potential model.
-        potential_id : int
-            The id associated with the potential model.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        prefix = self.prefix
-        matches = (
-            query.str_match.pandas(dataframe, f'{prefix}potential_LAMMPS_key',
-                                   potential_LAMMPS_key)
-            &query.str_match.pandas(dataframe, f'{prefix}potential_LAMMPS_id',
-                                    potential_LAMMPS_id)
-            &query.str_match.pandas(dataframe, f'{prefix}potential_key',
-                                    potential_key)
-            &query.str_match.pandas(dataframe, f'{prefix}potential_id',
-                                    potential_id)
-        )
-        return matches
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
             The dictionary of input parameters to add subset terms to.
         """
         if self.potential is None:
             raise ValueError('potential not set')
-            
-        input_dict['potential'] = self.potential
+
+        input_dict['potential'] = self.potential
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/PointDefect.py` & `iprPy-0.11.5/iprPy/calculation_subset/PointDefect.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,146 +1,179 @@
+# coding: utf-8
+
 # Standard Python libraries
 from pathlib import Path
+from typing import Optional, Union
 
 # http://www.numpy.org/
 import numpy as np
+import numpy.typing as npt
 
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
-from yabadaba import query
+from yabadaba import load_query
 
-# https://github.com/usnistgov/atomman
 import atomman as am
-import atomman.unitconvert as uc
 
+# Local imports
 from . import CalculationSubset
-from ..tools import dict_insert, aslist
-from ..input import termtodict, dicttoterm, boolean
+from ..input import boolean
 
 class PointDefectParams():
     """Class for managing point defect parameters"""
 
-    def __init__(self, ptd_type='v', atype=None, pos='0.0 0.0 0.0', db_vect=None,
-                 scale=False):
-    
+    def __init__(self,
+                 ptd_type: str = 'v',
+                 atype: Optional[str] = None,
+                 pos: Union[str, npt.ArrayLike] = '0.0 0.0 0.0',
+                 db_vect: Union[str, npt.ArrayLike, None] = None,
+                 scale: bool = False):
+        """
+        Define parameters for a point defect operation.
+
+        Parameters
+        ----------
+        ptd_type: str, optional
+            Indicates the point defect operation type: v, s, i, or db
+        atype: int or None, optional
+            Indicates the atom type of the defect atom added.  Used by
+            ptd_type styles s, i and db.
+        pos: str or array-like object, optional
+            Gives the position where the point defect operation is
+            performed.  For v, s, and db, this corresponds to the position of
+            an existing atom to delete or modify.  For i, this corresponds to
+            the position were the new interstitial atom is inserted.
+        db_vect: str, array-like object or None
+            The dumbbell vector to use for db style.  The atom at pos will be
+            shifted by -db_vect and a new atom inserted at pos + db_vect.
+        scale: bool
+            Indicates if pos and db_vect are absolute Cartesian (False, default)
+            or are scaled relative to the ucell.
+        """
         self.ptd_type = ptd_type
         self.atype = atype
         self.pos = pos
         self.db_vect = db_vect
         self.scale = scale
 
     @property
-    def ptd_type(self):
+    def ptd_type(self) -> str:
+        """str: the type of point defect"""
         return self.__ptd_type
 
     @ptd_type.setter
-    def ptd_type(self, value):
-        if value.lower() in ['v', 'vacancy']:
-            value = 'v'
-        elif value.lower() in ['i', 'interstitial']:
-            value = 'i'
-        elif value.lower() in ['s', 'substitutional']:
-            value = 's'
-        elif value.lower() in ['d', 'db', 'dumbbell']:
-            value = 'db'  
+    def ptd_type(self, val: str):
+        if val.lower() in ['v', 'vacancy']:
+            val = 'v'
+        elif val.lower() in ['i', 'interstitial']:
+            val = 'i'
+        elif val.lower() in ['s', 'substitutional']:
+            val = 's'
+        elif val.lower() in ['d', 'db', 'dumbbell']:
+            val = 'db'
         else:
             raise ValueError('invalid point defect type')
-        self.__ptd_type = str(value)
+        self.__ptd_type = str(val)
 
     @property
-    def atype(self):
+    def atype(self) -> Optional[int]:
+        """int or None: The int atype for the defect atom"""
         return self.__atype
 
     @atype.setter
-    def atype(self, value):
-        if value is None:
+    def atype(self, val: Optional[int]):
+        if val is None:
             self.__atype = None
         else:
-            self.__atype = int(value)
+            self.__atype = int(val)
 
     @property
-    def pos(self):
+    def pos(self) -> Optional[np.ndarray]:
+        """numpy.ndarray: The position of the defect atom"""
         return self.__pos
 
     @pos.setter
-    def pos(self, value):
-        if value is None:
+    def pos(self, val: Union[str, npt.ArrayLike, None]):
+        if val is None:
             self.__pos = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,)
-            self.__pos = value
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,)
+            self.__pos = val
 
     @property
-    def db_vect(self):
+    def db_vect(self) -> Optional[np.ndarray]:
+        """numpy.ndarray: The vector between dumbbell interstitial atoms"""
         return self.__db_vect
 
     @db_vect.setter
-    def db_vect(self, value):
-        if value is None:
+    def db_vect(self, val: Union[str, npt.ArrayLike, None]):
+        if val is None:
             self.__db_vect = None
         else:
-            if isinstance(value, str):
-                value = np.array(value.strip().split(), dtype=float)
+            if isinstance(val, str):
+                val = np.array(val.strip().split(), dtype=float)
             else:
-                value = np.asarray(value, dtype=float)
-            assert value.shape == (3,)
-            self.__db_vect = value
+                val = np.asarray(val, dtype=float)
+            assert val.shape == (3,)
+            self.__db_vect = val
 
     @property
-    def scale(self):
+    def scale(self) -> bool:
+        """bool: indicates if pos and db_vect are scaled by the unit cell box dimensions"""
         return self.__scale
 
     @scale.setter
-    def scale(self, value):
-        self.__scale = boolean(value)
+    def scale(self, val: bool):
+        self.__scale = boolean(val)
 
-    def calc_inputs(self, ucell=None):
+    def calc_inputs(self,
+                    ucell: Optional[am.System] = None):
         """
         Builds parameters for atomman.defect.point()
         
         Parameters
         ----------
         ucell: atomman.System, optional
             An alternate (unit cell) system to use as the reference for scaling
             pos and db_vect if scale is True.  If scale is True and ucell is
             not given, then the vectors will be scaled using the full system
-            as the reference.            
+            as the reference.
         """
-        
+
         params = {}
-        
+
         params['ptd_type'] = self.ptd_type
-        
+
         if self.atype is not None:
-            params['atype'] = self.atype        
-        
+            params['atype'] = self.atype
+
         if self.scale is True and ucell is not None:
             params['pos'] = ucell.unscale(self.pos)
         else:
             params['pos'] = self.pos
-        
+
         if self.db_vect is not None:
             if self.scale is True and ucell is not None:
                 params['db_vect'] = ucell.unscale(self.db_vect)
             else:
-                params['db_vect'] = self.db_vect        
-        
+                params['db_vect'] = self.db_vect
+
         if ucell is not None:
             params['scale'] = False
         else:
             params['scale'] = self.scale
 
         return params
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """Builds parameters for atomman.defect.point()"""
         params = DM()
         params['ptd_type'] = self.ptd_type
         if self.atype is not None:
             params['atype'] = self.atype
         params['pos'] = f'{self.pos[0]:.13} {self.pos[1]:.13} {self.pos[2]:.13}'
         if self.db_vect is not None:
@@ -149,17 +182,20 @@
 
         return params
 
 class PointDefect(CalculationSubset):
     """Handles calculation terms for point defect parameters"""
 
 ############################# Core properties #################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -184,62 +220,67 @@
         self.family = None
         self.__content = None
         self.__model = None
 
 ############################## Class attributes ################################
 
     @property
-    def param_file(self):
+    def param_file(self) -> Optional[Path]:
+        """Path or None: The path to the point defect parameter file"""
         return self.__param_file
 
     @param_file.setter
-    def param_file(self, value):
-        if value is None:
+    def param_file(self, val: Union[str, Path, None]):
+        if val is None:
             self.__param_file = None
         else:
-            self.__param_file = Path(value)
+            self.__param_file = Path(val)
 
     @property
-    def key(self):
+    def key(self) -> Optional[str]:
+        """str or None: UUID key of the point defect parameter set"""
         return self.__key
 
     @key.setter
-    def key(self, value):
-        if value is None:
+    def key(self, val: Optional[str]):
+        if val is None:
             self.__key = None
         else:
-            self.__key = str(value)
+            self.__key = str(val)
 
     @property
-    def id(self):
+    def id(self) -> Optional[str]:
+        """str or None: id of the point defect parameter set"""
         return self.__id
 
     @id.setter
-    def id(self, value):
-        if value is None:
+    def id(self, val: Optional[str]):
+        if val is None:
             self.__id = None
         else:
-            self.__id = str(value)
+            self.__id = str(val)
 
     @property
-    def params(self):
+    def params(self) -> list:
+        """list: The point defect operation parameters to perform"""
         return self.__params
-    
+
     @property
-    def family(self):
+    def family(self) -> Optional[str]:
+        """str or None: The prototype or reference crystal the point defect parameter set is for"""
         return self.__family
 
     @family.setter
-    def family(self, value):
-        if value is None:
+    def family(self, val: Optional[str]):
+        if val is None:
             self.__family = None
         else:
-            self.__family = str(value)
+            self.__family = str(val)
 
-    def set_values(self, **kwargs):
+    def set_values(self, **kwargs: any):
         """
         Allows for multiple class attribute values to be updated at once.
 
         Parameters
         ----------
         param_file : str, optional
             The path to a file that fully defines the input parameters for
@@ -256,23 +297,52 @@
         if 'key' in kwargs:
             self.key = kwargs['key']
         if 'id' in kwargs:
             self.id = kwargs['id']
         if 'family' in kwargs:
             self.family = kwargs['family']
 
-    def add_params(self, ptd_type='v', atype=None, pos='0.0 0.0 0.0',
-                   db_vect=None, scale=False):
+    def add_params(self,
+                   ptd_type: str = 'v',
+                   atype: Optional[int] = None,
+                   pos: Union[str, npt.ArrayLike] ='0.0 0.0 0.0',
+                   db_vect: Optional[str] = None,
+                   scale: bool = False):
+        """
+        Create and add a point defect operation to the params list.
+
+        Parameters
+        ----------
+        ptd_type: str, optional
+            Indicates the point defect operation type: v, s, i, or db
+        atype: int or None, optional
+            Indicates the atom type of the defect atom added.  Used by
+            ptd_type styles s, i and db.
+        pos: str or array-like object, optional
+            Gives the position where the point defect operation is
+            performed.  For v, s, and db, this corresponds to the position of
+            an existing atom to delete or modify.  For i, this corresponds to
+            the position were the new interstitial atom is inserted.
+        db_vect: str, array-like object or None
+            The dumbbell vector to use for db style.  The atom at pos will be
+            shifted by -db_vect and a new atom inserted at pos + db_vect.
+        scale: bool
+            Indicates if pos and db_vect are absolute Cartesian (False, default)
+            or are scaled relative to the ucell.
+        """
+
         self.params.append(PointDefectParams(ptd_type=ptd_type, atype=atype,
                                              pos=pos, db_vect=db_vect,
-                                             scale=scale))        
+                                             scale=scale))
 
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -283,21 +353,20 @@
         if templateheader is None:
             templateheader = 'Point Defect'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = ' '.join([
                 "Specifies the parameter set that defines a point defect."])
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return  {
             'pointdefect_file': ' '.join([
                 "The path to a point_defect record file that contains input",
                 "parameters associated with a specific point defect or a set",
                 "of point defects."]),
             'pointdefect_type': ' '.join([
                 "Indicates which type of point defect to generate.",
@@ -319,82 +388,83 @@
                 "-pointdefect_dumbbell_vect, and the inserted interstitial atom is",
                 "placed at pointdefect_pos + pointdefect_dumbbell_vect."]),
             'pointdefect_scale': ' '.join([
                 "Boolean indicating if pointdefect_pos and pointdefect_dumbbell_vect",
                 "are taken as absolute Cartesian vectors, or taken as scaled values",
                 "relative to the loaded system. Default value is False."]),
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return  list(self.templatekeys.keys()) + [
                     'pointdefect_family',
                     'pointdefect_content',
                 ]
+
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return  self.preparekeys + [
                     'pointdefect_model',
                     'ucell',
                     'calculation_params',
                     'point_kwargs',
                 ]
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-        
+
         # Extract input values and assign default values
         self.param_file = input_dict.get(keymap['pointdefect_file'], None)
         self.__content = input_dict.get(keymap['pointdefect_content'], None)
-        
+
         # Replace defect model with defect content if given
         param_file = self.param_file
         if self.__content is not None:
             param_file = self.__content
-        
+
         # Extract parameters from a file
         if param_file is not None:
-            
+
             # Verify competing parameters are not defined
             for key in ('pointdefect_type', 'pointdefect_atype', 'pointdefect_pos',
                         'pointdefect_dumbbell_vect', 'pointdefect_scale'):
                 if keymap[key] in input_dict:
                     raise ValueError(f"{keymap[key]} and {keymap['pointdefect_file']} cannot both be supplied")
-            
+
             # Load defect model
             self.__model = model = DM(param_file).find('point-defect')
 
             # Extract parameter values from defect model
             self.key = model['key']
             self.id = model['id']
             self.family = model['system-family']
             self.__params = []
             for cp in model.aslist('calculation-parameter'):
                 self.add_params(**cp)
-        
+
         # Set parameter values directly
         else:
             self.__model = None
             self.key = None
             self.id = None
             self.family = self.parent.system.family
             self.__params = []
@@ -407,33 +477,35 @@
                 if keymap[key1] in input_dict:
                     cp[key2] = input_dict[keymap[key1]]
             self.add_params(**cp)
 
 ########################### Data model interactions ###########################
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str : The root element name for the subset terms."""
         baseroot = 'point-defect'
         return f'{self.modelprefix}{baseroot}'
 
-    def load_model(self, model):
+    def load_model(self, model: DM):
         """Loads subset attributes from an existing model."""
         ptd = model[self.modelroot]
 
         self.__model = None
         self.__param_file = None
         self.key = ptd['key']
         self.id = ptd['id']
         self.family = ptd['system-family']
         self.__params = []
         for cp in ptd.aslist('calculation-parameter'):
             self.add_params(**cp)
-        
-    def build_model(self, model, **kwargs):
+
+    def build_model(self,
+                    model: DM,
+                    **kwargs: any):
         """
         Adds the subset model to the parent model.
         
         Parameters
         ----------
         model : DataModelDict.DataModelDict
             The record content (after root element) to add content to.
@@ -445,150 +517,58 @@
         model[self.modelroot] = ptd = DM()
         ptd['key'] = self.key
         ptd['id'] = self.id
         ptd['system-family'] = self.family
         for params in self.params:
             ptd.append('calculation-parameter', params.build_model())
 
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
 
-    def mongoquery(self, pointdefect_key=None, pointdefect_id=None,
-                   pointdefect_family=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a Mongo-style
-        database.
-        
-        Parameters
-        ----------
-        pointdefect_id : str
-            The id associated with a point defect parameter set.
-        pointdefect_key : str
-            The key associated with a point defect parameter set.
-        pointdefect_family : str
-            The "family" crystal structure/prototype that the point defect
-            is defined for.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        dict
-            The Mongo-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = f'content.{self.parent.modelroot}'
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.point-defect.key', pointdefect_key)
-        query.str_match.mongo(mquery, f'{root}.point-defect.id', pointdefect_id)
-        query.str_match.mongo(mquery, f'{root}.system-family', pointdefect_family)
-
-        # Return query dict
-        return mquery
+        root = f'{self.parent.modelroot}.{self.modelroot}'
 
-    def cdcsquery(self, pointdefect_key=None, pointdefect_id=None,
-                  pointdefect_family=None, **kwargs):
-        """
-        Generate a query to parse records with the subset from a CDCS-style
-        database.
-        
-        Parameters
-        ----------
-        pointdefect_id : str
-            The id associated with a point defect parameter set.
-        pointdefect_key : str
-            The key associated with a point defect parameter set.
-        pointdefect_family : str
-            The "family" crystal structure/prototype that the point defect
-            is defined for.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-        
-        Returns
-        -------
-        dict
-            The CDCS-style find query terms.
-        """
-        # Init query and set root paths
-        mquery = {}
-        parentroot = self.parent.modelroot
-        root = f'{parentroot}.{self.modelroot}'
-        runparam_prefix = f'{parentroot}.calculation.run-parameter.{self.modelprefix}'
-        
-        # Build query terms
-        query.str_match.mongo(mquery, f'{root}.point-defect.key', pointdefect_key)
-        query.str_match.mongo(mquery, f'{root}.point-defect.id', pointdefect_id)
-        query.str_match.mongo(mquery, f'{root}.system-family', pointdefect_family)
-
-        # Return query dict
-        return mquery      
+        return {
+            'pointdefect_id': load_query(
+                style='str_match',
+                name=f'{self.prefix}pointdefect_id',
+                path=f'{root}.id',
+                description='search by point defect parameter set id'),
+            'pointdefect_key': load_query(
+                style='str_match',
+                name=f'{self.prefix}pointdefect_key',
+                path=f'{root}.key',
+                description='search by point defect parameter set UUID key'),
+            'pointdefect_family': load_query(
+                style='str_match',
+                name=f'{self.prefix}pointdefect_family',
+                path=f'{root}.system-family',
+                description='search by crystal prototype that the point defect parameter set is for'),
+        }
 
 ########################## Metadata interactions ##############################
 
-    def metadata(self, meta):
+    def metadata(self, meta: dict):
         """
         Converts the structured content to a simpler dictionary.
         
         Parameters
         ----------
         meta : dict
             The dictionary to add the subset content to
         """
         prefix = self.prefix
 
         meta[f'{prefix}pointdefect_key'] = self.key
         meta[f'{prefix}pointdefect_id'] = self.id
         meta[f'{prefix}pointdefect_family'] = self.family
 
-    def pandasfilter(self, dataframe, pointdefect_key=None,
-                     pointdefect_id=None, pointdefect_family=None, **kwargs):
-        """
-        Parses a pandas dataframe containing the subset's metadata to find 
-        entries matching the terms and values given. Ideally, this should find
-        the same matches as the mongoquery and cdcsquery methods for the same
-        search parameters.
-
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            The metadata dataframe to filter.
-        pointdefect_id : str
-            The id associated with a point defect parameter set.
-        pointdefect_key : str
-            The key associated with a point defect parameter set.
-        pointdefect_family : str
-            The "family" crystal structure/prototype that the point defect
-            is defined for.
-        kwargs : any
-            The parent query terms and values ignored by the subset.
-
-        Returns
-        -------
-        pandas.Series of bool
-            True for each entry where all filter terms+values match, False for
-            all other entries.
-        """
-        prefix = self.prefix
-        matches = (
-            query.str_match.pandas(dataframe, f'{prefix}pointdefect_key',
-                                   pointdefect_key)
-            &query.str_match.pandas(dataframe, f'{prefix}pointdefect_id',
-                                    pointdefect_id)
-            &query.str_match.pandas(dataframe, f'{prefix}pointdefect_family',
-                                    pointdefect_family)
-        )
-        return matches
-
-    
-
 ########################### Calculation interactions ##########################
 
-    def calc_inputs(self, input_dict):
+    def calc_inputs(self, input_dict: dict):
         """
         Generates calculation function input parameters based on the values
         assigned to attributes of the subset.
 
         Parameters
         ----------
         input_dict : dict
@@ -598,10 +578,7 @@
             input_dict['point_kwargs'] = self.params[0].calc_inputs(self.parent.system.ucell)
         elif len(self.params) > 1:
             input_dict['point_kwargs'] = []
             for params in self.params:
                 input_dict['point_kwargs'].append(params.calc_inputs(self.parent.system.ucell))
         else:
             raise ValueError('No point defect parameters set')
-
-      
-
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/Units.py` & `iprPy-0.11.5/iprPy/calculation_subset/Units.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,16 +1,25 @@
+# coding: utf-8
+
+# Standard Python libraries
+from typing import Optional
+
+# Local imports
 from . import CalculationSubset
 
 class Units(CalculationSubset):
     """Handles calculation terms associated with input/output units settings"""
 
 ############################# Core properties ##################################
-     
-    def __init__(self, parent, prefix='', templateheader=None,
-                 templatedescription=None):
+
+    def __init__(self,
+                 parent,
+                 prefix: str = '',
+                 templateheader: Optional[str] = None,
+                 templatedescription: Optional[str] = None):
         """
         Initializes a calculation record subset object.
 
         Parameters
         ----------
         parent : iprPy.calculation.Calculation
             The parent calculation object that the subset object is part of.
@@ -32,59 +41,78 @@
         self.__pressure_unit = 'GPa'
         self.__energy_unit = 'eV'
         self.__force_unit = 'eV/angstrom'
 
 ############################## Class attributes ################################
 
     @property
-    def length_unit(self):
+    def length_unit(self) -> str:
+        """str: The unit of length to use for input/output values"""
         return self.__length_unit
-    
+
     @length_unit.setter
-    def length_unit(self, value):
-        self.__length_unit = str(value)
+    def length_unit(self, val: str):
+        self.__length_unit = str(val)
 
     @property
-    def pressure_unit(self):
+    def pressure_unit(self) -> str:
+        """str: The unit of pressure to use for input/output values"""
         return self.__pressure_unit
 
     @pressure_unit.setter
-    def pressure_unit(self, value):
-        self.__pressure_unit = str(value)
+    def pressure_unit(self, val: str):
+        self.__pressure_unit = str(val)
 
     @property
-    def energy_unit(self):
+    def energy_unit(self) -> str:
+        """str: The unit of energy to use for input/output values"""
         return self.__energy_unit
 
     @energy_unit.setter
-    def energy_unit(self, value):
-        self.__energy_unit = str(value)
+    def energy_unit(self, val: str):
+        self.__energy_unit = str(val)
 
     @property
-    def force_unit(self):
+    def force_unit(self) -> str:
+        """str: The unit of force to use for input/output values"""
         return self.__force_unit
 
     @force_unit.setter
-    def force_unit(self, value):
-        self.__force_unit = str(value)
+    def force_unit(self, val: str):
+        self.__force_unit = str(val)
 
-    def set_values(self, **kwargs):
-        
+    def set_values(self, **kwargs: any):
+        """
+        Allows for multiple class attribute values to be updated at once.
+
+        Parameters
+        ----------
+        length_unit: str, optional
+            The unit of length to use for input/output values
+        pressure_unit: str, optional
+            The unit of pressure to use for input/output values
+        energy_unit: str, optional
+            The unit of energy to use for input/output values
+        force_unit: str, optional
+            The unit of force to use for input/output values
+        """
         if 'length_unit' in kwargs:
             self.length_unit = kwargs['length_unit']
         if 'pressure_unit' in kwargs:
             self.pressure_unit = kwargs['pressure_unit']
         if 'energy_unit' in kwargs:
             self.energy_unit = kwargs['energy_unit']
         if 'force_unit' in kwargs:
             self.force_unit = kwargs['force_unit']
 
 ####################### Parameter file interactions ###########################
 
-    def _template_init(self, templateheader=None, templatedescription=None):
+    def _template_init(self,
+                       templateheader: Optional[str] = None,
+                       templatedescription: Optional[str] = None):
         """
         Sets the template header and description values.
 
         Parameters
         ----------
         templateheader : str, optional
             An alternate header to use in the template file for the subset.
@@ -96,67 +124,66 @@
             templateheader = 'Input/Output Units'
 
         # Set default template description
         if templatedescription is None:
             templatedescription = ' '.join([
                 "Specifies the default units to use for the other input keys",
                 "and to use for saving to the results file."])
-        
+
         super()._template_init(templateheader, templatedescription)
 
     @property
-    def templatekeys(self):
+    def templatekeys(self) -> dict:
         """dict : The subset-specific input keys and their descriptions."""
-        
         return  {
             'length_unit': ' '.join([
                 "The unit of length to use. Default value is 'angstrom'."]),
             'pressure_unit': ' '.join([
                 "The unit of pressure to use.  Default value is 'GPa'."]),
             'energy_unit': ' '.join([
                 "The unit of energy to use.  Default value is 'eV'."]),
             'force_unit': ' '.join([
                 "The unit of force to use.  Default value is 'eV/angstrom'."]),
         }
-    
+
     @property
-    def preparekeys(self):
+    def preparekeys(self) -> list:
         """
         list : The input keys (without prefix) used when preparing a calculation.
         Typically, this is templatekeys plus *_content keys so prepare can access
         content before it exists in the calc folders being prepared.
         """
         return  list(self.templatekeys.keys()) + []
 
     @property
-    def interpretkeys(self):
+    def interpretkeys(self) -> list:
         """
         list : The input keys (without prefix) accessed when interpreting the 
         calculation input file.  Typically, this is preparekeys plus any extra
         keys used or generated when processing the inputs.
         """
         return  self.preparekeys + []
 
-    def load_parameters(self, input_dict):
+    def load_parameters(self, input_dict: dict):
         """
         Interprets calculation parameters.
         
         Parameters
         ----------
         input_dict : dict
             Dictionary containing input parameter key-value pairs.
         """
 
         # Set default keynames
         keymap = self.keymap
-        
+
         # Set default unit styles to any terms not given
         self.length_unit = input_dict.get(keymap['length_unit'], 'angstrom')
         self.energy_unit = input_dict.get(keymap['energy_unit'], 'eV')
         self.pressure_unit = input_dict.get(keymap['pressure_unit'], 'GPa')
         self.force_unit = input_dict.get(keymap['force_unit'], 'eV/angstrom')
 
 ########################### Data model interactions ###########################
 
 ########################## Metadata interactions ##############################
 
-########################### Calculation interactions ##########################
+########################### Calculation interactions ##########################
```

### Comparing `iprPy-0.11.4/iprPy/calculation_subset/__init__.py` & `iprPy-0.11.5/iprPy/calculation_subset/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+# coding: utf-8
 from .CalculationSubset import CalculationSubset
 
 from .Units import Units
 
 from .LammpsCommands import LammpsCommands
 from .LammpsPotential import LammpsPotential
 from .LammpsMinimize import LammpsMinimize
```

### Comparing `iprPy-0.11.4/iprPy/command_line.py` & `iprPy-0.11.5/iprPy/command_line.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,58 +8,61 @@
 from . import (load_database, load_run_directory, load_calculation,
                check_modules, settings)
 from .calculation import run_calculation
 from .database import reset_orphans
 from .tools import filltemplate
 
 def command_line():
+    """
+    Parse command line arguments and call the associated iprPy actions.
+    """
     args = command_line_parser()
     command_line_actions(args)
 
 def command_line_actions(args):
     """
     Calls iprPy actions based on the parsed arguments
-    """   
+    """
     # Actions for subcommand check_records
     if args.action == 'check_records':
         database = load_database(args.database)
         database.check_records(args.record_style)
-    
+
     # Actions for subcommand check_modules
     elif args.action == 'check_modules':
         check_modules()
-    
+
     # Actions for subcommand clean_records
     elif args.action == 'clean_records':
         database = load_database(args.database)
         run_directory = load_run_directory(args.run_directory)
         database.clean_records(run_directory=run_directory,
                                record_style=args.record_style)
-    
+
     # Actions for subcommand copy_records
     elif args.action == 'copy_records':
         database1 = load_database(args.database1)
         database2 = load_database(args.database2)
         database1.copy_records(database2, record_style=args.record_style,
                                includetar=args.notar,
                                overwrite=args.overwrite)
-    
+
     # Actions for subcommand copy_references
     elif args.action == 'copy_references':
         database1 = load_database(args.database1)
         database2 = load_database(args.database2)
         database1.copy_references(database2,
                                   includetar=args.notar,
                                   overwrite=args.overwrite)
 
     # Actions for subcommand destroy_records
     elif args.action == 'destroy_records':
         database = load_database(args.database)
         database.destroy_records(args.record_style)
-    
+
     # Actions for subcommand finish_calculations
     elif args.action == 'finish_calculations':
         database = load_database(args.database)
         run_directory = load_run_directory(args.run_directory)
         database.finish_calculations(run_directory, verbose=args.verbose)
 
     # Actions for subcommand reset_orphans
@@ -80,15 +83,15 @@
         database = load_database(args.database)
         database.master_prepare(input_script=args.input_script)
 
     # Actions for subcommand maindoc
     elif args.action == 'maindoc':
         calculation = load_calculation(args.calculation)
         print(calculation.maindoc)
-    
+
     # Actions for subcommand theorydoc
     elif args.action == 'theorydoc':
         calculation = load_calculation(args.calculation)
         print(calculation.theorydoc)
 
     # Actions for subcommand template
     elif args.action == 'template':
@@ -117,15 +120,15 @@
             indent = 4
 
         # Call style-specific retrieve for extra functionality
         if style in ['potential_LAMMPS', 'potential_LAMMPS_KIM']:
             if args.getfiles is True:
                 pot_dir_style = 'id'
                 getfiles = True
-            else: 
+            else:
                 pot_dir_style = 'local'
                 getfiles = False
 
             database.potdb.retrieve_lammps_potential(name=args.record_name,
                                                      getfiles=getfiles,
                                                      format=args.format,
                                                      indent=indent,
@@ -140,52 +143,53 @@
         else:
             database.potdb.retrieve_record(style=style, name=args.record_name,
                                            format=args.format, indent=indent,
                                            verbose=True)
 
     # Actions for subcommand run
     elif args.action == 'run':
-        run_calculation(args.filename, calc_style=args.calc_style)
+        run_calculation(args.filename, calc_style=args.calc_style,
+                        raise_error=args.raise_error)
 
     # Actions for subcommand runner
     elif args.action == 'runner':
         database = load_database(args.database)
         run_directory = load_run_directory(args.run_directory)
         database.runner(run_directory,
                         calc_name=args.calc_name,
                         temp=args.temp,
                         bidtries=args.bidtries,
                         bidverbose=args.bidverbose)
-    
+
     # Actions for subcommand set_database
     elif args.action == 'set_database':
         settings.set_database(args.name)
-    
+
     # Actions for subcommand unset_database
     elif args.action == 'unset_database':
         settings.unset_database(args.name)
-    
+
     # Actions for list_databases
     elif args.action == 'list_databases':
         for name in settings.list_databases:
             print(name)
 
     # Actions for database
     elif args.action == 'database':
         database = load_database(args.database)
         print(database)
 
     # Actions for subcommand set_run_directory
     elif args.action == 'set_run_directory':
         settings.set_run_directory(args.name)
-    
+
     # Actions for subcommand unset_run_directory
     elif args.action == 'unset_run_directory':
         settings.unset_run_directory(args.name)
-    
+
     # Actions for list_run_directories
     elif args.action == 'list_run_directories':
         for name in settings.list_run_directories:
             print(name)
 
     # Actions for run_directory
     elif args.action == 'run_directory':
@@ -214,44 +218,44 @@
 
     # Actions for unset_runner_log_directory
     elif args.action == 'unset_runner_log_directory':
         settings.unset_runner_log_directory()
 
     else:
         raise ValueError('Unknown action argument')
-    
+
 def command_line_parser():
     """
     Defines the command line parsing logic for the iprPy command line executable.
     """
     parser = argparse.ArgumentParser(description='iprPy high-throughput commands')
     subparsers = parser.add_subparsers(title='actions', dest='action')
-    
+
     # Define subparser for check_records
-    subparser = subparsers.add_parser('check_records', 
+    subparser = subparsers.add_parser('check_records',
                         help='checks status of a run_directory or database')
     subparser.add_argument('database', nargs='?', default=None,
                         help='database name')
     subparser.add_argument('record_style', nargs='?', default=None,
                         help='optional record style to limit by')
-    
+
     # Define subparser for check_modules
     subparser = subparsers.add_parser('check_modules',
                         help='prints load status of all modules in iprPy')
-    
+
     # Define subparser for clean_records
     subparser = subparsers.add_parser('clean_records',
                         help='resets prepared calculations for running again')
     subparser.add_argument('database', nargs='?', default=None,
                         help='database name')
     subparser.add_argument('run_directory', nargs='?', default=None,
                         help='run_directory name')
     subparser.add_argument('record_style', nargs='?', default=None,
                         help='optional record style')
-    
+
     # Define subparser for copy_records
     subparser = subparsers.add_parser('copy_records',
                         help='copy records of a given style from one database to another')
     subparser.add_argument('database1', nargs='?', default=None,
                         help='database name to copy from')
     subparser.add_argument('database2', nargs='?', default=None,
                         help='database name to copy to')
@@ -269,23 +273,23 @@
                         help='database name to copy from')
     subparser.add_argument('database2', nargs='?', default=None,
                         help='database name to copy to')
     subparser.add_argument('-n', '--notar', action='store_false',
                         help="don't copy tar archives associated with the records")
     subparser.add_argument('-o', '--overwrite', action='store_true',
                         help='overwrite and update any records already in database2')
-    
+
     # Define subparser for destroy_records
     subparser = subparsers.add_parser('destroy_records',
                         help='delete all records of a given style from a database')
     subparser.add_argument('database', nargs='?', default=None,
                         help='database name')
     subparser.add_argument('record_style', nargs='?', default=None,
                         help='record style')
-    
+
     # Define subparser for finish_calculations
     subparser = subparsers.add_parser('finish_calculations',
                         help='moves finished calculations to a database')
     subparser.add_argument('database', nargs='?', default=None,
                         help='database name')
     subparser.add_argument('run_directory', nargs='?', default=None,
                         help='run_directory name')
@@ -307,15 +311,15 @@
                         help='database name')
     subparser.add_argument('run_directory',
                         help='run_directory name')
     subparser.add_argument('calculation',
                         help='calculation name')
     subparser.add_argument('input_script',
                         help='input parameter script')
-    
+
     # Define subparser for master_prepare
     subparser = subparsers.add_parser('master_prepare',
                         help='prepare multiple calculations using iprPy workflow')
     subparser.add_argument('database',
                         help='database name')
     subparser.add_argument('input_script',
                         help='input parameter script')
@@ -333,44 +337,46 @@
                         help='calculation name')
 
     # Define subparser for maindoc
     subparser = subparsers.add_parser('maindoc',
                         help="view the main documentation for a calculation")
     subparser.add_argument('calculation',
                         help='calculation name')
-    
+
     # Define subparser for theorydoc
     subparser = subparsers.add_parser('theorydoc',
                         help="view the documentation for a calculation's methods and theory")
     subparser.add_argument('calculation',
                         help='calculation name')
 
     # Define subparser for retrieve
     subparser = subparsers.add_parser('retrieve',
                         help="copy/download a record to the working directory")
     subparser.add_argument('database',
                         help='database name')
-    subparser.add_argument('record_style', 
+    subparser.add_argument('record_style',
                         help='style of the record to retrieve')
     subparser.add_argument('record_name',
                         help='the name of the record in the database to retrieve')
     subparser.add_argument('-f', '--format', default='json', type=str,
                         help='the format to save the record as')
     subparser.add_argument('-c', '--compact', action='store_true',
                         help='indicates if the record is saved in compact format')
     subparser.add_argument('-g', '--getfiles', action='store_true',
-                        help='if used, any files associated with the record will also be retrieved')    
+                        help='if used, any files associated with the record will also be retrieved')
 
     # Define subparser for run
     subparser = subparsers.add_parser('run',
                         help='run a single calculation from a parameter file')
     subparser.add_argument('filename',
                         help='path to a parameter file')
     subparser.add_argument('calc_style', nargs='?', default=None,
                         help='the style of the calculation to run - not needed if filename is "calc_<calc_style>.in"')
+    subparser.add_argument('-e', '--raise_error', action='store_true',
+                        help='indicates that calculation errors are to be raised')
 
     # Define subparser for runner
     subparser = subparsers.add_parser('runner',
                         help='start runner working on prepared calculations')
     subparser.add_argument('database', nargs='?', default=None,
                         help='database name')
     subparser.add_argument('run_directory', nargs='?', default=None,
@@ -379,31 +385,31 @@
                         help='specifies a single calculation in run_directory to run')
     subparser.add_argument('-t', '--temp', action='store_true',
                         help='indicates that the calculations are to run in a temporary directory')
     subparser.add_argument('-b', '--bidtries', default=10, type=int,
                         help='number of sequential bid failures before stopping the runner')
     subparser.add_argument('-v', '--bidverbose', action='store_true',
                         help='bid action info will be printed')
-    
+
     # Define subparser for list_databases
     subparser = subparsers.add_parser('list_databases',
                         help='prints the names of all set databases')
 
     # Define subparser for set_database
     subparser = subparsers.add_parser('set_database',
                         help='define database access information')
     subparser.add_argument('name', nargs='?', default=None,
                         help='name to assign to the database')
-    
+
     # Define subparser for unset_database
     subparser = subparsers.add_parser('unset_database',
                         help='forget settings for a defined database')
     subparser.add_argument('name', nargs='?', default=None,
                         help='name assigned to the database')
-    
+
     # Define subparser for database
     subparser = subparsers.add_parser('database',
                         help='check info on a set database')
     subparser.add_argument('database', nargs='?', default=None,
                         help='database name')
 
     # Define subparser for list_run_directories
@@ -411,21 +417,21 @@
                         help='prints the names of all set run_directory paths')
 
     # Define subparser for set_run_directory
     subparser = subparsers.add_parser('set_run_directory',
                         help='define run_directory path')
     subparser.add_argument('name', nargs='?', default=None,
                         help='name to assign to the run_directory')
-    
+
     # Define subparser for unset_run_directory
     subparser = subparsers.add_parser('unset_run_directory',
                         help='forget settings for a defined run_directory')
     subparser.add_argument('name', nargs='?', default=None,
                         help='name assigned to the run_directory')
-    
+
     # Define subparser for run_directory
     subparser = subparsers.add_parser('run_directory',
                         help='check info on a set run_directory')
     subparser.add_argument('run_directory', nargs='?', default=None,
                         help='run_directory name')
 
     # Define subparser for directory
@@ -433,31 +439,31 @@
                         help='prints the path where iprPy settings are saved')
 
     # Define subparser for set_directory
     subparser = subparsers.add_parser('set_directory',
                         help='define directory path where iprPy settings are saved')
     subparser.add_argument('path', nargs='?', default=None,
                         help='path for the directory')
-    
+
     # Define subparser for unset_directory
     subparser = subparsers.add_parser('unset_directory',
                         help="revert to using iprPy's default settings directory path <home>/.iprPy/")
 
     # Define subparser for runner_log_directory
     subparser = subparsers.add_parser('runner_log_directory',
                         help='prints the path where runner scripts will save their log files to')
 
     # Define subparser for set_library_directory
     subparser = subparsers.add_parser('set_library_directory',
                         help='define the path where runner scripts will save their log files to')
     subparser.add_argument('path', nargs='?', default=None,
                         help='path for the directory')
-    
+
     # Define subparser for unset_library_directory
     subparser = subparsers.add_parser('unset_library_directory',
                         help="revert to using default location of <directory>/runner-logs/")
 
     # Parse command line arguments
     return parser.parse_args()
 
 if __name__ == '__main__':
-    command_line()
+    command_line()
```

### Comparing `iprPy-0.11.4/iprPy/database/IprPyDatabase.py` & `iprPy-0.11.5/iprPy/database/IprPyDatabase.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/database/MongoDatabase.py` & `iprPy-0.11.5/iprPy/database/MongoDatabase.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/database/__init__.py` & `iprPy-0.11.5/iprPy/database/__init__.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/database/load_database.py` & `iprPy-0.11.5/iprPy/database/load_database.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/database/master_prepare.py` & `iprPy-0.11.5/iprPy/database/master_prepare.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/database/prepare.py` & `iprPy-0.11.5/iprPy/database/prepare.py`

 * *Files 0% similar despite different names*

```diff
@@ -123,15 +123,15 @@
         for key in keyset:
             if key in kwargs:
                 kwargs[key] = aslist(kwargs[key])
                 if length is None:
                     length = len(kwargs[key])
                 else:
                     if len(kwargs[key]) != length:
-                        raise ValueError('Incompatible multikey lengths')
+                        raise ValueError(f'Incompatible multikey lengths len({key}) != {length}')
     
         # Fill in necessary blanks
         if length is None:
             for key in keyset:
                 kwargs[key] = []
         else:
             for key in keyset:
```

### Comparing `iprPy-0.11.4/iprPy/database/reset_orphans.py` & `iprPy-0.11.5/iprPy/database/reset_orphans.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/database/runner.py` & `iprPy-0.11.5/iprPy/database/runner.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/fix_lammps_versions.py` & `iprPy-0.11.5/iprPy/fix_lammps_versions.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,26 +18,26 @@
         The name of the run directory containing the prepared calculations
         to update.
     kwargs : any
         Keyword parameters including the current and old LAMMPS commands.
         The current will be replaced by the old for the potentials where it
         is required. All other kwargs are ignored.
     """
-    # Handle run_directory 
+    # Handle run_directory
     try:
         run_directory = load_run_directory(run_directory)
     except:
         run_directory = Path(run_directory)
 
     # Construct default lammps_command line to change
     key = 'lammps_command                  '
     oldlammps = f"{key}{kwargs['lammps_command']}"
 
     replacementdict = {}
-    
+
     # Fix for SNAP version 1
     if 'lammps_command_snap_1' in kwargs:
         for pot_id in snap1_pots():
             replacementdict[pot_id] = f"{key}{kwargs['lammps_command_snap_1']}"
 
     # Fix for SNAP version 2
     if 'lammps_command_snap_2' in kwargs:
@@ -61,26 +61,26 @@
 
     # Fix for kim potentials
     if 'lammps_command_kim' in kwargs:
         for pot_id in kim_pots():
             replacementdict[pot_id] = f"{key}{kwargs['lammps_command_kim']}"
 
     if len(replacementdict) > 0:
-        
+
         # Change the lammps commands in the input files
         for inscript in run_directory.glob('*/calc_*.in'):
-            with open(inscript) as f:
+            with open(inscript, encoding='UTF-8') as f:
                 content = f.read()
-            
+
             for pot_id, lammps in replacementdict.items():
                 if pot_id in content:
                     content = content.replace(oldlammps, lammps)
                     break
-                    
-            with open(inscript, 'w') as f:
+
+            with open(inscript, 'w', encoding='UTF-8') as f:
                 f.write(content)
 
 def snap1_pots():
     """This is a list of all version 1 SNAP potentials."""
     return ['2015--Thompson-A-P--Ta--LAMMPS--ipr1']
 
 def snap2_pots():
@@ -106,8 +106,8 @@
     return [
         '2020--Purja-Pun-G-P--Al--LAMMPS--ipr1',
         '2022--Lin-Y-S--Ta--LAMMPS--ipr1',
     ]
 
 def kim_pots():
     """This is a shortcut to identify all KIM models."""
-    return ['__MO_']
+    return ['__MO_']
```

### Comparing `iprPy-0.11.4/iprPy/input/boolean.py` & `iprPy-0.11.5/iprPy/input/boolean.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos.py` & `iprPy-0.11.5/iprPy/input/buildcombos.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/README.rst` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/README.rst`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/atomicarchive.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/atomicarchive.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/atomicparent.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/atomicparent.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/atomicreference.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/atomicreference.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/crystalprototype.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/crystalprototype.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/defect.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/defect.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/diatom.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/diatom.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/buildcombos_functions/lammpspotential.py` & `iprPy-0.11.5/iprPy/input/buildcombos_functions/lammpspotential.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/parse.py` & `iprPy-0.11.5/iprPy/input/parse.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/termtodict.py` & `iprPy-0.11.5/iprPy/input/termtodict.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/input/value.py` & `iprPy-0.11.5/iprPy/input/value.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/load_run_directory.py` & `iprPy-0.11.5/iprPy/load_run_directory.py`

 * *Files 26% similar despite different names*

```diff
@@ -28,18 +28,18 @@
         if len(run_directory_names) > 0:
             print('Select a run_directory:')
             for i, run_directory in enumerate(run_directory_names):
                 print(i+1, run_directory)
             choice = screen_input(':')
             try:
                 choice = int(choice)
-            except:
+            except (ValueError, TypeError):
                 name = choice
             else:
                 name = run_directory_names[choice-1]
         else:
             raise KeyError('No run_directories currently set')
 
     try:
         return Path(settings.run_directories[name])
-    except:
-        raise ValueError(f'run_directory {name} not found')
+    except Exception as err:
+        raise ValueError(f'run_directory {name} not found') from err
```

### Comparing `iprPy-0.11.4/iprPy/record/PotentialProperties.py` & `iprPy-0.11.5/iprPy/record/PotentialProperties.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,25 +1,68 @@
 # coding: utf-8
 
+# Standard Python imports
+import io
+from typing import Optional, Tuple, Union
+
 # https://github.com/usnistgov/DataModelDict
 from DataModelDict import DataModelDict as DM
 
 # https://github.com/usnistgov/yabadaba
-from yabadaba import query
+from yabadaba import load_query
 
 # iprPy imports
 from . import Record
-from .PotentialPropertiesSubsets import *
+from .PotentialPropertiesSubsets import (DiatomScan, EvsRScan, CrystalStructure,
+                                         ElasticConstants, FreeSurface, StackingFault,
+                                         PointDefect, Phonon)
 
 class PotentialProperties(Record):
     """
     Class for representing PotentialProperties records that contain the data
     necessary to generate the properties pages for an interatomic potential.
     """
-    def __init__(self, model=None, name=None, **kwargs):
+    def __init__(self,
+                 model: Union[str, io.IOBase, DM, None] = None,
+                 name: Optional[str] = None,
+                 **kwargs: any):
+        """
+        Initialize a PotentialProperties object.  Calculation-specific content
+        is managed by PotentialPropertiesSubsets.
+
+        Parameters
+        ----------
+        model : str, file-like object, DataModelDict
+            The contents of the record.
+        name : str, optional
+            The unique name to assign to the record.  If model is a file
+            path, then the default record name is the file name without
+            extension.
+        potential : BaseLAMMPSPotential, optional
+            A record entry for a LAMMPS-compatible potential that the computed
+            properties being compiled here are for.  Cannot be given with model
+            or the other potential_ parameters as they provide the same
+            information.
+        potential_key : str, optional
+            The UUID key of the potential that the computed properties being
+            compiled here are for.  Cannot be given with model or potential as
+            they provide the same information.
+        potential_id : str, optional
+            The id of the potential that the computed properties being compiled
+            here are for.  Cannot be given with model or potential as they
+            provide the same information.
+        potential_LAMMPS_key : str, optional
+            The UUID key of the potential implementation that the computed
+            properties being compiled here are for.  Cannot be given with model
+            or potential as they provide the same information.
+        potential_LAMMPS_id : str, optional
+            The id of the potential implementation that the computed properties
+            being compiled here are for.  Cannot be given with model or
+            potential as they provide the same information.
+        """
 
         # Define default core properties
         self.__potential_key = None
         self.__potential_id = None
         self.__potential_LAMMPS_key = None
         self.__potential_LAMMPS_id = None
 
@@ -27,85 +70,130 @@
         self.diatom = DiatomScan(self)
         self.evsr = EvsRScan(self)
         self.crystals = CrystalStructure(self)
         self.cijs = ElasticConstants(self)
         self.freesurfaces = FreeSurface(self)
         self.stackingfaults = StackingFault(self)
         self.pointdefects = PointDefect(self)
+        self.phonons = Phonon(self)
 
         # Build list of all available subsets
         self.subsets = [
             self.diatom,
             self.evsr,
             self.crystals,
             self.cijs,
             self.freesurfaces,
             self.stackingfaults,
             self.pointdefects,
+            self.phonons
         ]
 
         # Call parent init
         super().__init__(model=model, name=name, **kwargs)
 
     @property
-    def style(self):
+    def style(self) -> str:
         """str: The record style"""
         return 'PotentialProperties'
 
     @property
-    def potential_key(self):
+    def xsl_filename(self) -> Tuple[str, str]:
+        """tuple: The module path and file name of the record's xsl html transformer"""
+        raise NotImplementedError('No xsl for this record yet')
+        #return ('iprPy.xsl', 'PotentialProperties.xsl')
+
+    @property
+    def xsd_filename(self) -> Tuple[str, str]:
+        """tuple: The module path and file name of the record's xsd schema"""
+        return ('iprPy.xsd', 'PotentialProperties.xsd')
+
+    @property
+    def potential_key(self) -> str:
         """str: UUID4 key assigned to the potential model"""
         return self.__potential_key
 
     @potential_key.setter
-    def potential_key(self, value):
+    def potential_key(self, value: str):
         self.__potential_key = str(value)
 
     @property
-    def potential_id(self):
+    def potential_id(self) -> str:
         """str: Unique id assigned to the potential model"""
         return self.__potential_id
 
     @potential_id.setter
-    def potential_id(self, value):
+    def potential_id(self, value: str):
         self.__potential_id = str(value)
 
     @property
-    def potential_LAMMPS_key(self):
+    def potential_LAMMPS_key(self) -> str:
         """str: UUID4 key assigned to the LAMMPS implementation"""
         return self.__potential_LAMMPS_key
 
     @potential_LAMMPS_key.setter
-    def potential_LAMMPS_key(self, value):
+    def potential_LAMMPS_key(self, value: str):
         self.__potential_LAMMPS_key = str(value)
 
     @property
-    def potential_LAMMPS_id(self):
+    def potential_LAMMPS_id(self) -> str:
         """str: Unique id assigned to the LAMMPS implementation"""
         return self.__potential_LAMMPS_id
 
     @potential_LAMMPS_id.setter
-    def potential_LAMMPS_id(self, value):
+    def potential_LAMMPS_id(self, value: str):
         self.__potential_LAMMPS_id = str(value)
 
     @property
-    def webdir(self):
+    def webdir(self) -> str:
         """str : Root URL for the potential properties content"""
         return f'https://www.ctcms.nist.gov/potentials/entry/{self.potential_id}/{self.potential_LAMMPS_id}'
 
     @property
-    def url(self):
+    def url(self) -> str:
         """str : URL for the potential properties web page"""
         return f'{self.webdir}.html'
 
-    def set_values(self, name=None, **kwargs):
+    def set_values(self,
+                   name: Optional[str] = None,
+                   **kwargs: any):
+        """
+        Sets multiple object values.
+
+        Parameters
+        ----------
+        name : str, optional
+            The name to use for saving the record.  Either name or id should
+            be given as they are treated as aliases for this record style.
+        potential : BaseLAMMPSPotential, optional
+            A record entry for a LAMMPS-compatible potential that the computed
+            properties being compiled here are for.  Cannot be given with model
+            or the other potential_ parameters as they provide the same
+            information.
+        potential_key : str, optional
+            The UUID key of the potential that the computed properties being
+            compiled here are for.  Cannot be given with model or potential as
+            they provide the same information.
+        potential_id : str, optional
+            The id of the potential that the computed properties being compiled
+            here are for.  Cannot be given with model or potential as they
+            provide the same information.
+        potential_LAMMPS_key : str, optional
+            The UUID key of the potential implementation that the computed
+            properties being compiled here are for.  Cannot be given with model
+            or potential as they provide the same information.
+        potential_LAMMPS_id : str, optional
+            The id of the potential implementation that the computed properties
+            being compiled here are for.  Cannot be given with model or
+            potential as they provide the same information.
+        """
 
         if 'potential' in kwargs:
             assert 'potential_key' not in kwargs
-            assert 'potential_id' not in kwargs            
+            assert 'potential_id' not in kwargs
             assert 'potential_LAMMPS_key' not in kwargs
             assert 'potential_LAMMPS_id' not in kwargs
             self.potential_key = kwargs['potential'].potkey
             self.potential_id = kwargs['potential'].potid
             self.potential_LAMMPS_key = kwargs['potential'].key
             self.potential_LAMMPS_id = kwargs['potential'].id
         else:
@@ -118,15 +206,17 @@
             if 'potential_LAMMPS_id' in kwargs:
                 self.potential_LAMMPS_id = kwargs['potential_LAMMPS_id']
 
         if name is None:
             if self.potential_LAMMPS_id is not None:
                 self.name = f'props.{self.potential_LAMMPS_id}.{self.potential_key[:8]}'
 
-    def load_model(self, model, name=None):
+    def load_model(self,
+                   model,
+                   name: Optional[str] = None,):
         """
         Loads record contents from a given model.
 
         Parameters
         ----------
         model : str or DataModelDict
             The model contents of the record to load.
@@ -137,23 +227,23 @@
         super().load_model(model, name=name)
         content = self.model[self.modelroot]
 
         self.potential_key = content['potential']['key']
         self.potential_id = content['potential']['id']
         self.potential_LAMMPS_key = content['implementation']['key']
         self.potential_LAMMPS_id = content['implementation']['id']
-        
+
         for subset in self.subsets:
             subset.load_model(content)
 
         if name is None:
             if self.potential_LAMMPS_id is not None:
                 self.name = f'props.{self.potential_LAMMPS_id}.{self.potential_key[:8]}'
 
-    def build_model(self):
+    def build_model(self) -> DM:
         """
         Returns the object info as data model content
         
         Returns
         ----------
         DataModelDict
             The data model content.
@@ -163,152 +253,68 @@
 
         content['potential'] = DM()
         content['potential']['key'] = self.potential_key
         content['potential']['id'] = self.potential_id
         content['implementation'] = DM()
         content['implementation']['key'] = self.potential_LAMMPS_key
         content['implementation']['id'] = self.potential_LAMMPS_id
-        
+
         for subset in self.subsets:
             subset.build_model(content)
 
         self._set_model(model)
-        return model    
+        return model
 
     @property
-    def modelroot(self):
+    def modelroot(self) -> str:
         """str: The root element of the content"""
         return 'per-potential-properties'
-    
-    def metadata(self):
+
+    def metadata(self) -> dict:
         """
         Generates a dict of simple metadata values associated with the record.
         Useful for quickly comparing records and for building pandas.DataFrames
         for multiple records of the same style.
         """
-        
+
         meta = {}
         meta['name'] = self.name
         meta['potential_key'] = self.potential_key
         meta['potential_id'] = self.potential_id
         meta['potential_LAMMPS_key'] = self.potential_LAMMPS_key
         meta['potential_LAMMPS_id'] = self.potential_LAMMPS_id
-        
+
         for subset in self.subsets:
             subset.metadata(meta)
 
         return meta
-    
-    def pandasfilter(self, dataframe, name=None, potential_key=None,
-                     potential_id=None, potential_LAMMPS_key=None,
-                     potential_LAMMPS_id=None):
-        """
-        Filters a pandas.DataFrame based on kwargs values for the record style.
-        
-        Parameters
-        ----------
-        dataframe : pandas.DataFrame
-            A table of metadata for multiple records of the record style.
-        name : str or list
-            The record name(s) to parse by.
-        id : str or list
-            The record id(s) to parse by.
-        key : str or list
-            The record key(s) to parse by.
-        family : str or list
-            Parent prototype/reference id(s) to parse by.
-        hkl : str or list
-            Space delimited fault plane(s) to parse by.
-        shiftindex : int or list
-            shiftindex value(s) to parse by.
-        cutboxvector : str or list
-            cutboxvector value(s) to parse by.
-        
-        Returns
-        -------
-        pandas.Series, numpy.NDArray
-            Boolean map of matching values
-        """
-        matches = (
-            query.str_match.pandas(dataframe, 'name', name)
-            &query.str_match.pandas(dataframe, 'potential_key', potential_key)
-            &query.str_match.pandas(dataframe, 'potential_id', potential_id)
-            &query.str_match.pandas(dataframe, 'potential_LAMMPS_key', potential_LAMMPS_key)
-            &query.str_match.pandas(dataframe, 'potential_LAMMPS_id', potential_LAMMPS_id)
-        )
-        return matches
-
-    def mongoquery(self, name=None, potential_key=None,
-                   potential_id=None, potential_LAMMPS_key=None,
-                   potential_LAMMPS_id=None):
-        """
-        Builds a Mongo-style query based on kwargs values for the record style.
-        
-        Parameters
-        ----------
-        name : str or list
-            The record name(s) to parse by.
-        id : str or list
-            The record id(s) to parse by.
-        key : str or list
-            The record key(s) to parse by.
-        family : str or list
-            Parent prototype/reference id(s) to parse by.
-        hkl : str or list
-            Space delimited fault plane(s) to parse by.
-        shiftindex : int or list
-            shiftindex value(s) to parse by.
-        cutboxvector : str or list
-            cutboxvector value(s) to parse by.
-        
-        Returns
-        -------
-        dict
-            The Mongo-style query
-        """   
-        mquery = {}
-        root = f'content.{self.modelroot}'
-
-        query.str_match.mongo(mquery, f'name', name)
-
-        query.str_match.mongo(mquery, f'{root}.potential.key', potential_key)
-        query.str_match.mongo(mquery, f'{root}.potential.id', potential_id)
-        query.str_match.mongo(mquery, f'{root}.implementation.key', potential_LAMMPS_key)
-        query.str_match.mongo(mquery, f'{root}.implementation.id', potential_LAMMPS_id)
-        
-        return mquery
 
-    def cdcsquery(self, potential_key=None,
-                   potential_id=None, potential_LAMMPS_key=None,
-                   potential_LAMMPS_id=None):
-        """
-        Builds a CDCS-style query based on kwargs values for the record style.
-        
-        Parameters
-        ----------
-        id : str or list
-            The record id(s) to parse by.
-        key : str or list
-            The record key(s) to parse by.
-        family : str or list
-            Parent prototype/reference id(s) to parse by.
-        hkl : str or list
-            Space delimited fault plane(s) to parse by.
-        shiftindex : int or list
-            shiftindex value(s) to parse by.
-        cutboxvector : str or list
-            cutboxvector value(s) to parse by.
-        
-        Returns
-        -------
-        dict
-            The CDCS-style query
-        """
-        mquery = {}
-        root = self.modelroot
+    @property
+    def queries(self) -> dict:
+        """dict: Query objects and their associated parameter names."""
+        queries = {
+            'potential_key': load_query(
+                style='str_match',
+                name='potential_key',
+                path=f'{self.modelroot}.potential.key',
+                description="search by potential's UUID key"),
+            'potential_id': load_query(
+                style='str_match',
+                name='potential_id',
+                path=f'{self.modelroot}.potential.id',
+                description="search by potential's UUID id"),
+            'potential_LAMMPS_key': load_query(
+                style='str_match',
+                name='potential_LAMMPS_key',
+                path=f'{self.modelroot}.implementation.key',
+                description="search by potential implementation's UUID key"),
+            'potential_LAMMPS_id': load_query(
+                style='str_match',
+                name='potential_LAMMPS_id',
+                path=f'{self.modelroot}.implementation.id',
+                description="search by potential implementation's id"),
+        }
 
-        query.str_match.mongo(mquery, f'{root}.potential.key', potential_key)
-        query.str_match.mongo(mquery, f'{root}.potential.id', potential_id)
-        query.str_match.mongo(mquery, f'{root}.implementation.key', potential_LAMMPS_key)
-        query.str_match.mongo(mquery, f'{root}.implementation.id', potential_LAMMPS_id)
+        for subset in self.subsets:
+            queries.update(subset.queries)
 
-        return mquery
+        return queries
```

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/CrystalStructure.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/CrystalStructure.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/DiatomScan.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/DiatomScan.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/ElasticConstants.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/ElasticConstants.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/EvsRScan.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/EvsRScan.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/FreeSurface.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/FreeSurface.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/PointDefect.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/PointDefect.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/PotentialsPropertiesSubset.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/PotentialsPropertiesSubset.py`

 * *Files 19% similar despite different names*

```diff
@@ -28,7 +28,12 @@
         raise NotImplementedError()
 
     def build_model(self, model):
         raise NotImplementedError()
 
     def metadata(self, meta):
         raise NotImplementedError()
+    
+    @property
+    def queries(self):
+        """dict: Query objects and their associated parameter names."""
+        return {}
```

### Comparing `iprPy-0.11.4/iprPy/record/PotentialPropertiesSubsets/StackingFault.py` & `iprPy-0.11.5/iprPy/record/PotentialPropertiesSubsets/StackingFault.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/tools/dict_insert.py` & `iprPy-0.11.5/iprPy/tools/dict_insert.py`

 * *Files 12% similar despite different names*

```diff
@@ -46,22 +46,22 @@
                 # Set normally if ref key not found
                 d[key] = value
                 return
         else:
             raise TypeError(f"dict_insert() got an unexpected keyword argument '{list(kwargs.keys())[0]}'")
     else:
         raise ValueError('Only one kwarg (before or after) can be given')
-    
+
     # Remove d if currently in d
     if key in d:
         del d[key]
-        
+
     # Pop all keys after previous
-    nd = {}
+    newdict = {}
     for k in list(d.keys())[i:]:
-        nd[k] = d.pop(k)
+        newdict[k] = d.pop(k)
 
     # Set key, value
     d[key] = value
 
     # Add popped keys back in
-    d.update(nd)
+    d.update(newdict)
```

### Comparing `iprPy-0.11.4/iprPy/tools/dynamic_import.py` & `iprPy-0.11.5/iprPy/tools/dynamic_import.py`

 * *Files identical despite different names*

### Comparing `iprPy-0.11.4/iprPy/tools/read_calc_file.py` & `iprPy-0.11.5/iprPy/tools/read_calc_file.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,11 +14,11 @@
     ----------
     parent_module : str
         The name of the parent module where the file resource should be located.
     filename : str
         The name of the file to read/get content for.
     """
     if Path(filename).is_file():
-        with open(filename) as f:
+        with open(filename, encoding='UTF-8') as f:
             return f.read()
     else:
-        return resources.read_text(parent_module, filename)
+        return resources.read_text(parent_module, filename)
```

### Comparing `iprPy-0.11.4/iprPy.egg-info/PKG-INFO` & `iprPy-0.11.5/iprPy.egg-info/PKG-INFO`

 * *Files 13% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 Metadata-Version: 2.1
 Name: iprPy
-Version: 0.11.4
+Version: 0.11.5
 Summary: Interatomic Potential Repository Python Property Calculations and Tools
 Home-page: https://github.com/usnistgov/iprPy
 Author: Lucas Hale
 Author-email: lucas.hale@nist.gov
 Keywords: atom,atomic,atomistic,molecular dynamics,high-throughput,interatomic potential
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: Natural Language :: English
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Scientific/Engineering :: Physics
 License-File: LICENSE.TXT
 
 =====
 iprPy
 =====
```

### Comparing `iprPy-0.11.4/iprPy.egg-info/SOURCES.txt` & `iprPy-0.11.5/iprPy.egg-info/SOURCES.txt`

 * *Files 6% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 bin/iprPy_prepare_pool_3
 bin/iprPy_prepare_pool_4
 bin/iprPy_prepare_pool_5
 bin/iprPy_slurm
 bin/iprPy_slurm_16
 bin/iprPy_slurm_4
 bin/iprPy_slurm_8
+bin/prepare_relax_dynamic_at_temp.py
 bin/prepare/master_prepare_ctcms.in
 bin/prepare/master_prepare_ctcms_pool_1.in
 bin/prepare/master_prepare_ctcms_pool_2.in
 bin/prepare/master_prepare_ctcms_pool_3.in
 bin/prepare/master_prepare_ctcms_pool_4.in
 bin/prepare/master_prepare_ctcms_pool_5.in
 bin/prepare/master_prepare_desktop.in
@@ -44,17 +45,22 @@
 iprPy/analysis/process_relaxations.py
 iprPy/analysis/PropertyProcessor/__init__.py
 iprPy/analysis/PropertyProcessor/_crystal.py
 iprPy/analysis/PropertyProcessor/_diatom.py
 iprPy/analysis/PropertyProcessor/_elastic.py
 iprPy/analysis/PropertyProcessor/_empty.py
 iprPy/analysis/PropertyProcessor/_evsr.py
+iprPy/analysis/PropertyProcessor/_phonon.py
 iprPy/analysis/PropertyProcessor/_point.py
 iprPy/analysis/PropertyProcessor/_stacking.py
 iprPy/analysis/PropertyProcessor/_surface.py
+iprPy/analysis/thermo/AnalyzeFE.py
+iprPy/analysis/thermo/AnalyzeMD.py
+iprPy/analysis/thermo/AnalyzeQHA.py
+iprPy/analysis/thermo/__init__.py
 iprPy/calculation/Calculation.py
 iprPy/calculation/__init__.py
 iprPy/calculation/E_vs_r_scan/EvsRScan.py
 iprPy/calculation/E_vs_r_scan/README.md
 iprPy/calculation/E_vs_r_scan/__init__.py
 iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsd
 iprPy/calculation/E_vs_r_scan/calculation_E_vs_r_scan.xsl
@@ -195,14 +201,22 @@
 iprPy/calculation/free_energy/README.md
 iprPy/calculation/free_energy/__init__.py
 iprPy/calculation/free_energy/calculation_free_energy.xsd
 iprPy/calculation/free_energy/free_energy.py
 iprPy/calculation/free_energy/free_energy.template
 iprPy/calculation/free_energy/msd.template
 iprPy/calculation/free_energy/theory.md
+iprPy/calculation/free_energy_liquid/FreeEnergyLiquid.py
+iprPy/calculation/free_energy_liquid/README.md
+iprPy/calculation/free_energy_liquid/UhlenbeckFordModel.py
+iprPy/calculation/free_energy_liquid/__init__.py
+iprPy/calculation/free_energy_liquid/calculation_free_energy_liquid.xsd
+iprPy/calculation/free_energy_liquid/free_energy_liquid.py
+iprPy/calculation/free_energy_liquid/free_energy_liquid.template
+iprPy/calculation/free_energy_liquid/theory.md
 iprPy/calculation/grain_boundary_bcc/__init__.py
 iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.py
 iprPy/calculation/grain_boundary_bcc/calc_bcc_grain_boundary.template
 iprPy/calculation/grain_boundary_bcc/grain_boundary.template
 iprPy/calculation/grain_boundary_search/README.md
 iprPy/calculation/grain_boundary_search/__init__.py
 iprPy/calculation/grain_boundary_search/compare_terms.py
@@ -250,14 +264,22 @@
 iprPy/calculation/relax_dynamic/RelaxDynamic.py
 iprPy/calculation/relax_dynamic/__init__.py
 iprPy/calculation/relax_dynamic/calculation_relax_dynamic.xsd
 iprPy/calculation/relax_dynamic/full_relax.template
 iprPy/calculation/relax_dynamic/full_relax_restart.template
 iprPy/calculation/relax_dynamic/relax_dynamic.py
 iprPy/calculation/relax_dynamic/theory.md
+iprPy/calculation/relax_liquid/README.md
+iprPy/calculation/relax_liquid/RelaxLiquid.py
+iprPy/calculation/relax_liquid/__init__.py
+iprPy/calculation/relax_liquid/calculation_relax_liquid.xsd
+iprPy/calculation/relax_liquid/liquid_ave_pe.template
+iprPy/calculation/relax_liquid/liquid_ave_te.template
+iprPy/calculation/relax_liquid/relax_liquid.py
+iprPy/calculation/relax_liquid/theory.md
 iprPy/calculation/relax_static/README.md
 iprPy/calculation/relax_static/RelaxStatic.py
 iprPy/calculation/relax_static/__init__.py
 iprPy/calculation/relax_static/calculation_relax_static.xsd
 iprPy/calculation/relax_static/minbox.template
 iprPy/calculation/relax_static/relax_static.py
 iprPy/calculation/relax_static/theory.md
@@ -324,16 +346,18 @@
 iprPy/record/PotentialProperties.py
 iprPy/record/__init__.py
 iprPy/record/PotentialPropertiesSubsets/CrystalStructure.py
 iprPy/record/PotentialPropertiesSubsets/DiatomScan.py
 iprPy/record/PotentialPropertiesSubsets/ElasticConstants.py
 iprPy/record/PotentialPropertiesSubsets/EvsRScan.py
 iprPy/record/PotentialPropertiesSubsets/FreeSurface.py
+iprPy/record/PotentialPropertiesSubsets/Phonon.py
 iprPy/record/PotentialPropertiesSubsets/PointDefect.py
 iprPy/record/PotentialPropertiesSubsets/PotentialsPropertiesSubset.py
 iprPy/record/PotentialPropertiesSubsets/StackingFault.py
 iprPy/record/PotentialPropertiesSubsets/__init__.py
 iprPy/record/xsd/__init__.py
 iprPy/tools/__init__.py
 iprPy/tools/dict_insert.py
 iprPy/tools/dynamic_import.py
+iprPy/tools/num_deriv_3_point.py
 iprPy/tools/read_calc_file.py
```

### Comparing `iprPy-0.11.4/setup.py` & `iprPy-0.11.5/setup.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,31 +1,33 @@
 import os
 from setuptools import setup, find_packages
 
 def getversion():
     """Fetches version information from VERSION file"""
-    with open(os.path.join('iprPy', 'VERSION')) as version_file:
+    with open(os.path.join('iprPy', 'VERSION'), encoding='UTF-8') as version_file:
         version = version_file.read().strip()
     return version
 
 def getreadme():
-    with open('README.rst') as readme_file:
+    with open('README.rst', encoding='UTF-8') as readme_file:
         return readme_file.read()
-   
+
 setup(name = 'iprPy',
       version = getversion(),
       description = 'Interatomic Potential Repository Python Property Calculations and Tools',
       long_description = getreadme(),
       classifiers=[
         'Development Status :: 4 - Beta',
         'Intended Audience :: Science/Research',
         'Natural Language :: English',
         'Programming Language :: Python :: 3.7',
         'Programming Language :: Python :: 3.8',
         'Programming Language :: Python :: 3.9',
+        'Programming Language :: Python :: 3.10',
+        'Programming Language :: Python :: 3.11',
         'Topic :: Scientific/Engineering :: Physics'
       ],
       keywords = [
         'atom', 
         'atomic', 
         'atomistic', 
         'molecular dynamics', 
@@ -38,16 +40,19 @@
       packages = find_packages(),
       install_requires = [
         'DataModelDict',
         'numpy', 
         'matplotlib',
         'scipy',
         'pandas',
-        'atomman==1.4.5',
+        'atomman==1.4.9',
         'requests',
+        'bokeh',
+        'plotly',
+        'kaleido'
       ],
       entry_points = {
         'console_scripts': [
           'iprPy = iprPy.command_line:command_line'
         ]
       },
       include_package_data = True,
```

